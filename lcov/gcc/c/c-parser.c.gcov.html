<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/c/c-parser.c</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">gcc/c</a> - c-parser.c<span style="font-size: 80%;"> (source / <a href="c-parser.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">7520</td>
            <td class="headerCovTableEntry">9014</td>
            <td class="headerCovTableEntryMed">83.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">202</td>
            <td class="headerCovTableEntry">247</td>
            <td class="headerCovTableEntryMed">81.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Parser for C and Objective-C.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 1987-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            :    Parser actions based on the old Bison parser; structure somewhat
<span class="lineNum">       5 </span>            :    influenced by and fragments based on the C++ parser.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : This file is part of GCC.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">      10 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">      11 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">      12 </span>            : version.
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      15 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      16 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      17 </span>            : for more details.
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      20 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      21 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : /* TODO:
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            :    Make sure all relevant comments, and all relevant code from all
<span class="lineNum">      26 </span>            :    actions, brought over from old parser.  Verify exact correspondence
<span class="lineNum">      27 </span>            :    of syntax accepted.
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            :    Add testcases covering every input symbol in every state in old and
<span class="lineNum">      30 </span>            :    new parsers.
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            :    Include full syntax for GNU C, including erroneous cases accepted
<span class="lineNum">      33 </span>            :    with error messages, in syntax productions in comments.
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            :    Make more diagnostics in the front end generally take an explicit
<span class="lineNum">      36 </span>            :    location rather than implicitly using input_location.  */
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      39 </span>            : #define INCLUDE_UNIQUE_PTR
<span class="lineNum">      40 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;target.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;function.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;c-tree.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;timevar.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;stringpool.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;cgraph.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;attribs.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;stor-layout.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;varasm.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;trans-mem.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;c-family/c-pragma.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;c-lang.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;c-family/c-objc.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;plugin.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;omp-general.h&quot;
<span class="lineNum">      57 </span>            : #include &quot;omp-offload.h&quot;
<span class="lineNum">      58 </span>            : #include &quot;builtins.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;gomp-constants.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;c-family/c-indentation.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;gimple-expr.h&quot;
<span class="lineNum">      62 </span>            : #include &quot;context.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;gcc-rich-location.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;c-parser.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;gimple-parser.h&quot;
<span class="lineNum">      66 </span>            : #include &quot;read-rtl-function.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;run-rtl-passes.h&quot;
<span class="lineNum">      68 </span>            : #include &quot;intl.h&quot;
<span class="lineNum">      69 </span>            : #include &quot;c-family/name-hint.h&quot;
<span class="lineNum">      70 </span>            : #include &quot;tree-iterator.h&quot;
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : /* We need to walk over decls with incomplete struct/union/enum types
<span class="lineNum">      73 </span>            :    after parsing the whole translation unit.
<span class="lineNum">      74 </span>            :    In finish_decl(), if the decl is static, has incomplete
<span class="lineNum">      75 </span>            :    struct/union/enum type, it is appeneded to incomplete_record_decls.
<span class="lineNum">      76 </span>            :    In c_parser_translation_unit(), we iterate over incomplete_record_decls
<span class="lineNum">      77 </span>            :    and report error if any of the decls are still incomplete.  */ 
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : vec&lt;tree&gt; incomplete_record_decls;
<a name="80"><span class="lineNum">      80 </span>            : </a>
<span class="lineNum">      81 </span>            : void
<span class="lineNum">      82 </span><span class="lineCov">  110537818 : set_c_expr_source_range (c_expr *expr,</span>
<span class="lineNum">      83 </span>            :                          location_t start, location_t finish)
<span class="lineNum">      84 </span>            : {
<span class="lineNum">      85 </span><span class="lineCov">  110537818 :   expr-&gt;src_range.m_start = start;</span>
<span class="lineNum">      86 </span><span class="lineCov">  110537818 :   expr-&gt;src_range.m_finish = finish;</span>
<span class="lineNum">      87 </span><span class="lineCov">  110537818 :   if (expr-&gt;value)</span>
<span class="lineNum">      88 </span><span class="lineCov">  110537728 :     set_source_range (expr-&gt;value, start, finish);</span>
<span class="lineNum">      89 </span><span class="lineCov">  110537818 : }</span>
<a name="90"><span class="lineNum">      90 </span>            : </a>
<span class="lineNum">      91 </span>            : void
<span class="lineNum">      92 </span><span class="lineCov">  108201499 : set_c_expr_source_range (c_expr *expr,</span>
<span class="lineNum">      93 </span>            :                          source_range src_range)
<span class="lineNum">      94 </span>            : {
<span class="lineNum">      95 </span><span class="lineCov">  108201499 :   expr-&gt;src_range = src_range;</span>
<span class="lineNum">      96 </span><span class="lineCov">  108201499 :   if (expr-&gt;value)</span>
<span class="lineNum">      97 </span><span class="lineCov">  108201499 :     set_source_range (expr-&gt;value, src_range);</span>
<span class="lineNum">      98 </span><span class="lineCov">  108201499 : }</span>
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : /* Initialization routine for this file.  */
<a name="102"><span class="lineNum">     102 </span>            : </a>
<span class="lineNum">     103 </span>            : void
<span class="lineNum">     104 </span><span class="lineCov">      72837 : c_parse_init (void)</span>
<span class="lineNum">     105 </span>            : {
<span class="lineNum">     106 </span>            :   /* The only initialization required is of the reserved word
<span class="lineNum">     107 </span>            :      identifiers.  */
<span class="lineNum">     108 </span><span class="lineCov">      72837 :   unsigned int i;</span>
<span class="lineNum">     109 </span><span class="lineCov">      72837 :   tree id;</span>
<span class="lineNum">     110 </span><span class="lineCov">      72837 :   int mask = 0;</span>
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            :   /* Make sure RID_MAX hasn't grown past the 8 bits used to hold the keyword in
<span class="lineNum">     113 </span>            :      the c_token structure.  */
<span class="lineNum">     114 </span><span class="lineCov">      72837 :   gcc_assert (RID_MAX &lt;= 255);</span>
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span><span class="lineCov">      72837 :   mask |= D_CXXONLY;</span>
<span class="lineNum">     117 </span><span class="lineCov">      72837 :   if (!flag_isoc99)</span>
<span class="lineNum">     118 </span><span class="lineCov">       1163 :     mask |= D_C99;</span>
<span class="lineNum">     119 </span><span class="lineCov">      72837 :   if (flag_no_asm)</span>
<span class="lineNum">     120 </span>            :     {
<span class="lineNum">     121 </span><span class="lineCov">       1837 :       mask |= D_ASM | D_EXT;</span>
<span class="lineNum">     122 </span><span class="lineCov">       1837 :       if (!flag_isoc99)</span>
<span class="lineNum">     123 </span><span class="lineCov">        953 :         mask |= D_EXT89;</span>
<span class="lineNum">     124 </span>            :     }
<span class="lineNum">     125 </span><span class="lineCov">      72837 :   if (!c_dialect_objc ())</span>
<span class="lineNum">     126 </span><span class="lineCov">      72837 :     mask |= D_OBJC | D_CXX_OBJC;</span>
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span><span class="lineCov">      72837 :   ridpointers = ggc_cleared_vec_alloc&lt;tree&gt; ((int) RID_MAX);</span>
<span class="lineNum">     129 </span><span class="lineCov">   15587118 :   for (i = 0; i &lt; num_c_common_reswords; i++)</span>
<span class="lineNum">     130 </span>            :     {
<span class="lineNum">     131 </span>            :       /* If a keyword is disabled, do not enter it into the table
<span class="lineNum">     132 </span>            :          and so create a canonical spelling that isn't a keyword.  */
<span class="lineNum">     133 </span><span class="lineCov">   15514281 :       if (c_common_reswords[i].disable &amp; mask)</span>
<span class="lineNum">     134 </span>            :         {
<span class="lineNum">     135 </span><span class="lineCov">    7883208 :           if (warn_cxx_compat</span>
<span class="lineNum">     136 </span><span class="lineCov">      62187 :               &amp;&amp; (c_common_reswords[i].disable &amp; D_CXXWARN))</span>
<span class="lineNum">     137 </span>            :             {
<span class="lineNum">     138 </span><span class="lineCov">      23000 :               id = get_identifier (c_common_reswords[i].word);</span>
<span class="lineNum">     139 </span><span class="lineCov">      23000 :               C_SET_RID_CODE (id, RID_CXX_COMPAT_WARN);</span>
<span class="lineNum">     140 </span><span class="lineCov">      46000 :               C_IS_RESERVED_WORD (id) = 1;</span>
<span class="lineNum">     141 </span>            :             }
<span class="lineNum">     142 </span><span class="lineCov">    7883208 :           continue;</span>
<span class="lineNum">     143 </span>            :         }
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineCov">    7631073 :       id = get_identifier (c_common_reswords[i].word);</span>
<span class="lineNum">     146 </span><span class="lineCov">    7631073 :       C_SET_RID_CODE (id, c_common_reswords[i].rid);</span>
<span class="lineNum">     147 </span><span class="lineCov">    7631073 :       C_IS_RESERVED_WORD (id) = 1;</span>
<span class="lineNum">     148 </span><span class="lineCov">    7631073 :       ridpointers [(int) c_common_reswords[i].rid] = id;</span>
<span class="lineNum">     149 </span>            :     }
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span><span class="lineCov">     145674 :   for (i = 0; i &lt; NUM_INT_N_ENTS; i++)</span>
<span class="lineNum">     152 </span>            :     {
<span class="lineNum">     153 </span>            :       /* We always create the symbols but they aren't always supported.  */
<span class="lineNum">     154 </span><span class="lineCov">      72837 :       char name[50];</span>
<span class="lineNum">     155 </span><span class="lineCov">      72837 :       sprintf (name, &quot;__int%d&quot;, int_n_data[i].bitsize);</span>
<span class="lineNum">     156 </span><span class="lineCov">      72837 :       id = get_identifier (name);</span>
<span class="lineNum">     157 </span><span class="lineCov">      72837 :       C_SET_RID_CODE (id, RID_FIRST_INT_N + i);</span>
<span class="lineNum">     158 </span><span class="lineCov">     145674 :       C_IS_RESERVED_WORD (id) = 1;</span>
<span class="lineNum">     159 </span>            :     }
<span class="lineNum">     160 </span><span class="lineCov">      72837 : }</span>
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            : /* A parser structure recording information about the state and
<span class="lineNum">     163 </span>            :    context of parsing.  Includes lexer information with up to two
<span class="lineNum">     164 </span>            :    tokens of look-ahead; more are not needed for C.  */
<span class="lineNum">     165 </span>            : struct GTY(()) c_parser {
<span class="lineNum">     166 </span>            :   /* The look-ahead tokens.  */
<span class="lineNum">     167 </span>            :   c_token * GTY((skip)) tokens;
<span class="lineNum">     168 </span>            :   /* Buffer for look-ahead tokens.  */
<span class="lineNum">     169 </span>            :   c_token tokens_buf[4];
<span class="lineNum">     170 </span>            :   /* How many look-ahead tokens are available (0 - 4, or
<span class="lineNum">     171 </span>            :      more if parsing from pre-lexed tokens).  */
<span class="lineNum">     172 </span>            :   unsigned int tokens_avail;
<span class="lineNum">     173 </span>            :   /* True if a syntax error is being recovered from; false otherwise.
<span class="lineNum">     174 </span>            :      c_parser_error sets this flag.  It should clear this flag when
<span class="lineNum">     175 </span>            :      enough tokens have been consumed to recover from the error.  */
<span class="lineNum">     176 </span>            :   BOOL_BITFIELD error : 1;
<span class="lineNum">     177 </span>            :   /* True if we're processing a pragma, and shouldn't automatically
<span class="lineNum">     178 </span>            :      consume CPP_PRAGMA_EOL.  */
<span class="lineNum">     179 </span>            :   BOOL_BITFIELD in_pragma : 1;
<span class="lineNum">     180 </span>            :   /* True if we're parsing the outermost block of an if statement.  */
<span class="lineNum">     181 </span>            :   BOOL_BITFIELD in_if_block : 1;
<span class="lineNum">     182 </span>            :   /* True if we want to lex an untranslated string.  */
<span class="lineNum">     183 </span>            :   BOOL_BITFIELD lex_untranslated_string : 1;
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            :   /* Objective-C specific parser/lexer information.  */
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            :   /* True if we are in a context where the Objective-C &quot;PQ&quot; keywords
<span class="lineNum">     188 </span>            :      are considered keywords.  */
<span class="lineNum">     189 </span>            :   BOOL_BITFIELD objc_pq_context : 1;
<span class="lineNum">     190 </span>            :   /* True if we are parsing a (potential) Objective-C foreach
<span class="lineNum">     191 </span>            :      statement.  This is set to true after we parsed 'for (' and while
<span class="lineNum">     192 </span>            :      we wait for 'in' or ';' to decide if it's a standard C for loop or an
<span class="lineNum">     193 </span>            :      Objective-C foreach loop.  */
<span class="lineNum">     194 </span>            :   BOOL_BITFIELD objc_could_be_foreach_context : 1;
<span class="lineNum">     195 </span>            :   /* The following flag is needed to contextualize Objective-C lexical
<span class="lineNum">     196 </span>            :      analysis.  In some cases (e.g., 'int NSObject;'), it is
<span class="lineNum">     197 </span>            :      undesirable to bind an identifier to an Objective-C class, even
<span class="lineNum">     198 </span>            :      if a class with that name exists.  */
<span class="lineNum">     199 </span>            :   BOOL_BITFIELD objc_need_raw_identifier : 1;
<span class="lineNum">     200 </span>            :   /* Nonzero if we're processing a __transaction statement.  The value
<span class="lineNum">     201 </span>            :      is 1 | TM_STMT_ATTR_*.  */
<span class="lineNum">     202 </span>            :   unsigned int in_transaction : 4;
<span class="lineNum">     203 </span>            :   /* True if we are in a context where the Objective-C &quot;Property attribute&quot;
<span class="lineNum">     204 </span>            :      keywords are valid.  */
<span class="lineNum">     205 </span>            :   BOOL_BITFIELD objc_property_attr_context : 1;
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :   /* Location of the last consumed token.  */
<span class="lineNum">     208 </span>            :   location_t last_token_location;
<span class="lineNum">     209 </span>            : };
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            : /* Return a pointer to the Nth token in PARSERs tokens_buf.  */
<a name="212"><span class="lineNum">     212 </span>            : </a>
<span class="lineNum">     213 </span>            : c_token *
<span class="lineNum">     214 </span><span class="lineCov">         14 : c_parser_tokens_buf (c_parser *parser, unsigned n)</span>
<span class="lineNum">     215 </span>            : {
<span class="lineNum">     216 </span><span class="lineCov">         14 :   return &amp;parser-&gt;tokens_buf[n];</span>
<span class="lineNum">     217 </span>            : }
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            : /* Return the error state of PARSER.  */
<a name="220"><span class="lineNum">     220 </span>            : </a>
<span class="lineNum">     221 </span>            : bool
<span class="lineNum">     222 </span><span class="lineCov">        536 : c_parser_error (c_parser *parser)</span>
<span class="lineNum">     223 </span>            : {
<span class="lineNum">     224 </span><span class="lineCov">        536 :   return parser-&gt;error;</span>
<span class="lineNum">     225 </span>            : }
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : /* Set the error state of PARSER to ERR.  */
<a name="228"><span class="lineNum">     228 </span>            : </a>
<span class="lineNum">     229 </span>            : void
<span class="lineNum">     230 </span><span class="lineNoCov">          0 : c_parser_set_error (c_parser *parser, bool err)</span>
<span class="lineNum">     231 </span>            : {
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :   parser-&gt;error = err;</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : /* The actual parser and external interface.  ??? Does this need to be
<span class="lineNum">     237 </span>            :    garbage-collected?  */
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            : static GTY (()) c_parser *the_parser;
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            : /* Read in and lex a single token, storing it in *TOKEN.  */
<a name="242"><span class="lineNum">     242 </span>            : </a>
<span class="lineNum">     243 </span>            : static void
<span class="lineNum">     244 </span><span class="lineCov"> 1190089784 : c_lex_one_token (c_parser *parser, c_token *token)</span>
<span class="lineNum">     245 </span>            : {
<span class="lineNum">     246 </span><span class="lineCov"> 1190089784 :   timevar_push (TV_LEX);</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineCov"> 3570269261 :   token-&gt;type = c_lex_with_flags (&amp;token-&gt;value, &amp;token-&gt;location,</span>
<span class="lineNum">     249 </span>            :                                   &amp;token-&gt;flags,
<span class="lineNum">     250 </span>            :                                   (parser-&gt;lex_untranslated_string
<span class="lineNum">     251 </span><span class="lineCov"> 1190089784 :                                    ? C_LEX_STRING_NO_TRANSLATE : 0));</span>
<span class="lineNum">     252 </span><span class="lineCov"> 1190089693 :   token-&gt;id_kind = C_ID_NONE;</span>
<span class="lineNum">     253 </span><span class="lineCov"> 1190089693 :   token-&gt;keyword = RID_MAX;</span>
<span class="lineNum">     254 </span><span class="lineCov"> 1190089693 :   token-&gt;pragma_kind = PRAGMA_NONE;</span>
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span><span class="lineCov"> 1190089693 :   switch (token-&gt;type)</span>
<span class="lineNum">     257 </span>            :     {
<span class="lineNum">     258 </span><span class="lineCov">  547780687 :     case CPP_NAME:</span>
<span class="lineNum">     259 </span><span class="lineCov">  547780687 :       {</span>
<span class="lineNum">     260 </span><span class="lineCov">  547780687 :         tree decl;</span>
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span><span class="lineCov">  547780687 :         bool objc_force_identifier = parser-&gt;objc_need_raw_identifier;</span>
<span class="lineNum">     263 </span><span class="lineCov">  547780687 :         if (c_dialect_objc ())</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :           parser-&gt;objc_need_raw_identifier = false;</span>
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span><span class="lineCov"> 1095561374 :         if (C_IS_RESERVED_WORD (token-&gt;value))</span>
<span class="lineNum">     267 </span>            :           {
<span class="lineNum">     268 </span><span class="lineCov">  159192655 :             enum rid rid_code = C_RID_CODE (token-&gt;value);</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineCov">  159192655 :             if (rid_code == RID_CXX_COMPAT_WARN)</span>
<span class="lineNum">     271 </span>            :               {
<span class="lineNum">     272 </span><span class="lineCov">         35 :                 warning_at (token-&gt;location,</span>
<span class="lineNum">     273 </span>            :                             OPT_Wc___compat,
<span class="lineNum">     274 </span>            :                             &quot;identifier %qE conflicts with C++ keyword&quot;,
<span class="lineNum">     275 </span>            :                             token-&gt;value);
<span class="lineNum">     276 </span>            :               }
<span class="lineNum">     277 </span><span class="lineCov">  318385240 :             else if (rid_code &gt;= RID_FIRST_ADDR_SPACE</span>
<span class="lineNum">     278 </span><span class="lineCov">  159192620 :                      &amp;&amp; rid_code &lt;= RID_LAST_ADDR_SPACE)</span>
<span class="lineNum">     279 </span>            :               {
<span class="lineNum">     280 </span><span class="lineCov">         28 :                 addr_space_t as;</span>
<span class="lineNum">     281 </span><span class="lineCov">         28 :                 as = (addr_space_t) (rid_code - RID_FIRST_ADDR_SPACE);</span>
<span class="lineNum">     282 </span><span class="lineCov">         28 :                 targetm.addr_space.diagnose_usage (as, token-&gt;location);</span>
<span class="lineNum">     283 </span><span class="lineCov">         28 :                 token-&gt;id_kind = C_ID_ADDRSPACE;</span>
<span class="lineNum">     284 </span><span class="lineCov">         28 :                 token-&gt;keyword = rid_code;</span>
<span class="lineNum">     285 </span><span class="lineCov">         28 :                 break;</span>
<span class="lineNum">     286 </span>            :               }
<span class="lineNum">     287 </span><span class="lineCov">  159192592 :             else if (c_dialect_objc () &amp;&amp; OBJC_IS_PQ_KEYWORD (rid_code))</span>
<span class="lineNum">     288 </span>            :               {
<span class="lineNum">     289 </span>            :                 /* We found an Objective-C &quot;pq&quot; keyword (in, out,
<span class="lineNum">     290 </span>            :                    inout, bycopy, byref, oneway).  They need special
<span class="lineNum">     291 </span>            :                    care because the interpretation depends on the
<span class="lineNum">     292 </span>            :                    context.  */
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :                 if (parser-&gt;objc_pq_context)</span>
<span class="lineNum">     294 </span>            :                   {
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :                     token-&gt;type = CPP_KEYWORD;</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :                     token-&gt;keyword = rid_code;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     298 </span>            :                   }
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :                 else if (parser-&gt;objc_could_be_foreach_context</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :                          &amp;&amp; rid_code == RID_IN)</span>
<span class="lineNum">     301 </span>            :                   {
<span class="lineNum">     302 </span>            :                     /* We are in Objective-C, inside a (potential)
<span class="lineNum">     303 </span>            :                        foreach context (which means after having
<span class="lineNum">     304 </span>            :                        parsed 'for (', but before having parsed ';'),
<span class="lineNum">     305 </span>            :                        and we found 'in'.  We consider it the keyword
<span class="lineNum">     306 </span>            :                        which terminates the declaration at the
<span class="lineNum">     307 </span>            :                        beginning of a foreach-statement.  Note that
<span class="lineNum">     308 </span>            :                        this means you can't use 'in' for anything else
<span class="lineNum">     309 </span>            :                        in that context; in particular, in Objective-C
<span class="lineNum">     310 </span>            :                        you can't use 'in' as the name of the running
<span class="lineNum">     311 </span>            :                        variable in a C for loop.  We could potentially
<span class="lineNum">     312 </span>            :                        try to add code here to disambiguate, but it
<span class="lineNum">     313 </span>            :                        seems a reasonable limitation.  */
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :                     token-&gt;type = CPP_KEYWORD;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :                     token-&gt;keyword = rid_code;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     317 </span>            :                   }
<span class="lineNum">     318 </span>            :                 /* Else, &quot;pq&quot; keywords outside of the &quot;pq&quot; context are
<span class="lineNum">     319 </span>            :                    not keywords, and we fall through to the code for
<span class="lineNum">     320 </span>            :                    normal tokens.  */
<span class="lineNum">     321 </span>            :               }
<span class="lineNum">     322 </span><span class="lineCov">  159192592 :             else if (c_dialect_objc () &amp;&amp; OBJC_IS_PATTR_KEYWORD (rid_code))</span>
<span class="lineNum">     323 </span>            :               {
<span class="lineNum">     324 </span>            :                 /* We found an Objective-C &quot;property attribute&quot;
<span class="lineNum">     325 </span>            :                    keyword (getter, setter, readonly, etc). These are
<span class="lineNum">     326 </span>            :                    only valid in the property context.  */
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :                 if (parser-&gt;objc_property_attr_context)</span>
<span class="lineNum">     328 </span>            :                   {
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :                     token-&gt;type = CPP_KEYWORD;</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :                     token-&gt;keyword = rid_code;</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     332 </span>            :                   }
<span class="lineNum">     333 </span>            :                 /* Else they are not special keywords.
<span class="lineNum">     334 </span>            :                 */
<span class="lineNum">     335 </span>            :               }
<span class="lineNum">     336 </span><span class="lineCov">  159192592 :             else if (c_dialect_objc () </span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :                      &amp;&amp; (OBJC_IS_AT_KEYWORD (rid_code)</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :                          || OBJC_IS_CXX_KEYWORD (rid_code)))</span>
<span class="lineNum">     339 </span>            :               {
<span class="lineNum">     340 </span>            :                 /* We found one of the Objective-C &quot;@&quot; keywords (defs,
<span class="lineNum">     341 </span>            :                    selector, synchronized, etc) or one of the
<span class="lineNum">     342 </span>            :                    Objective-C &quot;cxx&quot; keywords (class, private,
<span class="lineNum">     343 </span>            :                    protected, public, try, catch, throw) without a
<span class="lineNum">     344 </span>            :                    preceding '@' sign.  Do nothing and fall through to
<span class="lineNum">     345 </span>            :                    the code for normal tokens (in C++ we would still
<span class="lineNum">     346 </span>            :                    consider the CXX ones keywords, but not in C).  */
<span class="lineNum">     347 </span>            :                 ;
<span class="lineNum">     348 </span>            :               }
<span class="lineNum">     349 </span>            :             else
<span class="lineNum">     350 </span>            :               {
<span class="lineNum">     351 </span><span class="lineCov">  159192592 :                 token-&gt;type = CPP_KEYWORD;</span>
<span class="lineNum">     352 </span><span class="lineCov">  159192592 :                 token-&gt;keyword = rid_code;</span>
<span class="lineNum">     353 </span><span class="lineCov">  159192592 :                 break;</span>
<span class="lineNum">     354 </span>            :               }
<span class="lineNum">     355 </span>            :           }
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineCov">  388588067 :         decl = lookup_name (token-&gt;value);</span>
<span class="lineNum">     358 </span><span class="lineCov">  388588067 :         if (decl)</span>
<span class="lineNum">     359 </span>            :           {
<span class="lineNum">     360 </span><span class="lineCov">  214242232 :             if (TREE_CODE (decl) == TYPE_DECL)</span>
<span class="lineNum">     361 </span>            :               {
<span class="lineNum">     362 </span><span class="lineCov">  126717389 :                 token-&gt;id_kind = C_ID_TYPENAME;</span>
<span class="lineNum">     363 </span><span class="lineCov">  126717389 :                 break;</span>
<span class="lineNum">     364 </span>            :               }
<span class="lineNum">     365 </span>            :           }
<span class="lineNum">     366 </span><span class="lineCov">  174345835 :         else if (c_dialect_objc ())</span>
<span class="lineNum">     367 </span>            :           {
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :             tree objc_interface_decl = objc_is_class_name (token-&gt;value);</span>
<span class="lineNum">     369 </span>            :             /* Objective-C class names are in the same namespace as
<span class="lineNum">     370 </span>            :                variables and typedefs, and hence are shadowed by local
<span class="lineNum">     371 </span>            :                declarations.  */
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :             if (objc_interface_decl</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :                 &amp;&amp; (!objc_force_identifier || global_bindings_p ()))</span>
<span class="lineNum">     374 </span>            :               {
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :                 token-&gt;value = objc_interface_decl;</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :                 token-&gt;id_kind = C_ID_CLASSNAME;</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     378 </span>            :               }
<span class="lineNum">     379 </span>            :           }
<span class="lineNum">     380 </span><span class="lineCov">  261870678 :         token-&gt;id_kind = C_ID_ID;</span>
<span class="lineNum">     381 </span>            :       }
<span class="lineNum">     382 </span><span class="lineCov">  261870678 :       break;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     case CPP_AT_NAME:</span>
<span class="lineNum">     384 </span>            :       /* This only happens in Objective-C; it must be a keyword.  */
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :       token-&gt;type = CPP_KEYWORD;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :       switch (C_RID_CODE (token-&gt;value))</span>
<span class="lineNum">     387 </span>            :         {
<span class="lineNum">     388 </span>            :           /* Replace 'class' with '@class', 'private' with '@private',
<span class="lineNum">     389 </span>            :              etc.  This prevents confusion with the C++ keyword
<span class="lineNum">     390 </span>            :              'class', and makes the tokens consistent with other
<span class="lineNum">     391 </span>            :              Objective-C 'AT' keywords.  For example '@class' is
<span class="lineNum">     392 </span>            :              reported as RID_AT_CLASS which is consistent with
<span class="lineNum">     393 </span>            :              '@synchronized', which is reported as
<span class="lineNum">     394 </span>            :              RID_AT_SYNCHRONIZED.
<span class="lineNum">     395 </span>            :           */
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :         case RID_CLASS:     token-&gt;keyword = RID_AT_CLASS; break;</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         case RID_PRIVATE:   token-&gt;keyword = RID_AT_PRIVATE; break;</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :         case RID_PROTECTED: token-&gt;keyword = RID_AT_PROTECTED; break;</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :         case RID_PUBLIC:    token-&gt;keyword = RID_AT_PUBLIC; break;</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :         case RID_THROW:     token-&gt;keyword = RID_AT_THROW; break;</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :         case RID_TRY:       token-&gt;keyword = RID_AT_TRY; break;</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :         case RID_CATCH:     token-&gt;keyword = RID_AT_CATCH; break;</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :         case RID_SYNCHRONIZED: token-&gt;keyword = RID_AT_SYNCHRONIZED; break;</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :         default:            token-&gt;keyword = C_RID_CODE (token-&gt;value);</span>
<span class="lineNum">     405 </span>            :         }
<span class="lineNum">     406 </span>            :       break;
<span class="lineNum">     407 </span><span class="lineCov">  358903742 :     case CPP_COLON:</span>
<span class="lineNum">     408 </span><span class="lineCov">  358903742 :     case CPP_COMMA:</span>
<span class="lineNum">     409 </span><span class="lineCov">  358903742 :     case CPP_CLOSE_PAREN:</span>
<span class="lineNum">     410 </span><span class="lineCov">  358903742 :     case CPP_SEMICOLON:</span>
<span class="lineNum">     411 </span>            :       /* These tokens may affect the interpretation of any identifiers
<span class="lineNum">     412 </span>            :          following, if doing Objective-C.  */
<span class="lineNum">     413 </span><span class="lineCov">  358903742 :       if (c_dialect_objc ())</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :         parser-&gt;objc_need_raw_identifier = false;</span>
<span class="lineNum">     415 </span>            :       break;
<span class="lineNum">     416 </span><span class="lineCov">     597718 :     case CPP_PRAGMA:</span>
<span class="lineNum">     417 </span>            :       /* We smuggled the cpp_token-&gt;u.pragma value in an INTEGER_CST.  */
<span class="lineNum">     418 </span><span class="lineCov">     597718 :       token-&gt;pragma_kind = (enum pragma_kind) TREE_INT_CST_LOW (token-&gt;value);</span>
<span class="lineNum">     419 </span><span class="lineCov">     597718 :       token-&gt;value = NULL;</span>
<span class="lineNum">     420 </span><span class="lineCov">     597718 :       break;</span>
<span class="lineNum">     421 </span>            :     default:
<span class="lineNum">     422 </span>            :       break;
<span class="lineNum">     423 </span>            :     }
<span class="lineNum">     424 </span><span class="lineCov"> 1190089693 :   timevar_pop (TV_LEX);</span>
<span class="lineNum">     425 </span><span class="lineCov"> 1190089693 : }</span>
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            : /* Return a pointer to the next token from PARSER, reading it in if
<span class="lineNum">     428 </span>            :    necessary.  */
<a name="429"><span class="lineNum">     429 </span>            : </a>
<span class="lineNum">     430 </span>            : c_token *
<span class="lineNum">     431 </span><span class="lineCov"> 8968753351 : c_parser_peek_token (c_parser *parser)</span>
<span class="lineNum">     432 </span>            : {
<span class="lineNum">     433 </span><span class="lineCov"> 8968753351 :   if (parser-&gt;tokens_avail == 0)</span>
<span class="lineNum">     434 </span>            :     {
<span class="lineNum">     435 </span><span class="lineCov"> 1112117205 :       c_lex_one_token (parser, &amp;parser-&gt;tokens[0]);</span>
<span class="lineNum">     436 </span><span class="lineCov"> 1112117114 :       parser-&gt;tokens_avail = 1;</span>
<span class="lineNum">     437 </span>            :     }
<span class="lineNum">     438 </span><span class="lineCov"> 8968753260 :   return &amp;parser-&gt;tokens[0];</span>
<span class="lineNum">     439 </span>            : }
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            : /* Return a pointer to the next-but-one token from PARSER, reading it
<span class="lineNum">     442 </span>            :    in if necessary.  The next token is already read in.  */
<a name="443"><span class="lineNum">     443 </span>            : </a>
<span class="lineNum">     444 </span>            : c_token *
<span class="lineNum">     445 </span><span class="lineCov">   94055071 : c_parser_peek_2nd_token (c_parser *parser)</span>
<span class="lineNum">     446 </span>            : {
<span class="lineNum">     447 </span><span class="lineCov">   94055071 :   if (parser-&gt;tokens_avail &gt;= 2)</span>
<span class="lineNum">     448 </span><span class="lineCov">   16082560 :     return &amp;parser-&gt;tokens[1];</span>
<span class="lineNum">     449 </span><span class="lineCov">   77972511 :   gcc_assert (parser-&gt;tokens_avail == 1);</span>
<span class="lineNum">     450 </span><span class="lineCov">   77972511 :   gcc_assert (parser-&gt;tokens[0].type != CPP_EOF);</span>
<span class="lineNum">     451 </span><span class="lineCov">   77972511 :   gcc_assert (parser-&gt;tokens[0].type != CPP_PRAGMA_EOL);</span>
<span class="lineNum">     452 </span><span class="lineCov">   77972511 :   c_lex_one_token (parser, &amp;parser-&gt;tokens[1]);</span>
<span class="lineNum">     453 </span><span class="lineCov">   77972511 :   parser-&gt;tokens_avail = 2;</span>
<span class="lineNum">     454 </span><span class="lineCov">   77972511 :   return &amp;parser-&gt;tokens[1];</span>
<span class="lineNum">     455 </span>            : }
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            : /* Return a pointer to the Nth token from PARSER, reading it
<span class="lineNum">     458 </span>            :    in if necessary.  The N-1th token is already read in.  */
<a name="459"><span class="lineNum">     459 </span>            : </a>
<span class="lineNum">     460 </span>            : c_token *
<span class="lineNum">     461 </span><span class="lineCov">         68 : c_parser_peek_nth_token (c_parser *parser, unsigned int n)</span>
<span class="lineNum">     462 </span>            : {
<span class="lineNum">     463 </span>            :   /* N is 1-based, not zero-based.  */
<span class="lineNum">     464 </span><span class="lineCov">         68 :   gcc_assert (n &gt; 0);</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span><span class="lineCov">         68 :   if (parser-&gt;tokens_avail &gt;= n)</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :     return &amp;parser-&gt;tokens[n - 1];</span>
<span class="lineNum">     468 </span><span class="lineCov">         68 :   gcc_assert (parser-&gt;tokens_avail == n - 1);</span>
<span class="lineNum">     469 </span><span class="lineCov">         68 :   c_lex_one_token (parser, &amp;parser-&gt;tokens[n - 1]);</span>
<span class="lineNum">     470 </span><span class="lineCov">         68 :   parser-&gt;tokens_avail = n;</span>
<span class="lineNum">     471 </span><span class="lineCov">         68 :   return &amp;parser-&gt;tokens[n - 1];</span>
<span class="lineNum">     472 </span>            : }
<a name="473"><span class="lineNum">     473 </span>            : </a>
<span class="lineNum">     474 </span>            : bool
<span class="lineNum">     475 </span><span class="lineCov">   24401962 : c_keyword_starts_typename (enum rid keyword)</span>
<span class="lineNum">     476 </span>            : {
<span class="lineNum">     477 </span><span class="lineCov">   24401962 :   switch (keyword)</span>
<span class="lineNum">     478 </span>            :     {
<span class="lineNum">     479 </span>            :     case RID_UNSIGNED:
<span class="lineNum">     480 </span>            :     case RID_LONG:
<span class="lineNum">     481 </span>            :     case RID_SHORT:
<span class="lineNum">     482 </span>            :     case RID_SIGNED:
<span class="lineNum">     483 </span>            :     case RID_COMPLEX:
<span class="lineNum">     484 </span>            :     case RID_INT:
<span class="lineNum">     485 </span>            :     case RID_CHAR:
<span class="lineNum">     486 </span>            :     case RID_FLOAT:
<span class="lineNum">     487 </span>            :     case RID_DOUBLE:
<span class="lineNum">     488 </span>            :     case RID_VOID:
<span class="lineNum">     489 </span>            :     case RID_DFLOAT32:
<span class="lineNum">     490 </span>            :     case RID_DFLOAT64:
<span class="lineNum">     491 </span>            :     case RID_DFLOAT128:
<span class="lineNum">     492 </span>            :     CASE_RID_FLOATN_NX:
<span class="lineNum">     493 </span>            :     case RID_BOOL:
<span class="lineNum">     494 </span>            :     case RID_ENUM:
<span class="lineNum">     495 </span>            :     case RID_STRUCT:
<span class="lineNum">     496 </span>            :     case RID_UNION:
<span class="lineNum">     497 </span>            :     case RID_TYPEOF:
<span class="lineNum">     498 </span>            :     case RID_CONST:
<span class="lineNum">     499 </span>            :     case RID_ATOMIC:
<span class="lineNum">     500 </span>            :     case RID_VOLATILE:
<span class="lineNum">     501 </span>            :     case RID_RESTRICT:
<span class="lineNum">     502 </span>            :     case RID_ATTRIBUTE:
<span class="lineNum">     503 </span>            :     case RID_FRACT:
<span class="lineNum">     504 </span>            :     case RID_ACCUM:
<span class="lineNum">     505 </span>            :     case RID_SAT:
<span class="lineNum">     506 </span>            :     case RID_AUTO_TYPE:
<span class="lineNum">     507 </span>            :     case RID_ALIGNAS:
<span class="lineNum">     508 </span>            :       return true;
<span class="lineNum">     509 </span><span class="lineCov">   19413251 :     default:</span>
<span class="lineNum">     510 </span><span class="lineCov">   19413251 :       if (keyword &gt;= RID_FIRST_INT_N</span>
<span class="lineNum">     511 </span>            :           &amp;&amp; keyword &lt; RID_FIRST_INT_N + NUM_INT_N_ENTS
<span class="lineNum">     512 </span><span class="lineCov">        183 :           &amp;&amp; int_n_enabled_p[keyword - RID_FIRST_INT_N])</span>
<span class="lineNum">     513 </span><span class="lineCov">        183 :         return true;</span>
<span class="lineNum">     514 </span>            :       return false;
<span class="lineNum">     515 </span>            :     }
<span class="lineNum">     516 </span>            : }
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            : /* Return true if TOKEN can start a type name,
<a name="519"><span class="lineNum">     519 </span>            :    false otherwise.  */</a>
<span class="lineNum">     520 </span>            : bool
<span class="lineNum">     521 </span><span class="lineCov">  237068284 : c_token_starts_typename (c_token *token)</span>
<span class="lineNum">     522 </span>            : {
<span class="lineNum">     523 </span><span class="lineCov">  237068284 :   switch (token-&gt;type)</span>
<span class="lineNum">     524 </span>            :     {
<span class="lineNum">     525 </span><span class="lineCov">  209109695 :     case CPP_NAME:</span>
<span class="lineNum">     526 </span><span class="lineCov">  209109695 :       switch (token-&gt;id_kind)</span>
<span class="lineNum">     527 </span>            :         {
<span class="lineNum">     528 </span>            :         case C_ID_ID:
<span class="lineNum">     529 </span>            :           return false;
<span class="lineNum">     530 </span><span class="lineCov">          2 :         case C_ID_ADDRSPACE:</span>
<span class="lineNum">     531 </span><span class="lineCov">          2 :           return true;</span>
<span class="lineNum">     532 </span><span class="lineCov">  188587800 :         case C_ID_TYPENAME:</span>
<span class="lineNum">     533 </span><span class="lineCov">  188587800 :           return true;</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :         case C_ID_CLASSNAME:</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :           gcc_assert (c_dialect_objc ());</span>
<span class="lineNum">     536 </span>            :           return true;
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">     539 </span>            :         }
<span class="lineNum">     540 </span><span class="lineCov">   24362770 :     case CPP_KEYWORD:</span>
<span class="lineNum">     541 </span><span class="lineCov">   24362770 :       return c_keyword_starts_typename (token-&gt;keyword);</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :     case CPP_LESS:</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :       if (c_dialect_objc ())</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     545 </span>            :       return false;
<span class="lineNum">     546 </span>            :     default:
<span class="lineNum">     547 </span>            :       return false;
<span class="lineNum">     548 </span>            :     }
<span class="lineNum">     549 </span>            : }
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span>            : /* Return true if the next token from PARSER can start a type name,
<span class="lineNum">     552 </span>            :    false otherwise.  LA specifies how to do lookahead in order to
<span class="lineNum">     553 </span>            :    detect unknown type names.  If unsure, pick CLA_PREFER_ID.  */
<a name="554"><span class="lineNum">     554 </span>            : </a>
<span class="lineNum">     555 </span>            : static inline bool
<span class="lineNum">     556 </span><span class="lineCov">  167780660 : c_parser_next_tokens_start_typename (c_parser *parser, enum c_lookahead_kind la)</span>
<span class="lineNum">     557 </span>            : {
<span class="lineNum">     558 </span><span class="lineCov">  167780660 :   c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">     559 </span><span class="lineCov">  167780660 :   if (c_token_starts_typename (token))</span>
<span class="lineNum">     560 </span>            :     return true;
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span>            :   /* Try a bit harder to detect an unknown typename.  */
<span class="lineNum">     563 </span><span class="lineCov">   38675436 :   if (la != cla_prefer_id</span>
<span class="lineNum">     564 </span>            :       &amp;&amp; token-&gt;type == CPP_NAME
<span class="lineNum">     565 </span><span class="lineCov">   23096386 :       &amp;&amp; token-&gt;id_kind == C_ID_ID</span>
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span>            :       /* Do not try too hard when we could have &quot;object in array&quot;.  */
<span class="lineNum">     568 </span><span class="lineCov">    3429268 :       &amp;&amp; !parser-&gt;objc_could_be_foreach_context</span>
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineCov">    3429268 :       &amp;&amp; (la == cla_prefer_type</span>
<span class="lineNum">     571 </span><span class="lineCov">    3429176 :           || c_parser_peek_2nd_token (parser)-&gt;type == CPP_NAME</span>
<span class="lineNum">     572 </span><span class="lineCov">    3429121 :           || c_parser_peek_2nd_token (parser)-&gt;type == CPP_MULT)</span>
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span>            :       /* Only unknown identifiers.  */
<span class="lineNum">     575 </span><span class="lineCov">   38676519 :       &amp;&amp; !lookup_name (token-&gt;value))</span>
<span class="lineNum">     576 </span><span class="lineCov">        168 :     return true;</span>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :   return false;
<span class="lineNum">     579 </span>            : }
<span class="lineNum">     580 </span>            : 
<a name="581"><span class="lineNum">     581 </span>            : /* Return true if TOKEN is a type qualifier, false otherwise.  */</a>
<span class="lineNum">     582 </span>            : static bool
<span class="lineNum">     583 </span><span class="lineCov">  228011272 : c_token_is_qualifier (c_token *token)</span>
<span class="lineNum">     584 </span>            : {
<span class="lineNum">     585 </span><span class="lineCov">  228011272 :   switch (token-&gt;type)</span>
<span class="lineNum">     586 </span>            :     {
<span class="lineNum">     587 </span><span class="lineCov">  225527893 :     case CPP_NAME:</span>
<span class="lineNum">     588 </span><span class="lineCov">  225527893 :       switch (token-&gt;id_kind)</span>
<span class="lineNum">     589 </span>            :         {
<span class="lineNum">     590 </span>            :         case C_ID_ADDRSPACE:
<span class="lineNum">     591 </span>            :           return true;
<span class="lineNum">     592 </span><span class="lineCov">  225527892 :         default:</span>
<span class="lineNum">     593 </span><span class="lineCov">  225527892 :           return false;</span>
<span class="lineNum">     594 </span>            :         }
<span class="lineNum">     595 </span><span class="lineCov">    2483379 :     case CPP_KEYWORD:</span>
<span class="lineNum">     596 </span><span class="lineCov">    2483379 :       switch (token-&gt;keyword)</span>
<span class="lineNum">     597 </span>            :         {
<span class="lineNum">     598 </span>            :         case RID_CONST:
<span class="lineNum">     599 </span>            :         case RID_VOLATILE:
<span class="lineNum">     600 </span>            :         case RID_RESTRICT:
<span class="lineNum">     601 </span>            :         case RID_ATTRIBUTE:
<span class="lineNum">     602 </span>            :         case RID_ATOMIC:
<span class="lineNum">     603 </span>            :           return true;
<span class="lineNum">     604 </span>            :         default:
<span class="lineNum">     605 </span>            :           return false;
<span class="lineNum">     606 </span>            :         }
<span class="lineNum">     607 </span>            :     case CPP_LESS:
<span class="lineNum">     608 </span>            :       return false;
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">     611 </span>            :     }
<span class="lineNum">     612 </span>            : }
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            : /* Return true if the next token from PARSER is a type qualifier,
<span class="lineNum">     615 </span>            :    false otherwise.  */
<span class="lineNum">     616 </span>            : static inline bool
<span class="lineNum">     617 </span>            : c_parser_next_token_is_qualifier (c_parser *parser)
<span class="lineNum">     618 </span>            : {
<span class="lineNum">     619 </span><span class="lineCov">  456022544 :   c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">     620 </span><span class="lineCov">  228011272 :   return c_token_is_qualifier (token);</span>
<span class="lineNum">     621 </span>            : }
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            : /* Return true if TOKEN can start declaration specifiers, false
<a name="624"><span class="lineNum">     624 </span>            :    otherwise.  */</a>
<span class="lineNum">     625 </span>            : static bool
<span class="lineNum">     626 </span><span class="lineCov">   91422010 : c_token_starts_declspecs (c_token *token)</span>
<span class="lineNum">     627 </span>            : {
<span class="lineNum">     628 </span><span class="lineCov">   91422010 :   switch (token-&gt;type)</span>
<span class="lineNum">     629 </span>            :     {
<span class="lineNum">     630 </span><span class="lineCov">   49076877 :     case CPP_NAME:</span>
<span class="lineNum">     631 </span><span class="lineCov">   49076877 :       switch (token-&gt;id_kind)</span>
<span class="lineNum">     632 </span>            :         {
<span class="lineNum">     633 </span>            :         case C_ID_ID:
<span class="lineNum">     634 </span>            :           return false;
<span class="lineNum">     635 </span><span class="lineCov">          1 :         case C_ID_ADDRSPACE:</span>
<span class="lineNum">     636 </span><span class="lineCov">          1 :           return true;</span>
<span class="lineNum">     637 </span><span class="lineCov">   45661183 :         case C_ID_TYPENAME:</span>
<span class="lineNum">     638 </span><span class="lineCov">   45661183 :           return true;</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :         case C_ID_CLASSNAME:</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :           gcc_assert (c_dialect_objc ());</span>
<span class="lineNum">     641 </span>            :           return true;
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">     644 </span>            :         }
<span class="lineNum">     645 </span><span class="lineCov">   41764231 :     case CPP_KEYWORD:</span>
<span class="lineNum">     646 </span><span class="lineCov">   41764231 :       switch (token-&gt;keyword)</span>
<span class="lineNum">     647 </span>            :         {
<span class="lineNum">     648 </span>            :         case RID_STATIC:
<span class="lineNum">     649 </span>            :         case RID_EXTERN:
<span class="lineNum">     650 </span>            :         case RID_REGISTER:
<span class="lineNum">     651 </span>            :         case RID_TYPEDEF:
<span class="lineNum">     652 </span>            :         case RID_INLINE:
<span class="lineNum">     653 </span>            :         case RID_NORETURN:
<span class="lineNum">     654 </span>            :         case RID_AUTO:
<span class="lineNum">     655 </span>            :         case RID_THREAD:
<span class="lineNum">     656 </span>            :         case RID_UNSIGNED:
<span class="lineNum">     657 </span>            :         case RID_LONG:
<span class="lineNum">     658 </span>            :         case RID_SHORT:
<span class="lineNum">     659 </span>            :         case RID_SIGNED:
<span class="lineNum">     660 </span>            :         case RID_COMPLEX:
<span class="lineNum">     661 </span>            :         case RID_INT:
<span class="lineNum">     662 </span>            :         case RID_CHAR:
<span class="lineNum">     663 </span>            :         case RID_FLOAT:
<span class="lineNum">     664 </span>            :         case RID_DOUBLE:
<span class="lineNum">     665 </span>            :         case RID_VOID:
<span class="lineNum">     666 </span>            :         case RID_DFLOAT32:
<span class="lineNum">     667 </span>            :         case RID_DFLOAT64:
<span class="lineNum">     668 </span>            :         case RID_DFLOAT128:
<span class="lineNum">     669 </span>            :         CASE_RID_FLOATN_NX:
<span class="lineNum">     670 </span>            :         case RID_BOOL:
<span class="lineNum">     671 </span>            :         case RID_ENUM:
<span class="lineNum">     672 </span>            :         case RID_STRUCT:
<span class="lineNum">     673 </span>            :         case RID_UNION:
<span class="lineNum">     674 </span>            :         case RID_TYPEOF:
<span class="lineNum">     675 </span>            :         case RID_CONST:
<span class="lineNum">     676 </span>            :         case RID_VOLATILE:
<span class="lineNum">     677 </span>            :         case RID_RESTRICT:
<span class="lineNum">     678 </span>            :         case RID_ATTRIBUTE:
<span class="lineNum">     679 </span>            :         case RID_FRACT:
<span class="lineNum">     680 </span>            :         case RID_ACCUM:
<span class="lineNum">     681 </span>            :         case RID_SAT:
<span class="lineNum">     682 </span>            :         case RID_ALIGNAS:
<span class="lineNum">     683 </span>            :         case RID_ATOMIC:
<span class="lineNum">     684 </span>            :         case RID_AUTO_TYPE:
<span class="lineNum">     685 </span>            :           return true;
<span class="lineNum">     686 </span><span class="lineCov">   19143472 :         default:</span>
<span class="lineNum">     687 </span><span class="lineCov">   19143472 :           if (token-&gt;keyword &gt;= RID_FIRST_INT_N</span>
<span class="lineNum">     688 </span>            :               &amp;&amp; token-&gt;keyword &lt; RID_FIRST_INT_N + NUM_INT_N_ENTS
<span class="lineNum">     689 </span><span class="lineCov">        171 :               &amp;&amp; int_n_enabled_p[token-&gt;keyword - RID_FIRST_INT_N])</span>
<span class="lineNum">     690 </span><span class="lineCov">        171 :             return true;</span>
<span class="lineNum">     691 </span>            :           return false;
<span class="lineNum">     692 </span>            :         }
<span class="lineNum">     693 </span><span class="lineCov">          2 :     case CPP_LESS:</span>
<span class="lineNum">     694 </span><span class="lineCov">          2 :       if (c_dialect_objc ())</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     696 </span>            :       return false;
<span class="lineNum">     697 </span>            :     default:
<span class="lineNum">     698 </span>            :       return false;
<span class="lineNum">     699 </span>            :     }
<span class="lineNum">     700 </span>            : }
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            : /* Return true if TOKEN can start declaration specifiers or a static
<a name="704"><span class="lineNum">     704 </span>            :    assertion, false otherwise.  */</a>
<span class="lineNum">     705 </span>            : static bool
<span class="lineNum">     706 </span><span class="lineNoCov">          0 : c_token_starts_declaration (c_token *token)</span>
<span class="lineNum">     707 </span>            : {
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :   if (c_token_starts_declspecs (token)</span>
<span class="lineNum">     709 </span><span class="lineCov">   25737939 :       || token-&gt;keyword == RID_STATIC_ASSERT)</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     711 </span>            :   else
<span class="lineNum">     712 </span>            :     return false;
<span class="lineNum">     713 </span>            : }
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            : /* Return true if the next token from PARSER can start declaration
<a name="716"><span class="lineNum">     716 </span>            :    specifiers, false otherwise.  */</a>
<span class="lineNum">     717 </span>            : bool
<span class="lineNum">     718 </span><span class="lineCov">   65684071 : c_parser_next_token_starts_declspecs (c_parser *parser)</span>
<span class="lineNum">     719 </span>            : {
<span class="lineNum">     720 </span><span class="lineCov">   65684071 :   c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :   /* In Objective-C, a classname normally starts a declspecs unless it
<span class="lineNum">     723 </span>            :      is immediately followed by a dot.  In that case, it is the
<span class="lineNum">     724 </span>            :      Objective-C 2.0 &quot;dot-syntax&quot; for class objects, ie, calls the
<span class="lineNum">     725 </span>            :      setter/getter on the class.  c_token_starts_declspecs() can't
<span class="lineNum">     726 </span>            :      differentiate between the two cases because it only checks the
<span class="lineNum">     727 </span>            :      current token, so we have a special check here.  */
<span class="lineNum">     728 </span><span class="lineCov">   65684071 :   if (c_dialect_objc () </span>
<span class="lineNum">     729 </span>            :       &amp;&amp; token-&gt;type == CPP_NAME
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :       &amp;&amp; token-&gt;id_kind == C_ID_CLASSNAME </span>
<span class="lineNum">     731 </span><span class="lineCov">   65684071 :       &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type == CPP_DOT)</span>
<span class="lineNum">     732 </span>            :     return false;
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span><span class="lineCov">   65684071 :   return c_token_starts_declspecs (token);</span>
<span class="lineNum">     735 </span>            : }
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            : /* Return true if the next tokens from PARSER can start declaration
<a name="738"><span class="lineNum">     738 </span>            :    specifiers or a static assertion, false otherwise.  */</a>
<span class="lineNum">     739 </span>            : bool
<span class="lineNum">     740 </span><span class="lineCov">   25736272 : c_parser_next_tokens_start_declaration (c_parser *parser)</span>
<span class="lineNum">     741 </span>            : {
<span class="lineNum">     742 </span><span class="lineCov">   25736272 :   c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span>            :   /* Same as above.  */
<span class="lineNum">     745 </span><span class="lineCov">   25736272 :   if (c_dialect_objc () </span>
<span class="lineNum">     746 </span>            :       &amp;&amp; token-&gt;type == CPP_NAME
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :       &amp;&amp; token-&gt;id_kind == C_ID_CLASSNAME </span>
<span class="lineNum">     748 </span><span class="lineCov">   25736272 :       &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type == CPP_DOT)</span>
<span class="lineNum">     749 </span>            :     return false;
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            :   /* Labels do not start declarations.  */
<span class="lineNum">     752 </span><span class="lineCov">   25736272 :   if (token-&gt;type == CPP_NAME</span>
<span class="lineNum">     753 </span><span class="lineCov">   25736272 :       &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type == CPP_COLON)</span>
<span class="lineNum">     754 </span>            :     return false;
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span><span class="lineCov">   25735988 :   if (c_token_starts_declaration (token))</span>
<span class="lineNum">     757 </span>            :     return true;
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span><span class="lineCov">   22538115 :   if (c_parser_next_tokens_start_typename (parser, cla_nonabstract_decl))</span>
<span class="lineNum">     760 </span><span class="lineCov">         42 :     return true;</span>
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span>            :   return false;
<span class="lineNum">     763 </span>            : }
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            : /* Consume the next token from PARSER.  */
<a name="766"><span class="lineNum">     766 </span>            : </a>
<span class="lineNum">     767 </span>            : void
<span class="lineNum">     768 </span><span class="lineCov"> 1189422500 : c_parser_consume_token (c_parser *parser)</span>
<span class="lineNum">     769 </span>            : {
<span class="lineNum">     770 </span><span class="lineCov"> 1189422500 :   gcc_assert (parser-&gt;tokens_avail &gt;= 1);</span>
<span class="lineNum">     771 </span><span class="lineCov"> 1189422500 :   gcc_assert (parser-&gt;tokens[0].type != CPP_EOF);</span>
<span class="lineNum">     772 </span><span class="lineCov"> 1189422500 :   gcc_assert (!parser-&gt;in_pragma || parser-&gt;tokens[0].type != CPP_PRAGMA_EOL);</span>
<span class="lineNum">     773 </span><span class="lineCov"> 1189422500 :   gcc_assert (parser-&gt;error || parser-&gt;tokens[0].type != CPP_PRAGMA);</span>
<span class="lineNum">     774 </span><span class="lineCov"> 1189422500 :   parser-&gt;last_token_location = parser-&gt;tokens[0].location;</span>
<span class="lineNum">     775 </span><span class="lineCov"> 1189422500 :   if (parser-&gt;tokens != &amp;parser-&gt;tokens_buf[0])</span>
<span class="lineNum">     776 </span><span class="lineCov">       1768 :     parser-&gt;tokens++;</span>
<span class="lineNum">     777 </span><span class="lineCov"> 1189420732 :   else if (parser-&gt;tokens_avail == 2)</span>
<span class="lineNum">     778 </span><span class="lineCov">   77972490 :     parser-&gt;tokens[0] = parser-&gt;tokens[1];</span>
<span class="lineNum">     779 </span><span class="lineCov"> 1189422500 :   parser-&gt;tokens_avail--;</span>
<span class="lineNum">     780 </span><span class="lineCov"> 1189422500 : }</span>
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            : /* Expect the current token to be a #pragma.  Consume it and remember
<span class="lineNum">     783 </span>            :    that we've begun parsing a pragma.  */
<a name="784"><span class="lineNum">     784 </span>            : </a>
<span class="lineNum">     785 </span>            : static void
<span class="lineNum">     786 </span><span class="lineCov">     597644 : c_parser_consume_pragma (c_parser *parser)</span>
<span class="lineNum">     787 </span>            : {
<span class="lineNum">     788 </span><span class="lineCov">     597644 :   gcc_assert (!parser-&gt;in_pragma);</span>
<span class="lineNum">     789 </span><span class="lineCov">     597644 :   gcc_assert (parser-&gt;tokens_avail &gt;= 1);</span>
<span class="lineNum">     790 </span><span class="lineCov">     597644 :   gcc_assert (parser-&gt;tokens[0].type == CPP_PRAGMA);</span>
<span class="lineNum">     791 </span><span class="lineCov">     597644 :   if (parser-&gt;tokens != &amp;parser-&gt;tokens_buf[0])</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :     parser-&gt;tokens++;</span>
<span class="lineNum">     793 </span><span class="lineCov">     597644 :   else if (parser-&gt;tokens_avail == 2)</span>
<span class="lineNum">     794 </span><span class="lineCov">         21 :     parser-&gt;tokens[0] = parser-&gt;tokens[1];</span>
<span class="lineNum">     795 </span><span class="lineCov">     597644 :   parser-&gt;tokens_avail--;</span>
<span class="lineNum">     796 </span><span class="lineCov">     597644 :   parser-&gt;in_pragma = true;</span>
<span class="lineNum">     797 </span><span class="lineCov">     597644 : }</span>
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            : /* Update the global input_location from TOKEN.  */
<span class="lineNum">     800 </span>            : static inline void
<span class="lineNum">     801 </span>            : c_parser_set_source_position_from_token (c_token *token)
<span class="lineNum">     802 </span>            : {
<span class="lineNum">     803 </span><span class="lineCov">    5564957 :   if (token-&gt;type != CPP_EOF)</span>
<span class="lineNum">     804 </span>            :     {
<span class="lineNum">     805 </span><span class="lineCov">    5564914 :       input_location = token-&gt;location;</span>
<span class="lineNum">     806 </span>            :     }
<span class="lineNum">     807 </span>            : }
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            : /* Helper function for c_parser_error.
<span class="lineNum">     810 </span>            :    Having peeked a token of kind TOK1_KIND that might signify
<span class="lineNum">     811 </span>            :    a conflict marker, peek successor tokens to determine
<span class="lineNum">     812 </span>            :    if we actually do have a conflict marker.
<span class="lineNum">     813 </span>            :    Specifically, we consider a run of 7 '&lt;', '=' or '&gt;' characters
<span class="lineNum">     814 </span>            :    at the start of a line as a conflict marker.
<span class="lineNum">     815 </span>            :    These come through the lexer as three pairs and a single,
<span class="lineNum">     816 </span>            :    e.g. three CPP_LSHIFT (&quot;&lt;&lt;&quot;) and a CPP_LESS ('&lt;').
<span class="lineNum">     817 </span>            :    If it returns true, *OUT_LOC is written to with the location/range
<span class="lineNum">     818 </span>            :    of the marker.  */
<a name="819"><span class="lineNum">     819 </span>            : </a>
<span class="lineNum">     820 </span>            : static bool
<span class="lineNum">     821 </span><span class="lineCov">         24 : c_parser_peek_conflict_marker (c_parser *parser, enum cpp_ttype tok1_kind,</span>
<span class="lineNum">     822 </span>            :                                location_t *out_loc)
<span class="lineNum">     823 </span>            : {
<span class="lineNum">     824 </span><span class="lineCov">         24 :   c_token *token2 = c_parser_peek_2nd_token (parser);</span>
<span class="lineNum">     825 </span><span class="lineCov">         24 :   if (token2-&gt;type != tok1_kind)</span>
<span class="lineNum">     826 </span>            :     return false;
<span class="lineNum">     827 </span><span class="lineCov">         21 :   c_token *token3 = c_parser_peek_nth_token (parser, 3);</span>
<span class="lineNum">     828 </span><span class="lineCov">         21 :   if (token3-&gt;type != tok1_kind)</span>
<span class="lineNum">     829 </span>            :     return false;
<span class="lineNum">     830 </span><span class="lineCov">         18 :   c_token *token4 = c_parser_peek_nth_token (parser, 4);</span>
<span class="lineNum">     831 </span><span class="lineCov">         18 :   if (token4-&gt;type != conflict_marker_get_final_tok_kind (tok1_kind))</span>
<span class="lineNum">     832 </span>            :     return false;
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span>            :   /* It must be at the start of the line.  */
<span class="lineNum">     835 </span><span class="lineCov">         15 :   location_t start_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">     836 </span><span class="lineCov">         15 :   if (LOCATION_COLUMN (start_loc) != 1)</span>
<span class="lineNum">     837 </span>            :     return false;
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :   /* We have a conflict marker.  Construct a location of the form:
<span class="lineNum">     840 </span>            :        &lt;&lt;&lt;&lt;&lt;&lt;&lt;
<span class="lineNum">     841 </span>            :        ^~~~~~~
<span class="lineNum">     842 </span>            :      with start == caret, finishing at the end of the marker.  */
<span class="lineNum">     843 </span><span class="lineCov">         12 :   location_t finish_loc = get_finish (token4-&gt;location);</span>
<span class="lineNum">     844 </span><span class="lineCov">         12 :   *out_loc = make_location (start_loc, start_loc, finish_loc);</span>
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span><span class="lineCov">         12 :   return true;</span>
<span class="lineNum">     847 </span>            : }
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            : /* Issue a diagnostic of the form
<span class="lineNum">     850 </span>            :       FILE:LINE: MESSAGE before TOKEN
<span class="lineNum">     851 </span>            :    where TOKEN is the next token in the input stream of PARSER.
<span class="lineNum">     852 </span>            :    MESSAGE (specified by the caller) is usually of the form &quot;expected
<span class="lineNum">     853 </span>            :    OTHER-TOKEN&quot;.
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            :    Use RICHLOC as the location of the diagnostic.
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            :    Do not issue a diagnostic if still recovering from an error.
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span>            :    Return true iff an error was actually emitted.
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            :    ??? This is taken from the C++ parser, but building up messages in
<span class="lineNum">     862 </span>            :    this way is not i18n-friendly and some other approach should be
<span class="lineNum">     863 </span>            :    used.  */
<a name="864"><span class="lineNum">     864 </span>            : </a>
<span class="lineNum">     865 </span>            : static bool
<span class="lineNum">     866 </span><span class="lineCov">       1716 : c_parser_error_richloc (c_parser *parser, const char *gmsgid,</span>
<span class="lineNum">     867 </span>            :                         rich_location *richloc)
<span class="lineNum">     868 </span>            : {
<span class="lineNum">     869 </span><span class="lineCov">       1716 :   c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">     870 </span><span class="lineCov">       1716 :   if (parser-&gt;error)</span>
<span class="lineNum">     871 </span>            :     return false;
<span class="lineNum">     872 </span><span class="lineCov">       1258 :   parser-&gt;error = true;</span>
<span class="lineNum">     873 </span><span class="lineCov">       1258 :   if (!gmsgid)</span>
<span class="lineNum">     874 </span>            :     return false;
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span>            :   /* If this is actually a conflict marker, report it as such.  */
<span class="lineNum">     877 </span><span class="lineCov">       2360 :   if (token-&gt;type == CPP_LSHIFT</span>
<span class="lineNum">     878 </span><span class="lineCov">       1180 :       || token-&gt;type == CPP_RSHIFT</span>
<span class="lineNum">     879 </span><span class="lineCov">       1164 :       || token-&gt;type == CPP_EQ_EQ)</span>
<span class="lineNum">     880 </span>            :     {
<span class="lineNum">     881 </span><span class="lineCov">         24 :       location_t loc;</span>
<span class="lineNum">     882 </span><span class="lineCov">         24 :       if (c_parser_peek_conflict_marker (parser, token-&gt;type, &amp;loc))</span>
<span class="lineNum">     883 </span>            :         {
<span class="lineNum">     884 </span><span class="lineCov">         12 :           error_at (loc, &quot;version control conflict marker in file&quot;);</span>
<span class="lineNum">     885 </span><span class="lineCov">         12 :           return true;</span>
<span class="lineNum">     886 </span>            :         }
<span class="lineNum">     887 </span>            :     }
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span><span class="lineCov">       1065 :   c_parse_error (gmsgid,</span>
<span class="lineNum">     890 </span>            :                  /* Because c_parse_error does not understand
<span class="lineNum">     891 </span>            :                     CPP_KEYWORD, keywords are treated like
<span class="lineNum">     892 </span>            :                     identifiers.  */
<span class="lineNum">     893 </span><span class="lineCov">       1168 :                  (token-&gt;type == CPP_KEYWORD ? CPP_NAME : token-&gt;type),</span>
<span class="lineNum">     894 </span>            :                  /* ??? The C parser does not save the cpp flags of a
<span class="lineNum">     895 </span>            :                     token, we need to pass 0 here and we will not get
<span class="lineNum">     896 </span>            :                     the source spelling of some tokens but rather the
<span class="lineNum">     897 </span>            :                     canonical spelling.  */
<span class="lineNum">     898 </span>            :                  token-&gt;value, /*flags=*/0, richloc);
<span class="lineNum">     899 </span><span class="lineCov">       1168 :   return true;</span>
<span class="lineNum">     900 </span>            : }
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span>            : /* As c_parser_error_richloc, but issue the message at the
<span class="lineNum">     903 </span>            :    location of PARSER's next token, or at input_location
<span class="lineNum">     904 </span>            :    if the next token is EOF.  */
<a name="905"><span class="lineNum">     905 </span>            : </a>
<span class="lineNum">     906 </span>            : bool
<span class="lineNum">     907 </span><span class="lineCov">       1038 : c_parser_error (c_parser *parser, const char *gmsgid)</span>
<span class="lineNum">     908 </span>            : {
<span class="lineNum">     909 </span><span class="lineCov">       1038 :   c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">     910 </span><span class="lineCov">       1038 :   c_parser_set_source_position_from_token (token);</span>
<span class="lineNum">     911 </span><span class="lineCov">       2076 :   rich_location richloc (line_table, input_location);</span>
<span class="lineNum">     912 </span><span class="lineCov">       1038 :   return c_parser_error_richloc (parser, gmsgid, &amp;richloc);</span>
<span class="lineNum">     913 </span>            : }
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span>            : /* Some tokens naturally come in pairs e.g.'(' and ')'.
<span class="lineNum">     916 </span>            :    This class is for tracking such a matching pair of symbols.
<span class="lineNum">     917 </span>            :    In particular, it tracks the location of the first token,
<span class="lineNum">     918 </span>            :    so that if the second token is missing, we can highlight the
<span class="lineNum">     919 </span>            :    location of the first token when notifying the user about the
<span class="lineNum">     920 </span>            :    problem.  */
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            : template &lt;typename traits_t&gt;
<span class="lineNum">     923 </span>            : class token_pair
<span class="lineNum">     924 </span>            : {
<span class="lineNum">     925 </span>            :  public:
<span class="lineNum">     926 </span>            :   /* token_pair's ctor.  */
<span class="lineNum">     927 </span><span class="lineCov">   68504805 :   token_pair () : m_open_loc (UNKNOWN_LOCATION) {}</span>
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span>            :   /* If the next token is the opening symbol for this pair, consume it and
<span class="lineNum">     930 </span>            :      return true.
<span class="lineNum">     931 </span>            :      Otherwise, issue an error and return false.
<a name="932"><span class="lineNum">     932 </span>            :      In either case, record the location of the opening token.  */</a>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :   bool require_open (c_parser *parser)</span>
<span class="lineNum">     935 </span>            :   {
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :     if (token)</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :       m_open_loc = token-&gt;location;</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :     return c_parser_require (parser, traits_t::open_token_type,</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :                              traits_t::open_gmsgid);</span>
<span class="lineNum">     942 </span>            :   }
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span>            :   /* Consume the next token from PARSER, recording its location as
<a name="945"><span class="lineNum">     945 </span>            :      that of the opening token within the pair.  */</a>
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :   void consume_open (c_parser *parser)</span>
<span class="lineNum">     948 </span>            :   {
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :     gcc_assert (token-&gt;type == traits_t::open_token_type);</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :     m_open_loc = token-&gt;location;</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     c_parser_consume_token (parser);</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     955 </span>            :   /* If the next token is the closing symbol for this pair, consume it
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :      and return true.</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :      Otherwise, issue an error, highlighting the location of the</span>
<a name="958"><span class="lineNum">     958 </span><span class="lineNoCov">          0 :      corresponding opening token, and return false.  */</span></a>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :   bool require_close (c_parser *parser) const</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">     962 </span>            :     return c_parser_require (parser, traits_t::close_token_type,
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :                              traits_t::close_gmsgid, m_open_loc);</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :   /* Like token_pair::require_close, except that tokens will be skipped</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :      until the desired token is found.  An error message is still produced</span>
<a name="968"><span class="lineNum">     968 </span>            :      if the next token is not as expected.  */</a>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            :   void skip_until_found_close (c_parser *parser) const
<span class="lineNum">     971 </span>            :   {
<span class="lineNum">     972 </span>            :     c_parser_skip_until_found (parser, traits_t::close_token_type,
<span class="lineNum">     973 </span>            :                                traits_t::close_gmsgid, m_open_loc);
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span><span class="lineCov">    1240640 :  private:</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :   location_t m_open_loc;</span>
<span class="lineNum">     978 </span>            : };
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            : /* Traits for token_pair&lt;T&gt; for tracking matching pairs of parentheses.  */
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            : struct matching_paren_traits
<span class="lineNum">     983 </span>            : {
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :   static const enum cpp_ttype open_token_type = CPP_OPEN_PAREN;</span>
<span class="lineNum">     985 </span>            :   static const char * const open_gmsgid;
<span class="lineNum">     986 </span><span class="lineCov">   66478759 :   static const enum cpp_ttype close_token_type = CPP_CLOSE_PAREN;</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :   static const char * const close_gmsgid;</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 : };</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     990 </span>            : const char * const matching_paren_traits::open_gmsgid = &quot;expected %&lt;(%&gt;&quot;;
<span class="lineNum">     991 </span><span class="lineNoCov">          0 : const char * const matching_paren_traits::close_gmsgid = &quot;expected %&lt;)%&gt;&quot;;</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 : /* &quot;matching_parens&quot; is a token_pair&lt;T&gt; class for tracking matching</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :    pairs of parentheses.  */</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span><span class="lineNoCov">          0 : typedef token_pair&lt;matching_paren_traits&gt; matching_parens;</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 : /* Traits for token_pair&lt;T&gt; for tracking matching pairs of braces.  */</span>
<span class="lineNum">     999 </span>            : 
<span class="lineNum">    1000 </span>            : struct matching_brace_traits
<span class="lineNum">    1001 </span>            : {
<span class="lineNum">    1002 </span>            :   static const enum cpp_ttype open_token_type = CPP_OPEN_BRACE;
<span class="lineNum">    1003 </span>            :   static const char * const open_gmsgid;
<span class="lineNum">    1004 </span>            :   static const enum cpp_ttype close_token_type = CPP_CLOSE_BRACE;
<span class="lineNum">    1005 </span>            :   static const char * const close_gmsgid;
<span class="lineNum">    1006 </span>            : };
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            : const char * const matching_brace_traits::open_gmsgid = &quot;expected %&lt;{%&gt;&quot;;
<span class="lineNum">    1009 </span>            : const char * const matching_brace_traits::close_gmsgid = &quot;expected %&lt;}%&gt;&quot;;
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            : /* &quot;matching_braces&quot; is a token_pair&lt;T&gt; class for tracking matching
<span class="lineNum">    1012 </span>            :    pairs of braces.  */
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span>            : typedef token_pair&lt;matching_brace_traits&gt; matching_braces;
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span>            : /* Get a description of the matching symbol to TYPE e.g. &quot;(&quot; for
<span class="lineNum">    1017 </span>            :    CPP_CLOSE_PAREN.  */
<a name="1018"><span class="lineNum">    1018 </span>            : </a>
<span class="lineNum">    1019 </span>            : static const char *
<span class="lineNum">    1020 </span>            : get_matching_symbol (enum cpp_ttype type)
<span class="lineNum">    1021 </span>            : {
<span class="lineNum">    1022 </span>            :   switch (type)
<span class="lineNum">    1023 </span>            :     {
<span class="lineNum">    1024 </span>            :     default:
<span class="lineNum">    1025 </span>            :       gcc_unreachable ();
<span class="lineNum">    1026 </span>            :       return &quot;&quot;;
<span class="lineNum">    1027 </span>            :     case CPP_CLOSE_PAREN:
<span class="lineNum">    1028 </span>            :       return &quot;(&quot;;
<span class="lineNum">    1029 </span>            :     case CPP_CLOSE_BRACE:
<span class="lineNum">    1030 </span>            :       return &quot;{&quot;;
<span class="lineNum">    1031 </span>            :     }
<span class="lineNum">    1032 </span>            : }
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            : /* If the next token is of the indicated TYPE, consume it.  Otherwise,
<span class="lineNum">    1035 </span>            :    issue the error MSGID.  If MSGID is NULL then a message has already
<span class="lineNum">    1036 </span>            :    been produced and no message will be produced this time.  Returns
<span class="lineNum">    1037 </span>            :    true if found, false otherwise.
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span>            :    If MATCHING_LOCATION is not UNKNOWN_LOCATION, then highlight it
<span class="lineNum">    1040 </span>            :    within any error as the location of an &quot;opening&quot; token matching
<span class="lineNum">    1041 </span>            :    the close token TYPE (e.g. the location of the '(' when TYPE is
<span class="lineNum">    1042 </span>            :    CPP_CLOSE_PAREN).
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :    If TYPE_IS_UNIQUE is true (the default) then msgid describes exactly</span>
<span class="lineNum">    1045 </span>            :    one type (e.g. &quot;expected %&lt;)%&gt;&quot;) and thus it may be reasonable to
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :    attempt to generate a fix-it hint for the problem.</span>
<span class="lineNum">    1047 </span>            :    Otherwise msgid describes multiple token types (e.g.
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :    &quot;expected %&lt;;%&gt;, %&lt;,%&gt; or %&lt;)%&gt;&quot;), and thus we shouldn't attempt to</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :    generate a fix-it hint.  */</span>
<a name="1050"><span class="lineNum">    1050 </span>            : </a>
<span class="lineNum">    1051 </span>            : bool
<span class="lineNum">    1052 </span>            : c_parser_require (c_parser *parser,
<span class="lineNum">    1053 </span><span class="lineCov">          1 :                   enum cpp_ttype type,</span>
<span class="lineNum">    1054 </span><span class="lineCov">          1 :                   const char *msgid,</span>
<span class="lineNum">    1055 </span>            :                   location_t matching_location,
<span class="lineNum">    1056 </span>            :                   bool type_is_unique)
<span class="lineNum">    1057 </span>            : {
<span class="lineNum">    1058 </span>            :   if (c_parser_next_token_is (parser, type))
<span class="lineNum">    1059 </span>            :     {
<span class="lineNum">    1060 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    1061 </span>            :       return true;
<span class="lineNum">    1062 </span>            :     }
<span class="lineNum">    1063 </span>            :   else
<span class="lineNum">    1064 </span>            :     {
<span class="lineNum">    1065 </span>            :       location_t next_token_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    1066 </span>            :       gcc_rich_location richloc (next_token_loc);
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span>            :       /* Potentially supply a fix-it hint, suggesting to add the
<span class="lineNum">    1069 </span>            :          missing token immediately after the *previous* token.
<span class="lineNum">    1070 </span>            :          This may move the primary location within richloc.  */
<span class="lineNum">    1071 </span>            :       if (!parser-&gt;error &amp;&amp; type_is_unique)
<span class="lineNum">    1072 </span>            :         maybe_suggest_missing_token_insertion (&amp;richloc, type,
<span class="lineNum">    1073 </span>            :                                                parser-&gt;last_token_location);
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            :       /* If matching_location != UNKNOWN_LOCATION, highlight it.
<span class="lineNum">    1076 </span><span class="lineCov">  238225276 :          Attempt to consolidate diagnostics by printing it as a</span>
<span class="lineNum">    1077 </span>            :          secondary range within the main diagnostic.  */
<span class="lineNum">    1078 </span>            :       bool added_matching_location = false;
<span class="lineNum">    1079 </span>            :       if (matching_location != UNKNOWN_LOCATION)
<span class="lineNum">    1080 </span>            :         added_matching_location
<span class="lineNum">    1081 </span>            :           = richloc.add_location_if_nearby (matching_location);
<span class="lineNum">    1082 </span><span class="lineCov">  238225276 : </span>
<span class="lineNum">    1083 </span>            :       if (c_parser_error_richloc (parser, msgid, &amp;richloc))
<span class="lineNum">    1084 </span><span class="lineCov">  238224598 :         /* If we weren't able to consolidate matching_location, then</span>
<span class="lineNum">    1085 </span><span class="lineCov">  238224598 :            print it as a secondary diagnostic.  */</span>
<span class="lineNum">    1086 </span>            :         if (matching_location != UNKNOWN_LOCATION &amp;&amp; !added_matching_location)
<span class="lineNum">    1087 </span>            :           inform (matching_location, &quot;to match this %qs&quot;,
<span class="lineNum">    1088 </span>            :                   get_matching_symbol (type));
<span class="lineNum">    1089 </span><span class="lineCov">        678 : </span>
<span class="lineNum">    1090 </span><span class="lineCov">       1356 :       return false;</span>
<span class="lineNum">    1091 </span>            :     }
<span class="lineNum">    1092 </span>            : }
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span>            : /* If the next token is the indicated keyword, consume it.  Otherwise,
<span class="lineNum">    1095 </span><span class="lineCov">        678 :    issue the error MSGID.  Returns true if found, false otherwise.  */</span>
<a name="1096"><span class="lineNum">    1096 </span><span class="lineCov">        366 : </span></a>
<span class="lineNum">    1097 </span>            : static bool
<span class="lineNum">    1098 </span>            : c_parser_require_keyword (c_parser *parser,
<span class="lineNum">    1099 </span>            :                           enum rid keyword,
<span class="lineNum">    1100 </span>            :                           const char *msgid)
<span class="lineNum">    1101 </span>            : {
<span class="lineNum">    1102 </span><span class="lineCov">        678 :   if (c_parser_next_token_is_keyword (parser, keyword))</span>
<span class="lineNum">    1103 </span><span class="lineCov">        678 :     {</span>
<span class="lineNum">    1104 </span><span class="lineCov">        190 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    1105 </span><span class="lineCov">        190 :       return true;</span>
<span class="lineNum">    1106 </span>            :     }
<span class="lineNum">    1107 </span><span class="lineCov">        678 :   else</span>
<span class="lineNum">    1108 </span>            :     {
<span class="lineNum">    1109 </span>            :       c_parser_error (parser, msgid);
<span class="lineNum">    1110 </span><span class="lineCov">        296 :       return false;</span>
<span class="lineNum">    1111 </span><span class="lineCov">          4 :     }</span>
<span class="lineNum">    1112 </span>            : }
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span><span class="lineCov">        678 : /* Like c_parser_require, except that tokens will be skipped until the</span>
<span class="lineNum">    1115 </span>            :    desired token is found.  An error message is still produced if the
<span class="lineNum">    1116 </span>            :    next token is not as expected.  If MSGID is NULL then a message has
<span class="lineNum">    1117 </span>            :    already been produced and no message will be produced this
<span class="lineNum">    1118 </span>            :    time.
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            :    If MATCHING_LOCATION is not UNKNOWN_LOCATION, then highlight it
<span class="lineNum">    1121 </span>            :    within any error as the location of an &quot;opening&quot; token matching
<span class="lineNum">    1122 </span><span class="lineCov">      99301 :    the close token TYPE (e.g. the location of the '(' when TYPE is</span>
<span class="lineNum">    1123 </span>            :    CPP_CLOSE_PAREN).  */
<a name="1124"><span class="lineNum">    1124 </span>            : </a>
<span class="lineNum">    1125 </span>            : void
<span class="lineNum">    1126 </span><span class="lineCov">      99301 : c_parser_skip_until_found (c_parser *parser,</span>
<span class="lineNum">    1127 </span>            :                            enum cpp_ttype type,
<span class="lineNum">    1128 </span><span class="lineCov">      99301 :                            const char *msgid,</span>
<span class="lineNum">    1129 </span><span class="lineCov">      99301 :                            location_t matching_location)</span>
<span class="lineNum">    1130 </span>            : {
<span class="lineNum">    1131 </span>            :   unsigned nesting_depth = 0;
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :   if (c_parser_require (parser, type, msgid, matching_location))</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span>            :   /* Skip tokens until the desired token is found.  */
<span class="lineNum">    1137 </span>            :   while (true)
<span class="lineNum">    1138 </span>            :     {
<span class="lineNum">    1139 </span>            :       /* Peek at the next token.  */
<span class="lineNum">    1140 </span>            :       c_token *token = c_parser_peek_token (parser);
<span class="lineNum">    1141 </span>            :       /* If we've reached the token we want, consume it and stop.  */
<span class="lineNum">    1142 </span>            :       if (token-&gt;type == type &amp;&amp; !nesting_depth)
<span class="lineNum">    1143 </span>            :         {
<span class="lineNum">    1144 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    1145 </span>            :           break;
<span class="lineNum">    1146 </span>            :         }
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span>            :       /* If we've run out of tokens, stop.  */
<span class="lineNum">    1149 </span>            :       if (token-&gt;type == CPP_EOF)
<span class="lineNum">    1150 </span><span class="lineCov">  118839281 :         return;</span>
<span class="lineNum">    1151 </span>            :       if (token-&gt;type == CPP_PRAGMA_EOL &amp;&amp; parser-&gt;in_pragma)
<span class="lineNum">    1152 </span>            :         return;
<span class="lineNum">    1153 </span>            :       if (token-&gt;type == CPP_OPEN_BRACE
<span class="lineNum">    1154 </span>            :           || token-&gt;type == CPP_OPEN_PAREN
<span class="lineNum">    1155 </span><span class="lineCov">  118839281 :           || token-&gt;type == CPP_OPEN_SQUARE)</span>
<span class="lineNum">    1156 </span>            :         ++nesting_depth;
<span class="lineNum">    1157 </span><span class="lineCov">  118839281 :       else if (token-&gt;type == CPP_CLOSE_BRACE</span>
<span class="lineNum">    1158 </span>            :                || token-&gt;type == CPP_CLOSE_PAREN
<span class="lineNum">    1159 </span>            :                || token-&gt;type == CPP_CLOSE_SQUARE)
<span class="lineNum">    1160 </span>            :         {
<span class="lineNum">    1161 </span><span class="lineCov">       2166 :           if (nesting_depth-- == 0)</span>
<span class="lineNum">    1162 </span>            :             break;
<span class="lineNum">    1163 </span>            :         }
<span class="lineNum">    1164 </span><span class="lineCov">       2166 :       /* Consume this token.  */</span>
<span class="lineNum">    1165 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    1166 </span><span class="lineCov">       2166 :     }</span>
<span class="lineNum">    1167 </span>            :   parser-&gt;error = false;
<span class="lineNum">    1168 </span><span class="lineCov">        406 : }</span>
<span class="lineNum">    1169 </span><span class="lineCov">        406 : </span>
<span class="lineNum">    1170 </span>            : /* Skip tokens until the end of a parameter is found, but do not
<span class="lineNum">    1171 </span>            :    consume the comma, semicolon or closing delimiter.  */
<a name="1172"><span class="lineNum">    1172 </span>            : </a>
<span class="lineNum">    1173 </span><span class="lineCov">       1760 : static void</span>
<span class="lineNum">    1174 </span>            : c_parser_skip_to_end_of_parameter (c_parser *parser)
<span class="lineNum">    1175 </span><span class="lineCov">       1742 : {</span>
<span class="lineNum">    1176 </span>            :   unsigned nesting_depth = 0;
<span class="lineNum">    1177 </span><span class="lineCov">       3390 : </span>
<span class="lineNum">    1178 </span><span class="lineCov">       1695 :   while (true)</span>
<span class="lineNum">    1179 </span><span class="lineCov">       1522 :     {</span>
<span class="lineNum">    1180 </span><span class="lineCov">        200 :       c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">    1181 </span><span class="lineCov">       2990 :       if ((token-&gt;type == CPP_COMMA || token-&gt;type == CPP_SEMICOLON)</span>
<span class="lineNum">    1182 </span><span class="lineCov">       1495 :           &amp;&amp; !nesting_depth)</span>
<span class="lineNum">    1183 </span><span class="lineCov">       1230 :         break;</span>
<span class="lineNum">    1184 </span>            :       /* If we've run out of tokens, stop.  */
<span class="lineNum">    1185 </span><span class="lineCov">        291 :       if (token-&gt;type == CPP_EOF)</span>
<span class="lineNum">    1186 </span>            :         return;
<span class="lineNum">    1187 </span>            :       if (token-&gt;type == CPP_PRAGMA_EOL &amp;&amp; parser-&gt;in_pragma)
<span class="lineNum">    1188 </span>            :         return;
<span class="lineNum">    1189 </span><span class="lineCov">       1604 :       if (token-&gt;type == CPP_OPEN_BRACE</span>
<span class="lineNum">    1190 </span><span class="lineCov">       1604 :           || token-&gt;type == CPP_OPEN_PAREN</span>
<span class="lineNum">    1191 </span><span class="lineCov">        497 :           || token-&gt;type == CPP_OPEN_SQUARE)</span>
<span class="lineNum">    1192 </span>            :         ++nesting_depth;
<span class="lineNum">    1193 </span>            :       else if (token-&gt;type == CPP_CLOSE_BRACE
<span class="lineNum">    1194 </span>            :                || token-&gt;type == CPP_CLOSE_PAREN
<span class="lineNum">    1195 </span>            :                || token-&gt;type == CPP_CLOSE_SQUARE)
<span class="lineNum">    1196 </span>            :         {
<span class="lineNum">    1197 </span>            :           if (nesting_depth-- == 0)
<span class="lineNum">    1198 </span><span class="lineCov">         98 :             break;</span>
<span class="lineNum">    1199 </span>            :         }
<span class="lineNum">    1200 </span><span class="lineCov">         98 :       /* Consume this token.  */</span>
<span class="lineNum">    1201 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    1202 </span><span class="lineCov">        305 :     }</span>
<span class="lineNum">    1203 </span>            :   parser-&gt;error = false;
<span class="lineNum">    1204 </span><span class="lineCov">        305 : }</span>
<span class="lineNum">    1205 </span><span class="lineCov">        305 : </span>
<span class="lineNum">    1206 </span><span class="lineCov">         27 : /* Expect to be at the end of the pragma directive and consume an</span>
<span class="lineNum">    1207 </span>            :    end of line marker.  */
<a name="1208"><span class="lineNum">    1208 </span>            : </a>
<span class="lineNum">    1209 </span><span class="lineCov">        278 : static void</span>
<span class="lineNum">    1210 </span>            : c_parser_skip_to_pragma_eol (c_parser *parser, bool error_if_not_eol = true)
<span class="lineNum">    1211 </span><span class="lineCov">        278 : {</span>
<span class="lineNum">    1212 </span>            :   gcc_assert (parser-&gt;in_pragma);
<span class="lineNum">    1213 </span><span class="lineCov">        556 :   parser-&gt;in_pragma = false;</span>
<span class="lineNum">    1214 </span><span class="lineCov">        278 : </span>
<span class="lineNum">    1215 </span><span class="lineCov">        276 :   if (error_if_not_eol &amp;&amp; c_parser_peek_token (parser)-&gt;type != CPP_PRAGMA_EOL)</span>
<span class="lineNum">    1216 </span><span class="lineCov">          3 :     c_parser_error (parser, &quot;expected end of line&quot;);</span>
<span class="lineNum">    1217 </span><span class="lineCov">        550 : </span>
<span class="lineNum">    1218 </span><span class="lineCov">        275 :   cpp_ttype token_type;</span>
<span class="lineNum">    1219 </span><span class="lineCov">        202 :   do</span>
<span class="lineNum">    1220 </span>            :     {
<span class="lineNum">    1221 </span><span class="lineCov">         74 :       c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">    1222 </span>            :       token_type = token-&gt;type;
<span class="lineNum">    1223 </span>            :       if (token_type == CPP_EOF)
<span class="lineNum">    1224 </span>            :         break;
<span class="lineNum">    1225 </span><span class="lineCov">        207 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    1226 </span><span class="lineCov">        207 :     }</span>
<span class="lineNum">    1227 </span><span class="lineCov">         98 :   while (token_type != CPP_PRAGMA_EOL);</span>
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            :   parser-&gt;error = false;
<span class="lineNum">    1230 </span>            : }
<span class="lineNum">    1231 </span>            : 
<span class="lineNum">    1232 </span>            : /* Skip tokens until we have consumed an entire block, or until we
<span class="lineNum">    1233 </span>            :    have consumed a non-nested ';'.  */
<a name="1234"><span class="lineNum">    1234 </span><span class="lineCov">     597815 : </span></a>
<span class="lineNum">    1235 </span>            : static void
<span class="lineNum">    1236 </span><span class="lineCov">     597815 : c_parser_skip_to_end_of_block_or_statement (c_parser *parser)</span>
<span class="lineNum">    1237 </span><span class="lineCov">     597815 : {</span>
<span class="lineNum">    1238 </span>            :   unsigned nesting_depth = 0;
<span class="lineNum">    1239 </span><span class="lineCov">     597815 :   bool save_error = parser-&gt;error;</span>
<span class="lineNum">    1240 </span><span class="lineCov">         91 : </span>
<span class="lineNum">    1241 </span>            :   while (true)
<span class="lineNum">    1242 </span><span class="lineCov">     598332 :     {</span>
<span class="lineNum">    1243 </span><span class="lineCov">     598332 :       c_token *token;</span>
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span><span class="lineCov">     598332 :       /* Peek at the next token.  */</span>
<span class="lineNum">    1246 </span><span class="lineCov">     598332 :       token = c_parser_peek_token (parser);</span>
<span class="lineNum">    1247 </span><span class="lineCov">     598332 : </span>
<span class="lineNum">    1248 </span>            :       switch (token-&gt;type)
<span class="lineNum">    1249 </span><span class="lineCov">     598332 :         {</span>
<span class="lineNum">    1250 </span>            :         case CPP_EOF:
<span class="lineNum">    1251 </span><span class="lineCov">     598332 :           return;</span>
<span class="lineNum">    1252 </span>            : 
<span class="lineNum">    1253 </span><span class="lineCov">     597815 :         case CPP_PRAGMA_EOL:</span>
<span class="lineNum">    1254 </span><span class="lineCov">     597815 :           if (parser-&gt;in_pragma)</span>
<span class="lineNum">    1255 </span>            :             return;
<span class="lineNum">    1256 </span>            :           break;
<span class="lineNum">    1257 </span>            : 
<span class="lineNum">    1258 </span>            :         case CPP_SEMICOLON:
<span class="lineNum">    1259 </span>            :           /* If the next token is a ';', we have reached the
<span class="lineNum">    1260 </span><span class="lineCov">        325 :              end of the statement.  */</span>
<span class="lineNum">    1261 </span>            :           if (!nesting_depth)
<span class="lineNum">    1262 </span><span class="lineCov">        325 :             {</span>
<span class="lineNum">    1263 </span><span class="lineCov">        325 :               /* Consume the ';'.  */</span>
<span class="lineNum">    1264 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">    1265 </span><span class="lineCov">       1200 :               goto finished;</span>
<span class="lineNum">    1266 </span>            :             }
<span class="lineNum">    1267 </span><span class="lineCov">       1200 :           break;</span>
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span>            :         case CPP_CLOSE_BRACE:
<span class="lineNum">    1270 </span><span class="lineCov">       1200 :           /* If the next token is a non-nested '}', then we have</span>
<span class="lineNum">    1271 </span>            :              reached the end of the current block.  */
<span class="lineNum">    1272 </span><span class="lineCov">       1200 :           if (nesting_depth == 0 || --nesting_depth == 0)</span>
<span class="lineNum">    1273 </span>            :             {
<span class="lineNum">    1274 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">    1275 </span>            :               goto finished;
<span class="lineNum">    1276 </span>            :             }
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1279 </span>            :         case CPP_OPEN_BRACE:
<span class="lineNum">    1280 </span>            :           /* If it the next token is a '{', then we are entering a new
<span class="lineNum">    1281 </span>            :              block.  Consume the entire block.  */
<span class="lineNum">    1282 </span><span class="lineCov">        301 :           ++nesting_depth;</span>
<span class="lineNum">    1283 </span>            :           break;
<span class="lineNum">    1284 </span>            : 
<span class="lineNum">    1285 </span><span class="lineCov">        301 :         case CPP_PRAGMA:</span>
<span class="lineNum">    1286 </span>            :           /* If we see a pragma, consume the whole thing at once.  We
<span class="lineNum">    1287 </span>            :              have some safeguards against consuming pragmas willy-nilly.
<span class="lineNum">    1288 </span><span class="lineCov">        258 :              Normally, we'd expect to be here with parser-&gt;error set,</span>
<span class="lineNum">    1289 </span><span class="lineCov">        258 :              which disables these safeguards.  But it's possible to get</span>
<span class="lineNum">    1290 </span>            :              here for secondary error recovery, after parser-&gt;error has
<span class="lineNum">    1291 </span>            :              been cleared.  */
<span class="lineNum">    1292 </span>            :           c_parser_consume_pragma (parser);
<span class="lineNum">    1293 </span><span class="lineCov">         60 :           c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">    1294 </span>            :           parser-&gt;error = save_error;
<span class="lineNum">    1295 </span>            :           continue;
<span class="lineNum">    1296 </span><span class="lineCov">         60 : </span>
<span class="lineNum">    1297 </span>            :         default:
<span class="lineNum">    1298 </span><span class="lineCov">         60 :           break;</span>
<span class="lineNum">    1299 </span><span class="lineCov">         60 :         }</span>
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    1302 </span>            :     }
<span class="lineNum">    1303 </span><span class="lineCov">         36 : </span>
<span class="lineNum">    1304 </span>            :  finished:
<span class="lineNum">    1305 </span>            :   parser-&gt;error = false;
<span class="lineNum">    1306 </span><span class="lineCov">         36 : }</span>
<span class="lineNum">    1307 </span><span class="lineCov">         36 : </span>
<span class="lineNum">    1308 </span>            : /* CPP's options (initialized by c-opts.c).  */
<span class="lineNum">    1309 </span><span class="lineCov">          5 : extern cpp_options *cpp_opts;</span>
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span>            : /* Save the warning flags which are controlled by __extension__.  */
<a name="1312"><span class="lineNum">    1312 </span>            : </a>
<span class="lineNum">    1313 </span>            : static inline int
<span class="lineNum">    1314 </span>            : disable_extension_diagnostics (void)
<span class="lineNum">    1315 </span>            : {
<span class="lineNum">    1316 </span><span class="lineCov">          5 :   int ret = (pedantic</span>
<span class="lineNum">    1317 </span><span class="lineCov">          5 :              | (warn_pointer_arith &lt;&lt; 1)</span>
<span class="lineNum">    1318 </span><span class="lineCov">          5 :              | (warn_traditional &lt;&lt; 2)</span>
<span class="lineNum">    1319 </span><span class="lineCov">          5 :              | (flag_iso &lt;&lt; 3)</span>
<span class="lineNum">    1320 </span>            :              | (warn_long_long &lt;&lt; 4)
<span class="lineNum">    1321 </span>            :              | (warn_cxx_compat &lt;&lt; 5)
<span class="lineNum">    1322 </span>            :              | (warn_overlength_strings &lt;&lt; 6)
<span class="lineNum">    1323 </span>            :              /* warn_c90_c99_compat has three states: -1/0/1, so we must
<span class="lineNum">    1324 </span>            :                 play tricks to properly restore it.  */
<span class="lineNum">    1325 </span><span class="lineCov">        870 :              | ((warn_c90_c99_compat == 1) &lt;&lt; 7)</span>
<span class="lineNum">    1326 </span>            :              | ((warn_c90_c99_compat == -1) &lt;&lt; 8)
<span class="lineNum">    1327 </span>            :              /* Similarly for warn_c99_c11_compat.  */
<span class="lineNum">    1328 </span><span class="lineCov">        318 :              | ((warn_c99_c11_compat == 1) &lt;&lt; 9)</span>
<span class="lineNum">    1329 </span><span class="lineCov">        318 :              | ((warn_c99_c11_compat == -1) &lt;&lt; 10)</span>
<span class="lineNum">    1330 </span>            :              );
<span class="lineNum">    1331 </span>            :   cpp_opts-&gt;cpp_pedantic = pedantic = 0;
<span class="lineNum">    1332 </span>            :   warn_pointer_arith = 0;
<span class="lineNum">    1333 </span>            :   cpp_opts-&gt;cpp_warn_traditional = warn_traditional = 0;
<span class="lineNum">    1334 </span>            :   flag_iso = 0;
<span class="lineNum">    1335 </span>            :   cpp_opts-&gt;cpp_warn_long_long = warn_long_long = 0;
<span class="lineNum">    1336 </span>            :   warn_cxx_compat = 0;
<span class="lineNum">    1337 </span>            :   warn_overlength_strings = 0;
<span class="lineNum">    1338 </span><span class="lineCov">     612509 :   warn_c90_c99_compat = 0;</span>
<span class="lineNum">    1339 </span>            :   warn_c99_c11_compat = 0;
<span class="lineNum">    1340 </span><span class="lineCov">    1225018 :   return ret;</span>
<span class="lineNum">    1341 </span><span class="lineCov">     612509 : }</span>
<span class="lineNum">    1342 </span><span class="lineCov">     612509 : </span>
<span class="lineNum">    1343 </span><span class="lineCov">     612509 : /* Restore the warning flags which are controlled by __extension__.</span>
<span class="lineNum">    1344 </span><span class="lineCov">     612509 :    FLAGS is the return value from disable_extension_diagnostics.  */</span>
<a name="1345"><span class="lineNum">    1345 </span><span class="lineCov">     612509 : </span></a>
<span class="lineNum">    1346 </span><span class="lineCov">     612509 : static inline void</span>
<span class="lineNum">    1347 </span>            : restore_extension_diagnostics (int flags)
<span class="lineNum">    1348 </span>            : {
<span class="lineNum">    1349 </span><span class="lineCov">     612509 :   cpp_opts-&gt;cpp_pedantic = pedantic = flags &amp; 1;</span>
<span class="lineNum">    1350 </span><span class="lineCov">     612509 :   warn_pointer_arith = (flags &gt;&gt; 1) &amp; 1;</span>
<span class="lineNum">    1351 </span>            :   cpp_opts-&gt;cpp_warn_traditional = warn_traditional = (flags &gt;&gt; 2) &amp; 1;
<span class="lineNum">    1352 </span><span class="lineCov">     612509 :   flag_iso = (flags &gt;&gt; 3) &amp; 1;</span>
<span class="lineNum">    1353 </span><span class="lineCov">     612509 :   cpp_opts-&gt;cpp_warn_long_long = warn_long_long = (flags &gt;&gt; 4) &amp; 1;</span>
<span class="lineNum">    1354 </span>            :   warn_cxx_compat = (flags &gt;&gt; 5) &amp; 1;
<span class="lineNum">    1355 </span><span class="lineCov">     612509 :   warn_overlength_strings = (flags &gt;&gt; 6) &amp; 1;</span>
<span class="lineNum">    1356 </span><span class="lineCov">     612509 :   /* See above for why is this needed.  */</span>
<span class="lineNum">    1357 </span><span class="lineCov">     612509 :   warn_c90_c99_compat = (flags &gt;&gt; 7) &amp; 1 ? 1 : ((flags &gt;&gt; 8) &amp; 1 ? -1 : 0);</span>
<span class="lineNum">    1358 </span><span class="lineCov">     612509 :   warn_c99_c11_compat = (flags &gt;&gt; 9) &amp; 1 ? 1 : ((flags &gt;&gt; 10) &amp; 1 ? -1 : 0);</span>
<span class="lineNum">    1359 </span><span class="lineCov">     612509 : }</span>
<span class="lineNum">    1360 </span><span class="lineCov">     612509 : </span>
<span class="lineNum">    1361 </span><span class="lineCov">     612509 : /* Helper data structure for parsing #pragma acc routine.  */</span>
<span class="lineNum">    1362 </span><span class="lineCov">     612509 : struct oacc_routine_data {</span>
<span class="lineNum">    1363 </span><span class="lineCov">     612509 :   bool error_seen; /* Set if error has been reported.  */</span>
<span class="lineNum">    1364 </span><span class="lineCov">     612509 :   bool fndecl_seen; /* Set if one fn decl/definition has been seen already.  */</span>
<span class="lineNum">    1365 </span>            :   tree clauses;
<span class="lineNum">    1366 </span>            :   location_t loc;
<span class="lineNum">    1367 </span>            : };
<span class="lineNum">    1368 </span>            : 
<span class="lineNum">    1369 </span>            : static void c_parser_external_declaration (c_parser *);
<span class="lineNum">    1370 </span>            : static void c_parser_asm_definition (c_parser *);
<span class="lineNum">    1371 </span><span class="lineCov">     612509 : static void c_parser_declaration_or_fndef (c_parser *, bool, bool, bool,</span>
<span class="lineNum">    1372 </span>            :                                            bool, bool, tree *, vec&lt;c_token&gt;,
<span class="lineNum">    1373 </span><span class="lineCov">     612509 :                                            struct oacc_routine_data * = NULL,</span>
<span class="lineNum">    1374 </span><span class="lineCov">     612509 :                                            bool * = NULL);</span>
<span class="lineNum">    1375 </span><span class="lineCov">     612509 : static void c_parser_static_assert_declaration_no_semi (c_parser *);</span>
<span class="lineNum">    1376 </span><span class="lineCov">     612509 : static void c_parser_static_assert_declaration (c_parser *);</span>
<span class="lineNum">    1377 </span><span class="lineCov">     612509 : static struct c_typespec c_parser_enum_specifier (c_parser *);</span>
<span class="lineNum">    1378 </span><span class="lineCov">     612509 : static struct c_typespec c_parser_struct_or_union_specifier (c_parser *);</span>
<span class="lineNum">    1379 </span><span class="lineCov">     612509 : static tree c_parser_struct_declaration (c_parser *);</span>
<span class="lineNum">    1380 </span>            : static struct c_typespec c_parser_typeof_specifier (c_parser *);
<span class="lineNum">    1381 </span><span class="lineCov">     612509 : static tree c_parser_alignas_specifier (c_parser *);</span>
<span class="lineNum">    1382 </span><span class="lineCov">     612509 : static struct c_declarator *c_parser_direct_declarator (c_parser *, bool,</span>
<span class="lineNum">    1383 </span><span class="lineCov">     612509 :                                                         c_dtr_syn, bool *);</span>
<span class="lineNum">    1384 </span>            : static struct c_declarator *c_parser_direct_declarator_inner (c_parser *,
<span class="lineNum">    1385 </span>            :                                                               bool,
<span class="lineNum">    1386 </span>            :                                                               struct c_declarator *);
<span class="lineNum">    1387 </span>            : static struct c_arg_info *c_parser_parms_declarator (c_parser *, bool, tree);
<span class="lineNum">    1388 </span>            : static struct c_arg_info *c_parser_parms_list_declarator (c_parser *, tree,
<span class="lineNum">    1389 </span>            :                                                           tree);
<span class="lineNum">    1390 </span>            : static struct c_parm *c_parser_parameter_declaration (c_parser *, tree);
<span class="lineNum">    1391 </span>            : static tree c_parser_simple_asm_expr (c_parser *);
<span class="lineNum">    1392 </span>            : static tree c_parser_attributes (c_parser *);
<span class="lineNum">    1393 </span>            : static struct c_expr c_parser_initializer (c_parser *);
<span class="lineNum">    1394 </span>            : static struct c_expr c_parser_braced_init (c_parser *, tree, bool,
<span class="lineNum">    1395 </span>            :                                            struct obstack *);
<span class="lineNum">    1396 </span>            : static void c_parser_initelt (c_parser *, struct obstack *);
<span class="lineNum">    1397 </span>            : static void c_parser_initval (c_parser *, struct c_expr *,
<span class="lineNum">    1398 </span>            :                               struct obstack *);
<span class="lineNum">    1399 </span>            : static tree c_parser_compound_statement (c_parser *);
<span class="lineNum">    1400 </span>            : static void c_parser_compound_statement_nostart (c_parser *);
<span class="lineNum">    1401 </span>            : static void c_parser_label (c_parser *);
<span class="lineNum">    1402 </span>            : static void c_parser_statement (c_parser *, bool *, location_t * = NULL);
<span class="lineNum">    1403 </span>            : static void c_parser_statement_after_labels (c_parser *, bool *,
<span class="lineNum">    1404 </span>            :                                              vec&lt;tree&gt; * = NULL);
<span class="lineNum">    1405 </span>            : static tree c_parser_c99_block_statement (c_parser *, bool *,
<span class="lineNum">    1406 </span>            :                                           location_t * = NULL);
<span class="lineNum">    1407 </span>            : static void c_parser_if_statement (c_parser *, bool *, vec&lt;tree&gt; *);
<span class="lineNum">    1408 </span>            : static void c_parser_switch_statement (c_parser *, bool *);
<span class="lineNum">    1409 </span>            : static void c_parser_while_statement (c_parser *, bool, unsigned short, bool *);
<span class="lineNum">    1410 </span>            : static void c_parser_do_statement (c_parser *, bool, unsigned short);
<span class="lineNum">    1411 </span>            : static void c_parser_for_statement (c_parser *, bool, unsigned short, bool *);
<span class="lineNum">    1412 </span>            : static tree c_parser_asm_statement (c_parser *);
<span class="lineNum">    1413 </span>            : static tree c_parser_asm_operands (c_parser *);
<span class="lineNum">    1414 </span>            : static tree c_parser_asm_goto_operands (c_parser *);
<span class="lineNum">    1415 </span>            : static tree c_parser_asm_clobbers (c_parser *);
<span class="lineNum">    1416 </span>            : static struct c_expr c_parser_expr_no_commas (c_parser *, struct c_expr *,
<span class="lineNum">    1417 </span>            :                                               tree = NULL_TREE);
<span class="lineNum">    1418 </span>            : static struct c_expr c_parser_conditional_expression (c_parser *,
<span class="lineNum">    1419 </span>            :                                                       struct c_expr *, tree);
<span class="lineNum">    1420 </span>            : static struct c_expr c_parser_binary_expression (c_parser *, struct c_expr *,
<span class="lineNum">    1421 </span>            :                                                  tree);
<span class="lineNum">    1422 </span>            : static struct c_expr c_parser_cast_expression (c_parser *, struct c_expr *);
<span class="lineNum">    1423 </span>            : static struct c_expr c_parser_unary_expression (c_parser *);
<span class="lineNum">    1424 </span>            : static struct c_expr c_parser_sizeof_expression (c_parser *);
<span class="lineNum">    1425 </span>            : static struct c_expr c_parser_alignof_expression (c_parser *);
<span class="lineNum">    1426 </span>            : static struct c_expr c_parser_postfix_expression (c_parser *);
<span class="lineNum">    1427 </span>            : static struct c_expr c_parser_postfix_expression_after_paren_type (c_parser *,
<span class="lineNum">    1428 </span>            :                                                                    struct c_type_name *,
<span class="lineNum">    1429 </span>            :                                                                    location_t);
<span class="lineNum">    1430 </span>            : static struct c_expr c_parser_postfix_expression_after_primary (c_parser *,
<span class="lineNum">    1431 </span>            :                                                                 location_t loc,
<span class="lineNum">    1432 </span>            :                                                                 struct c_expr);
<span class="lineNum">    1433 </span>            : static tree c_parser_transaction (c_parser *, enum rid);
<span class="lineNum">    1434 </span>            : static struct c_expr c_parser_transaction_expression (c_parser *, enum rid);
<span class="lineNum">    1435 </span>            : static tree c_parser_transaction_cancel (c_parser *);
<span class="lineNum">    1436 </span>            : static struct c_expr c_parser_expression (c_parser *);
<span class="lineNum">    1437 </span>            : static struct c_expr c_parser_expression_conv (c_parser *);
<span class="lineNum">    1438 </span>            : static vec&lt;tree, va_gc&gt; *c_parser_expr_list (c_parser *, bool, bool,
<span class="lineNum">    1439 </span>            :                                              vec&lt;tree, va_gc&gt; **, location_t *,
<span class="lineNum">    1440 </span>            :                                              tree *, vec&lt;location_t&gt; *,
<span class="lineNum">    1441 </span>            :                                              unsigned int * = NULL);
<span class="lineNum">    1442 </span>            : static void c_parser_oacc_declare (c_parser *);
<span class="lineNum">    1443 </span>            : static void c_parser_oacc_enter_exit_data (c_parser *, bool);
<span class="lineNum">    1444 </span>            : static void c_parser_oacc_update (c_parser *);
<span class="lineNum">    1445 </span>            : static void c_parser_omp_construct (c_parser *, bool *);
<span class="lineNum">    1446 </span>            : static void c_parser_omp_threadprivate (c_parser *);
<span class="lineNum">    1447 </span>            : static void c_parser_omp_barrier (c_parser *);
<span class="lineNum">    1448 </span>            : static void c_parser_omp_flush (c_parser *);
<span class="lineNum">    1449 </span>            : static tree c_parser_omp_for_loop (location_t, c_parser *, enum tree_code,
<span class="lineNum">    1450 </span>            :                                    tree, tree *, bool *);
<span class="lineNum">    1451 </span>            : static void c_parser_omp_taskwait (c_parser *);
<span class="lineNum">    1452 </span>            : static void c_parser_omp_taskyield (c_parser *);
<span class="lineNum">    1453 </span>            : static void c_parser_omp_cancel (c_parser *);
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span>            : enum pragma_context { pragma_external, pragma_struct, pragma_param,
<span class="lineNum">    1456 </span>            :                       pragma_stmt, pragma_compound };
<span class="lineNum">    1457 </span>            : static bool c_parser_pragma (c_parser *, enum pragma_context, bool *);
<span class="lineNum">    1458 </span>            : static void c_parser_omp_cancellation_point (c_parser *, enum pragma_context);
<span class="lineNum">    1459 </span>            : static bool c_parser_omp_target (c_parser *, enum pragma_context, bool *);
<span class="lineNum">    1460 </span>            : static void c_parser_omp_end_declare_target (c_parser *);
<span class="lineNum">    1461 </span>            : static void c_parser_omp_declare (c_parser *, enum pragma_context);
<span class="lineNum">    1462 </span>            : static bool c_parser_omp_ordered (c_parser *, enum pragma_context, bool *);
<span class="lineNum">    1463 </span>            : static void c_parser_oacc_routine (c_parser *, enum pragma_context);
<span class="lineNum">    1464 </span>            : 
<span class="lineNum">    1465 </span>            : /* These Objective-C parser functions are only ever called when
<span class="lineNum">    1466 </span>            :    compiling Objective-C.  */
<span class="lineNum">    1467 </span>            : static void c_parser_objc_class_definition (c_parser *, tree);
<span class="lineNum">    1468 </span>            : static void c_parser_objc_class_instance_variables (c_parser *);
<span class="lineNum">    1469 </span>            : static void c_parser_objc_class_declaration (c_parser *);
<span class="lineNum">    1470 </span>            : static void c_parser_objc_alias_declaration (c_parser *);
<span class="lineNum">    1471 </span>            : static void c_parser_objc_protocol_definition (c_parser *, tree);
<span class="lineNum">    1472 </span>            : static bool c_parser_objc_method_type (c_parser *);
<span class="lineNum">    1473 </span>            : static void c_parser_objc_method_definition (c_parser *);
<span class="lineNum">    1474 </span>            : static void c_parser_objc_methodprotolist (c_parser *);
<span class="lineNum">    1475 </span>            : static void c_parser_objc_methodproto (c_parser *);
<span class="lineNum">    1476 </span>            : static tree c_parser_objc_method_decl (c_parser *, bool, tree *, tree *);
<span class="lineNum">    1477 </span>            : static tree c_parser_objc_type_name (c_parser *);
<span class="lineNum">    1478 </span>            : static tree c_parser_objc_protocol_refs (c_parser *);
<span class="lineNum">    1479 </span>            : static void c_parser_objc_try_catch_finally_statement (c_parser *);
<span class="lineNum">    1480 </span>            : static void c_parser_objc_synchronized_statement (c_parser *);
<span class="lineNum">    1481 </span>            : static tree c_parser_objc_selector (c_parser *);
<span class="lineNum">    1482 </span>            : static tree c_parser_objc_selector_arg (c_parser *);
<span class="lineNum">    1483 </span>            : static tree c_parser_objc_receiver (c_parser *);
<span class="lineNum">    1484 </span>            : static tree c_parser_objc_message_args (c_parser *);
<span class="lineNum">    1485 </span>            : static tree c_parser_objc_keywordexpr (c_parser *);
<span class="lineNum">    1486 </span>            : static void c_parser_objc_at_property_declaration (c_parser *);
<span class="lineNum">    1487 </span>            : static void c_parser_objc_at_synthesize_declaration (c_parser *);
<span class="lineNum">    1488 </span>            : static void c_parser_objc_at_dynamic_declaration (c_parser *);
<span class="lineNum">    1489 </span>            : static bool c_parser_objc_diagnose_bad_element_prefix
<span class="lineNum">    1490 </span>            :   (c_parser *, struct c_declspecs *);
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span>            : static void c_parser_parse_rtl_body (c_parser *parser, char *start_with_pass);
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span>            : /* Parse a translation unit (C90 6.7, C99 6.9, C11 6.9).
<span class="lineNum">    1495 </span>            : 
<span class="lineNum">    1496 </span>            :    translation-unit:
<span class="lineNum">    1497 </span>            :      external-declarations
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span>            :    external-declarations:
<span class="lineNum">    1500 </span>            :      external-declaration
<span class="lineNum">    1501 </span>            :      external-declarations external-declaration
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span>            :    GNU extensions:
<span class="lineNum">    1504 </span>            : 
<span class="lineNum">    1505 </span>            :    translation-unit:
<span class="lineNum">    1506 </span>            :      empty
<span class="lineNum">    1507 </span>            : */
<a name="1508"><span class="lineNum">    1508 </span>            : </a>
<span class="lineNum">    1509 </span>            : static void
<span class="lineNum">    1510 </span>            : c_parser_translation_unit (c_parser *parser)
<span class="lineNum">    1511 </span>            : {
<span class="lineNum">    1512 </span>            :   if (c_parser_next_token_is (parser, CPP_EOF))
<span class="lineNum">    1513 </span>            :     {
<span class="lineNum">    1514 </span>            :       pedwarn (c_parser_peek_token (parser)-&gt;location, OPT_Wpedantic,
<span class="lineNum">    1515 </span>            :                &quot;ISO C forbids an empty translation unit&quot;);
<span class="lineNum">    1516 </span>            :     }
<span class="lineNum">    1517 </span>            :   else
<span class="lineNum">    1518 </span>            :     {
<span class="lineNum">    1519 </span>            :       void *obstack_position = obstack_alloc (&amp;parser_obstack, 0);
<span class="lineNum">    1520 </span>            :       mark_valid_location_for_stdc_pragma (false);
<span class="lineNum">    1521 </span>            :       do
<span class="lineNum">    1522 </span>            :         {
<span class="lineNum">    1523 </span>            :           ggc_collect ();
<span class="lineNum">    1524 </span>            :           c_parser_external_declaration (parser);
<span class="lineNum">    1525 </span>            :           obstack_free (&amp;parser_obstack, obstack_position);
<span class="lineNum">    1526 </span>            :         }
<span class="lineNum">    1527 </span>            :       while (c_parser_next_token_is_not (parser, CPP_EOF));
<span class="lineNum">    1528 </span>            :     }
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span>            :   unsigned int i;
<span class="lineNum">    1531 </span>            :   tree decl;
<span class="lineNum">    1532 </span>            :   FOR_EACH_VEC_ELT (incomplete_record_decls, i, decl)
<span class="lineNum">    1533 </span>            :     if (DECL_SIZE (decl) == NULL_TREE &amp;&amp; TREE_TYPE (decl) != error_mark_node)
<span class="lineNum">    1534 </span><span class="lineCov">      71373 :       error (&quot;storage size of %q+D isn%'t known&quot;, decl);</span>
<span class="lineNum">    1535 </span>            : }
<span class="lineNum">    1536 </span><span class="lineCov">      71373 : </span>
<span class="lineNum">    1537 </span>            : /* Parse an external declaration (C90 6.7, C99 6.9, C11 6.9).
<span class="lineNum">    1538 </span><span class="lineCov">        528 : </span>
<span class="lineNum">    1539 </span>            :    external-declaration:
<span class="lineNum">    1540 </span>            :      function-definition
<span class="lineNum">    1541 </span>            :      declaration
<span class="lineNum">    1542 </span>            : 
<span class="lineNum">    1543 </span><span class="lineCov">      70845 :    GNU extensions:</span>
<span class="lineNum">    1544 </span><span class="lineCov">      70845 : </span>
<span class="lineNum">    1545 </span><span class="lineCov">   32288537 :    external-declaration:</span>
<span class="lineNum">    1546 </span>            :      asm-definition
<span class="lineNum">    1547 </span><span class="lineCov">   32288537 :      ;</span>
<span class="lineNum">    1548 </span><span class="lineCov">   32288537 :      __extension__ external-declaration</span>
<span class="lineNum">    1549 </span><span class="lineCov">   32288533 : </span>
<span class="lineNum">    1550 </span>            :    Objective-C:
<span class="lineNum">    1551 </span><span class="lineCov">   32288533 : </span>
<span class="lineNum">    1552 </span>            :    external-declaration:
<span class="lineNum">    1553 </span>            :      objc-class-definition
<span class="lineNum">    1554 </span>            :      objc-class-declaration
<span class="lineNum">    1555 </span>            :      objc-alias-declaration
<span class="lineNum">    1556 </span><span class="lineCov">      71456 :      objc-protocol-definition</span>
<span class="lineNum">    1557 </span><span class="lineCov">        142 :      objc-method-definition</span>
<span class="lineNum">    1558 </span><span class="lineCov">         17 :      @end</span>
<span class="lineNum">    1559 </span><span class="lineCov">      71314 : */</span>
<a name="1560"><span class="lineNum">    1560 </span>            : </a>
<span class="lineNum">    1561 </span>            : static void
<span class="lineNum">    1562 </span>            : c_parser_external_declaration (c_parser *parser)
<span class="lineNum">    1563 </span>            : {
<span class="lineNum">    1564 </span>            :   int ext;
<span class="lineNum">    1565 </span>            :   switch (c_parser_peek_token (parser)-&gt;type)
<span class="lineNum">    1566 </span>            :     {
<span class="lineNum">    1567 </span>            :     case CPP_KEYWORD:
<span class="lineNum">    1568 </span>            :       switch (c_parser_peek_token (parser)-&gt;keyword)
<span class="lineNum">    1569 </span>            :         {
<span class="lineNum">    1570 </span>            :         case RID_EXTENSION:
<span class="lineNum">    1571 </span>            :           ext = disable_extension_diagnostics ();
<span class="lineNum">    1572 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    1573 </span>            :           c_parser_external_declaration (parser);
<span class="lineNum">    1574 </span>            :           restore_extension_diagnostics (ext);
<span class="lineNum">    1575 </span>            :           break;
<span class="lineNum">    1576 </span>            :         case RID_ASM:
<span class="lineNum">    1577 </span>            :           c_parser_asm_definition (parser);
<span class="lineNum">    1578 </span>            :           break;
<span class="lineNum">    1579 </span>            :         case RID_AT_INTERFACE:
<span class="lineNum">    1580 </span>            :         case RID_AT_IMPLEMENTATION:
<span class="lineNum">    1581 </span>            :           gcc_assert (c_dialect_objc ());
<span class="lineNum">    1582 </span>            :           c_parser_objc_class_definition (parser, NULL_TREE);
<span class="lineNum">    1583 </span>            :           break;
<span class="lineNum">    1584 </span>            :         case RID_AT_CLASS:
<span class="lineNum">    1585 </span>            :           gcc_assert (c_dialect_objc ());
<span class="lineNum">    1586 </span><span class="lineCov">   32579903 :           c_parser_objc_class_declaration (parser);</span>
<span class="lineNum">    1587 </span>            :           break;
<span class="lineNum">    1588 </span><span class="lineCov">   32579903 :         case RID_AT_ALIAS:</span>
<span class="lineNum">    1589 </span><span class="lineCov">   32579903 :           gcc_assert (c_dialect_objc ());</span>
<span class="lineNum">    1590 </span>            :           c_parser_objc_alias_declaration (parser);
<span class="lineNum">    1591 </span><span class="lineCov">   31850685 :           break;</span>
<span class="lineNum">    1592 </span><span class="lineCov">   31850685 :         case RID_AT_PROTOCOL:</span>
<span class="lineNum">    1593 </span>            :           gcc_assert (c_dialect_objc ());
<span class="lineNum">    1594 </span><span class="lineCov">     291366 :           c_parser_objc_protocol_definition (parser, NULL_TREE);</span>
<span class="lineNum">    1595 </span><span class="lineCov">     291366 :           break;</span>
<span class="lineNum">    1596 </span><span class="lineCov">     291366 :         case RID_AT_PROPERTY:</span>
<span class="lineNum">    1597 </span><span class="lineCov">     291366 :           gcc_assert (c_dialect_objc ());</span>
<span class="lineNum">    1598 </span><span class="lineCov">     291366 :           c_parser_objc_at_property_declaration (parser);</span>
<span class="lineNum">    1599 </span><span class="lineCov">     291366 :           break;</span>
<span class="lineNum">    1600 </span><span class="lineCov">        135 :         case RID_AT_SYNTHESIZE:</span>
<span class="lineNum">    1601 </span><span class="lineCov">        135 :           gcc_assert (c_dialect_objc ());</span>
<span class="lineNum">    1602 </span><span class="lineCov">        135 :           c_parser_objc_at_synthesize_declaration (parser);</span>
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :         case RID_AT_DYNAMIC:</span>
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :           gcc_assert (c_dialect_objc ());</span>
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :           c_parser_objc_at_dynamic_declaration (parser);</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :         case RID_AT_END:</span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :           gcc_assert (c_dialect_objc ());</span>
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :           objc_finish_implementation ();</span>
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :           goto decl_or_fndef;</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :     case CPP_SEMICOLON:</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :       pedwarn (c_parser_peek_token (parser)-&gt;location, OPT_Wpedantic,</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :                &quot;ISO C does not allow extra %&lt;;%&gt; outside of a function&quot;);</span>
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :     case CPP_PRAGMA:</span>
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :       mark_valid_location_for_stdc_pragma (true);</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :       c_parser_pragma (parser, pragma_external, NULL);</span>
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :       mark_valid_location_for_stdc_pragma (false);</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :     case CPP_PLUS:</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :     case CPP_MINUS:</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :       if (c_dialect_objc ())</span>
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :           c_parser_objc_method_definition (parser);</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :       /* Else fall through, and yield a syntax error trying to parse</span>
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :          as a declaration or function definition.  */</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :       /* FALLTHRU */</span>
<span class="lineNum">    1637 </span>            :     default:
<span class="lineNum">    1638 </span>            :     decl_or_fndef:
<span class="lineNum">    1639 </span>            :       /* A declaration or a function definition (or, in Objective-C,
<span class="lineNum">    1640 </span>            :          an @interface or @protocol with prefix attributes).  We can
<span class="lineNum">    1641 </span><span class="lineCov">        788 :          only tell which after parsing the declaration specifiers, if</span>
<span class="lineNum">    1642 </span><span class="lineCov">        788 :          any, and the first declarator.  */</span>
<span class="lineNum">    1643 </span>            :       c_parser_declaration_or_fndef (parser, true, true, true, false, true,
<span class="lineNum">    1644 </span><span class="lineCov">        788 :                                      NULL, vNULL);</span>
<span class="lineNum">    1645 </span><span class="lineCov">        788 :       break;</span>
<span class="lineNum">    1646 </span><span class="lineCov">     585680 :     }</span>
<span class="lineNum">    1647 </span><span class="lineCov">     585680 : }</span>
<span class="lineNum">    1648 </span><span class="lineCov">     585680 : </span>
<span class="lineNum">    1649 </span><span class="lineCov">     585680 : static void c_finish_omp_declare_simd (c_parser *, tree, tree, vec&lt;c_token&gt;);</span>
<span class="lineNum">    1650 </span><span class="lineCov">     585680 : static void c_finish_oacc_routine (struct oacc_routine_data *, tree, bool);</span>
<span class="lineNum">    1651 </span><span class="lineCov">          1 : </span>
<span class="lineNum">    1652 </span><span class="lineCov">          1 : /* Build and add a DEBUG_BEGIN_STMT statement with location LOC.  */</span>
<a name="1653"><span class="lineNum">    1653 </span><span class="lineCov">          1 : </span></a>
<span class="lineNum">    1654 </span>            : static void
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 : add_debug_begin_stmt (location_t loc)</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1657 </span>            :   /* Don't add DEBUG_BEGIN_STMTs outside of functions, see PR84721.  */
<span class="lineNum">    1658 </span>            :   if (!MAY_HAVE_DEBUG_MARKER_STMTS || !building_stmt_list_p ())
<span class="lineNum">    1659 </span>            :     return;
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span><span class="lineCov">   31701934 :   tree stmt = build0 (DEBUG_BEGIN_STMT, void_type_node);</span>
<span class="lineNum">    1662 </span><span class="lineCov">          1 :   SET_EXPR_LOCATION (stmt, loc);</span>
<span class="lineNum">    1663 </span>            :   add_stmt (stmt);
<span class="lineNum">    1664 </span>            : }
<span class="lineNum">    1665 </span>            : 
<span class="lineNum">    1666 </span>            : /* Parse a declaration or function definition (C90 6.5, 6.7.1, C99
<span class="lineNum">    1667 </span><span class="lineCov">   31701934 :    6.7, 6.9.1, C11 6.7, 6.9.1).  If FNDEF_OK is true, a function definition</span>
<span class="lineNum">    1668 </span>            :    is accepted; otherwise (old-style parameter declarations) only other
<span class="lineNum">    1669 </span><span class="lineCov">   31701934 :    declarations are accepted.  If STATIC_ASSERT_OK is true, a static</span>
<span class="lineNum">    1670 </span>            :    assertion is accepted; otherwise (old-style parameter declarations)
<span class="lineNum">    1671 </span><span class="lineCov">   32579899 :    it is not.  If NESTED is true, we are inside a function or parsing</span>
<span class="lineNum">    1672 </span>            :    old-style parameter declarations; any functions encountered are
<span class="lineNum">    1673 </span>            :    nested functions and declaration specifiers are required; otherwise
<span class="lineNum">    1674 </span>            :    we are at top level and functions are normal functions and
<span class="lineNum">    1675 </span>            :    declaration specifiers may be optional.  If EMPTY_OK is true, empty
<span class="lineNum">    1676 </span>            :    declarations are OK (subject to all other constraints); otherwise
<span class="lineNum">    1677 </span>            :    (old-style parameter declarations) they are diagnosed.  If
<span class="lineNum">    1678 </span>            :    START_ATTR_OK is true, the declaration specifiers may start with
<span class="lineNum">    1679 </span><span class="lineCov">   57336204 :    attributes; otherwise they may not.</span>
<span class="lineNum">    1680 </span>            :    OBJC_FOREACH_OBJECT_DECLARATION can be used to get back the parsed
<span class="lineNum">    1681 </span>            :    declaration when parsing an Objective-C foreach statement.
<span class="lineNum">    1682 </span><span class="lineCov">   57336204 :    FALLTHRU_ATTR_P is used to signal whether this function parsed</span>
<span class="lineNum">    1683 </span><span class="lineCov">   55807150 :    &quot;__attribute__((fallthrough));&quot;.</span>
<span class="lineNum">    1684 </span>            : 
<span class="lineNum">    1685 </span><span class="lineCov">    1529054 :    declaration:</span>
<span class="lineNum">    1686 </span><span class="lineCov">    1529054 :      declaration-specifiers init-declarator-list[opt] ;</span>
<span class="lineNum">    1687 </span><span class="lineCov">    1529054 :      static_assert-declaration</span>
<span class="lineNum">    1688 </span>            : 
<span class="lineNum">    1689 </span>            :    function-definition:
<span class="lineNum">    1690 </span>            :      declaration-specifiers[opt] declarator declaration-list[opt]
<span class="lineNum">    1691 </span>            :        compound-statement
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span>            :    declaration-list:
<span class="lineNum">    1694 </span>            :      declaration
<span class="lineNum">    1695 </span>            :      declaration-list declaration
<span class="lineNum">    1696 </span>            : 
<span class="lineNum">    1697 </span>            :    init-declarator-list:
<span class="lineNum">    1698 </span>            :      init-declarator
<span class="lineNum">    1699 </span>            :      init-declarator-list , init-declarator
<span class="lineNum">    1700 </span>            : 
<span class="lineNum">    1701 </span>            :    init-declarator:
<span class="lineNum">    1702 </span>            :      declarator simple-asm-expr[opt] attributes[opt]
<span class="lineNum">    1703 </span>            :      declarator simple-asm-expr[opt] attributes[opt] = initializer
<span class="lineNum">    1704 </span>            : 
<span class="lineNum">    1705 </span>            :    GNU extensions:
<span class="lineNum">    1706 </span>            : 
<span class="lineNum">    1707 </span>            :    nested-function-definition:
<span class="lineNum">    1708 </span>            :      declaration-specifiers declarator declaration-list[opt]
<span class="lineNum">    1709 </span>            :        compound-statement
<span class="lineNum">    1710 </span>            : 
<span class="lineNum">    1711 </span>            :    attribute ;
<span class="lineNum">    1712 </span>            : 
<span class="lineNum">    1713 </span>            :    Objective-C:
<span class="lineNum">    1714 </span>            :      attributes objc-class-definition
<span class="lineNum">    1715 </span>            :      attributes objc-category-definition
<span class="lineNum">    1716 </span>            :      attributes objc-protocol-definition
<span class="lineNum">    1717 </span>            : 
<span class="lineNum">    1718 </span>            :    The simple-asm-expr and attributes are GNU extensions.
<span class="lineNum">    1719 </span>            : 
<span class="lineNum">    1720 </span>            :    This function does not handle __extension__; that is handled in its
<span class="lineNum">    1721 </span>            :    callers.  ??? Following the old parser, __extension__ may start
<span class="lineNum">    1722 </span>            :    external declarations, declarations in functions and declarations
<span class="lineNum">    1723 </span>            :    at the start of &quot;for&quot; loops, but not old-style parameter
<span class="lineNum">    1724 </span>            :    declarations.
<span class="lineNum">    1725 </span>            : 
<span class="lineNum">    1726 </span>            :    C99 requires declaration specifiers in a function definition; the
<span class="lineNum">    1727 </span>            :    absence is diagnosed through the diagnosis of implicit int.  In GNU
<span class="lineNum">    1728 </span>            :    C we also allow but diagnose declarations without declaration
<span class="lineNum">    1729 </span>            :    specifiers, but only at top level (elsewhere they conflict with
<span class="lineNum">    1730 </span>            :    other syntax).
<span class="lineNum">    1731 </span>            : 
<span class="lineNum">    1732 </span>            :    In Objective-C, declarations of the looping variable in a foreach
<span class="lineNum">    1733 </span>            :    statement are exceptionally terminated by 'in' (for example, 'for
<span class="lineNum">    1734 </span>            :    (NSObject *object in array) { ... }').
<span class="lineNum">    1735 </span>            : 
<span class="lineNum">    1736 </span>            :    OpenMP:
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span>            :    declaration:
<span class="lineNum">    1739 </span>            :      threadprivate-directive
<span class="lineNum">    1740 </span>            : 
<span class="lineNum">    1741 </span>            :    GIMPLE:
<span class="lineNum">    1742 </span>            : 
<span class="lineNum">    1743 </span>            :    gimple-function-definition:
<span class="lineNum">    1744 </span>            :      declaration-specifiers[opt] __GIMPLE (gimple-or-rtl-pass-list) declarator
<span class="lineNum">    1745 </span>            :        declaration-list[opt] compound-statement
<span class="lineNum">    1746 </span>            : 
<span class="lineNum">    1747 </span>            :    rtl-function-definition:
<span class="lineNum">    1748 </span>            :      declaration-specifiers[opt] __RTL (gimple-or-rtl-pass-list) declarator
<span class="lineNum">    1749 </span>            :        declaration-list[opt] compound-statement  */
<a name="1750"><span class="lineNum">    1750 </span>            : </a>
<span class="lineNum">    1751 </span>            : static void
<span class="lineNum">    1752 </span>            : c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,
<span class="lineNum">    1753 </span>            :                                bool static_assert_ok, bool empty_ok,
<span class="lineNum">    1754 </span>            :                                bool nested, bool start_attr_ok,
<span class="lineNum">    1755 </span>            :                                tree *objc_foreach_object_declaration,
<span class="lineNum">    1756 </span>            :                                vec&lt;c_token&gt; omp_declare_simd_clauses,
<span class="lineNum">    1757 </span>            :                                struct oacc_routine_data *oacc_routine_data,
<span class="lineNum">    1758 </span>            :                                bool *fallthru_attr_p)
<span class="lineNum">    1759 </span>            : {
<span class="lineNum">    1760 </span>            :   struct c_declspecs *specs;
<span class="lineNum">    1761 </span>            :   tree prefix_attrs;
<span class="lineNum">    1762 </span>            :   tree all_prefix_attrs;
<span class="lineNum">    1763 </span>            :   bool diagnosed_no_specs = false;
<span class="lineNum">    1764 </span>            :   location_t here = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    1765 </span>            : 
<span class="lineNum">    1766 </span>            :   add_debug_begin_stmt (c_parser_peek_token (parser)-&gt;location);
<span class="lineNum">    1767 </span>            : 
<span class="lineNum">    1768 </span>            :   if (static_assert_ok
<span class="lineNum">    1769 </span>            :       &amp;&amp; c_parser_next_token_is_keyword (parser, RID_STATIC_ASSERT))
<span class="lineNum">    1770 </span>            :     {
<span class="lineNum">    1771 </span>            :       c_parser_static_assert_declaration (parser);
<span class="lineNum">    1772 </span>            :       return;
<span class="lineNum">    1773 </span>            :     }
<span class="lineNum">    1774 </span>            :   specs = build_null_declspecs ();
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span><span class="lineCov">   34914110 :   /* Try to detect an unknown type name when we have &quot;A B&quot; or &quot;A *B&quot;.  */</span>
<span class="lineNum">    1777 </span>            :   if (c_parser_peek_token (parser)-&gt;type == CPP_NAME
<span class="lineNum">    1778 </span>            :       &amp;&amp; c_parser_peek_token (parser)-&gt;id_kind == C_ID_ID
<span class="lineNum">    1779 </span>            :       &amp;&amp; (c_parser_peek_2nd_token (parser)-&gt;type == CPP_NAME
<span class="lineNum">    1780 </span>            :           || c_parser_peek_2nd_token (parser)-&gt;type == CPP_MULT)
<span class="lineNum">    1781 </span>            :       &amp;&amp; (!nested || !lookup_name (c_parser_peek_token (parser)-&gt;value)))
<span class="lineNum">    1782 </span>            :     {
<span class="lineNum">    1783 </span>            :       tree name = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    1784 </span><span class="lineCov">   34914110 : </span>
<span class="lineNum">    1785 </span><span class="lineCov">   34914110 :       /* Issue a warning about NAME being an unknown type name, perhaps</span>
<span class="lineNum">    1786 </span><span class="lineCov">   34914110 :          with some kind of hint.</span>
<span class="lineNum">    1787 </span><span class="lineCov">   34914110 :          If the user forgot a &quot;struct&quot; etc, suggest inserting</span>
<span class="lineNum">    1788 </span><span class="lineCov">   34914110 :          it.  Otherwise, attempt to look for misspellings.  */</span>
<span class="lineNum">    1789 </span>            :       gcc_rich_location richloc (here);
<span class="lineNum">    1790 </span><span class="lineCov">   34914110 :       if (tag_exists_p (RECORD_TYPE, name))</span>
<span class="lineNum">    1791 </span>            :         {
<span class="lineNum">    1792 </span><span class="lineCov">   34914110 :           /* This is not C++ with its implicit typedef.  */</span>
<span class="lineNum">    1793 </span><span class="lineCov">   34914110 :           richloc.add_fixit_insert_before (&quot;struct &quot;);</span>
<span class="lineNum">    1794 </span>            :           error_at (&amp;richloc,
<span class="lineNum">    1795 </span><span class="lineCov">        561 :                     &quot;unknown type name %qE;&quot;</span>
<span class="lineNum">    1796 </span><span class="lineCov">        561 :                     &quot; use %&lt;struct%&gt; keyword to refer to the type&quot;,</span>
<span class="lineNum">    1797 </span>            :                     name);
<span class="lineNum">    1798 </span><span class="lineCov">   34913549 :         }</span>
<span class="lineNum">    1799 </span>            :       else if (tag_exists_p (UNION_TYPE, name))
<span class="lineNum">    1800 </span>            :         {
<span class="lineNum">    1801 </span><span class="lineCov">   34913549 :           richloc.add_fixit_insert_before (&quot;union &quot;);</span>
<span class="lineNum">    1802 </span><span class="lineCov">    1861362 :           error_at (&amp;richloc,</span>
<span class="lineNum">    1803 </span><span class="lineCov">      13101 :                     &quot;unknown type name %qE;&quot;</span>
<span class="lineNum">    1804 </span><span class="lineCov">      13010 :                     &quot; use %&lt;union%&gt; keyword to refer to the type&quot;,</span>
<span class="lineNum">    1805 </span><span class="lineCov">   34913664 :                     name);</span>
<span class="lineNum">    1806 </span>            :         }
<span class="lineNum">    1807 </span><span class="lineCov">        115 :       else if (tag_exists_p (ENUMERAL_TYPE, name))</span>
<span class="lineNum">    1808 </span>            :         {
<span class="lineNum">    1809 </span>            :           richloc.add_fixit_insert_before (&quot;enum &quot;);
<span class="lineNum">    1810 </span>            :           error_at (&amp;richloc,
<span class="lineNum">    1811 </span>            :                     &quot;unknown type name %qE;&quot;
<span class="lineNum">    1812 </span>            :                     &quot; use %&lt;enum%&gt; keyword to refer to the type&quot;,
<span class="lineNum">    1813 </span><span class="lineCov">        230 :                     name);</span>
<span class="lineNum">    1814 </span><span class="lineCov">        115 :         }</span>
<span class="lineNum">    1815 </span>            :       else
<span class="lineNum">    1816 </span>            :         {
<span class="lineNum">    1817 </span><span class="lineCov">          3 :           auto_diagnostic_group d;</span>
<span class="lineNum">    1818 </span><span class="lineCov">          3 :           name_hint hint = lookup_name_fuzzy (name, FUZZY_LOOKUP_TYPENAME,</span>
<span class="lineNum">    1819 </span>            :                                               here);
<span class="lineNum">    1820 </span>            :           if (hint)
<span class="lineNum">    1821 </span>            :             {
<span class="lineNum">    1822 </span>            :               richloc.add_fixit_replace (hint.suggestion ());
<span class="lineNum">    1823 </span><span class="lineCov">        112 :               error_at (&amp;richloc,</span>
<span class="lineNum">    1824 </span>            :                         &quot;unknown type name %qE; did you mean %qs?&quot;,
<span class="lineNum">    1825 </span><span class="lineCov">          3 :                         name, hint.suggestion ());</span>
<span class="lineNum">    1826 </span><span class="lineCov">          3 :             }</span>
<span class="lineNum">    1827 </span>            :           else
<span class="lineNum">    1828 </span>            :             error_at (here, &quot;unknown type name %qE&quot;, name);
<span class="lineNum">    1829 </span>            :         }
<span class="lineNum">    1830 </span>            : 
<span class="lineNum">    1831 </span><span class="lineCov">        109 :       /* Parse declspecs normally to get a correct pointer type, but avoid</span>
<span class="lineNum">    1832 </span>            :          a further &quot;fails to be a type name&quot; error.  Refuse nested functions
<span class="lineNum">    1833 </span><span class="lineCov">          3 :          since it is not how the user likely wants us to recover.  */</span>
<span class="lineNum">    1834 </span><span class="lineCov">          3 :       c_parser_peek_token (parser)-&gt;type = CPP_KEYWORD;</span>
<span class="lineNum">    1835 </span>            :       c_parser_peek_token (parser)-&gt;keyword = RID_VOID;
<span class="lineNum">    1836 </span>            :       c_parser_peek_token (parser)-&gt;value = error_mark_node;
<span class="lineNum">    1837 </span>            :       fndef_ok = !nested;
<span class="lineNum">    1838 </span>            :     }
<span class="lineNum">    1839 </span>            : 
<span class="lineNum">    1840 </span>            :   c_parser_declspecs (parser, specs, true, true, start_attr_ok,
<span class="lineNum">    1841 </span><span class="lineCov">        106 :                       true, true, cla_nonabstract_decl);</span>
<span class="lineNum">    1842 </span><span class="lineCov">        106 :   if (parser-&gt;error)</span>
<span class="lineNum">    1843 </span><span class="lineCov">        217 :     {</span>
<span class="lineNum">    1844 </span><span class="lineCov">        212 :       c_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">    1845 </span>            :       return;
<span class="lineNum">    1846 </span><span class="lineCov">         24 :     }</span>
<span class="lineNum">    1847 </span><span class="lineCov">         24 :   if (nested &amp;&amp; !specs-&gt;declspecs_seen_p)</span>
<span class="lineNum">    1848 </span>            :     {
<span class="lineNum">    1849 </span>            :       c_parser_error (parser, &quot;expected declaration specifiers&quot;);
<span class="lineNum">    1850 </span>            :       c_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">    1851 </span>            :       return;
<span class="lineNum">    1852 </span><span class="lineCov">         94 :     }</span>
<span class="lineNum">    1853 </span>            : 
<span class="lineNum">    1854 </span>            :   finish_declspecs (specs);
<span class="lineNum">    1855 </span>            :   bool auto_type_p = specs-&gt;typespec_word == cts_auto_type;
<span class="lineNum">    1856 </span>            :   if (c_parser_next_token_is (parser, CPP_SEMICOLON))
<span class="lineNum">    1857 </span>            :     {
<span class="lineNum">    1858 </span><span class="lineCov">        115 :       if (auto_type_p)</span>
<span class="lineNum">    1859 </span><span class="lineCov">        115 :         error_at (here, &quot;%&lt;__auto_type%&gt; in empty declaration&quot;);</span>
<span class="lineNum">    1860 </span><span class="lineCov">        115 :       else if (specs-&gt;typespec_kind == ctsk_none</span>
<span class="lineNum">    1861 </span><span class="lineCov">        115 :                &amp;&amp; attribute_fallthrough_p (specs-&gt;attrs))</span>
<span class="lineNum">    1862 </span>            :         {
<span class="lineNum">    1863 </span>            :           if (fallthru_attr_p != NULL)
<span class="lineNum">    1864 </span><span class="lineCov">   34913549 :             *fallthru_attr_p = true;</span>
<span class="lineNum">    1865 </span>            :           tree fn = build_call_expr_internal_loc (here, IFN_FALLTHROUGH,
<span class="lineNum">    1866 </span><span class="lineCov">   34913549 :                                                   void_type_node, 0);</span>
<span class="lineNum">    1867 </span>            :           add_stmt (fn);
<span class="lineNum">    1868 </span><span class="lineCov">         24 :         }</span>
<span class="lineNum">    1869 </span><span class="lineCov">         24 :       else if (empty_ok)</span>
<span class="lineNum">    1870 </span>            :         shadow_tag (specs);
<span class="lineNum">    1871 </span><span class="lineCov">   34913525 :       else</span>
<span class="lineNum">    1872 </span>            :         {
<span class="lineNum">    1873 </span><span class="lineCov">         59 :           shadow_tag_warned (specs, 1);</span>
<span class="lineNum">    1874 </span><span class="lineCov">         59 :           pedwarn (here, 0, &quot;empty declaration&quot;);</span>
<span class="lineNum">    1875 </span><span class="lineCov">         59 :         }</span>
<span class="lineNum">    1876 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    1877 </span>            :       if (oacc_routine_data)
<span class="lineNum">    1878 </span><span class="lineCov">   34913466 :         c_finish_oacc_routine (oacc_routine_data, NULL_TREE, false);</span>
<span class="lineNum">    1879 </span><span class="lineCov">   34913466 :       return;</span>
<span class="lineNum">    1880 </span><span class="lineCov">   34913466 :     }</span>
<span class="lineNum">    1881 </span>            : 
<span class="lineNum">    1882 </span><span class="lineCov">     371187 :   /* Provide better error recovery.  Note that a type name here is usually</span>
<span class="lineNum">    1883 </span><span class="lineCov">          1 :      better diagnosed as a redeclaration.  */</span>
<span class="lineNum">    1884 </span><span class="lineCov">     371186 :   if (empty_ok</span>
<span class="lineNum">    1885 </span><span class="lineCov">     371186 :       &amp;&amp; specs-&gt;typespec_kind == ctsk_tagdef</span>
<span class="lineNum">    1886 </span>            :       &amp;&amp; c_parser_next_token_starts_declspecs (parser)
<span class="lineNum">    1887 </span><span class="lineCov">         48 :       &amp;&amp; !c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">    1888 </span><span class="lineCov">         48 :     {</span>
<span class="lineNum">    1889 </span><span class="lineCov">         48 :       c_parser_error (parser, &quot;expected %&lt;;%&gt;, identifier or %&lt;(%&gt;&quot;);</span>
<span class="lineNum">    1890 </span>            :       parser-&gt;error = false;
<span class="lineNum">    1891 </span><span class="lineCov">         48 :       shadow_tag_warned (specs, 1);</span>
<span class="lineNum">    1892 </span>            :       return;
<span class="lineNum">    1893 </span><span class="lineCov">     371138 :     }</span>
<span class="lineNum">    1894 </span><span class="lineCov">     371125 :   else if (c_dialect_objc () &amp;&amp; !auto_type_p)</span>
<span class="lineNum">    1895 </span>            :     {
<span class="lineNum">    1896 </span>            :       /* Prefix attributes are an error on method decls.  */
<span class="lineNum">    1897 </span><span class="lineCov">         13 :       switch (c_parser_peek_token (parser)-&gt;type)</span>
<span class="lineNum">    1898 </span><span class="lineCov">         13 :         {</span>
<span class="lineNum">    1899 </span>            :           case CPP_PLUS:
<span class="lineNum">    1900 </span><span class="lineCov">     371187 :           case CPP_MINUS:</span>
<span class="lineNum">    1901 </span><span class="lineCov">     371187 :             if (c_parser_objc_diagnose_bad_element_prefix (parser, specs))</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :               return;</span>
<span class="lineNum">    1903 </span><span class="lineCov">     371187 :             if (specs-&gt;attrs)</span>
<span class="lineNum">    1904 </span>            :               {
<span class="lineNum">    1905 </span>            :                 warning_at (c_parser_peek_token (parser)-&gt;location, 
<span class="lineNum">    1906 </span>            :                             OPT_Wattributes,
<span class="lineNum">    1907 </span>            :                             &quot;prefix attributes are ignored for methods&quot;);
<span class="lineNum">    1908 </span><span class="lineCov">   34542279 :                 specs-&gt;attrs = NULL_TREE;</span>
<span class="lineNum">    1909 </span><span class="lineCov">   34529476 :               }</span>
<span class="lineNum">    1910 </span><span class="lineCov">     404841 :             if (fndef_ok)</span>
<span class="lineNum">    1911 </span><span class="lineCov">   34542286 :               c_parser_objc_method_definition (parser);</span>
<span class="lineNum">    1912 </span>            :             else
<span class="lineNum">    1913 </span><span class="lineCov">          6 :               c_parser_objc_methodproto (parser);</span>
<span class="lineNum">    1914 </span><span class="lineCov">          6 :             return;</span>
<span class="lineNum">    1915 </span><span class="lineCov">          6 :             break;</span>
<span class="lineNum">    1916 </span><span class="lineCov">          6 :           default:</span>
<span class="lineNum">    1917 </span>            :             break;
<span class="lineNum">    1918 </span><span class="lineCov">   34542273 :         }</span>
<span class="lineNum">    1919 </span>            :       /* This is where we parse 'attributes @interface ...',
<span class="lineNum">    1920 </span>            :          'attributes @implementation ...', 'attributes @protocol ...'
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :          (where attributes could be, for example, __attribute__</span>
<span class="lineNum">    1922 </span>            :          ((deprecated)).
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 :       */</span>
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :       switch (c_parser_peek_token (parser)-&gt;keyword)</span>
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    1926 </span>            :         case RID_AT_INTERFACE:
<span class="lineNum">    1927 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">    1928 </span>            :             if (c_parser_objc_diagnose_bad_element_prefix (parser, specs))
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :               return;</span>
<span class="lineNum">    1930 </span>            :             c_parser_objc_class_definition (parser, specs-&gt;attrs);
<span class="lineNum">    1931 </span>            :             return;
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1933 </span>            :           break;
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :         case RID_AT_IMPLEMENTATION:</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">    1936 </span>            :             if (c_parser_objc_diagnose_bad_element_prefix (parser, specs))
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :               return;</span>
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :             if (specs-&gt;attrs)</span>
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :               {</span>
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :                 warning_at (c_parser_peek_token (parser)-&gt;location, </span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :                         OPT_Wattributes,</span>
<span class="lineNum">    1942 </span>            :                         &quot;prefix attributes are ignored for implementations&quot;);
<span class="lineNum">    1943 </span>            :                 specs-&gt;attrs = NULL_TREE;
<span class="lineNum">    1944 </span>            :               }
<span class="lineNum">    1945 </span>            :             c_parser_objc_class_definition (parser, NULL_TREE);     
<span class="lineNum">    1946 </span>            :             return;
<span class="lineNum">    1947 </span>            :           }
<span class="lineNum">    1948 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1949 </span>            :         case RID_AT_PROTOCOL:
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :             if (c_parser_objc_diagnose_bad_element_prefix (parser, specs))</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :               return;</span>
<span class="lineNum">    1953 </span>            :             c_parser_objc_protocol_definition (parser, specs-&gt;attrs);
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    1956 </span>            :           break;
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :         case RID_AT_ALIAS:</span>
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :         case RID_AT_CLASS:</span>
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :         case RID_AT_END:</span>
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :         case RID_AT_PROPERTY:</span>
<span class="lineNum">    1961 </span>            :           if (specs-&gt;attrs)
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">    1963 </span>            :               c_parser_error (parser, &quot;unexpected attribute&quot;);
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :               specs-&gt;attrs = NULL;</span>
<span class="lineNum">    1965 </span>            :             }
<span class="lineNum">    1966 </span>            :           break;
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    1968 </span>            :           break;
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1971 </span>            :   else if (attribute_fallthrough_p (specs-&gt;attrs))
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :     warning_at (here, OPT_Wattributes,</span>
<span class="lineNum">    1973 </span><span class="lineNoCov">          0 :                 &quot;%&lt;fallthrough%&gt; attribute not followed by %&lt;;%&gt;&quot;);</span>
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1975 </span><span class="lineNoCov">          0 :   pending_xref_error ();</span>
<span class="lineNum">    1976 </span>            :   prefix_attrs = specs-&gt;attrs;
<span class="lineNum">    1977 </span><span class="lineNoCov">          0 :   all_prefix_attrs = prefix_attrs;</span>
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :   specs-&gt;attrs = NULL_TREE;</span>
<span class="lineNum">    1979 </span>            :   while (true)
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 :       struct c_declarator *declarator;</span>
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :       bool dummy = false;</span>
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :       timevar_id_t tv;</span>
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :       tree fnbody = NULL_TREE;</span>
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :       /* Declaring either one or more declarators (in which case we</span>
<span class="lineNum">    1986 </span>            :          should diagnose if there were no declaration specifiers) or a
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :          function definition (in which case the diagnostic for</span>
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :          implicit int suffices).  */</span>
<span class="lineNum">    1989 </span>            :       declarator = c_parser_declarator (parser, 
<span class="lineNum">    1990 </span>            :                                         specs-&gt;typespec_kind != ctsk_none,
<span class="lineNum">    1991 </span>            :                                         C_DTR_NORMAL, &amp;dummy);
<span class="lineNum">    1992 </span>            :       if (declarator == NULL)
<span class="lineNum">    1993 </span>            :         {
<span class="lineNum">    1994 </span>            :           if (omp_declare_simd_clauses.exists ())
<span class="lineNum">    1995 </span><span class="lineCov">   34542273 :             c_finish_omp_declare_simd (parser, NULL_TREE, NULL_TREE,</span>
<span class="lineNum">    1996 </span><span class="lineCov">          4 :                                        omp_declare_simd_clauses);</span>
<span class="lineNum">    1997 </span>            :           if (oacc_routine_data)
<span class="lineNum">    1998 </span>            :             c_finish_oacc_routine (oacc_routine_data, NULL_TREE, false);
<span class="lineNum">    1999 </span><span class="lineCov">   34542273 :           c_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">    2000 </span><span class="lineCov">   34542273 :           return;</span>
<span class="lineNum">    2001 </span><span class="lineCov">   34542273 :         }</span>
<span class="lineNum">    2002 </span><span class="lineCov">   34542273 :       if (auto_type_p &amp;&amp; declarator-&gt;kind != cdk_id)</span>
<span class="lineNum">    2003 </span><span class="lineCov">   34827226 :         {</span>
<span class="lineNum">    2004 </span>            :           error_at (here,
<span class="lineNum">    2005 </span><span class="lineCov">   34827226 :                     &quot;%&lt;__auto_type%&gt; requires a plain identifier&quot;</span>
<span class="lineNum">    2006 </span><span class="lineCov">   34827226 :                     &quot; as declarator&quot;);</span>
<span class="lineNum">    2007 </span><span class="lineCov">   34827226 :           c_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">    2008 </span><span class="lineCov">   34827226 :           return;</span>
<span class="lineNum">    2009 </span>            :         }
<span class="lineNum">    2010 </span>            :       if (c_parser_next_token_is (parser, CPP_EQ)
<span class="lineNum">    2011 </span>            :           || c_parser_next_token_is (parser, CPP_COMMA)
<span class="lineNum">    2012 </span>            :           || c_parser_next_token_is (parser, CPP_SEMICOLON)
<span class="lineNum">    2013 </span><span class="lineCov">  104481678 :           || c_parser_next_token_is_keyword (parser, RID_ASM)</span>
<span class="lineNum">    2014 </span><span class="lineCov">   34827226 :           || c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE)</span>
<span class="lineNum">    2015 </span>            :           || c_parser_next_token_is_keyword (parser, RID_IN))
<span class="lineNum">    2016 </span><span class="lineCov">   34827226 :         {</span>
<span class="lineNum">    2017 </span>            :           tree asm_name = NULL_TREE;
<span class="lineNum">    2018 </span><span class="lineCov">        167 :           tree postfix_attrs = NULL_TREE;</span>
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :           if (!diagnosed_no_specs &amp;&amp; !specs-&gt;declspecs_seen_p)</span>
<span class="lineNum">    2020 </span>            :             {
<span class="lineNum">    2021 </span><span class="lineCov">        167 :               diagnosed_no_specs = true;</span>
<span class="lineNum">    2022 </span><span class="lineNoCov">          0 :               pedwarn (here, 0, &quot;data definition has no type or storage class&quot;);</span>
<span class="lineNum">    2023 </span><span class="lineCov">        167 :             }</span>
<span class="lineNum">    2024 </span><span class="lineCov">   16456275 :           /* Having seen a data definition, there cannot now be a</span>
<span class="lineNum">    2025 </span>            :              function definition.  */
<span class="lineNum">    2026 </span><span class="lineCov">   34827059 :           fndef_ok = false;</span>
<span class="lineNum">    2027 </span>            :           if (c_parser_next_token_is_keyword (parser, RID_ASM))
<span class="lineNum">    2028 </span><span class="lineCov">          1 :             asm_name = c_parser_simple_asm_expr (parser);</span>
<span class="lineNum">    2029 </span>            :           if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))
<span class="lineNum">    2030 </span>            :             {
<span class="lineNum">    2031 </span><span class="lineCov">          1 :               postfix_attrs = c_parser_attributes (parser);</span>
<span class="lineNum">    2032 </span><span class="lineCov">          1 :               if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))</span>
<span class="lineNum">    2033 </span>            :                 {
<span class="lineNum">    2034 </span><span class="lineCov">   34827058 :                   /* This means there is an attribute specifier after</span>
<span class="lineNum">    2035 </span><span class="lineCov">   32922019 :                      the declarator in a function definition.  Provide</span>
<span class="lineNum">    2036 </span><span class="lineCov">   32654557 :                      some more information for the user.  */</span>
<span class="lineNum">    2037 </span><span class="lineCov">   26169471 :                   error_at (here, &quot;attributes should be specified before the &quot;</span>
<span class="lineNum">    2038 </span><span class="lineCov">   25606585 :                             &quot;declarator in a function definition&quot;);</span>
<span class="lineNum">    2039 </span><span class="lineCov">   52913085 :                   c_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">    2040 </span>            :                   return;
<span class="lineNum">    2041 </span><span class="lineCov">   16741031 :                 }</span>
<span class="lineNum">    2042 </span><span class="lineCov">   16741031 :             }</span>
<span class="lineNum">    2043 </span><span class="lineCov">   16741031 :           if (c_parser_next_token_is (parser, CPP_EQ))</span>
<span class="lineNum">    2044 </span>            :             {
<span class="lineNum">    2045 </span><span class="lineCov">         67 :               tree d;</span>
<span class="lineNum">    2046 </span><span class="lineCov">         67 :               struct c_expr init;</span>
<span class="lineNum">    2047 </span>            :               location_t init_loc;
<span class="lineNum">    2048 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">    2049 </span>            :               if (auto_type_p)
<span class="lineNum">    2050 </span><span class="lineCov">   16741031 :                 {</span>
<span class="lineNum">    2051 </span><span class="lineCov">   16741031 :                   init_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    2052 </span><span class="lineCov">     562886 :                   rich_location richloc (line_table, init_loc);</span>
<span class="lineNum">    2053 </span><span class="lineCov">   16741031 :                   start_init (NULL_TREE, asm_name, global_bindings_p (), &amp;richloc);</span>
<span class="lineNum">    2054 </span>            :                   /* A parameter is initialized, which is invalid.  Don't
<span class="lineNum">    2055 </span><span class="lineCov">    8027396 :                      attempt to instrument the initializer.  */</span>
<span class="lineNum">    2056 </span><span class="lineCov">    8027396 :                   int flag_sanitize_save = flag_sanitize;</span>
<span class="lineNum">    2057 </span>            :                   if (nested &amp;&amp; !empty_ok)
<span class="lineNum">    2058 </span>            :                     flag_sanitize = 0;
<span class="lineNum">    2059 </span>            :                   init = c_parser_expr_no_commas (parser, NULL);
<span class="lineNum">    2060 </span>            :                   flag_sanitize = flag_sanitize_save;
<span class="lineNum">    2061 </span><span class="lineCov">          1 :                   if (TREE_CODE (init.value) == COMPONENT_REF</span>
<span class="lineNum">    2062 </span>            :                       &amp;&amp; DECL_C_BIT_FIELD (TREE_OPERAND (init.value, 1)))
<span class="lineNum">    2063 </span><span class="lineCov">          1 :                     error_at (here,</span>
<span class="lineNum">    2064 </span><span class="lineCov">          1 :                               &quot;%&lt;__auto_type%&gt; used with a bit-field&quot;</span>
<span class="lineNum">    2065 </span>            :                               &quot; initializer&quot;);
<span class="lineNum">    2066 </span>            :                   init = convert_lvalue_to_rvalue (init_loc, init, true, true);
<span class="lineNum">    2067 </span><span class="lineCov">   16741030 :                   tree init_type = TREE_TYPE (init.value);</span>
<span class="lineNum">    2068 </span>            :                   /* As with typeof, remove all qualifiers from atomic types.  */
<span class="lineNum">    2069 </span><span class="lineCov">    1905939 :                   if (init_type != error_mark_node &amp;&amp; TYPE_ATOMIC (init_type))</span>
<span class="lineNum">    2070 </span><span class="lineCov">    1905939 :                     init_type</span>
<span class="lineNum">    2071 </span><span class="lineCov">    1905939 :                       = c_build_qualified_type (init_type, TYPE_UNQUALIFIED);</span>
<span class="lineNum">    2072 </span><span class="lineCov">    1905939 :                   bool vm_type = variably_modified_type_p (init_type,</span>
<span class="lineNum">    2073 </span><span class="lineCov">    1905939 :                                                            NULL_TREE);</span>
<span class="lineNum">    2074 </span>            :                   if (vm_type)
<span class="lineNum">    2075 </span><span class="lineCov">       1376 :                     init.value = save_expr (init.value);</span>
<span class="lineNum">    2076 </span><span class="lineCov">       2752 :                   finish_init ();</span>
<span class="lineNum">    2077 </span><span class="lineCov">       1376 :                   specs-&gt;typespec_kind = ctsk_typeof;</span>
<span class="lineNum">    2078 </span>            :                   specs-&gt;locations[cdw_typedef] = init_loc;
<span class="lineNum">    2079 </span>            :                   specs-&gt;typedef_p = true;
<span class="lineNum">    2080 </span><span class="lineCov">       1376 :                   specs-&gt;type = init_type;</span>
<span class="lineNum">    2081 </span><span class="lineCov">       1376 :                   if (vm_type)</span>
<span class="lineNum">    2082 </span><span class="lineCov">         14 :                     {</span>
<span class="lineNum">    2083 </span><span class="lineCov">       1376 :                       bool maybe_const = true;</span>
<span class="lineNum">    2084 </span><span class="lineCov">       1376 :                       tree type_expr = c_fully_fold (init.value, false,</span>
<span class="lineNum">    2085 </span><span class="lineCov">       1376 :                                                      &amp;maybe_const);</span>
<span class="lineNum">    2086 </span><span class="lineCov">       1376 :                       specs-&gt;expr_const_operands &amp;= maybe_const;</span>
<span class="lineNum">    2087 </span><span class="lineCov">          1 :                       if (specs-&gt;expr)</span>
<span class="lineNum">    2088 </span>            :                         specs-&gt;expr = build2 (COMPOUND_EXPR,
<span class="lineNum">    2089 </span>            :                                               TREE_TYPE (type_expr),
<span class="lineNum">    2090 </span><span class="lineCov">       1376 :                                               specs-&gt;expr, type_expr);</span>
<span class="lineNum">    2091 </span><span class="lineCov">       1376 :                       else</span>
<span class="lineNum">    2092 </span>            :                         specs-&gt;expr = type_expr;
<span class="lineNum">    2093 </span><span class="lineCov">       1376 :                     }</span>
<span class="lineNum">    2094 </span><span class="lineNoCov">          0 :                   d = start_decl (declarator, specs, true,</span>
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :                                   chainon (postfix_attrs, all_prefix_attrs));</span>
<span class="lineNum">    2096 </span><span class="lineCov">       1376 :                   if (!d)</span>
<span class="lineNum">    2097 </span>            :                     d = error_mark_node;
<span class="lineNum">    2098 </span><span class="lineCov">       1376 :                   if (omp_declare_simd_clauses.exists ())</span>
<span class="lineNum">    2099 </span><span class="lineCov">         91 :                     c_finish_omp_declare_simd (parser, d, NULL_TREE,</span>
<span class="lineNum">    2100 </span><span class="lineCov">       1376 :                                                omp_declare_simd_clauses);</span>
<span class="lineNum">    2101 </span><span class="lineCov">       1376 :                 }</span>
<span class="lineNum">    2102 </span><span class="lineCov">       1376 :               else</span>
<span class="lineNum">    2103 </span><span class="lineCov">       1376 :                 {</span>
<span class="lineNum">    2104 </span><span class="lineCov">       1376 :                   /* The declaration of the variable is in effect while</span>
<span class="lineNum">    2105 </span><span class="lineCov">       1376 :                      its initializer is parsed.  */</span>
<span class="lineNum">    2106 </span>            :                   d = start_decl (declarator, specs, true,
<span class="lineNum">    2107 </span><span class="lineCov">         91 :                                   chainon (postfix_attrs, all_prefix_attrs));</span>
<span class="lineNum">    2108 </span><span class="lineCov">         91 :                   if (!d)</span>
<span class="lineNum">    2109 </span><span class="lineCov">         91 :                     d = error_mark_node;</span>
<span class="lineNum">    2110 </span><span class="lineCov">         91 :                   if (omp_declare_simd_clauses.exists ())</span>
<span class="lineNum">    2111 </span><span class="lineCov">         91 :                     c_finish_omp_declare_simd (parser, d, NULL_TREE,</span>
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :                                                omp_declare_simd_clauses);</span>
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :                   init_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    2114 </span>            :                   rich_location richloc (line_table, init_loc);
<span class="lineNum">    2115 </span>            :                   start_init (d, asm_name, global_bindings_p (), &amp;richloc);
<span class="lineNum">    2116 </span><span class="lineCov">         91 :                   /* A parameter is initialized, which is invalid.  Don't</span>
<span class="lineNum">    2117 </span>            :                      attempt to instrument the initializer.  */
<span class="lineNum">    2118 </span><span class="lineCov">       1376 :                   int flag_sanitize_save = flag_sanitize;</span>
<span class="lineNum">    2119 </span>            :                   if (TREE_CODE (d) == PARM_DECL)
<span class="lineNum">    2120 </span><span class="lineCov">       1376 :                     flag_sanitize = 0;</span>
<span class="lineNum">    2121 </span><span class="lineCov">          2 :                   init = c_parser_initializer (parser);</span>
<span class="lineNum">    2122 </span><span class="lineCov">       1376 :                   flag_sanitize = flag_sanitize_save;</span>
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 :                   finish_init ();</span>
<span class="lineNum">    2124 </span>            :                 }
<span class="lineNum">    2125 </span>            :               if (oacc_routine_data)
<span class="lineNum">    2126 </span>            :                 c_finish_oacc_routine (oacc_routine_data, d, false);
<span class="lineNum">    2127 </span>            :               if (d != error_mark_node)
<span class="lineNum">    2128 </span>            :                 {
<span class="lineNum">    2129 </span>            :                   maybe_warn_string_init (init_loc, TREE_TYPE (d), init);
<span class="lineNum">    2130 </span><span class="lineCov">    1904563 :                   finish_decl (d, init_loc, init.value,</span>
<span class="lineNum">    2131 </span>            :                                init.original_type, asm_name);
<span class="lineNum">    2132 </span><span class="lineCov">    1904563 :                 }</span>
<span class="lineNum">    2133 </span><span class="lineCov">          4 :             }</span>
<span class="lineNum">    2134 </span><span class="lineCov">    1904563 :           else</span>
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">    2136 </span>            :               if (auto_type_p)
<span class="lineNum">    2137 </span><span class="lineCov">    1904563 :                 {</span>
<span class="lineNum">    2138 </span><span class="lineCov">    3809124 :                   error_at (here,</span>
<span class="lineNum">    2139 </span><span class="lineCov">    1904563 :                             &quot;%&lt;__auto_type%&gt; requires an initialized &quot;</span>
<span class="lineNum">    2140 </span>            :                             &quot;data declaration&quot;);
<span class="lineNum">    2141 </span>            :                   c_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">    2142 </span><span class="lineCov">    1904563 :                   return;</span>
<span class="lineNum">    2143 </span><span class="lineCov">    1904563 :                 }</span>
<span class="lineNum">    2144 </span><span class="lineCov">         35 :               tree d = start_decl (declarator, specs, false,</span>
<span class="lineNum">    2145 </span><span class="lineCov">    1904563 :                                    chainon (postfix_attrs,</span>
<span class="lineNum">    2146 </span><span class="lineCov">    1904561 :                                             all_prefix_attrs));</span>
<span class="lineNum">    2147 </span><span class="lineCov">    1904561 :               if (d &amp;&amp; TREE_CODE (d) == FUNCTION_DECL)</span>
<span class="lineNum">    2148 </span>            :                 if (declarator-&gt;kind == cdk_function)
<span class="lineNum">    2149 </span><span class="lineCov">    1905937 :                   if (DECL_ARGUMENTS (d) == NULL_TREE)</span>
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :                     DECL_ARGUMENTS (d) = declarator-&gt;u.arg_info-&gt;parms;</span>
<span class="lineNum">    2151 </span><span class="lineCov">    1905937 :               if (omp_declare_simd_clauses.exists ())</span>
<span class="lineNum">    2152 </span>            :                 {
<span class="lineNum">    2153 </span><span class="lineCov">    1905931 :                   tree parms = NULL_TREE;</span>
<span class="lineNum">    2154 </span><span class="lineCov">    1905931 :                   if (d &amp;&amp; TREE_CODE (d) == FUNCTION_DECL)</span>
<span class="lineNum">    2155 </span>            :                     {
<span class="lineNum">    2156 </span>            :                       struct c_declarator *ce = declarator;
<span class="lineNum">    2157 </span>            :                       while (ce != NULL)
<span class="lineNum">    2158 </span>            :                         if (ce-&gt;kind == cdk_function)
<span class="lineNum">    2159 </span>            :                           {
<span class="lineNum">    2160 </span><span class="lineCov">   14835091 :                             parms = ce-&gt;u.arg_info-&gt;parms;</span>
<span class="lineNum">    2161 </span>            :                             break;
<span class="lineNum">    2162 </span><span class="lineCov">          1 :                           }</span>
<span class="lineNum">    2163 </span>            :                         else
<span class="lineNum">    2164 </span>            :                           ce = ce-&gt;declarator;
<span class="lineNum">    2165 </span><span class="lineCov">          1 :                     }</span>
<span class="lineNum">    2166 </span><span class="lineCov">          1 :                   if (parms)</span>
<span class="lineNum">    2167 </span>            :                     temp_store_parm_decls (d, parms);
<span class="lineNum">    2168 </span><span class="lineCov">   14835090 :                   c_finish_omp_declare_simd (parser, d, parms,</span>
<span class="lineNum">    2169 </span>            :                                              omp_declare_simd_clauses);
<span class="lineNum">    2170 </span><span class="lineCov">   14835090 :                   if (parms)</span>
<span class="lineNum">    2171 </span><span class="lineCov">   14835090 :                     temp_pop_parm_decls ();</span>
<span class="lineNum">    2172 </span><span class="lineCov">    9809294 :                 }</span>
<span class="lineNum">    2173 </span><span class="lineCov">   17115650 :               if (oacc_routine_data)</span>
<span class="lineNum">    2174 </span><span class="lineCov">   16984586 :                 c_finish_oacc_routine (oacc_routine_data, d, false);</span>
<span class="lineNum">    2175 </span><span class="lineCov">   14835090 :               if (d)</span>
<span class="lineNum">    2176 </span>            :                 finish_decl (d, UNKNOWN_LOCATION, NULL_TREE,
<span class="lineNum">    2177 </span><span class="lineCov">         60 :                              NULL_TREE, asm_name);</span>
<span class="lineNum">    2178 </span><span class="lineCov">         60 :               </span>
<span class="lineNum">    2179 </span>            :               if (c_parser_next_token_is_keyword (parser, RID_IN))
<span class="lineNum">    2180 </span>            :                 {
<span class="lineNum">    2181 </span><span class="lineCov">         57 :                   if (d)</span>
<span class="lineNum">    2182 </span><span class="lineCov">         57 :                     *objc_foreach_object_declaration = d;</span>
<span class="lineNum">    2183 </span>            :                   else
<span class="lineNum">    2184 </span><span class="lineCov">         57 :                     *objc_foreach_object_declaration = error_mark_node;             </span>
<span class="lineNum">    2185 </span><span class="lineCov">         57 :                 }</span>
<span class="lineNum">    2186 </span>            :             }
<span class="lineNum">    2187 </span>            :           if (c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">    2189 </span>            :               if (auto_type_p)
<span class="lineNum">    2190 </span><span class="lineCov">         57 :                 {</span>
<span class="lineNum">    2191 </span><span class="lineCov">         57 :                   error_at (here,</span>
<span class="lineNum">    2192 </span><span class="lineCov">         60 :                             &quot;%&lt;__auto_type%&gt; may only be used with&quot;</span>
<span class="lineNum">    2193 </span>            :                             &quot; a single declarator&quot;);
<span class="lineNum">    2194 </span><span class="lineCov">         60 :                   c_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">    2195 </span><span class="lineCov">         57 :                   return;</span>
<span class="lineNum">    2196 </span>            :                 }
<span class="lineNum">    2197 </span><span class="lineCov">   14835090 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    2198 </span><span class="lineCov">         28 :               if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))</span>
<span class="lineNum">    2199 </span><span class="lineCov">   14835090 :                 all_prefix_attrs = chainon (c_parser_attributes (parser),</span>
<span class="lineNum">    2200 </span><span class="lineCov">   14835083 :                                             prefix_attrs);</span>
<span class="lineNum">    2201 </span>            :               else
<span class="lineNum">    2202 </span>            :                 all_prefix_attrs = prefix_attrs;
<span class="lineNum">    2203 </span><span class="lineCov">   14835090 :               continue;</span>
<span class="lineNum">    2204 </span>            :             }
<span class="lineNum">    2205 </span><span class="lineNoCov">          0 :           else if (c_parser_next_token_is (parser, CPP_SEMICOLON))</span>
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">    2207 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :               return;</span>
<span class="lineNum">    2209 </span>            :             }
<span class="lineNum">    2210 </span>            :           else if (c_parser_next_token_is_keyword (parser, RID_IN))
<span class="lineNum">    2211 </span><span class="lineCov">   16741027 :             {</span>
<span class="lineNum">    2212 </span>            :               /* This can only happen in Objective-C: we found the
<span class="lineNum">    2213 </span><span class="lineCov">     284954 :                  'in' that terminates the declaration inside an</span>
<span class="lineNum">    2214 </span>            :                  Objective-C foreach statement.  Do not consume the
<span class="lineNum">    2215 </span><span class="lineCov">          1 :                  token, so that the caller can use it to determine</span>
<span class="lineNum">    2216 </span>            :                  that this indeed is a foreach context.  */
<span class="lineNum">    2217 </span>            :               return;
<span class="lineNum">    2218 </span><span class="lineCov">          1 :             }</span>
<span class="lineNum">    2219 </span><span class="lineCov">          1 :           else</span>
<span class="lineNum">    2220 </span>            :             {
<span class="lineNum">    2221 </span><span class="lineCov">     284953 :               c_parser_error (parser, &quot;expected %&lt;,%&gt; or %&lt;;%&gt;&quot;);</span>
<span class="lineNum">    2222 </span><span class="lineCov">     284953 :               c_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">    2223 </span><span class="lineCov">         12 :               return;</span>
<span class="lineNum">    2224 </span>            :             }
<span class="lineNum">    2225 </span>            :         }
<span class="lineNum">    2226 </span>            :       else if (auto_type_p)
<span class="lineNum">    2227 </span><span class="lineCov">     284953 :         {</span>
<span class="lineNum">    2228 </span>            :           error_at (here,
<span class="lineNum">    2229 </span><span class="lineCov">   16456073 :                     &quot;%&lt;__auto_type%&gt; requires an initialized data declaration&quot;);</span>
<span class="lineNum">    2230 </span>            :           c_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">    2231 </span><span class="lineCov">   16456041 :           return;</span>
<span class="lineNum">    2232 </span><span class="lineCov">   16456041 :         }</span>
<span class="lineNum">    2233 </span>            :       else if (!fndef_ok)
<span class="lineNum">    2234 </span><span class="lineCov">         32 :         {</span>
<span class="lineNum">    2235 </span>            :           c_parser_error (parser, &quot;expected %&lt;=%&gt;, %&lt;,%&gt;, %&lt;;%&gt;, &quot;
<span class="lineNum">    2236 </span>            :                           &quot;%&lt;asm%&gt; or %&lt;__attribute__%&gt;&quot;);
<span class="lineNum">    2237 </span>            :           c_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">    2238 </span>            :           return;
<span class="lineNum">    2239 </span>            :         }
<span class="lineNum">    2240 </span>            :       /* Function definition (nested or otherwise).  */
<span class="lineNum">    2241 </span>            :       if (nested)
<span class="lineNum">    2242 </span>            :         {
<span class="lineNum">    2243 </span>            :           pedwarn (here, OPT_Wpedantic, &quot;ISO C forbids nested functions&quot;);
<span class="lineNum">    2244 </span>            :           c_push_function_context ();
<span class="lineNum">    2245 </span><span class="lineCov">         32 :         }</span>
<span class="lineNum">    2246 </span><span class="lineCov">         32 :       if (!start_function (specs, declarator, all_prefix_attrs))</span>
<span class="lineNum">    2247 </span><span class="lineCov">         32 :         {</span>
<span class="lineNum">    2248 </span>            :           /* At this point we've consumed:
<span class="lineNum">    2249 </span>            :                declaration-specifiers declarator
<span class="lineNum">    2250 </span><span class="lineCov">   18086027 :              and the next token isn't CPP_EQ, CPP_COMMA, CPP_SEMICOLON,</span>
<span class="lineNum">    2251 </span>            :              RID_ASM, RID_ATTRIBUTE, or RID_IN,
<span class="lineNum">    2252 </span><span class="lineCov">          1 :              but the</span>
<span class="lineNum">    2253 </span>            :                declaration-specifiers declarator
<span class="lineNum">    2254 </span><span class="lineCov">          1 :              aren't grokkable as a function definition, so we have</span>
<span class="lineNum">    2255 </span><span class="lineCov">          1 :              an error.  */</span>
<span class="lineNum">    2256 </span>            :           gcc_assert (!c_parser_next_token_is (parser, CPP_SEMICOLON));
<span class="lineNum">    2257 </span><span class="lineCov">   18086026 :           if (c_parser_next_token_starts_declspecs (parser))</span>
<span class="lineNum">    2258 </span>            :             {
<span class="lineNum">    2259 </span><span class="lineCov">         13 :               /* If we have</span>
<span class="lineNum">    2260 </span>            :                    declaration-specifiers declarator decl-specs
<span class="lineNum">    2261 </span><span class="lineCov">         13 :                  then assume we have a missing semicolon, which would</span>
<span class="lineNum">    2262 </span><span class="lineCov">         13 :                  give us:</span>
<span class="lineNum">    2263 </span>            :                    declaration-specifiers declarator  decl-specs
<span class="lineNum">    2264 </span>            :                                                     ^
<span class="lineNum">    2265 </span><span class="lineCov">   18086013 :                                                     ;</span>
<span class="lineNum">    2266 </span>            :                    &lt;~~~~~~~~~ declaration ~~~~~~~~~~&gt;
<span class="lineNum">    2267 </span><span class="lineCov">       1363 :                  Use c_parser_require to get an error with a fix-it hint.  */</span>
<span class="lineNum">    2268 </span><span class="lineCov">       1363 :               c_parser_require (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);</span>
<span class="lineNum">    2269 </span>            :               parser-&gt;error = false;
<span class="lineNum">    2270 </span><span class="lineCov">   18086013 :             }</span>
<span class="lineNum">    2271 </span>            :           else
<span class="lineNum">    2272 </span>            :             {
<span class="lineNum">    2273 </span>            :               /* This can appear in many cases looking nothing like a
<span class="lineNum">    2274 </span>            :                  function definition, so we don't give a more specific
<span class="lineNum">    2275 </span>            :                  error suggesting there was one.  */
<span class="lineNum">    2276 </span>            :               c_parser_error (parser, &quot;expected %&lt;=%&gt;, %&lt;,%&gt;, %&lt;;%&gt;, %&lt;asm%&gt; &quot;
<span class="lineNum">    2277 </span>            :                               &quot;or %&lt;__attribute__%&gt;&quot;);
<span class="lineNum">    2278 </span>            :             }
<span class="lineNum">    2279 </span>            :           if (nested)
<span class="lineNum">    2280 </span><span class="lineCov">         36 :             c_pop_function_context ();</span>
<span class="lineNum">    2281 </span><span class="lineCov">         36 :           break;</span>
<span class="lineNum">    2282 </span>            :         }
<span class="lineNum">    2283 </span>            : 
<span class="lineNum">    2284 </span>            :       if (DECL_DECLARED_INLINE_P (current_function_decl))
<span class="lineNum">    2285 </span>            :         tv = TV_PARSE_INLINE;
<span class="lineNum">    2286 </span>            :       else
<span class="lineNum">    2287 </span>            :         tv = TV_PARSE_FUNC;
<span class="lineNum">    2288 </span>            :       auto_timevar at (g_timer, tv);
<span class="lineNum">    2289 </span>            : 
<span class="lineNum">    2290 </span>            :       /* Parse old-style parameter declarations.  ??? Attributes are
<span class="lineNum">    2291 </span>            :          not allowed to start declaration specifiers here because of a
<span class="lineNum">    2292 </span><span class="lineCov">         12 :          syntax conflict between a function declaration with attribute</span>
<span class="lineNum">    2293 </span><span class="lineCov">         12 :          suffix and a function definition with an attribute prefix on</span>
<span class="lineNum">    2294 </span>            :          first old-style parameter declaration.  Following the old
<span class="lineNum">    2295 </span>            :          parser, they are not accepted on subsequent old-style
<span class="lineNum">    2296 </span>            :          parameter declarations either.  However, there is no
<span class="lineNum">    2297 </span>            :          ambiguity after the first declaration, nor indeed on the
<span class="lineNum">    2298 </span>            :          first as long as we don't allow postfix attributes after a
<span class="lineNum">    2299 </span>            :          declarator with a nonempty identifier list in a definition;
<span class="lineNum">    2300 </span><span class="lineCov">         24 :          and postfix attributes have never been accepted here in</span>
<span class="lineNum">    2301 </span>            :          function definitions either.  */
<span class="lineNum">    2302 </span>            :       while (c_parser_next_token_is_not (parser, CPP_EOF)
<span class="lineNum">    2303 </span><span class="lineCov">         36 :              &amp;&amp; c_parser_next_token_is_not (parser, CPP_OPEN_BRACE))</span>
<span class="lineNum">    2304 </span><span class="lineCov">          1 :         c_parser_declaration_or_fndef (parser, false, false, false,</span>
<span class="lineNum">    2305 </span><span class="lineCov">   18085994 :                                        true, false, NULL, vNULL);</span>
<span class="lineNum">    2306 </span>            :       store_parm_decls ();
<span class="lineNum">    2307 </span>            :       if (omp_declare_simd_clauses.exists ())
<span class="lineNum">    2308 </span><span class="lineCov">   18085977 :         c_finish_omp_declare_simd (parser, current_function_decl, NULL_TREE,</span>
<span class="lineNum">    2309 </span>            :                                    omp_declare_simd_clauses);
<span class="lineNum">    2310 </span>            :       if (oacc_routine_data)
<span class="lineNum">    2311 </span><span class="lineCov">     428211 :         c_finish_oacc_routine (oacc_routine_data, current_function_decl, true);</span>
<span class="lineNum">    2312 </span><span class="lineCov">   18085977 :       DECL_STRUCT_FUNCTION (current_function_decl)-&gt;function_start_locus</span>
<span class="lineNum">    2313 </span>            :         = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    2314 </span>            : 
<span class="lineNum">    2315 </span>            :       /* If the definition was marked with __GIMPLE then parse the
<span class="lineNum">    2316 </span>            :          function body as GIMPLE.  */
<span class="lineNum">    2317 </span>            :       if (specs-&gt;gimple_p)
<span class="lineNum">    2318 </span>            :         {
<span class="lineNum">    2319 </span>            :           cfun-&gt;pass_startwith = specs-&gt;gimple_or_rtl_pass;
<span class="lineNum">    2320 </span>            :           bool saved = in_late_binary_op;
<span class="lineNum">    2321 </span>            :           in_late_binary_op = true;
<span class="lineNum">    2322 </span>            :           c_parser_parse_gimple_body (parser);
<span class="lineNum">    2323 </span>            :           in_late_binary_op = saved;
<span class="lineNum">    2324 </span>            :         }
<span class="lineNum">    2325 </span>            :       /* Similarly, if it was marked with __RTL, use the RTL parser now,
<span class="lineNum">    2326 </span><span class="lineCov">   18098852 :          consuming the function body.  */</span>
<span class="lineNum">    2327 </span><span class="lineCov">   18098852 :       else if (specs-&gt;rtl_p)</span>
<span class="lineNum">    2328 </span><span class="lineCov">      12875 :         {</span>
<span class="lineNum">    2329 </span>            :           c_parser_parse_rtl_body (parser, specs-&gt;gimple_or_rtl_pass);
<span class="lineNum">    2330 </span><span class="lineCov">   18085977 : </span>
<span class="lineNum">    2331 </span><span class="lineCov">   18085977 :           /* Normally, store_parm_decls sets next_is_function_body,</span>
<span class="lineNum">    2332 </span><span class="lineCov">         93 :              anticipating a function body.  We need a push_scope/pop_scope</span>
<span class="lineNum">    2333 </span>            :              pair to flush out this state, or subsequent function parsing
<span class="lineNum">    2334 </span><span class="lineCov">   18085977 :              will go wrong.  */</span>
<span class="lineNum">    2335 </span><span class="lineCov">         60 :           push_scope ();</span>
<span class="lineNum">    2336 </span><span class="lineCov">   18085977 :           pop_scope ();</span>
<span class="lineNum">    2337 </span><span class="lineCov">   18085977 : </span>
<span class="lineNum">    2338 </span>            :           finish_function ();
<span class="lineNum">    2339 </span>            :           return;
<span class="lineNum">    2340 </span>            :         }
<span class="lineNum">    2341 </span><span class="lineCov">   18085977 :       else</span>
<span class="lineNum">    2342 </span>            :         fnbody = c_parser_compound_statement (parser);
<span class="lineNum">    2343 </span><span class="lineCov">         53 :       tree fndecl = current_function_decl;</span>
<span class="lineNum">    2344 </span><span class="lineCov">         53 :       if (nested)</span>
<span class="lineNum">    2345 </span><span class="lineCov">         53 :         {</span>
<span class="lineNum">    2346 </span><span class="lineCov">         53 :           tree decl = current_function_decl;</span>
<span class="lineNum">    2347 </span><span class="lineCov">         53 :           /* Mark nested functions as needing static-chain initially.</span>
<span class="lineNum">    2348 </span>            :              lower_nested_functions will recompute it but the
<span class="lineNum">    2349 </span>            :              DECL_STATIC_CHAIN flag is also used before that happens,
<span class="lineNum">    2350 </span>            :              by initializer_constant_valid_p.  See gcc.dg/nested-fn-2.c.  */
<span class="lineNum">    2351 </span><span class="lineCov">   18085924 :           DECL_STATIC_CHAIN (decl) = 1;</span>
<span class="lineNum">    2352 </span>            :           add_stmt (fnbody);
<span class="lineNum">    2353 </span><span class="lineCov">         18 :           finish_function ();</span>
<span class="lineNum">    2354 </span>            :           c_pop_function_context ();
<span class="lineNum">    2355 </span>            :           add_stmt (build_stmt (DECL_SOURCE_LOCATION (decl), DECL_EXPR, decl));
<span class="lineNum">    2356 </span>            :         }
<span class="lineNum">    2357 </span>            :       else
<span class="lineNum">    2358 </span>            :         {
<span class="lineNum">    2359 </span><span class="lineCov">         17 :           if (fnbody)</span>
<span class="lineNum">    2360 </span><span class="lineCov">         17 :             add_stmt (fnbody);</span>
<span class="lineNum">    2361 </span>            :           finish_function ();
<span class="lineNum">    2362 </span><span class="lineCov">         17 :         }</span>
<span class="lineNum">    2363 </span><span class="lineCov">         17 :       /* Get rid of the empty stmt list for GIMPLE.  */</span>
<span class="lineNum">    2364 </span>            :       if (specs-&gt;gimple_p)
<span class="lineNum">    2365 </span>            :         DECL_SAVED_TREE (fndecl) = NULL_TREE;
<span class="lineNum">    2366 </span><span class="lineCov">   18085906 : </span>
<span class="lineNum">    2367 </span><span class="lineCov">   18085958 :       break;</span>
<span class="lineNum">    2368 </span><span class="lineCov">   18085958 :     }</span>
<span class="lineNum">    2369 </span>            : }
<span class="lineNum">    2370 </span><span class="lineCov">       1362 : </span>
<span class="lineNum">    2371 </span>            : /* Parse an asm-definition (asm() outside a function body).  This is a
<span class="lineNum">    2372 </span>            :    GNU extension.
<span class="lineNum">    2373 </span>            : 
<span class="lineNum">    2374 </span>            :    asm-definition:
<span class="lineNum">    2375 </span><span class="lineCov">       1362 :      simple-asm-expr ;</span>
<span class="lineNum">    2376 </span><span class="lineCov">       1362 : */</span>
<a name="2377"><span class="lineNum">    2377 </span><span class="lineCov">       1362 : </span></a>
<span class="lineNum">    2378 </span><span class="lineCov">       1362 : static void</span>
<span class="lineNum">    2379 </span><span class="lineCov">       1362 : c_parser_asm_definition (c_parser *parser)</span>
<span class="lineNum">    2380 </span>            : {
<span class="lineNum">    2381 </span>            :   tree asm_str = c_parser_simple_asm_expr (parser);
<span class="lineNum">    2382 </span>            :   if (asm_str)
<span class="lineNum">    2383 </span><span class="lineCov">   18084596 :     symtab-&gt;finalize_toplevel_asm (asm_str);</span>
<span class="lineNum">    2384 </span><span class="lineCov">   18084543 :   c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);</span>
<span class="lineNum">    2385 </span><span class="lineCov">   18084596 : }</span>
<span class="lineNum">    2386 </span>            : 
<span class="lineNum">    2387 </span>            : /* Parse a static assertion (C11 6.7.10).
<span class="lineNum">    2388 </span><span class="lineCov">   18085958 : </span>
<span class="lineNum">    2389 </span><span class="lineCov">         53 :    static_assert-declaration:</span>
<span class="lineNum">    2390 </span>            :      static_assert-declaration-no-semi ;
<span class="lineNum">    2391 </span><span class="lineCov">   18085958 : */</span>
<a name="2392"><span class="lineNum">    2392 </span>            : </a>
<span class="lineNum">    2393 </span>            : static void
<span class="lineNum">    2394 </span>            : c_parser_static_assert_declaration (c_parser *parser)
<span class="lineNum">    2395 </span>            : {
<span class="lineNum">    2396 </span>            :   c_parser_static_assert_declaration_no_semi (parser);
<span class="lineNum">    2397 </span>            :   if (parser-&gt;error
<span class="lineNum">    2398 </span>            :       || !c_parser_require (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;))
<span class="lineNum">    2399 </span>            :     c_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">    2400 </span>            : }
<span class="lineNum">    2401 </span>            : 
<span class="lineNum">    2402 </span>            : /* Parse a static assertion (C11 6.7.10), without the trailing
<span class="lineNum">    2403 </span><span class="lineCov">        135 :    semicolon.</span>
<span class="lineNum">    2404 </span>            : 
<span class="lineNum">    2405 </span><span class="lineCov">        135 :    static_assert-declaration-no-semi:</span>
<span class="lineNum">    2406 </span><span class="lineCov">        135 :      _Static_assert ( constant-expression , string-literal )</span>
<span class="lineNum">    2407 </span><span class="lineCov">        134 : */</span>
<a name="2408"><span class="lineNum">    2408 </span><span class="lineCov">        135 : </span></a>
<span class="lineNum">    2409 </span><span class="lineCov">        135 : static void</span>
<span class="lineNum">    2410 </span>            : c_parser_static_assert_declaration_no_semi (c_parser *parser)
<span class="lineNum">    2411 </span>            : {
<span class="lineNum">    2412 </span>            :   location_t assert_loc, value_loc;
<span class="lineNum">    2413 </span>            :   tree value;
<span class="lineNum">    2414 </span>            :   tree string;
<span class="lineNum">    2415 </span>            : 
<span class="lineNum">    2416 </span>            :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_STATIC_ASSERT));
<span class="lineNum">    2417 </span>            :   assert_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    2418 </span><span class="lineCov">        561 :   if (flag_isoc99)</span>
<span class="lineNum">    2419 </span>            :     pedwarn_c99 (assert_loc, OPT_Wpedantic,
<span class="lineNum">    2420 </span><span class="lineCov">        561 :                  &quot;ISO C99 does not support %&lt;_Static_assert%&gt;&quot;);</span>
<span class="lineNum">    2421 </span><span class="lineCov">        561 :   else</span>
<span class="lineNum">    2422 </span><span class="lineCov">        561 :     pedwarn_c99 (assert_loc, OPT_Wpedantic,</span>
<span class="lineNum">    2423 </span><span class="lineCov">          8 :                  &quot;ISO C90 does not support %&lt;_Static_assert%&gt;&quot;);</span>
<span class="lineNum">    2424 </span><span class="lineCov">        561 :   c_parser_consume_token (parser);</span>
<span class="lineNum">    2425 </span>            :   matching_parens parens;
<span class="lineNum">    2426 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">    2427 </span>            :     return;
<span class="lineNum">    2428 </span>            :   location_t value_tok_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    2429 </span>            :   value = c_parser_expr_no_commas (parser, NULL).value;
<span class="lineNum">    2430 </span>            :   value_loc = EXPR_LOC_OR_LOC (value, value_tok_loc);
<span class="lineNum">    2431 </span>            :   parser-&gt;lex_untranslated_string = true;
<span class="lineNum">    2432 </span>            :   if (!c_parser_require (parser, CPP_COMMA, &quot;expected %&lt;,%&gt;&quot;))
<span class="lineNum">    2433 </span>            :     {
<span class="lineNum">    2434 </span><span class="lineCov">        565 :       parser-&gt;lex_untranslated_string = false;</span>
<span class="lineNum">    2435 </span>            :       return;
<span class="lineNum">    2436 </span><span class="lineCov">        565 :     }</span>
<span class="lineNum">    2437 </span><span class="lineCov">        565 :   switch (c_parser_peek_token (parser)-&gt;type)</span>
<span class="lineNum">    2438 </span><span class="lineCov">        565 :     {</span>
<span class="lineNum">    2439 </span>            :     case CPP_STRING:
<span class="lineNum">    2440 </span><span class="lineCov">        565 :     case CPP_STRING16:</span>
<span class="lineNum">    2441 </span><span class="lineCov">        565 :     case CPP_STRING32:</span>
<span class="lineNum">    2442 </span><span class="lineCov">        565 :     case CPP_WSTRING:</span>
<span class="lineNum">    2443 </span><span class="lineCov">        562 :     case CPP_UTF8STRING:</span>
<span class="lineNum">    2444 </span>            :       string = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    2445 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    2446 </span><span class="lineCov">          3 :       parser-&gt;lex_untranslated_string = false;</span>
<span class="lineNum">    2447 </span>            :       break;
<span class="lineNum">    2448 </span><span class="lineCov">        565 :     default:</span>
<span class="lineNum">    2449 </span><span class="lineCov">       1130 :       c_parser_error (parser, &quot;expected string literal&quot;);</span>
<span class="lineNum">    2450 </span><span class="lineCov">        565 :       parser-&gt;lex_untranslated_string = false;</span>
<span class="lineNum">    2451 </span><span class="lineCov">         11 :       return;</span>
<span class="lineNum">    2452 </span><span class="lineCov">        564 :     }</span>
<span class="lineNum">    2453 </span><span class="lineCov">        564 :   parens.require_close (parser);</span>
<span class="lineNum">    2454 </span><span class="lineCov">        564 : </span>
<span class="lineNum">    2455 </span><span class="lineCov">        564 :   if (!INTEGRAL_TYPE_P (TREE_TYPE (value)))</span>
<span class="lineNum">    2456 </span><span class="lineCov">        564 :     {</span>
<span class="lineNum">    2457 </span>            :       error_at (value_loc, &quot;expression in static assertion is not an integer&quot;);
<span class="lineNum">    2458 </span><span class="lineCov">          1 :       return;</span>
<span class="lineNum">    2459 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    2460 </span>            :   if (TREE_CODE (value) != INTEGER_CST)
<span class="lineNum">    2461 </span><span class="lineCov">        563 :     {</span>
<span class="lineNum">    2462 </span>            :       value = c_fully_fold (value, false, NULL);
<span class="lineNum">    2463 </span><span class="lineCov">        560 :       /* Strip no-op conversions.  */</span>
<span class="lineNum">    2464 </span><span class="lineCov">        560 :       STRIP_TYPE_NOPS (value);</span>
<span class="lineNum">    2465 </span><span class="lineCov">        560 :       if (TREE_CODE (value) == INTEGER_CST)</span>
<span class="lineNum">    2466 </span><span class="lineCov">        560 :         pedwarn (value_loc, OPT_Wpedantic, &quot;expression in static assertion &quot;</span>
<span class="lineNum">    2467 </span><span class="lineCov">        560 :                  &quot;is not an integer constant expression&quot;);</span>
<span class="lineNum">    2468 </span><span class="lineCov">        560 :     }</span>
<span class="lineNum">    2469 </span><span class="lineCov">        560 :   if (TREE_CODE (value) != INTEGER_CST)</span>
<span class="lineNum">    2470 </span><span class="lineCov">        560 :     {</span>
<span class="lineNum">    2471 </span><span class="lineCov">        560 :       error_at (value_loc, &quot;expression in static assertion is not constant&quot;);</span>
<span class="lineNum">    2472 </span><span class="lineCov">          3 :       return;</span>
<span class="lineNum">    2473 </span><span class="lineCov">          3 :     }</span>
<span class="lineNum">    2474 </span><span class="lineCov">          3 :   constant_expression_warning (value);</span>
<span class="lineNum">    2475 </span><span class="lineCov">          3 :   if (integer_zerop (value))</span>
<span class="lineNum">    2476 </span>            :     error_at (assert_loc, &quot;static assertion failed: %E&quot;, string);
<span class="lineNum">    2477 </span><span class="lineCov">        560 : }</span>
<span class="lineNum">    2478 </span>            : 
<span class="lineNum">    2479 </span><span class="lineCov">        560 : /* Parse some declaration specifiers (possibly none) (C90 6.5, C99</span>
<span class="lineNum">    2480 </span>            :    6.7, C11 6.7), adding them to SPECS (which may already include some).
<span class="lineNum">    2481 </span><span class="lineCov">          2 :    Storage class specifiers are accepted iff SCSPEC_OK; type</span>
<span class="lineNum">    2482 </span><span class="lineCov">          2 :    specifiers are accepted iff TYPESPEC_OK; alignment specifiers are</span>
<span class="lineNum">    2483 </span>            :    accepted iff ALIGNSPEC_OK; attributes are accepted at the start
<span class="lineNum">    2484 </span><span class="lineCov">        558 :    iff START_ATTR_OK; __auto_type is accepted iff AUTO_TYPE_OK.</span>
<span class="lineNum">    2485 </span>            : 
<span class="lineNum">    2486 </span><span class="lineCov">          9 :    declaration-specifiers:</span>
<span class="lineNum">    2487 </span>            :      storage-class-specifier declaration-specifiers[opt]
<span class="lineNum">    2488 </span><span class="lineCov">          9 :      type-specifier declaration-specifiers[opt]</span>
<span class="lineNum">    2489 </span><span class="lineCov">          9 :      type-qualifier declaration-specifiers[opt]</span>
<span class="lineNum">    2490 </span><span class="lineCov">          5 :      function-specifier declaration-specifiers[opt]</span>
<span class="lineNum">    2491 </span>            :      alignment-specifier declaration-specifiers[opt]
<span class="lineNum">    2492 </span>            : 
<span class="lineNum">    2493 </span><span class="lineCov">        558 :    Function specifiers (inline) are from C99, and are currently</span>
<span class="lineNum">    2494 </span>            :    handled as storage class specifiers, as is __thread.  Alignment
<span class="lineNum">    2495 </span><span class="lineCov">          4 :    specifiers are from C11.</span>
<span class="lineNum">    2496 </span><span class="lineCov">          4 : </span>
<span class="lineNum">    2497 </span>            :    C90 6.5.1, C99 6.7.1, C11 6.7.1:
<span class="lineNum">    2498 </span><span class="lineCov">        554 :    storage-class-specifier:</span>
<span class="lineNum">    2499 </span><span class="lineCov">        554 :      typedef</span>
<span class="lineNum">    2500 </span><span class="lineCov">          8 :      extern</span>
<span class="lineNum">    2501 </span>            :      static
<span class="lineNum">    2502 </span>            :      auto
<span class="lineNum">    2503 </span>            :      register
<span class="lineNum">    2504 </span>            :      _Thread_local
<span class="lineNum">    2505 </span>            : 
<span class="lineNum">    2506 </span>            :    (_Thread_local is new in C11.)
<span class="lineNum">    2507 </span>            : 
<span class="lineNum">    2508 </span>            :    C99 6.7.4, C11 6.7.4:
<span class="lineNum">    2509 </span>            :    function-specifier:
<span class="lineNum">    2510 </span>            :      inline
<span class="lineNum">    2511 </span>            :      _Noreturn
<span class="lineNum">    2512 </span>            : 
<span class="lineNum">    2513 </span>            :    (_Noreturn is new in C11.)
<span class="lineNum">    2514 </span>            : 
<span class="lineNum">    2515 </span>            :    C90 6.5.2, C99 6.7.2, C11 6.7.2:
<span class="lineNum">    2516 </span>            :    type-specifier:
<span class="lineNum">    2517 </span>            :      void
<span class="lineNum">    2518 </span>            :      char
<span class="lineNum">    2519 </span>            :      short
<span class="lineNum">    2520 </span>            :      int
<span class="lineNum">    2521 </span>            :      long
<span class="lineNum">    2522 </span>            :      float
<span class="lineNum">    2523 </span>            :      double
<span class="lineNum">    2524 </span>            :      signed
<span class="lineNum">    2525 </span>            :      unsigned
<span class="lineNum">    2526 </span>            :      _Bool
<span class="lineNum">    2527 </span>            :      _Complex
<span class="lineNum">    2528 </span>            :      [_Imaginary removed in C99 TC2]
<span class="lineNum">    2529 </span>            :      struct-or-union-specifier
<span class="lineNum">    2530 </span>            :      enum-specifier
<span class="lineNum">    2531 </span>            :      typedef-name
<span class="lineNum">    2532 </span>            :      atomic-type-specifier
<span class="lineNum">    2533 </span>            : 
<span class="lineNum">    2534 </span>            :    (_Bool and _Complex are new in C99.)
<span class="lineNum">    2535 </span>            :    (atomic-type-specifier is new in C11.)
<span class="lineNum">    2536 </span>            : 
<span class="lineNum">    2537 </span>            :    C90 6.5.3, C99 6.7.3, C11 6.7.3:
<span class="lineNum">    2538 </span>            : 
<span class="lineNum">    2539 </span>            :    type-qualifier:
<span class="lineNum">    2540 </span>            :      const
<span class="lineNum">    2541 </span>            :      restrict
<span class="lineNum">    2542 </span>            :      volatile
<span class="lineNum">    2543 </span>            :      address-space-qualifier
<span class="lineNum">    2544 </span>            :      _Atomic
<span class="lineNum">    2545 </span>            : 
<span class="lineNum">    2546 </span>            :    (restrict is new in C99.)
<span class="lineNum">    2547 </span>            :    (_Atomic is new in C11.)
<span class="lineNum">    2548 </span>            : 
<span class="lineNum">    2549 </span>            :    GNU extensions:
<span class="lineNum">    2550 </span>            : 
<span class="lineNum">    2551 </span>            :    declaration-specifiers:
<span class="lineNum">    2552 </span>            :      attributes declaration-specifiers[opt]
<span class="lineNum">    2553 </span>            : 
<span class="lineNum">    2554 </span>            :    type-qualifier:
<span class="lineNum">    2555 </span>            :      address-space
<span class="lineNum">    2556 </span>            : 
<span class="lineNum">    2557 </span>            :    address-space:
<span class="lineNum">    2558 </span>            :      identifier recognized by the target
<span class="lineNum">    2559 </span>            : 
<span class="lineNum">    2560 </span>            :    storage-class-specifier:
<span class="lineNum">    2561 </span>            :      __thread
<span class="lineNum">    2562 </span>            : 
<span class="lineNum">    2563 </span>            :    type-specifier:
<span class="lineNum">    2564 </span>            :      typeof-specifier
<span class="lineNum">    2565 </span>            :      __auto_type
<span class="lineNum">    2566 </span>            :      __intN
<span class="lineNum">    2567 </span>            :      _Decimal32
<span class="lineNum">    2568 </span>            :      _Decimal64
<span class="lineNum">    2569 </span>            :      _Decimal128
<span class="lineNum">    2570 </span>            :      _Fract
<span class="lineNum">    2571 </span>            :      _Accum
<span class="lineNum">    2572 </span>            :      _Sat
<span class="lineNum">    2573 </span>            : 
<span class="lineNum">    2574 </span>            :   (_Fract, _Accum, and _Sat are new from ISO/IEC DTR 18037:
<span class="lineNum">    2575 </span>            :    http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1169.pdf)
<span class="lineNum">    2576 </span>            : 
<span class="lineNum">    2577 </span>            :    atomic-type-specifier
<span class="lineNum">    2578 </span>            :     _Atomic ( type-name )
<span class="lineNum">    2579 </span>            : 
<span class="lineNum">    2580 </span>            :    Objective-C:
<span class="lineNum">    2581 </span>            : 
<span class="lineNum">    2582 </span>            :    type-specifier:
<span class="lineNum">    2583 </span>            :      class-name objc-protocol-refs[opt]
<span class="lineNum">    2584 </span>            :      typedef-name objc-protocol-refs
<span class="lineNum">    2585 </span>            :      objc-protocol-refs
<span class="lineNum">    2586 </span>            : */
<a name="2587"><span class="lineNum">    2587 </span>            : </a>
<span class="lineNum">    2588 </span>            : void
<span class="lineNum">    2589 </span>            : c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,
<span class="lineNum">    2590 </span>            :                     bool scspec_ok, bool typespec_ok, bool start_attr_ok,
<span class="lineNum">    2591 </span>            :                     bool alignspec_ok, bool auto_type_ok,
<span class="lineNum">    2592 </span>            :                     enum c_lookahead_kind la)
<span class="lineNum">    2593 </span>            : {
<span class="lineNum">    2594 </span>            :   bool attrs_ok = start_attr_ok;
<span class="lineNum">    2595 </span>            :   bool seen_type = specs-&gt;typespec_kind != ctsk_none;
<span class="lineNum">    2596 </span>            : 
<span class="lineNum">    2597 </span>            :   if (!typespec_ok)
<span class="lineNum">    2598 </span>            :     gcc_assert (la == cla_prefer_id);
<span class="lineNum">    2599 </span>            : 
<span class="lineNum">    2600 </span>            :   while (c_parser_next_token_is (parser, CPP_NAME)
<span class="lineNum">    2601 </span>            :          || c_parser_next_token_is (parser, CPP_KEYWORD)
<span class="lineNum">    2602 </span>            :          || (c_dialect_objc () &amp;&amp; c_parser_next_token_is (parser, CPP_LESS)))
<span class="lineNum">    2603 </span>            :     {
<span class="lineNum">    2604 </span>            :       struct c_typespec t;
<span class="lineNum">    2605 </span>            :       tree attrs;
<span class="lineNum">    2606 </span>            :       tree align;
<span class="lineNum">    2607 </span>            :       location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    2608 </span>            : 
<span class="lineNum">    2609 </span>            :       /* If we cannot accept a type, exit if the next token must start
<span class="lineNum">    2610 </span>            :          one.  Also, if we already have seen a tagged definition,
<span class="lineNum">    2611 </span>            :          a typename would be an error anyway and likely the user
<span class="lineNum">    2612 </span>            :          has simply forgotten a semicolon, so we exit.  */
<span class="lineNum">    2613 </span><span class="lineCov">  179223026 :       if ((!typespec_ok || specs-&gt;typespec_kind == ctsk_tagdef)</span>
<span class="lineNum">    2614 </span>            :           &amp;&amp; c_parser_next_tokens_start_typename (parser, la)
<span class="lineNum">    2615 </span>            :           &amp;&amp; !c_parser_next_token_is_qualifier (parser)
<span class="lineNum">    2616 </span>            :           &amp;&amp; !c_parser_next_token_is_keyword (parser, RID_ALIGNAS))
<span class="lineNum">    2617 </span>            :         break;
<span class="lineNum">    2618 </span><span class="lineCov">  179223026 : </span>
<span class="lineNum">    2619 </span><span class="lineCov">  179223026 :       if (c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">    2620 </span>            :         {
<span class="lineNum">    2621 </span><span class="lineCov">  179223026 :           c_token *name_token = c_parser_peek_token (parser);</span>
<span class="lineNum">    2622 </span><span class="lineCov">   11977766 :           tree value = name_token-&gt;value;</span>
<span class="lineNum">    2623 </span>            :           c_id_kind kind = name_token-&gt;id_kind;
<span class="lineNum">    2624 </span><span class="lineCov">  431972383 : </span>
<span class="lineNum">    2625 </span><span class="lineCov">  206444463 :           if (kind == C_ID_ADDRSPACE)</span>
<span class="lineNum">    2626 </span><span class="lineCov">  512287784 :             {</span>
<span class="lineNum">    2627 </span>            :               addr_space_t as
<span class="lineNum">    2628 </span><span class="lineCov">  351656982 :                 = name_token-&gt;keyword - RID_FIRST_ADDR_SPACE;</span>
<span class="lineNum">    2629 </span><span class="lineCov">  351656982 :               declspecs_add_addrspace (name_token-&gt;location, specs, as);</span>
<span class="lineNum">    2630 </span><span class="lineCov">  351656982 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    2631 </span><span class="lineCov">  351656982 :               attrs_ok = true;</span>
<span class="lineNum">    2632 </span>            :               continue;
<span class="lineNum">    2633 </span>            :             }
<span class="lineNum">    2634 </span>            : 
<span class="lineNum">    2635 </span>            :           gcc_assert (!c_parser_next_token_is_qualifier (parser));
<span class="lineNum">    2636 </span>            : 
<span class="lineNum">    2637 </span><span class="lineCov">  341763393 :           /* If we cannot accept a type, and the next token must start one,</span>
<span class="lineNum">    2638 </span><span class="lineCov">   10438230 :              exit.  Do the same if we already have seen a tagged definition,</span>
<span class="lineNum">    2639 </span><span class="lineCov">    4966806 :              since it would be an error anyway and likely the user has simply</span>
<span class="lineNum">    2640 </span><span class="lineCov">  351657023 :              forgotten a semicolon.  */</span>
<span class="lineNum">    2641 </span>            :           if (seen_type || !c_parser_next_tokens_start_typename (parser, la))
<span class="lineNum">    2642 </span>            :             break;
<span class="lineNum">    2643 </span><span class="lineCov">  351656950 : </span>
<span class="lineNum">    2644 </span>            :           /* Now at an unknown typename (C_ID_ID), a C_ID_TYPENAME or
<span class="lineNum">    2645 </span><span class="lineCov">  225527897 :              a C_ID_CLASSNAME.  */</span>
<span class="lineNum">    2646 </span><span class="lineCov">  225527897 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    2647 </span><span class="lineCov">  225527897 :           seen_type = true;</span>
<span class="lineNum">    2648 </span>            :           attrs_ok = true;
<span class="lineNum">    2649 </span><span class="lineCov">  225527897 :           if (kind == C_ID_ID)</span>
<span class="lineNum">    2650 </span>            :             {
<span class="lineNum">    2651 </span><span class="lineCov">         56 :               error_at (loc, &quot;unknown type name %qE&quot;, value);</span>
<span class="lineNum">    2652 </span><span class="lineCov">         28 :               t.kind = ctsk_typedef;</span>
<span class="lineNum">    2653 </span><span class="lineCov">         28 :               t.spec = error_mark_node;</span>
<span class="lineNum">    2654 </span><span class="lineCov">         28 :             }</span>
<span class="lineNum">    2655 </span><span class="lineCov">         28 :           else if (kind == C_ID_TYPENAME</span>
<span class="lineNum">    2656 </span><span class="lineCov">  126621558 :                    &amp;&amp; (!c_dialect_objc ()</span>
<span class="lineNum">    2657 </span>            :                        || c_parser_next_token_is_not (parser, CPP_LESS)))
<span class="lineNum">    2658 </span>            :             {
<span class="lineNum">    2659 </span><span class="lineCov">  451055738 :               t.kind = ctsk_typedef;</span>
<span class="lineNum">    2660 </span>            :               /* For a typedef name, record the meaning, not the name.
<span class="lineNum">    2661 </span>            :                  In case of 'foo foo, bar;'.  */
<span class="lineNum">    2662 </span>            :               t.spec = lookup_name (value);
<span class="lineNum">    2663 </span>            :             }
<span class="lineNum">    2664 </span>            :           else
<span class="lineNum">    2665 </span><span class="lineCov">  225527869 :             {</span>
<span class="lineNum">    2666 </span>            :               tree proto = NULL_TREE;
<span class="lineNum">    2667 </span>            :               gcc_assert (c_dialect_objc ());
<span class="lineNum">    2668 </span>            :               t.kind = ctsk_objc;
<span class="lineNum">    2669 </span>            :               if (c_parser_next_token_is (parser, CPP_LESS))
<span class="lineNum">    2670 </span><span class="lineCov">  126621530 :                 proto = c_parser_objc_protocol_refs (parser);</span>
<span class="lineNum">    2671 </span><span class="lineCov">  126621530 :               t.spec = objc_get_protocol_qualified_type (value, proto);</span>
<span class="lineNum">    2672 </span><span class="lineCov">  126621530 :             }</span>
<span class="lineNum">    2673 </span><span class="lineCov">  126621530 :           t.expr = NULL_TREE;</span>
<span class="lineNum">    2674 </span>            :           t.expr_const_operands = true;
<span class="lineNum">    2675 </span><span class="lineCov">         43 :           declspecs_add_type (name_token-&gt;location, specs, t);</span>
<span class="lineNum">    2676 </span><span class="lineCov">         43 :           continue;</span>
<span class="lineNum">    2677 </span><span class="lineCov">         43 :         }</span>
<span class="lineNum">    2678 </span>            :       if (c_parser_next_token_is (parser, CPP_LESS))
<span class="lineNum">    2679 </span><span class="lineCov">  126621487 :         {</span>
<span class="lineNum">    2680 </span><span class="lineCov">  126621487 :           /* Make &quot;&lt;SomeProtocol&gt;&quot; equivalent to &quot;id &lt;SomeProtocol&gt;&quot; -</span>
<span class="lineNum">    2681 </span><span class="lineNoCov">          0 :              nisse@lysator.liu.se.  */</span>
<span class="lineNum">    2682 </span>            :           tree proto;
<span class="lineNum">    2683 </span><span class="lineCov">  126621487 :           gcc_assert (c_dialect_objc ());</span>
<span class="lineNum">    2684 </span>            :           if (!typespec_ok || seen_type)
<span class="lineNum">    2685 </span>            :             break;
<span class="lineNum">    2686 </span><span class="lineCov">  126621487 :           proto = c_parser_objc_protocol_refs (parser);</span>
<span class="lineNum">    2687 </span>            :           t.kind = ctsk_objc;
<span class="lineNum">    2688 </span>            :           t.spec = objc_get_protocol_qualified_type (NULL_TREE, proto);
<span class="lineNum">    2689 </span>            :           t.expr = NULL_TREE;
<span class="lineNum">    2690 </span><span class="lineNoCov">          0 :           t.expr_const_operands = true;</span>
<span class="lineNum">    2691 </span><span class="lineNoCov">          0 :           declspecs_add_type (loc, specs, t);</span>
<span class="lineNum">    2692 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">    2693 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2694 </span><span class="lineNoCov">          0 :       gcc_assert (c_parser_next_token_is (parser, CPP_KEYWORD));</span>
<span class="lineNum">    2695 </span><span class="lineNoCov">          0 :       switch (c_parser_peek_token (parser)-&gt;keyword)</span>
<span class="lineNum">    2696 </span>            :         {
<span class="lineNum">    2697 </span><span class="lineCov">  126621530 :         case RID_STATIC:</span>
<span class="lineNum">    2698 </span><span class="lineCov">  126621530 :         case RID_EXTERN:</span>
<span class="lineNum">    2699 </span><span class="lineCov">  126621530 :         case RID_REGISTER:</span>
<span class="lineNum">    2700 </span><span class="lineCov">  126621530 :         case RID_TYPEDEF:</span>
<span class="lineNum">    2701 </span>            :         case RID_INLINE:
<span class="lineNum">    2702 </span><span class="lineCov">  126129053 :         case RID_NORETURN:</span>
<span class="lineNum">    2703 </span>            :         case RID_AUTO:
<span class="lineNum">    2704 </span>            :         case RID_THREAD:
<span class="lineNum">    2705 </span>            :           if (!scspec_ok)
<span class="lineNum">    2706 </span><span class="lineNoCov">          0 :             goto out;</span>
<span class="lineNum">    2707 </span><span class="lineNoCov">          0 :           attrs_ok = true;</span>
<span class="lineNum">    2708 </span><span class="lineNoCov">          0 :           /* TODO: Distinguish between function specifiers (inline, noreturn)</span>
<span class="lineNum">    2709 </span>            :              and storage class specifiers, either here or in
<span class="lineNum">    2710 </span><span class="lineNoCov">          0 :              declspecs_add_scspec.  */</span>
<span class="lineNum">    2711 </span><span class="lineNoCov">          0 :           declspecs_add_scspec (loc, specs,</span>
<span class="lineNum">    2712 </span><span class="lineNoCov">          0 :                                 c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">    2713 </span><span class="lineNoCov">          0 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    2714 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2715 </span><span class="lineNoCov">          0 :         case RID_AUTO_TYPE:</span>
<span class="lineNum">    2716 </span><span class="lineNoCov">          0 :           if (!auto_type_ok)</span>
<span class="lineNum">    2717 </span>            :             goto out;
<span class="lineNum">    2718 </span><span class="lineCov">  126129053 :           /* Fall through.  */</span>
<span class="lineNum">    2719 </span><span class="lineCov">  126129053 :         case RID_UNSIGNED:</span>
<span class="lineNum">    2720 </span>            :         case RID_LONG:
<span class="lineNum">    2721 </span><span class="lineCov">   47888795 :         case RID_SHORT:</span>
<span class="lineNum">    2722 </span><span class="lineCov">   47888795 :         case RID_SIGNED:</span>
<span class="lineNum">    2723 </span><span class="lineCov">   47888795 :         case RID_COMPLEX:</span>
<span class="lineNum">    2724 </span><span class="lineCov">   47888795 :         case RID_INT:</span>
<span class="lineNum">    2725 </span><span class="lineCov">   47888795 :         case RID_CHAR:</span>
<span class="lineNum">    2726 </span><span class="lineCov">   47888795 :         case RID_FLOAT:</span>
<span class="lineNum">    2727 </span><span class="lineCov">   47888795 :         case RID_DOUBLE:</span>
<span class="lineNum">    2728 </span><span class="lineCov">   47888795 :         case RID_VOID:</span>
<span class="lineNum">    2729 </span><span class="lineCov">   47888795 :         case RID_DFLOAT32:</span>
<span class="lineNum">    2730 </span><span class="lineCov">       1254 :         case RID_DFLOAT64:</span>
<span class="lineNum">    2731 </span><span class="lineCov">   47888761 :         case RID_DFLOAT128:</span>
<span class="lineNum">    2732 </span>            :         CASE_RID_FLOATN_NX:
<span class="lineNum">    2733 </span>            :         case RID_BOOL:
<span class="lineNum">    2734 </span>            :         case RID_FRACT:
<span class="lineNum">    2735 </span><span class="lineCov">   47888761 :         case RID_ACCUM:</span>
<span class="lineNum">    2736 </span><span class="lineCov">   47888761 :         case RID_SAT:</span>
<span class="lineNum">    2737 </span><span class="lineCov">   47888761 :         case RID_INT_N_0:</span>
<span class="lineNum">    2738 </span><span class="lineCov">   47888761 :         case RID_INT_N_1:</span>
<span class="lineNum">    2739 </span><span class="lineCov">       1386 :         case RID_INT_N_2:</span>
<span class="lineNum">    2740 </span><span class="lineCov">       1386 :         case RID_INT_N_3:</span>
<span class="lineNum">    2741 </span>            :           if (!typespec_ok)
<span class="lineNum">    2742 </span>            :             goto out;
<span class="lineNum">    2743 </span><span class="lineCov">   48447202 :           attrs_ok = true;</span>
<span class="lineNum">    2744 </span><span class="lineCov">   48447202 :           seen_type = true;</span>
<span class="lineNum">    2745 </span><span class="lineCov">   48447202 :           if (c_dialect_objc ())</span>
<span class="lineNum">    2746 </span><span class="lineCov">   48447202 :             parser-&gt;objc_need_raw_identifier = true;</span>
<span class="lineNum">    2747 </span><span class="lineCov">   48447202 :           t.kind = ctsk_resword;</span>
<span class="lineNum">    2748 </span><span class="lineCov">   48447202 :           t.spec = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">    2749 </span><span class="lineCov">   48447202 :           t.expr = NULL_TREE;</span>
<span class="lineNum">    2750 </span><span class="lineCov">   48447202 :           t.expr_const_operands = true;</span>
<span class="lineNum">    2751 </span><span class="lineCov">   48447202 :           declspecs_add_type (loc, specs, t);</span>
<span class="lineNum">    2752 </span><span class="lineCov">   48447202 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    2753 </span><span class="lineCov">   48447202 :           break;</span>
<span class="lineNum">    2754 </span><span class="lineCov">   48447202 :         case RID_ENUM:</span>
<span class="lineNum">    2755 </span><span class="lineCov">   48447202 :           if (!typespec_ok)</span>
<span class="lineNum">    2756 </span><span class="lineCov">   48447202 :             goto out;</span>
<span class="lineNum">    2757 </span><span class="lineCov">   48447202 :           attrs_ok = true;</span>
<span class="lineNum">    2758 </span><span class="lineCov">   48447202 :           seen_type = true;</span>
<span class="lineNum">    2759 </span><span class="lineCov">   48447202 :           t = c_parser_enum_specifier (parser);</span>
<span class="lineNum">    2760 </span><span class="lineCov">   48447202 :           invoke_plugin_callbacks (PLUGIN_FINISH_TYPE, t.spec);</span>
<span class="lineNum">    2761 </span><span class="lineCov">   48447202 :           declspecs_add_type (loc, specs, t);</span>
<span class="lineNum">    2762 </span><span class="lineCov">   48447202 :           break;</span>
<span class="lineNum">    2763 </span><span class="lineCov">   48447202 :         case RID_STRUCT:</span>
<span class="lineNum">    2764 </span><span class="lineCov">   48447202 :         case RID_UNION:</span>
<span class="lineNum">    2765 </span><span class="lineCov">   48447202 :           if (!typespec_ok)</span>
<span class="lineNum">    2766 </span>            :             goto out;
<span class="lineNum">    2767 </span><span class="lineCov">   48447202 :           attrs_ok = true;</span>
<span class="lineNum">    2768 </span><span class="lineCov">   48447202 :           seen_type = true;</span>
<span class="lineNum">    2769 </span><span class="lineCov">   48447202 :           t = c_parser_struct_or_union_specifier (parser);</span>
<span class="lineNum">    2770 </span><span class="lineNoCov">          0 :           invoke_plugin_callbacks (PLUGIN_FINISH_TYPE, t.spec);</span>
<span class="lineNum">    2771 </span><span class="lineCov">   48447202 :           declspecs_add_type (loc, specs, t);</span>
<span class="lineNum">    2772 </span><span class="lineCov">   48447202 :           break;</span>
<span class="lineNum">    2773 </span><span class="lineCov">   48447202 :         case RID_TYPEOF:</span>
<span class="lineNum">    2774 </span><span class="lineCov">   48447202 :           /* ??? The old parser rejected typeof after other type</span>
<span class="lineNum">    2775 </span><span class="lineCov">   48447202 :              specifiers, but is a syntax error the best way of</span>
<span class="lineNum">    2776 </span><span class="lineCov">   48447202 :              handling this?  */</span>
<span class="lineNum">    2777 </span><span class="lineCov">   48447202 :           if (!typespec_ok || seen_type)</span>
<span class="lineNum">    2778 </span><span class="lineCov">     175438 :             goto out;</span>
<span class="lineNum">    2779 </span><span class="lineCov">     175438 :           attrs_ok = true;</span>
<span class="lineNum">    2780 </span>            :           seen_type = true;
<span class="lineNum">    2781 </span><span class="lineCov">     175438 :           t = c_parser_typeof_specifier (parser);</span>
<span class="lineNum">    2782 </span><span class="lineCov">     175438 :           declspecs_add_type (loc, specs, t);</span>
<span class="lineNum">    2783 </span><span class="lineCov">     175438 :           break;</span>
<span class="lineNum">    2784 </span><span class="lineCov">     175438 :         case RID_ATOMIC:</span>
<span class="lineNum">    2785 </span><span class="lineCov">     175438 :           /* C parser handling of Objective-C constructs needs</span>
<span class="lineNum">    2786 </span><span class="lineCov">     175438 :              checking for correct lvalue-to-rvalue conversions, and</span>
<span class="lineNum">    2787 </span><span class="lineCov">    1514585 :              the code in build_modify_expr handling various</span>
<span class="lineNum">    2788 </span><span class="lineCov">    1514585 :              Objective-C cases, and that in build_unary_op handling</span>
<span class="lineNum">    2789 </span><span class="lineCov">    1514585 :              Objective-C cases for increment / decrement, also needs</span>
<span class="lineNum">    2790 </span>            :              updating; uses of TYPE_MAIN_VARIANT in objc_compare_types
<span class="lineNum">    2791 </span><span class="lineCov">    1514585 :              and objc_types_are_equivalent may also need updates.  */</span>
<span class="lineNum">    2792 </span><span class="lineCov">    1514585 :           if (c_dialect_objc ())</span>
<span class="lineNum">    2793 </span><span class="lineCov">    1514585 :             sorry (&quot;%&lt;_Atomic%&gt; in Objective-C&quot;);</span>
<span class="lineNum">    2794 </span><span class="lineCov">    1514585 :           if (flag_isoc99)</span>
<span class="lineNum">    2795 </span><span class="lineCov">    1514585 :             pedwarn_c99 (loc, OPT_Wpedantic,</span>
<span class="lineNum">    2796 </span><span class="lineCov">    1514585 :                          &quot;ISO C99 does not support the %&lt;_Atomic%&gt; qualifier&quot;);</span>
<span class="lineNum">    2797 </span><span class="lineCov">     760049 :           else</span>
<span class="lineNum">    2798 </span>            :             pedwarn_c99 (loc, OPT_Wpedantic,
<span class="lineNum">    2799 </span>            :                          &quot;ISO C90 does not support the %&lt;_Atomic%&gt; qualifier&quot;);
<span class="lineNum">    2800 </span>            :           attrs_ok = true;
<span class="lineNum">    2801 </span><span class="lineCov">     760049 :           tree value;</span>
<span class="lineNum">    2802 </span>            :           value = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    2803 </span><span class="lineCov">     760047 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    2804 </span><span class="lineCov">     760047 :           if (typespec_ok &amp;&amp; c_parser_next_token_is (parser, CPP_OPEN_PAREN))</span>
<span class="lineNum">    2805 </span><span class="lineCov">     760047 :             {</span>
<span class="lineNum">    2806 </span><span class="lineCov">     760047 :               /* _Atomic ( type-name ).  */</span>
<span class="lineNum">    2807 </span><span class="lineCov">     760047 :               seen_type = true;</span>
<span class="lineNum">    2808 </span><span class="lineCov">      29224 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    2809 </span>            :               struct c_type_name *type = c_parser_type_name (parser);
<span class="lineNum">    2810 </span>            :               t.kind = ctsk_typeof;
<span class="lineNum">    2811 </span>            :               t.spec = error_mark_node;
<span class="lineNum">    2812 </span>            :               t.expr = NULL_TREE;
<span class="lineNum">    2813 </span>            :               t.expr_const_operands = true;
<span class="lineNum">    2814 </span>            :               if (type != NULL)
<span class="lineNum">    2815 </span>            :                 t.spec = groktypename (type, &amp;t.expr,
<span class="lineNum">    2816 </span><span class="lineCov">      29224 :                                        &amp;t.expr_const_operands);</span>
<span class="lineNum">    2817 </span><span class="lineNoCov">          0 :               c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,</span>
<span class="lineNum">    2818 </span><span class="lineCov">      29224 :                                          &quot;expected %&lt;)%&gt;&quot;);</span>
<span class="lineNum">    2819 </span><span class="lineCov">      29181 :               if (t.spec != error_mark_node)</span>
<span class="lineNum">    2820 </span>            :                 {
<span class="lineNum">    2821 </span>            :                   if (TREE_CODE (t.spec) == ARRAY_TYPE)
<span class="lineNum">    2822 </span><span class="lineCov">         43 :                     error_at (loc, &quot;%&lt;_Atomic%&gt;-qualified array type&quot;);</span>
<span class="lineNum">    2823 </span>            :                   else if (TREE_CODE (t.spec) == FUNCTION_TYPE)
<span class="lineNum">    2824 </span><span class="lineCov">      29224 :                     error_at (loc, &quot;%&lt;_Atomic%&gt;-qualified function type&quot;);</span>
<span class="lineNum">    2825 </span><span class="lineCov">      29224 :                   else if (TYPE_QUALS (t.spec) != TYPE_UNQUALIFIED)</span>
<span class="lineNum">    2826 </span><span class="lineCov">      29224 :                     error_at (loc, &quot;%&lt;_Atomic%&gt; applied to a qualified type&quot;);</span>
<span class="lineNum">    2827 </span><span class="lineCov">      29224 :                   else</span>
<span class="lineNum">    2828 </span><span class="lineCov">      29224 :                     t.spec = c_build_qualified_type (t.spec, TYPE_QUAL_ATOMIC);</span>
<span class="lineNum">    2829 </span>            :                 }
<span class="lineNum">    2830 </span>            :               declspecs_add_type (loc, specs, t);
<span class="lineNum">    2831 </span><span class="lineCov">      13420 :             }</span>
<span class="lineNum">    2832 </span><span class="lineCov">      13420 :           else</span>
<span class="lineNum">    2833 </span><span class="lineCov">      13420 :             declspecs_add_qual (loc, specs, value);</span>
<span class="lineNum">    2834 </span><span class="lineCov">      13420 :           break;</span>
<span class="lineNum">    2835 </span><span class="lineCov">      13420 :         case RID_CONST:</span>
<span class="lineNum">    2836 </span><span class="lineCov">      13420 :         case RID_VOLATILE:</span>
<span class="lineNum">    2837 </span><span class="lineCov">      13420 :         case RID_RESTRICT:</span>
<span class="lineNum">    2838 </span><span class="lineCov">      13420 :           attrs_ok = true;</span>
<span class="lineNum">    2839 </span><span class="lineCov">      13419 :           declspecs_add_qual (loc, specs, c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">    2840 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    2841 </span><span class="lineCov">      13420 :           break;</span>
<span class="lineNum">    2842 </span>            :         case RID_ATTRIBUTE:
<span class="lineNum">    2843 </span><span class="lineCov">      13420 :           if (!attrs_ok)</span>
<span class="lineNum">    2844 </span>            :             goto out;
<span class="lineNum">    2845 </span><span class="lineCov">      13419 :           attrs = c_parser_attributes (parser);</span>
<span class="lineNum">    2846 </span><span class="lineCov">          1 :           declspecs_add_attrs (loc, specs, attrs);</span>
<span class="lineNum">    2847 </span><span class="lineCov">      13418 :           break;</span>
<span class="lineNum">    2848 </span><span class="lineCov">          1 :         case RID_ALIGNAS:</span>
<span class="lineNum">    2849 </span><span class="lineCov">      13417 :           if (!alignspec_ok)</span>
<span class="lineNum">    2850 </span><span class="lineCov">          4 :             goto out;</span>
<span class="lineNum">    2851 </span>            :           align = c_parser_alignas_specifier (parser);
<span class="lineNum">    2852 </span><span class="lineCov">      13413 :           declspecs_add_alignas (loc, specs, align);</span>
<span class="lineNum">    2853 </span>            :           break;
<span class="lineNum">    2854 </span><span class="lineCov">      13420 :         case RID_GIMPLE:</span>
<span class="lineNum">    2855 </span>            :           if (! flag_gimple)
<span class="lineNum">    2856 </span>            :             error_at (loc, &quot;%&lt;__GIMPLE%&gt; only valid with -fgimple&quot;);
<span class="lineNum">    2857 </span><span class="lineCov">      15804 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    2858 </span>            :           specs-&gt;gimple_p = true;
<span class="lineNum">    2859 </span><span class="lineCov">    9363042 :           specs-&gt;locations[cdw_gimple] = loc;</span>
<span class="lineNum">    2860 </span><span class="lineCov">    9363042 :           specs-&gt;gimple_or_rtl_pass = c_parser_gimple_or_rtl_pass_list (parser);</span>
<span class="lineNum">    2861 </span><span class="lineCov">    9363042 :           break;</span>
<span class="lineNum">    2862 </span><span class="lineCov">    9363042 :         case RID_RTL:</span>
<span class="lineNum">    2863 </span><span class="lineCov">    9363042 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    2864 </span><span class="lineCov">    9363042 :           specs-&gt;rtl_p = true;</span>
<span class="lineNum">    2865 </span><span class="lineCov">    9363042 :           specs-&gt;locations[cdw_rtl] = loc;</span>
<span class="lineNum">    2866 </span><span class="lineCov">   17949269 :           specs-&gt;gimple_or_rtl_pass = c_parser_gimple_or_rtl_pass_list (parser);</span>
<span class="lineNum">    2867 </span><span class="lineCov">   17949269 :           break;</span>
<span class="lineNum">    2868 </span>            :         default:
<span class="lineNum">    2869 </span><span class="lineCov">   17949269 :           goto out;</span>
<span class="lineNum">    2870 </span><span class="lineCov">   17949269 :         }</span>
<span class="lineNum">    2871 </span><span class="lineCov">   17949269 :     }</span>
<span class="lineNum">    2872 </span><span class="lineCov">        176 :  out: ;</span>
<span class="lineNum">    2873 </span><span class="lineCov">        176 : }</span>
<span class="lineNum">    2874 </span>            : 
<span class="lineNum">    2875 </span><span class="lineCov">        160 : /* Parse an enum specifier (C90 6.5.2.2, C99 6.7.2.2, C11 6.7.2.2).</span>
<span class="lineNum">    2876 </span><span class="lineCov">        160 : </span>
<span class="lineNum">    2877 </span><span class="lineCov">        160 :    enum-specifier:</span>
<span class="lineNum">    2878 </span><span class="lineCov">         53 :      enum attributes[opt] identifier[opt] { enumerator-list } attributes[opt]</span>
<span class="lineNum">    2879 </span><span class="lineCov">         53 :      enum attributes[opt] identifier[opt] { enumerator-list , } attributes[opt]</span>
<span class="lineNum">    2880 </span><span class="lineNoCov">          0 :      enum attributes[opt] identifier</span>
<span class="lineNum">    2881 </span><span class="lineCov">         53 : </span>
<span class="lineNum">    2882 </span><span class="lineCov">         53 :    The form with trailing comma is new in C99.  The forms with</span>
<span class="lineNum">    2883 </span><span class="lineCov">         53 :    attributes are GNU extensions.  In GNU C, we accept any expression</span>
<span class="lineNum">    2884 </span><span class="lineCov">         53 :    without commas in the syntax (assignment expressions, not just</span>
<span class="lineNum">    2885 </span><span class="lineCov">         53 :    conditional expressions); assignment expressions will be diagnosed</span>
<span class="lineNum">    2886 </span><span class="lineCov">         18 :    as non-constant.</span>
<span class="lineNum">    2887 </span><span class="lineCov">         18 : </span>
<span class="lineNum">    2888 </span><span class="lineCov">         18 :    enumerator-list:</span>
<span class="lineNum">    2889 </span><span class="lineCov">         18 :      enumerator</span>
<span class="lineNum">    2890 </span><span class="lineCov">         18 :      enumerator-list , enumerator</span>
<span class="lineNum">    2891 </span><span class="lineCov">         18 : </span>
<span class="lineNum">    2892 </span>            :    enumerator:
<span class="lineNum">    2893 </span>            :      enumeration-constant
<span class="lineNum">    2894 </span>            :      enumeration-constant = constant-expression
<span class="lineNum">    2895 </span>            : 
<span class="lineNum">    2896 </span><span class="lineCov">  179223026 :    GNU Extensions:</span>
<span class="lineNum">    2897 </span><span class="lineCov">  179223026 : </span>
<span class="lineNum">    2898 </span>            :    enumerator:
<span class="lineNum">    2899 </span>            :      enumeration-constant attributes[opt]
<span class="lineNum">    2900 </span>            :      enumeration-constant attributes[opt] = constant-expression
<span class="lineNum">    2901 </span>            : 
<span class="lineNum">    2902 </span>            : */
<a name="2903"><span class="lineNum">    2903 </span>            : </a>
<span class="lineNum">    2904 </span>            : static struct c_typespec
<span class="lineNum">    2905 </span>            : c_parser_enum_specifier (c_parser *parser)
<span class="lineNum">    2906 </span>            : {
<span class="lineNum">    2907 </span>            :   struct c_typespec ret;
<span class="lineNum">    2908 </span>            :   tree attrs;
<span class="lineNum">    2909 </span>            :   tree ident = NULL_TREE;
<span class="lineNum">    2910 </span>            :   location_t enum_loc;
<span class="lineNum">    2911 </span>            :   location_t ident_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */
<span class="lineNum">    2912 </span>            :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ENUM));
<span class="lineNum">    2913 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    2914 </span>            :   attrs = c_parser_attributes (parser);
<span class="lineNum">    2915 </span>            :   enum_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    2916 </span>            :   /* Set the location in case we create a decl now.  */
<span class="lineNum">    2917 </span>            :   c_parser_set_source_position_from_token (c_parser_peek_token (parser));
<span class="lineNum">    2918 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">    2919 </span>            :     {
<span class="lineNum">    2920 </span>            :       ident = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    2921 </span>            :       ident_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    2922 </span>            :       enum_loc = ident_loc;
<span class="lineNum">    2923 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    2924 </span>            :     }
<span class="lineNum">    2925 </span>            :   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))
<span class="lineNum">    2926 </span>            :     {
<span class="lineNum">    2927 </span>            :       /* Parse an enum definition.  */
<span class="lineNum">    2928 </span>            :       struct c_enum_contents the_enum;
<span class="lineNum">    2929 </span><span class="lineCov">     175438 :       tree type;</span>
<span class="lineNum">    2930 </span>            :       tree postfix_attrs;
<span class="lineNum">    2931 </span><span class="lineCov">     175438 :       /* We chain the enumerators in reverse order, then put them in</span>
<span class="lineNum">    2932 </span><span class="lineCov">     175438 :          forward order at the end.  */</span>
<span class="lineNum">    2933 </span><span class="lineCov">     175438 :       tree values;</span>
<span class="lineNum">    2934 </span><span class="lineCov">     175438 :       timevar_push (TV_PARSE_ENUM);</span>
<span class="lineNum">    2935 </span><span class="lineCov">     175438 :       type = start_enum (enum_loc, &amp;the_enum, ident);</span>
<span class="lineNum">    2936 </span><span class="lineCov">     175438 :       values = NULL_TREE;</span>
<span class="lineNum">    2937 </span><span class="lineCov">     175438 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    2938 </span><span class="lineCov">     175438 :       while (true)</span>
<span class="lineNum">    2939 </span><span class="lineCov">     175438 :         {</span>
<span class="lineNum">    2940 </span>            :           tree enum_id;
<span class="lineNum">    2941 </span><span class="lineCov">     175438 :           tree enum_value;</span>
<span class="lineNum">    2942 </span><span class="lineCov">     175438 :           tree enum_decl;</span>
<span class="lineNum">    2943 </span>            :           bool seen_comma;
<span class="lineNum">    2944 </span><span class="lineCov">     111140 :           c_token *token;</span>
<span class="lineNum">    2945 </span><span class="lineCov">     111140 :           location_t comma_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */</span>
<span class="lineNum">    2946 </span><span class="lineCov">     111140 :           location_t decl_loc, value_loc;</span>
<span class="lineNum">    2947 </span><span class="lineCov">     111140 :           if (c_parser_next_token_is_not (parser, CPP_NAME))</span>
<span class="lineNum">    2948 </span>            :             {
<span class="lineNum">    2949 </span><span class="lineCov">     175438 :               /* Give a nicer error for &quot;enum {}&quot;.  */</span>
<span class="lineNum">    2950 </span>            :               if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE)
<span class="lineNum">    2951 </span>            :                   &amp;&amp; !parser-&gt;error)
<span class="lineNum">    2952 </span><span class="lineCov">     133164 :                 {</span>
<span class="lineNum">    2953 </span><span class="lineCov">     133164 :                   error_at (c_parser_peek_token (parser)-&gt;location,</span>
<span class="lineNum">    2954 </span><span class="lineCov">     133164 :                             &quot;empty enum is invalid&quot;);</span>
<span class="lineNum">    2955 </span>            :                   parser-&gt;error = true;
<span class="lineNum">    2956 </span>            :                 }
<span class="lineNum">    2957 </span><span class="lineCov">     133164 :               else</span>
<span class="lineNum">    2958 </span><span class="lineCov">     133164 :                 c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">    2959 </span><span class="lineCov">     133164 :               c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, NULL);</span>
<span class="lineNum">    2960 </span><span class="lineCov">     133164 :               values = error_mark_node;</span>
<span class="lineNum">    2961 </span><span class="lineCov">     133164 :               break;</span>
<span class="lineNum">    2962 </span><span class="lineCov">    3873803 :             }</span>
<span class="lineNum">    2963 </span>            :           token = c_parser_peek_token (parser);
<span class="lineNum">    2964 </span><span class="lineCov">    3873803 :           enum_id = token-&gt;value;</span>
<span class="lineNum">    2965 </span><span class="lineCov">    3873803 :           /* Set the location in case we create a decl now.  */</span>
<span class="lineNum">    2966 </span><span class="lineCov">    3873803 :           c_parser_set_source_position_from_token (token);</span>
<span class="lineNum">    2967 </span><span class="lineCov">    3873803 :           decl_loc = value_loc = token-&gt;location;</span>
<span class="lineNum">    2968 </span><span class="lineCov">    3873803 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    2969 </span><span class="lineCov">    3873803 :           /* Parse any specified attributes.  */</span>
<span class="lineNum">    2970 </span><span class="lineCov">    3873803 :           tree enum_attrs = c_parser_attributes (parser);</span>
<span class="lineNum">    2971 </span><span class="lineCov">    3873803 :           if (c_parser_next_token_is (parser, CPP_EQ))</span>
<span class="lineNum">    2972 </span>            :             {
<span class="lineNum">    2973 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">    2974 </span><span class="lineCov">          5 :               value_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    2975 </span><span class="lineCov">          5 :               enum_value = c_parser_expr_no_commas (parser, NULL).value;</span>
<span class="lineNum">    2976 </span>            :             }
<span class="lineNum">    2977 </span><span class="lineCov">          3 :           else</span>
<span class="lineNum">    2978 </span>            :             enum_value = NULL_TREE;
<span class="lineNum">    2979 </span><span class="lineCov">          3 :           enum_decl = build_enumerator (decl_loc, value_loc,</span>
<span class="lineNum">    2980 </span>            :                                         &amp;the_enum, enum_id, enum_value);
<span class="lineNum">    2981 </span>            :           if (enum_attrs)
<span class="lineNum">    2982 </span><span class="lineCov">          2 :             decl_attributes (&amp;TREE_PURPOSE (enum_decl), enum_attrs, 0);</span>
<span class="lineNum">    2983 </span><span class="lineCov">          5 :           TREE_CHAIN (enum_decl) = values;</span>
<span class="lineNum">    2984 </span><span class="lineCov">          5 :           values = enum_decl;</span>
<span class="lineNum">    2985 </span><span class="lineCov">          5 :           seen_comma = false;</span>
<span class="lineNum">    2986 </span>            :           if (c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">    2987 </span><span class="lineCov">    3873798 :             {</span>
<span class="lineNum">    2988 </span><span class="lineCov">    3873798 :               comma_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    2989 </span>            :               seen_comma = true;
<span class="lineNum">    2990 </span><span class="lineCov">    3873798 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    2991 </span><span class="lineCov">    3873798 :             }</span>
<span class="lineNum">    2992 </span><span class="lineCov">    3873798 :           if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))</span>
<span class="lineNum">    2993 </span>            :             {
<span class="lineNum">    2994 </span><span class="lineCov">    3873798 :               if (seen_comma)</span>
<span class="lineNum">    2995 </span><span class="lineCov">    3873798 :                 pedwarn_c90 (comma_loc, OPT_Wpedantic,</span>
<span class="lineNum">    2996 </span>            :                              &quot;comma at end of enumerator list&quot;);
<span class="lineNum">    2997 </span><span class="lineCov">    2166686 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    2998 </span><span class="lineCov">    2166686 :               break;</span>
<span class="lineNum">    2999 </span><span class="lineCov">    2166686 :             }</span>
<span class="lineNum">    3000 </span>            :           if (!seen_comma)
<span class="lineNum">    3001 </span>            :             {
<span class="lineNum">    3002 </span>            :               c_parser_error (parser, &quot;expected %&lt;,%&gt; or %&lt;}%&gt;&quot;);
<span class="lineNum">    3003 </span><span class="lineCov">    3873798 :               c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, NULL);</span>
<span class="lineNum">    3004 </span>            :               values = error_mark_node;
<span class="lineNum">    3005 </span><span class="lineCov">    3873798 :               break;</span>
<span class="lineNum">    3006 </span><span class="lineCov">         12 :             }</span>
<span class="lineNum">    3007 </span><span class="lineCov">    3873798 :         }</span>
<span class="lineNum">    3008 </span><span class="lineCov">    3873798 :       postfix_attrs = c_parser_attributes (parser);</span>
<span class="lineNum">    3009 </span><span class="lineCov">    3873798 :       ret.spec = finish_enum (type, nreverse (values),</span>
<span class="lineNum">    3010 </span><span class="lineCov">    3873798 :                               chainon (attrs, postfix_attrs));</span>
<span class="lineNum">    3011 </span>            :       ret.kind = ctsk_tagdef;
<span class="lineNum">    3012 </span><span class="lineCov">    3748222 :       ret.expr = NULL_TREE;</span>
<span class="lineNum">    3013 </span><span class="lineCov">    3748222 :       ret.expr_const_operands = true;</span>
<span class="lineNum">    3014 </span><span class="lineCov">    3748222 :       timevar_pop (TV_PARSE_ENUM);</span>
<span class="lineNum">    3015 </span>            :       return ret;
<span class="lineNum">    3016 </span><span class="lineCov">    3873798 :     }</span>
<span class="lineNum">    3017 </span>            :   else if (!ident)
<span class="lineNum">    3018 </span><span class="lineCov">     133144 :     {</span>
<span class="lineNum">    3019 </span><span class="lineCov">       7583 :       c_parser_error (parser, &quot;expected %&lt;{%&gt;&quot;);</span>
<span class="lineNum">    3020 </span>            :       ret.spec = error_mark_node;
<span class="lineNum">    3021 </span><span class="lineCov">     133144 :       ret.kind = ctsk_tagref;</span>
<span class="lineNum">    3022 </span><span class="lineCov">     133144 :       ret.expr = NULL_TREE;</span>
<span class="lineNum">    3023 </span>            :       ret.expr_const_operands = true;
<span class="lineNum">    3024 </span><span class="lineCov">    3740654 :       return ret;</span>
<span class="lineNum">    3025 </span>            :     }
<span class="lineNum">    3026 </span><span class="lineCov">         15 :   ret = parser_xref_tag (ident_loc, ENUMERAL_TYPE, ident);</span>
<span class="lineNum">    3027 </span><span class="lineCov">         15 :   /* In ISO C, enumerated types can be referred to only if already</span>
<span class="lineNum">    3028 </span><span class="lineCov">         15 :      defined.  */</span>
<span class="lineNum">    3029 </span><span class="lineCov">         15 :   if (pedantic &amp;&amp; !COMPLETE_TYPE_P (ret.spec))</span>
<span class="lineNum">    3030 </span>            :     {
<span class="lineNum">    3031 </span>            :       gcc_assert (ident);
<span class="lineNum">    3032 </span><span class="lineCov">     133164 :       pedwarn (enum_loc, OPT_Wpedantic,</span>
<span class="lineNum">    3033 </span><span class="lineCov">     133164 :                &quot;ISO C forbids forward references to %&lt;enum%&gt; types&quot;);</span>
<span class="lineNum">    3034 </span>            :     }
<span class="lineNum">    3035 </span><span class="lineCov">     133164 :   return ret;</span>
<span class="lineNum">    3036 </span><span class="lineCov">     133164 : }</span>
<span class="lineNum">    3037 </span><span class="lineCov">     133164 : </span>
<span class="lineNum">    3038 </span><span class="lineCov">     133164 : /* Parse a struct or union specifier (C90 6.5.2.1, C99 6.7.2.1, C11 6.7.2.1).</span>
<span class="lineNum">    3039 </span><span class="lineCov">     133164 : </span>
<span class="lineNum">    3040 </span>            :    struct-or-union-specifier:
<span class="lineNum">    3041 </span><span class="lineCov">      42274 :      struct-or-union attributes[opt] identifier[opt]</span>
<span class="lineNum">    3042 </span>            :        { struct-contents } attributes[opt]
<span class="lineNum">    3043 </span><span class="lineNoCov">          0 :      struct-or-union attributes[opt] identifier</span>
<span class="lineNum">    3044 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    3045 </span><span class="lineNoCov">          0 :    struct-contents:</span>
<span class="lineNum">    3046 </span><span class="lineNoCov">          0 :      struct-declaration-list</span>
<span class="lineNum">    3047 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    3048 </span><span class="lineNoCov">          0 :    struct-declaration-list:</span>
<span class="lineNum">    3049 </span>            :      struct-declaration ;
<span class="lineNum">    3050 </span><span class="lineCov">      42274 :      struct-declaration-list struct-declaration ;</span>
<span class="lineNum">    3051 </span>            : 
<span class="lineNum">    3052 </span>            :    GNU extensions:
<span class="lineNum">    3053 </span><span class="lineCov">      42274 : </span>
<span class="lineNum">    3054 </span>            :    struct-contents:
<span class="lineNum">    3055 </span><span class="lineCov">          9 :      empty</span>
<span class="lineNum">    3056 </span><span class="lineCov">          9 :      struct-declaration</span>
<span class="lineNum">    3057 </span>            :      struct-declaration-list struct-declaration
<span class="lineNum">    3058 </span>            : 
<span class="lineNum">    3059 </span>            :    struct-declaration-list:
<span class="lineNum">    3060 </span>            :      struct-declaration-list ;
<span class="lineNum">    3061 </span>            :      ;
<span class="lineNum">    3062 </span>            : 
<span class="lineNum">    3063 </span>            :    (Note that in the syntax here, unlike that in ISO C, the semicolons
<span class="lineNum">    3064 </span>            :    are included here rather than in struct-declaration, in order to
<span class="lineNum">    3065 </span>            :    describe the syntax with extra semicolons and missing semicolon at
<span class="lineNum">    3066 </span>            :    end.)
<span class="lineNum">    3067 </span>            : 
<span class="lineNum">    3068 </span>            :    Objective-C:
<span class="lineNum">    3069 </span>            : 
<span class="lineNum">    3070 </span>            :    struct-declaration-list:
<span class="lineNum">    3071 </span>            :      @defs ( class-name )
<span class="lineNum">    3072 </span>            : 
<span class="lineNum">    3073 </span>            :    (Note this does not include a trailing semicolon, but can be
<span class="lineNum">    3074 </span>            :    followed by further declarations, and gets a pedwarn-if-pedantic
<span class="lineNum">    3075 </span>            :    when followed by a semicolon.)  */
<a name="3076"><span class="lineNum">    3076 </span>            : </a>
<span class="lineNum">    3077 </span>            : static struct c_typespec
<span class="lineNum">    3078 </span>            : c_parser_struct_or_union_specifier (c_parser *parser)
<span class="lineNum">    3079 </span>            : {
<span class="lineNum">    3080 </span>            :   struct c_typespec ret;
<span class="lineNum">    3081 </span>            :   tree attrs;
<span class="lineNum">    3082 </span>            :   tree ident = NULL_TREE;
<span class="lineNum">    3083 </span>            :   location_t struct_loc;
<span class="lineNum">    3084 </span>            :   location_t ident_loc = UNKNOWN_LOCATION;
<span class="lineNum">    3085 </span>            :   enum tree_code code;
<span class="lineNum">    3086 </span>            :   switch (c_parser_peek_token (parser)-&gt;keyword)
<span class="lineNum">    3087 </span>            :     {
<span class="lineNum">    3088 </span>            :     case RID_STRUCT:
<span class="lineNum">    3089 </span>            :       code = RECORD_TYPE;
<span class="lineNum">    3090 </span>            :       break;
<span class="lineNum">    3091 </span>            :     case RID_UNION:
<span class="lineNum">    3092 </span>            :       code = UNION_TYPE;
<span class="lineNum">    3093 </span>            :       break;
<span class="lineNum">    3094 </span>            :     default:
<span class="lineNum">    3095 </span>            :       gcc_unreachable ();
<span class="lineNum">    3096 </span>            :     }
<span class="lineNum">    3097 </span>            :   struct_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    3098 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    3099 </span>            :   attrs = c_parser_attributes (parser);
<span class="lineNum">    3100 </span>            : 
<span class="lineNum">    3101 </span>            :   /* Set the location in case we create a decl now.  */
<span class="lineNum">    3102 </span><span class="lineCov">    1514585 :   c_parser_set_source_position_from_token (c_parser_peek_token (parser));</span>
<span class="lineNum">    3103 </span>            : 
<span class="lineNum">    3104 </span><span class="lineCov">    1514585 :   if (c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">    3105 </span><span class="lineCov">    1514585 :     {</span>
<span class="lineNum">    3106 </span><span class="lineCov">    1514585 :       ident = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">    3107 </span><span class="lineCov">    1514585 :       ident_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    3108 </span><span class="lineCov">    1514585 :       struct_loc = ident_loc;</span>
<span class="lineNum">    3109 </span><span class="lineCov">    1514585 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    3110 </span><span class="lineCov">    1514585 :     }</span>
<span class="lineNum">    3111 </span>            :   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))
<span class="lineNum">    3112 </span>            :     {
<span class="lineNum">    3113 </span>            :       /* Parse a struct or union definition.  Start the scope of the
<span class="lineNum">    3114 </span>            :          tag before parsing components.  */
<span class="lineNum">    3115 </span><span class="lineCov">     264795 :       struct c_struct_parse_info *struct_info;</span>
<span class="lineNum">    3116 </span><span class="lineCov">     264795 :       tree type = start_struct (struct_loc, code, ident, &amp;struct_info);</span>
<span class="lineNum">    3117 </span><span class="lineCov">     264795 :       tree postfix_attrs;</span>
<span class="lineNum">    3118 </span><span class="lineNoCov">          0 :       /* We chain the components in reverse order, then put them in</span>
<span class="lineNum">    3119 </span><span class="lineNoCov">          0 :          forward order at the end.  Each struct-declaration may</span>
<span class="lineNum">    3120 </span>            :          declare multiple components (comma-separated), so we must use
<span class="lineNum">    3121 </span><span class="lineCov">    1514585 :          chainon to join them, although when parsing each</span>
<span class="lineNum">    3122 </span><span class="lineCov">    1514585 :          struct-declaration we can use TREE_CHAIN directly.</span>
<span class="lineNum">    3123 </span><span class="lineCov">    1514585 : </span>
<span class="lineNum">    3124 </span>            :          The theory behind all this is that there will be more
<span class="lineNum">    3125 </span>            :          semicolon separated fields than comma separated fields, and
<span class="lineNum">    3126 </span><span class="lineCov">    1514585 :          so we'll be minimizing the number of node traversals required</span>
<span class="lineNum">    3127 </span>            :          by chainon.  */
<span class="lineNum">    3128 </span><span class="lineCov">    1514585 :       tree contents;</span>
<span class="lineNum">    3129 </span>            :       timevar_push (TV_PARSE_STRUCT);
<span class="lineNum">    3130 </span><span class="lineCov">    1073962 :       contents = NULL_TREE;</span>
<span class="lineNum">    3131 </span><span class="lineCov">    1073962 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    3132 </span><span class="lineCov">    1073962 :       /* Handle the Objective-C @defs construct,</span>
<span class="lineNum">    3133 </span><span class="lineCov">    1073962 :          e.g. foo(sizeof(struct{ @defs(ClassName) }));.  */</span>
<span class="lineNum">    3134 </span>            :       if (c_parser_next_token_is_keyword (parser, RID_AT_DEFS))
<span class="lineNum">    3135 </span><span class="lineCov">    1514585 :         {</span>
<span class="lineNum">    3136 </span>            :           tree name;
<span class="lineNum">    3137 </span>            :           gcc_assert (c_dialect_objc ());
<span class="lineNum">    3138 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    3139 </span><span class="lineCov">     759363 :           matching_parens parens;</span>
<span class="lineNum">    3140 </span><span class="lineCov">     759363 :           if (!parens.require_open (parser))</span>
<span class="lineNum">    3141 </span><span class="lineCov">     759363 :             goto end_at_defs;</span>
<span class="lineNum">    3142 </span>            :           if (c_parser_next_token_is (parser, CPP_NAME)
<span class="lineNum">    3143 </span>            :               &amp;&amp; c_parser_peek_token (parser)-&gt;id_kind == C_ID_CLASSNAME)
<span class="lineNum">    3144 </span>            :             {
<span class="lineNum">    3145 </span>            :               name = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    3146 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">    3147 </span>            :             }
<span class="lineNum">    3148 </span>            :           else
<span class="lineNum">    3149 </span>            :             {
<span class="lineNum">    3150 </span>            :               c_parser_error (parser, &quot;expected class name&quot;);
<span class="lineNum">    3151 </span>            :               c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
<span class="lineNum">    3152 </span><span class="lineCov">     759363 :               goto end_at_defs;</span>
<span class="lineNum">    3153 </span><span class="lineCov">     759363 :             }</span>
<span class="lineNum">    3154 </span><span class="lineCov">     759363 :           parens.skip_until_found_close (parser);</span>
<span class="lineNum">    3155 </span><span class="lineCov">     759363 :           contents = nreverse (objc_get_class_ivars (name));</span>
<span class="lineNum">    3156 </span>            :         }
<span class="lineNum">    3157 </span>            :     end_at_defs:
<span class="lineNum">    3158 </span><span class="lineCov">     759363 :       /* Parse the struct-declarations and semicolons.  Problems with</span>
<span class="lineNum">    3159 </span>            :          semicolons are diagnosed here; empty structures are diagnosed
<span class="lineNum">    3160 </span><span class="lineNoCov">          0 :          elsewhere.  */</span>
<span class="lineNum">    3161 </span><span class="lineNoCov">          0 :       while (true)</span>
<span class="lineNum">    3162 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    3163 </span><span class="lineNoCov">          0 :           tree decls;</span>
<span class="lineNum">    3164 </span><span class="lineNoCov">          0 :           /* Parse any stray semicolon.  */</span>
<span class="lineNum">    3165 </span><span class="lineNoCov">          0 :           if (c_parser_next_token_is (parser, CPP_SEMICOLON))</span>
<span class="lineNum">    3166 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">    3167 </span><span class="lineNoCov">          0 :               location_t semicolon_loc</span>
<span class="lineNum">    3168 </span>            :                 = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    3169 </span><span class="lineNoCov">          0 :               gcc_rich_location richloc (semicolon_loc);</span>
<span class="lineNum">    3170 </span><span class="lineNoCov">          0 :               richloc.add_fixit_remove ();</span>
<span class="lineNum">    3171 </span>            :               pedwarn (&amp;richloc, OPT_Wpedantic,
<span class="lineNum">    3172 </span>            :                        &quot;extra semicolon in struct or union specified&quot;);
<span class="lineNum">    3173 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">    3174 </span><span class="lineNoCov">          0 :               continue;</span>
<span class="lineNum">    3175 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    3176 </span><span class="lineNoCov">          0 :           /* Stop if at the end of the struct or union contents.  */</span>
<span class="lineNum">    3177 </span>            :           if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))
<span class="lineNum">    3178 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">    3179 </span><span class="lineNoCov">          0 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    3180 </span>            :               break;
<span class="lineNum">    3181 </span><span class="lineCov">     759363 :             }</span>
<span class="lineNum">    3182 </span>            :           /* Accept #pragmas at struct scope.  */
<span class="lineNum">    3183 </span>            :           if (c_parser_next_token_is (parser, CPP_PRAGMA))
<span class="lineNum">    3184 </span>            :             {
<span class="lineNum">    3185 </span><span class="lineCov">    3510479 :               c_parser_pragma (parser, pragma_struct, NULL);</span>
<span class="lineNum">    3186 </span>            :               continue;
<span class="lineNum">    3187 </span><span class="lineCov">    3510479 :             }</span>
<span class="lineNum">    3188 </span>            :           /* Parse some comma-separated declarations, but not the
<span class="lineNum">    3189 </span><span class="lineCov">    3510479 :              trailing semicolon if any.  */</span>
<span class="lineNum">    3190 </span>            :           decls = c_parser_struct_declaration (parser);
<span class="lineNum">    3191 </span><span class="lineCov">         11 :           contents = chainon (decls, contents);</span>
<span class="lineNum">    3192 </span><span class="lineCov">         11 :           /* If no semicolon follows, either we have a parse error or</span>
<span class="lineNum">    3193 </span><span class="lineCov">         22 :              are at the end of the struct or union and should</span>
<span class="lineNum">    3194 </span><span class="lineCov">         11 :              pedwarn.  */</span>
<span class="lineNum">    3195 </span><span class="lineCov">         11 :           if (c_parser_next_token_is (parser, CPP_SEMICOLON))</span>
<span class="lineNum">    3196 </span>            :             c_parser_consume_token (parser);
<span class="lineNum">    3197 </span><span class="lineCov">         11 :           else</span>
<span class="lineNum">    3198 </span><span class="lineCov">         11 :             {</span>
<span class="lineNum">    3199 </span>            :               if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))
<span class="lineNum">    3200 </span>            :                 pedwarn (c_parser_peek_token (parser)-&gt;location, 0,
<span class="lineNum">    3201 </span><span class="lineCov">    3510468 :                          &quot;no semicolon at end of struct or union&quot;);</span>
<span class="lineNum">    3202 </span>            :               else if (parser-&gt;error
<span class="lineNum">    3203 </span><span class="lineCov">     759354 :                        || !c_parser_next_token_starts_declspecs (parser))</span>
<span class="lineNum">    3204 </span><span class="lineCov">     759354 :                 {</span>
<span class="lineNum">    3205 </span>            :                   c_parser_error (parser, &quot;expected %&lt;;%&gt;&quot;);
<span class="lineNum">    3206 </span>            :                   c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, NULL);
<span class="lineNum">    3207 </span><span class="lineCov">    2751114 :                   break;</span>
<span class="lineNum">    3208 </span>            :                 }
<span class="lineNum">    3209 </span><span class="lineCov">          9 : </span>
<span class="lineNum">    3210 </span><span class="lineCov">          9 :               /* If we come here, we have already emitted an error</span>
<span class="lineNum">    3211 </span>            :                  for an expected `;', identifier or `(', and we also
<span class="lineNum">    3212 </span>            :                  recovered already.  Go on with the next field. */
<span class="lineNum">    3213 </span>            :             }
<span class="lineNum">    3214 </span><span class="lineCov">    2751105 :         }</span>
<span class="lineNum">    3215 </span><span class="lineCov">    2751105 :       postfix_attrs = c_parser_attributes (parser);</span>
<span class="lineNum">    3216 </span>            :       ret.spec = finish_struct (struct_loc, type, nreverse (contents),
<span class="lineNum">    3217 </span>            :                                 chainon (attrs, postfix_attrs), struct_info);
<span class="lineNum">    3218 </span>            :       ret.kind = ctsk_tagdef;
<span class="lineNum">    3219 </span><span class="lineCov">    2751105 :       ret.expr = NULL_TREE;</span>
<span class="lineNum">    3220 </span><span class="lineCov">    2751065 :       ret.expr_const_operands = true;</span>
<span class="lineNum">    3221 </span>            :       timevar_pop (TV_PARSE_STRUCT);
<span class="lineNum">    3222 </span>            :       return ret;
<span class="lineNum">    3223 </span><span class="lineCov">         40 :     }</span>
<span class="lineNum">    3224 </span><span class="lineCov">         29 :   else if (!ident)</span>
<span class="lineNum">    3225 </span>            :     {
<span class="lineNum">    3226 </span><span class="lineCov">         11 :       c_parser_error (parser, &quot;expected %&lt;{%&gt;&quot;);</span>
<span class="lineNum">    3227 </span><span class="lineCov">         11 :       ret.spec = error_mark_node;</span>
<span class="lineNum">    3228 </span>            :       ret.kind = ctsk_tagref;
<span class="lineNum">    3229 </span><span class="lineCov">          9 :       ret.expr = NULL_TREE;</span>
<span class="lineNum">    3230 </span><span class="lineCov">          9 :       ret.expr_const_operands = true;</span>
<span class="lineNum">    3231 </span><span class="lineCov">          9 :       return ret;</span>
<span class="lineNum">    3232 </span>            :     }
<span class="lineNum">    3233 </span>            :   ret = parser_xref_tag (ident_loc, code, ident);
<span class="lineNum">    3234 </span>            :   return ret;
<span class="lineNum">    3235 </span>            : }
<span class="lineNum">    3236 </span>            : 
<span class="lineNum">    3237 </span>            : /* Parse a struct-declaration (C90 6.5.2.1, C99 6.7.2.1, C11 6.7.2.1),
<span class="lineNum">    3238 </span>            :    *without* the trailing semicolon.
<span class="lineNum">    3239 </span><span class="lineCov">     759363 : </span>
<span class="lineNum">    3240 </span><span class="lineCov">     759363 :    struct-declaration:</span>
<span class="lineNum">    3241 </span>            :      specifier-qualifier-list struct-declarator-list
<span class="lineNum">    3242 </span><span class="lineCov">     759363 :      static_assert-declaration-no-semi</span>
<span class="lineNum">    3243 </span><span class="lineCov">     759363 : </span>
<span class="lineNum">    3244 </span><span class="lineCov">     759363 :    specifier-qualifier-list:</span>
<span class="lineNum">    3245 </span><span class="lineCov">     759363 :      type-specifier specifier-qualifier-list[opt]</span>
<span class="lineNum">    3246 </span><span class="lineCov">     759363 :      type-qualifier specifier-qualifier-list[opt]</span>
<span class="lineNum">    3247 </span>            :      alignment-specifier specifier-qualifier-list[opt]
<span class="lineNum">    3248 </span><span class="lineCov">     755222 :      attributes specifier-qualifier-list[opt]</span>
<span class="lineNum">    3249 </span>            : 
<span class="lineNum">    3250 </span><span class="lineCov">          8 :    struct-declarator-list:</span>
<span class="lineNum">    3251 </span><span class="lineCov">          8 :      struct-declarator</span>
<span class="lineNum">    3252 </span><span class="lineCov">          8 :      struct-declarator-list , attributes[opt] struct-declarator</span>
<span class="lineNum">    3253 </span><span class="lineCov">          8 : </span>
<span class="lineNum">    3254 </span><span class="lineCov">          8 :    struct-declarator:</span>
<span class="lineNum">    3255 </span><span class="lineCov">          8 :      declarator attributes[opt]</span>
<span class="lineNum">    3256 </span>            :      declarator[opt] : constant-expression attributes[opt]
<span class="lineNum">    3257 </span><span class="lineCov">     755214 : </span>
<span class="lineNum">    3258 </span><span class="lineCov">     755214 :    GNU extensions:</span>
<span class="lineNum">    3259 </span>            : 
<span class="lineNum">    3260 </span>            :    struct-declaration:
<span class="lineNum">    3261 </span>            :      __extension__ struct-declaration
<span class="lineNum">    3262 </span>            :      specifier-qualifier-list
<span class="lineNum">    3263 </span>            : 
<span class="lineNum">    3264 </span>            :    Unlike the ISO C syntax, semicolons are handled elsewhere.  The use
<span class="lineNum">    3265 </span>            :    of attributes where shown is a GNU extension.  In GNU C, we accept
<span class="lineNum">    3266 </span>            :    any expression without commas in the syntax (assignment
<span class="lineNum">    3267 </span>            :    expressions, not just conditional expressions); assignment
<span class="lineNum">    3268 </span>            :    expressions will be diagnosed as non-constant.  */
<a name="3269"><span class="lineNum">    3269 </span>            : </a>
<span class="lineNum">    3270 </span>            : static tree
<span class="lineNum">    3271 </span>            : c_parser_struct_declaration (c_parser *parser)
<span class="lineNum">    3272 </span>            : {
<span class="lineNum">    3273 </span>            :   struct c_declspecs *specs;
<span class="lineNum">    3274 </span>            :   tree prefix_attrs;
<span class="lineNum">    3275 </span>            :   tree all_prefix_attrs;
<span class="lineNum">    3276 </span>            :   tree decls;
<span class="lineNum">    3277 </span>            :   location_t decl_loc;
<span class="lineNum">    3278 </span>            :   if (c_parser_next_token_is_keyword (parser, RID_EXTENSION))
<span class="lineNum">    3279 </span>            :     {
<span class="lineNum">    3280 </span>            :       int ext;
<span class="lineNum">    3281 </span>            :       tree decl;
<span class="lineNum">    3282 </span>            :       ext = disable_extension_diagnostics ();
<span class="lineNum">    3283 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    3284 </span>            :       decl = c_parser_struct_declaration (parser);
<span class="lineNum">    3285 </span>            :       restore_extension_diagnostics (ext);
<span class="lineNum">    3286 </span>            :       return decl;
<span class="lineNum">    3287 </span>            :     }
<span class="lineNum">    3288 </span>            :   if (c_parser_next_token_is_keyword (parser, RID_STATIC_ASSERT))
<span class="lineNum">    3289 </span>            :     {
<span class="lineNum">    3290 </span>            :       c_parser_static_assert_declaration_no_semi (parser);
<span class="lineNum">    3291 </span>            :       return NULL_TREE;
<span class="lineNum">    3292 </span>            :     }
<span class="lineNum">    3293 </span>            :   specs = build_null_declspecs ();
<span class="lineNum">    3294 </span>            :   decl_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    3295 </span><span class="lineCov">    2831819 :   /* Strictly by the standard, we shouldn't allow _Alignas here,</span>
<span class="lineNum">    3296 </span>            :      but it appears to have been intended to allow it there, so
<span class="lineNum">    3297 </span><span class="lineCov">    2831819 :      we're keeping it as it is until WG14 reaches a conclusion</span>
<span class="lineNum">    3298 </span><span class="lineCov">    2831819 :      of N1731.</span>
<span class="lineNum">    3299 </span><span class="lineCov">    2831819 :      &lt;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1731.pdf&gt;  */</span>
<span class="lineNum">    3300 </span><span class="lineCov">    2831819 :   c_parser_declspecs (parser, specs, false, true, true,</span>
<span class="lineNum">    3301 </span><span class="lineCov">    2831819 :                       true, false, cla_nonabstract_decl);</span>
<span class="lineNum">    3302 </span><span class="lineCov">    2831819 :   if (parser-&gt;error)</span>
<span class="lineNum">    3303 </span>            :     return NULL_TREE;
<span class="lineNum">    3304 </span><span class="lineCov">      80714 :   if (!specs-&gt;declspecs_seen_p)</span>
<span class="lineNum">    3305 </span><span class="lineCov">      80714 :     {</span>
<span class="lineNum">    3306 </span><span class="lineCov">      80714 :       c_parser_error (parser, &quot;expected specifier-qualifier-list&quot;);</span>
<span class="lineNum">    3307 </span><span class="lineCov">      80714 :       return NULL_TREE;</span>
<span class="lineNum">    3308 </span><span class="lineCov">      80714 :     }</span>
<span class="lineNum">    3309 </span><span class="lineCov">      80714 :   finish_declspecs (specs);</span>
<span class="lineNum">    3310 </span><span class="lineCov">      80714 :   if (c_parser_next_token_is (parser, CPP_SEMICOLON)</span>
<span class="lineNum">    3311 </span>            :       || c_parser_next_token_is (parser, CPP_CLOSE_BRACE))
<span class="lineNum">    3312 </span><span class="lineCov">    2751105 :     {</span>
<span class="lineNum">    3313 </span>            :       tree ret;
<span class="lineNum">    3314 </span><span class="lineCov">          4 :       if (specs-&gt;typespec_kind == ctsk_none)</span>
<span class="lineNum">    3315 </span><span class="lineCov">          4 :         {</span>
<span class="lineNum">    3316 </span>            :           pedwarn (decl_loc, OPT_Wpedantic,
<span class="lineNum">    3317 </span><span class="lineCov">    2751101 :                    &quot;ISO C forbids member declarations with no members&quot;);</span>
<span class="lineNum">    3318 </span><span class="lineCov">    2751101 :           shadow_tag_warned (specs, pedantic);</span>
<span class="lineNum">    3319 </span>            :           ret = NULL_TREE;
<span class="lineNum">    3320 </span>            :         }
<span class="lineNum">    3321 </span>            :       else
<span class="lineNum">    3322 </span>            :         {
<span class="lineNum">    3323 </span>            :           /* Support for unnamed structs or unions as members of
<span class="lineNum">    3324 </span><span class="lineCov">    2751101 :              structs or unions (which is [a] useful and [b] supports</span>
<span class="lineNum">    3325 </span>            :              MS P-SDK).  */
<span class="lineNum">    3326 </span><span class="lineCov">    2751101 :           tree attrs = NULL;</span>
<span class="lineNum">    3327 </span>            : 
<span class="lineNum">    3328 </span><span class="lineCov">    2751093 :           ret = grokfield (c_parser_peek_token (parser)-&gt;location,</span>
<span class="lineNum">    3329 </span>            :                            build_id_declarator (NULL_TREE), specs,
<span class="lineNum">    3330 </span><span class="lineCov">          1 :                            NULL_TREE, &amp;attrs);</span>
<span class="lineNum">    3331 </span><span class="lineCov">          1 :           if (ret)</span>
<span class="lineNum">    3332 </span>            :             decl_attributes (&amp;ret, attrs, 0);
<span class="lineNum">    3333 </span><span class="lineCov">    2751092 :         }</span>
<span class="lineNum">    3334 </span><span class="lineCov">    2751092 :       return ret;</span>
<span class="lineNum">    3335 </span><span class="lineCov">    2751092 :     }</span>
<span class="lineNum">    3336 </span>            : 
<span class="lineNum">    3337 </span><span class="lineCov">      31786 :   /* Provide better error recovery.  Note that a type name here is valid,</span>
<span class="lineNum">    3338 </span><span class="lineCov">      31786 :      and will be treated as a field name.  */</span>
<span class="lineNum">    3339 </span>            :   if (specs-&gt;typespec_kind == ctsk_tagdef
<span class="lineNum">    3340 </span><span class="lineCov">          3 :       &amp;&amp; TREE_CODE (specs-&gt;type) != ENUMERAL_TYPE</span>
<span class="lineNum">    3341 </span>            :       &amp;&amp; c_parser_next_token_starts_declspecs (parser)
<span class="lineNum">    3342 </span><span class="lineCov">          3 :       &amp;&amp; !c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">    3343 </span><span class="lineCov">          3 :     {</span>
<span class="lineNum">    3344 </span>            :       c_parser_error (parser, &quot;expected %&lt;;%&gt;, identifier or %&lt;(%&gt;&quot;);
<span class="lineNum">    3345 </span>            :       parser-&gt;error = false;
<span class="lineNum">    3346 </span>            :       return NULL_TREE;
<span class="lineNum">    3347 </span>            :     }
<span class="lineNum">    3348 </span>            : 
<span class="lineNum">    3349 </span>            :   pending_xref_error ();
<span class="lineNum">    3350 </span><span class="lineCov">      31783 :   prefix_attrs = specs-&gt;attrs;</span>
<span class="lineNum">    3351 </span>            :   all_prefix_attrs = prefix_attrs;
<span class="lineNum">    3352 </span><span class="lineCov">      31783 :   specs-&gt;attrs = NULL_TREE;</span>
<span class="lineNum">    3353 </span>            :   decls = NULL_TREE;
<span class="lineNum">    3354 </span>            :   while (true)
<span class="lineNum">    3355 </span><span class="lineCov">      31783 :     {</span>
<span class="lineNum">    3356 </span><span class="lineCov">      31759 :       /* Declaring one or more declarators or un-named bit-fields.  */</span>
<span class="lineNum">    3357 </span>            :       struct c_declarator *declarator;
<span class="lineNum">    3358 </span><span class="lineCov">      31786 :       bool dummy = false;</span>
<span class="lineNum">    3359 </span>            :       if (c_parser_next_token_is (parser, CPP_COLON))
<span class="lineNum">    3360 </span>            :         declarator = build_id_declarator (NULL_TREE);
<span class="lineNum">    3361 </span>            :       else
<span class="lineNum">    3362 </span>            :         declarator = c_parser_declarator (parser,
<span class="lineNum">    3363 </span><span class="lineCov">    2719306 :                                           specs-&gt;typespec_kind != ctsk_none,</span>
<span class="lineNum">    3364 </span><span class="lineCov">     140468 :                                           C_DTR_NORMAL, &amp;dummy);</span>
<span class="lineNum">    3365 </span><span class="lineCov">     140333 :       if (declarator == NULL)</span>
<span class="lineNum">    3366 </span><span class="lineCov">    2719308 :         {</span>
<span class="lineNum">    3367 </span>            :           c_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">    3368 </span><span class="lineCov">          2 :           break;</span>
<span class="lineNum">    3369 </span><span class="lineCov">          2 :         }</span>
<span class="lineNum">    3370 </span><span class="lineCov">          2 :       if (c_parser_next_token_is (parser, CPP_COLON)</span>
<span class="lineNum">    3371 </span>            :           || c_parser_next_token_is (parser, CPP_COMMA)
<span class="lineNum">    3372 </span>            :           || c_parser_next_token_is (parser, CPP_SEMICOLON)
<span class="lineNum">    3373 </span><span class="lineCov">    2719304 :           || c_parser_next_token_is (parser, CPP_CLOSE_BRACE)</span>
<span class="lineNum">    3374 </span><span class="lineCov">    2719304 :           || c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))</span>
<span class="lineNum">    3375 </span><span class="lineCov">    2719304 :         {</span>
<span class="lineNum">    3376 </span><span class="lineCov">    2719304 :           tree postfix_attrs = NULL_TREE;</span>
<span class="lineNum">    3377 </span><span class="lineCov">    2719304 :           tree width = NULL_TREE;</span>
<span class="lineNum">    3378 </span><span class="lineCov">    2751777 :           tree d;</span>
<span class="lineNum">    3379 </span>            :           if (c_parser_next_token_is (parser, CPP_COLON))
<span class="lineNum">    3380 </span>            :             {
<span class="lineNum">    3381 </span><span class="lineCov">    2751777 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    3382 </span><span class="lineCov">    2751777 :               width = c_parser_expr_no_commas (parser, NULL).value;</span>
<span class="lineNum">    3383 </span><span class="lineCov">    2751777 :             }</span>
<span class="lineNum">    3384 </span><span class="lineCov">       8490 :           if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))</span>
<span class="lineNum">    3385 </span>            :             postfix_attrs = c_parser_attributes (parser);
<span class="lineNum">    3386 </span><span class="lineCov">    5486574 :           d = grokfield (c_parser_peek_token (parser)-&gt;location,</span>
<span class="lineNum">    3387 </span><span class="lineCov">    2743287 :                          declarator, specs, width, &amp;all_prefix_attrs);</span>
<span class="lineNum">    3388 </span>            :           decl_attributes (&amp;d, chainon (postfix_attrs,
<span class="lineNum">    3389 </span><span class="lineCov">    2751777 :                                         all_prefix_attrs), 0);</span>
<span class="lineNum">    3390 </span>            :           DECL_CHAIN (d) = decls;
<span class="lineNum">    3391 </span><span class="lineCov">          1 :           decls = d;</span>
<span class="lineNum">    3392 </span><span class="lineCov">          1 :           if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))</span>
<span class="lineNum">    3393 </span>            :             all_prefix_attrs = chainon (c_parser_attributes (parser),
<span class="lineNum">    3394 </span><span class="lineCov">    2751776 :                                         prefix_attrs);</span>
<span class="lineNum">    3395 </span><span class="lineCov">    2718960 :           else</span>
<span class="lineNum">    3396 </span><span class="lineCov">    2688391 :             all_prefix_attrs = prefix_attrs;</span>
<span class="lineNum">    3397 </span><span class="lineCov">      15935 :           if (c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">    3398 </span><span class="lineCov">    2767684 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    3399 </span>            :           else if (c_parser_next_token_is (parser, CPP_SEMICOLON)
<span class="lineNum">    3400 </span><span class="lineCov">    2751776 :                    || c_parser_next_token_is (parser, CPP_CLOSE_BRACE))</span>
<span class="lineNum">    3401 </span><span class="lineCov">    2751776 :             {</span>
<span class="lineNum">    3402 </span><span class="lineCov">    2751776 :               /* Semicolon consumed in caller.  */</span>
<span class="lineNum">    3403 </span><span class="lineCov">    2751776 :               break;</span>
<span class="lineNum">    3404 </span>            :             }
<span class="lineNum">    3405 </span><span class="lineCov">      32816 :           else</span>
<span class="lineNum">    3406 </span><span class="lineCov">      32816 :             {</span>
<span class="lineNum">    3407 </span>            :               c_parser_error (parser, &quot;expected %&lt;,%&gt;, %&lt;;%&gt; or %&lt;}%&gt;&quot;);
<span class="lineNum">    3408 </span><span class="lineCov">    2751776 :               break;</span>
<span class="lineNum">    3409 </span><span class="lineCov">      16087 :             }</span>
<span class="lineNum">    3410 </span><span class="lineCov">    2751776 :         }</span>
<span class="lineNum">    3411 </span>            :       else
<span class="lineNum">    3412 </span><span class="lineCov">    2751776 :         {</span>
<span class="lineNum">    3413 </span>            :           c_parser_error (parser,
<span class="lineNum">    3414 </span><span class="lineCov">    2751776 :                           &quot;expected %&lt;:%&gt;, %&lt;,%&gt;, %&lt;;%&gt;, %&lt;}%&gt; or &quot;</span>
<span class="lineNum">    3415 </span><span class="lineCov">    2751776 :                           &quot;%&lt;__attribute__%&gt;&quot;);</span>
<span class="lineNum">    3416 </span><span class="lineCov">    2751776 :           break;</span>
<span class="lineNum">    3417 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    3418 </span>            :     }
<span class="lineNum">    3419 </span>            :   return decls;
<span class="lineNum">    3420 </span><span class="lineCov">    2751776 : }</span>
<span class="lineNum">    3421 </span><span class="lineCov">    2751776 : </span>
<span class="lineNum">    3422 </span><span class="lineCov">      32473 : /* Parse a typeof specifier (a GNU extension).</span>
<span class="lineNum">    3423 </span><span class="lineCov">    2719303 : </span>
<span class="lineNum">    3424 </span><span class="lineCov">    2719303 :    typeof-specifier:</span>
<span class="lineNum">    3425 </span>            :      typeof ( expression )
<span class="lineNum">    3426 </span>            :      typeof ( type-name )
<span class="lineNum">    3427 </span>            : */
<a name="3428"><span class="lineNum">    3428 </span>            : </a>
<span class="lineNum">    3429 </span>            : static struct c_typespec
<span class="lineNum">    3430 </span>            : c_parser_typeof_specifier (c_parser *parser)
<span class="lineNum">    3431 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    3432 </span><span class="lineNoCov">          0 :   struct c_typespec ret;</span>
<span class="lineNum">    3433 </span>            :   ret.kind = ctsk_typeof;
<span class="lineNum">    3434 </span>            :   ret.spec = error_mark_node;
<span class="lineNum">    3435 </span>            :   ret.expr = NULL_TREE;
<span class="lineNum">    3436 </span>            :   ret.expr_const_operands = true;
<span class="lineNum">    3437 </span><span class="lineNoCov">          0 :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_TYPEOF));</span>
<span class="lineNum">    3438 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    3439 </span>            :   c_inhibit_evaluation_warnings++;
<span class="lineNum">    3440 </span><span class="lineNoCov">          0 :   in_typeof++;</span>
<span class="lineNum">    3441 </span>            :   matching_parens parens;
<span class="lineNum">    3442 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">    3443 </span><span class="lineCov">    2719304 :     {</span>
<span class="lineNum">    3444 </span>            :       c_inhibit_evaluation_warnings--;
<span class="lineNum">    3445 </span>            :       in_typeof--;
<span class="lineNum">    3446 </span>            :       return ret;
<span class="lineNum">    3447 </span>            :     }
<span class="lineNum">    3448 </span>            :   if (c_parser_next_tokens_start_typename (parser, cla_prefer_id))
<span class="lineNum">    3449 </span>            :     {
<span class="lineNum">    3450 </span>            :       struct c_type_name *type = c_parser_type_name (parser);
<span class="lineNum">    3451 </span>            :       c_inhibit_evaluation_warnings--;
<span class="lineNum">    3452 </span>            :       in_typeof--;
<span class="lineNum">    3453 </span>            :       if (type != NULL)
<span class="lineNum">    3454 </span><span class="lineCov">     760047 :         {</span>
<span class="lineNum">    3455 </span>            :           ret.spec = groktypename (type, &amp;ret.expr, &amp;ret.expr_const_operands);
<span class="lineNum">    3456 </span><span class="lineCov">     760047 :           pop_maybe_used (variably_modified_type_p (ret.spec, NULL_TREE));</span>
<span class="lineNum">    3457 </span><span class="lineCov">     760047 :         }</span>
<span class="lineNum">    3458 </span><span class="lineCov">     760047 :     }</span>
<span class="lineNum">    3459 </span><span class="lineCov">     760047 :   else</span>
<span class="lineNum">    3460 </span><span class="lineCov">     760047 :     {</span>
<span class="lineNum">    3461 </span><span class="lineCov">     760047 :       bool was_vm;</span>
<span class="lineNum">    3462 </span><span class="lineCov">     760047 :       location_t here = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    3463 </span><span class="lineCov">     760047 :       struct c_expr expr = c_parser_expression (parser);</span>
<span class="lineNum">    3464 </span><span class="lineCov">     760047 :       c_inhibit_evaluation_warnings--;</span>
<span class="lineNum">    3465 </span><span class="lineCov">    1520094 :       in_typeof--;</span>
<span class="lineNum">    3466 </span><span class="lineCov">     760047 :       if (TREE_CODE (expr.value) == COMPONENT_REF</span>
<span class="lineNum">    3467 </span>            :           &amp;&amp; DECL_C_BIT_FIELD (TREE_OPERAND (expr.value, 1)))
<span class="lineNum">    3468 </span><span class="lineNoCov">          0 :         error_at (here, &quot;%&lt;typeof%&gt; applied to a bit-field&quot;);</span>
<span class="lineNum">    3469 </span><span class="lineNoCov">          0 :       mark_exp_read (expr.value);</span>
<span class="lineNum">    3470 </span><span class="lineNoCov">          0 :       ret.spec = TREE_TYPE (expr.value);</span>
<span class="lineNum">    3471 </span>            :       was_vm = variably_modified_type_p (ret.spec, NULL_TREE);
<span class="lineNum">    3472 </span><span class="lineCov">     760047 :       /* This is returned with the type so that when the type is</span>
<span class="lineNum">    3473 </span>            :          evaluated, this can be evaluated.  */
<span class="lineNum">    3474 </span><span class="lineCov">        224 :       if (was_vm)</span>
<span class="lineNum">    3475 </span><span class="lineCov">        224 :         ret.expr = c_fully_fold (expr.value, false, &amp;ret.expr_const_operands);</span>
<span class="lineNum">    3476 </span><span class="lineCov">        224 :       pop_maybe_used (was_vm);</span>
<span class="lineNum">    3477 </span><span class="lineCov">        224 :       /* For use in macros such as those in &lt;stdatomic.h&gt;, remove all</span>
<span class="lineNum">    3478 </span>            :          qualifiers from atomic types.  (const can be an issue for more macros
<span class="lineNum">    3479 </span><span class="lineCov">        224 :          using typeof than just the &lt;stdatomic.h&gt; ones.)  */</span>
<span class="lineNum">    3480 </span><span class="lineCov">        224 :       if (ret.spec != error_mark_node &amp;&amp; TYPE_ATOMIC (ret.spec))</span>
<span class="lineNum">    3481 </span>            :         ret.spec = c_build_qualified_type (ret.spec, TYPE_UNQUALIFIED);
<span class="lineNum">    3482 </span>            :     }
<span class="lineNum">    3483 </span>            :   parens.skip_until_found_close (parser);
<span class="lineNum">    3484 </span>            :   return ret;
<span class="lineNum">    3485 </span><span class="lineCov">     759823 : }</span>
<span class="lineNum">    3486 </span><span class="lineCov">     759823 : </span>
<span class="lineNum">    3487 </span><span class="lineCov">     759823 : /* Parse an alignment-specifier.</span>
<span class="lineNum">    3488 </span><span class="lineCov">     759823 : </span>
<span class="lineNum">    3489 </span><span class="lineCov">     759823 :    C11 6.7.5:</span>
<span class="lineNum">    3490 </span><span class="lineCov">     759823 : </span>
<span class="lineNum">    3491 </span><span class="lineCov">     759823 :    alignment-specifier:</span>
<span class="lineNum">    3492 </span><span class="lineCov">          1 :      _Alignas ( type-name )</span>
<span class="lineNum">    3493 </span><span class="lineCov">     759823 :      _Alignas ( constant-expression )</span>
<span class="lineNum">    3494 </span><span class="lineCov">     759823 : */</span>
<a name="3495"><span class="lineNum">    3495 </span><span class="lineCov">     759823 : </span></a>
<span class="lineNum">    3496 </span>            : static tree
<span class="lineNum">    3497 </span>            : c_parser_alignas_specifier (c_parser * parser)
<span class="lineNum">    3498 </span><span class="lineCov">     759823 : {</span>
<span class="lineNum">    3499 </span><span class="lineCov">        160 :   tree ret = error_mark_node;</span>
<span class="lineNum">    3500 </span><span class="lineCov">     759823 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    3501 </span>            :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ALIGNAS));
<span class="lineNum">    3502 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    3503 </span>            :   if (flag_isoc99)
<span class="lineNum">    3504 </span><span class="lineCov">     759823 :     pedwarn_c99 (loc, OPT_Wpedantic,</span>
<span class="lineNum">    3505 </span><span class="lineCov">       1468 :                  &quot;ISO C99 does not support %&lt;_Alignas%&gt;&quot;);</span>
<span class="lineNum">    3506 </span>            :   else
<span class="lineNum">    3507 </span><span class="lineCov">     760047 :     pedwarn_c99 (loc, OPT_Wpedantic,</span>
<span class="lineNum">    3508 </span>            :                  &quot;ISO C90 does not support %&lt;_Alignas%&gt;&quot;);
<span class="lineNum">    3509 </span>            :   matching_parens parens;
<span class="lineNum">    3510 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">    3511 </span>            :     return ret;
<span class="lineNum">    3512 </span>            :   if (c_parser_next_tokens_start_typename (parser, cla_prefer_id))
<span class="lineNum">    3513 </span>            :     {
<span class="lineNum">    3514 </span>            :       struct c_type_name *type = c_parser_type_name (parser);
<span class="lineNum">    3515 </span>            :       if (type != NULL)
<span class="lineNum">    3516 </span>            :         ret = c_sizeof_or_alignof_type (loc, groktypename (type, NULL, NULL),
<span class="lineNum">    3517 </span>            :                                         false, true, 1);
<span class="lineNum">    3518 </span>            :     }
<span class="lineNum">    3519 </span>            :   else
<span class="lineNum">    3520 </span>            :     ret = c_parser_expr_no_commas (parser, NULL).value;
<span class="lineNum">    3521 </span><span class="lineCov">        160 :   parens.skip_until_found_close (parser);</span>
<span class="lineNum">    3522 </span>            :   return ret;
<span class="lineNum">    3523 </span><span class="lineCov">        160 : }</span>
<span class="lineNum">    3524 </span><span class="lineCov">        160 : </span>
<span class="lineNum">    3525 </span><span class="lineCov">        160 : /* Parse a declarator, possibly an abstract declarator (C90 6.5.4,</span>
<span class="lineNum">    3526 </span><span class="lineCov">        160 :    6.5.5, C99 6.7.5, 6.7.6, C11 6.7.6, 6.7.7).  If TYPE_SEEN_P then</span>
<span class="lineNum">    3527 </span><span class="lineCov">        160 :    a typedef name may be redeclared; otherwise it may not.  KIND</span>
<span class="lineNum">    3528 </span><span class="lineCov">        157 :    indicates which kind of declarator is wanted.  Returns a valid</span>
<span class="lineNum">    3529 </span>            :    declarator except in the case of a syntax error in which case NULL is
<span class="lineNum">    3530 </span>            :    returned.  *SEEN_ID is set to true if an identifier being declared is
<span class="lineNum">    3531 </span><span class="lineCov">          3 :    seen; this is used to diagnose bad forms of abstract array declarators</span>
<span class="lineNum">    3532 </span>            :    and to determine whether an identifier list is syntactically permitted.
<span class="lineNum">    3533 </span><span class="lineCov">        320 : </span>
<span class="lineNum">    3534 </span><span class="lineCov">        160 :    declarator:</span>
<span class="lineNum">    3535 </span>            :      pointer[opt] direct-declarator
<span class="lineNum">    3536 </span><span class="lineCov">        160 : </span>
<span class="lineNum">    3537 </span>            :    direct-declarator:
<span class="lineNum">    3538 </span><span class="lineCov">        110 :      identifier</span>
<span class="lineNum">    3539 </span><span class="lineCov">        110 :      ( attributes[opt] declarator )</span>
<span class="lineNum">    3540 </span><span class="lineCov">        109 :      direct-declarator array-declarator</span>
<span class="lineNum">    3541 </span>            :      direct-declarator ( parameter-type-list )
<span class="lineNum">    3542 </span>            :      direct-declarator ( identifier-list[opt] )
<span class="lineNum">    3543 </span>            : 
<span class="lineNum">    3544 </span><span class="lineCov">         50 :    pointer:</span>
<span class="lineNum">    3545 </span><span class="lineCov">        320 :      * type-qualifier-list[opt]</span>
<span class="lineNum">    3546 </span><span class="lineCov">        160 :      * type-qualifier-list[opt] pointer</span>
<span class="lineNum">    3547 </span>            : 
<span class="lineNum">    3548 </span>            :    type-qualifier-list:
<span class="lineNum">    3549 </span>            :      type-qualifier
<span class="lineNum">    3550 </span>            :      attributes
<span class="lineNum">    3551 </span>            :      type-qualifier-list type-qualifier
<span class="lineNum">    3552 </span>            :      type-qualifier-list attributes
<span class="lineNum">    3553 </span>            : 
<span class="lineNum">    3554 </span>            :    array-declarator:
<span class="lineNum">    3555 </span>            :      [ type-qualifier-list[opt] assignment-expression[opt] ]
<span class="lineNum">    3556 </span>            :      [ static type-qualifier-list[opt] assignment-expression ]
<span class="lineNum">    3557 </span>            :      [ type-qualifier-list static assignment-expression ]
<span class="lineNum">    3558 </span>            :      [ type-qualifier-list[opt] * ]
<span class="lineNum">    3559 </span>            : 
<span class="lineNum">    3560 </span>            :    parameter-type-list:
<span class="lineNum">    3561 </span>            :      parameter-list
<span class="lineNum">    3562 </span>            :      parameter-list , ...
<span class="lineNum">    3563 </span>            : 
<span class="lineNum">    3564 </span>            :    parameter-list:
<span class="lineNum">    3565 </span>            :      parameter-declaration
<span class="lineNum">    3566 </span>            :      parameter-list , parameter-declaration
<span class="lineNum">    3567 </span>            : 
<span class="lineNum">    3568 </span>            :    parameter-declaration:
<span class="lineNum">    3569 </span>            :      declaration-specifiers declarator attributes[opt]
<span class="lineNum">    3570 </span>            :      declaration-specifiers abstract-declarator[opt] attributes[opt]
<span class="lineNum">    3571 </span>            : 
<span class="lineNum">    3572 </span>            :    identifier-list:
<span class="lineNum">    3573 </span>            :      identifier
<span class="lineNum">    3574 </span>            :      identifier-list , identifier
<span class="lineNum">    3575 </span>            : 
<span class="lineNum">    3576 </span>            :    abstract-declarator:
<span class="lineNum">    3577 </span>            :      pointer
<span class="lineNum">    3578 </span>            :      pointer[opt] direct-abstract-declarator
<span class="lineNum">    3579 </span>            : 
<span class="lineNum">    3580 </span>            :    direct-abstract-declarator:
<span class="lineNum">    3581 </span>            :      ( attributes[opt] abstract-declarator )
<span class="lineNum">    3582 </span>            :      direct-abstract-declarator[opt] array-declarator
<span class="lineNum">    3583 </span>            :      direct-abstract-declarator[opt] ( parameter-type-list[opt] )
<span class="lineNum">    3584 </span>            : 
<span class="lineNum">    3585 </span>            :    GNU extensions:
<span class="lineNum">    3586 </span>            : 
<span class="lineNum">    3587 </span>            :    direct-declarator:
<span class="lineNum">    3588 </span>            :      direct-declarator ( parameter-forward-declarations
<span class="lineNum">    3589 </span>            :                          parameter-type-list[opt] )
<span class="lineNum">    3590 </span>            : 
<span class="lineNum">    3591 </span>            :    direct-abstract-declarator:
<span class="lineNum">    3592 </span>            :      direct-abstract-declarator[opt] ( parameter-forward-declarations
<span class="lineNum">    3593 </span>            :                                        parameter-type-list[opt] )
<span class="lineNum">    3594 </span>            : 
<span class="lineNum">    3595 </span>            :    parameter-forward-declarations:
<span class="lineNum">    3596 </span>            :      parameter-list ;
<span class="lineNum">    3597 </span>            :      parameter-forward-declarations parameter-list ;
<span class="lineNum">    3598 </span>            : 
<span class="lineNum">    3599 </span>            :    The uses of attributes shown above are GNU extensions.
<span class="lineNum">    3600 </span>            : 
<span class="lineNum">    3601 </span>            :    Some forms of array declarator are not included in C99 in the
<span class="lineNum">    3602 </span>            :    syntax for abstract declarators; these are disallowed elsewhere.
<span class="lineNum">    3603 </span>            :    This may be a defect (DR#289).
<span class="lineNum">    3604 </span>            : 
<span class="lineNum">    3605 </span>            :    This function also accepts an omitted abstract declarator as being
<span class="lineNum">    3606 </span>            :    an abstract declarator, although not part of the formal syntax.  */
<a name="3607"><span class="lineNum">    3607 </span>            : </a>
<span class="lineNum">    3608 </span>            : struct c_declarator *
<span class="lineNum">    3609 </span>            : c_parser_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,
<span class="lineNum">    3610 </span>            :                      bool *seen_id)
<span class="lineNum">    3611 </span>            : {
<span class="lineNum">    3612 </span>            :   /* Parse any initial pointer part.  */
<span class="lineNum">    3613 </span>            :   if (c_parser_next_token_is (parser, CPP_MULT))
<span class="lineNum">    3614 </span>            :     {
<span class="lineNum">    3615 </span>            :       struct c_declspecs *quals_attrs = build_null_declspecs ();
<span class="lineNum">    3616 </span>            :       struct c_declarator *inner;
<span class="lineNum">    3617 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    3618 </span>            :       c_parser_declspecs (parser, quals_attrs, false, false, true,
<span class="lineNum">    3619 </span>            :                           false, false, cla_prefer_id);
<span class="lineNum">    3620 </span>            :       inner = c_parser_declarator (parser, type_seen_p, kind, seen_id);
<span class="lineNum">    3621 </span>            :       if (inner == NULL)
<span class="lineNum">    3622 </span>            :         return NULL;
<span class="lineNum">    3623 </span>            :       else
<span class="lineNum">    3624 </span>            :         return make_pointer_declarator (quals_attrs, inner);
<span class="lineNum">    3625 </span>            :     }
<span class="lineNum">    3626 </span>            :   /* Now we have a direct declarator, direct abstract declarator or
<span class="lineNum">    3627 </span>            :      nothing (which counts as a direct abstract declarator here).  */
<span class="lineNum">    3628 </span>            :   return c_parser_direct_declarator (parser, type_seen_p, kind, seen_id);
<span class="lineNum">    3629 </span>            : }
<span class="lineNum">    3630 </span>            : 
<span class="lineNum">    3631 </span>            : /* Parse a direct declarator or direct abstract declarator; arguments
<span class="lineNum">    3632 </span>            :    as c_parser_declarator.  */
<a name="3633"><span class="lineNum">    3633 </span><span class="lineCov">  178602780 : </span></a>
<span class="lineNum">    3634 </span>            : static struct c_declarator *
<span class="lineNum">    3635 </span>            : c_parser_direct_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,
<span class="lineNum">    3636 </span>            :                             bool *seen_id)
<span class="lineNum">    3637 </span><span class="lineCov">  178602780 : {</span>
<span class="lineNum">    3638 </span>            :   /* The direct declarator must start with an identifier (possibly
<span class="lineNum">    3639 </span><span class="lineCov">   11282484 :      omitted) or a parenthesized declarator (possibly abstract).  In</span>
<span class="lineNum">    3640 </span><span class="lineCov">   11282484 :      an ordinary declarator, initial parentheses must start a</span>
<span class="lineNum">    3641 </span><span class="lineCov">   11282484 :      parenthesized declarator.  In an abstract declarator or parameter</span>
<span class="lineNum">    3642 </span><span class="lineCov">   11282484 :      declarator, they could start a parenthesized declarator or a</span>
<span class="lineNum">    3643 </span>            :      parameter list.  To tell which, the open parenthesis and any
<span class="lineNum">    3644 </span><span class="lineCov">   11282484 :      following attributes must be read.  If a declaration specifier</span>
<span class="lineNum">    3645 </span><span class="lineCov">   11282484 :      follows, then it is a parameter list; if the specifier is a</span>
<span class="lineNum">    3646 </span>            :      typedef name, there might be an ambiguity about redeclaring it,
<span class="lineNum">    3647 </span>            :      which is resolved in the direction of treating it as a typedef
<span class="lineNum">    3648 </span><span class="lineCov">   11282476 :      name.  If a close parenthesis follows, it is also an empty</span>
<span class="lineNum">    3649 </span>            :      parameter list, as the syntax does not permit empty abstract
<span class="lineNum">    3650 </span>            :      declarators.  Otherwise, it is a parenthesized declarator (in
<span class="lineNum">    3651 </span>            :      which case the analysis may be repeated inside it, recursively).
<span class="lineNum">    3652 </span><span class="lineCov">  167320296 : </span>
<span class="lineNum">    3653 </span>            :      ??? There is an ambiguity in a parameter declaration &quot;int
<span class="lineNum">    3654 </span>            :      (__attribute__((foo)) x)&quot;, where x is not a typedef name: it
<span class="lineNum">    3655 </span>            :      could be an abstract declarator for a function, or declare x with
<span class="lineNum">    3656 </span>            :      parentheses.  The proper resolution of this ambiguity needs
<span class="lineNum">    3657 </span>            :      documenting.  At present we follow an accident of the old
<span class="lineNum">    3658 </span>            :      parser's implementation, whereby the first parameter must have
<span class="lineNum">    3659 </span><span class="lineCov">  167320296 :      some declaration specifiers other than just attributes.  Thus as</span>
<span class="lineNum">    3660 </span>            :      a parameter declaration it is treated as a parenthesized
<span class="lineNum">    3661 </span>            :      parameter named x, and as an abstract declarator it is
<span class="lineNum">    3662 </span>            :      rejected.
<span class="lineNum">    3663 </span>            : 
<span class="lineNum">    3664 </span>            :      ??? Also following the old parser, attributes inside an empty
<span class="lineNum">    3665 </span>            :      parameter list are ignored, making it a list not yielding a
<span class="lineNum">    3666 </span>            :      prototype, rather than giving an error or making it have one
<span class="lineNum">    3667 </span>            :      parameter with implicit type int.
<span class="lineNum">    3668 </span>            : 
<span class="lineNum">    3669 </span>            :      ??? Also following the old parser, typedef names may be
<span class="lineNum">    3670 </span>            :      redeclared in declarators, but not Objective-C class names.  */
<span class="lineNum">    3671 </span>            : 
<span class="lineNum">    3672 </span>            :   if (kind != C_DTR_ABSTRACT
<span class="lineNum">    3673 </span>            :       &amp;&amp; c_parser_next_token_is (parser, CPP_NAME)
<span class="lineNum">    3674 </span>            :       &amp;&amp; ((type_seen_p
<span class="lineNum">    3675 </span>            :            &amp;&amp; (c_parser_peek_token (parser)-&gt;id_kind == C_ID_TYPENAME
<span class="lineNum">    3676 </span>            :                || c_parser_peek_token (parser)-&gt;id_kind == C_ID_CLASSNAME))
<span class="lineNum">    3677 </span>            :           || c_parser_peek_token (parser)-&gt;id_kind == C_ID_ID))
<span class="lineNum">    3678 </span>            :     {
<span class="lineNum">    3679 </span>            :       struct c_declarator *inner
<span class="lineNum">    3680 </span>            :         = build_id_declarator (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">    3681 </span>            :       *seen_id = true;
<span class="lineNum">    3682 </span>            :       inner-&gt;id_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    3683 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    3684 </span>            :       return c_parser_direct_declarator_inner (parser, *seen_id, inner);
<span class="lineNum">    3685 </span>            :     }
<span class="lineNum">    3686 </span>            : 
<span class="lineNum">    3687 </span>            :   if (kind != C_DTR_NORMAL
<span class="lineNum">    3688 </span>            :       &amp;&amp; c_parser_next_token_is (parser, CPP_OPEN_SQUARE))
<span class="lineNum">    3689 </span>            :     {
<span class="lineNum">    3690 </span>            :       struct c_declarator *inner = build_id_declarator (NULL_TREE);
<span class="lineNum">    3691 </span>            :       inner-&gt;id_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    3692 </span>            :       return c_parser_direct_declarator_inner (parser, *seen_id, inner);
<span class="lineNum">    3693 </span>            :     }
<span class="lineNum">    3694 </span>            : 
<span class="lineNum">    3695 </span>            :   /* Either we are at the end of an abstract declarator, or we have
<span class="lineNum">    3696 </span><span class="lineCov">  167320296 :      parentheses.  */</span>
<span class="lineNum">    3697 </span><span class="lineCov">  102820201 : </span>
<span class="lineNum">    3698 </span><span class="lineCov">  266515486 :   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))</span>
<span class="lineNum">    3699 </span><span class="lineCov">   99181538 :     {</span>
<span class="lineNum">    3700 </span><span class="lineCov">   99117193 :       tree attrs;</span>
<span class="lineNum">    3701 </span><span class="lineCov">   99130845 :       struct c_declarator *inner;</span>
<span class="lineNum">    3702 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    3703 </span><span class="lineCov">   99195190 :       attrs = c_parser_attributes (parser);</span>
<span class="lineNum">    3704 </span><span class="lineCov">   99195190 :       if (kind != C_DTR_NORMAL</span>
<span class="lineNum">    3705 </span><span class="lineCov">   99195190 :           &amp;&amp; (c_parser_next_token_starts_declspecs (parser)</span>
<span class="lineNum">    3706 </span><span class="lineCov">   99195190 :               || c_parser_next_token_is (parser, CPP_CLOSE_PAREN)))</span>
<span class="lineNum">    3707 </span><span class="lineCov">   99195190 :         {</span>
<span class="lineNum">    3708 </span><span class="lineCov">   99195190 :           struct c_arg_info *args</span>
<span class="lineNum">    3709 </span>            :             = c_parser_parms_declarator (parser, kind == C_DTR_NORMAL,
<span class="lineNum">    3710 </span>            :                                          attrs);
<span class="lineNum">    3711 </span><span class="lineCov">   68125106 :           if (args == NULL)</span>
<span class="lineNum">    3712 </span><span class="lineCov">   68125106 :             return NULL;</span>
<span class="lineNum">    3713 </span>            :           else
<span class="lineNum">    3714 </span><span class="lineCov">        584 :             {</span>
<span class="lineNum">    3715 </span><span class="lineCov">        584 :               inner</span>
<span class="lineNum">    3716 </span><span class="lineCov">        584 :                 = build_function_declarator (args,</span>
<span class="lineNum">    3717 </span>            :                                              build_id_declarator (NULL_TREE));
<span class="lineNum">    3718 </span>            :               return c_parser_direct_declarator_inner (parser, *seen_id,
<span class="lineNum">    3719 </span>            :                                                        inner);
<span class="lineNum">    3720 </span>            :             }
<span class="lineNum">    3721 </span>            :         }
<span class="lineNum">    3722 </span><span class="lineCov">   68124522 :       /* A parenthesized declarator.  */</span>
<span class="lineNum">    3723 </span>            :       inner = c_parser_declarator (parser, type_seen_p, kind, seen_id);
<span class="lineNum">    3724 </span><span class="lineCov">     169213 :       if (inner != NULL &amp;&amp; attrs != NULL)</span>
<span class="lineNum">    3725 </span><span class="lineCov">     169213 :         inner = build_attrs_declarator (attrs, inner);</span>
<span class="lineNum">    3726 </span><span class="lineCov">     169213 :       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))</span>
<span class="lineNum">    3727 </span><span class="lineCov">     169213 :         {</span>
<span class="lineNum">    3728 </span><span class="lineCov">     169213 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    3729 </span><span class="lineCov">     169213 :           if (inner == NULL)</span>
<span class="lineNum">    3730 </span><span class="lineCov">      55259 :             return NULL;</span>
<span class="lineNum">    3731 </span>            :           else
<span class="lineNum">    3732 </span><span class="lineCov">         37 :             return c_parser_direct_declarator_inner (parser, *seen_id, inner);</span>
<span class="lineNum">    3733 </span><span class="lineCov">         37 :         }</span>
<span class="lineNum">    3734 </span>            :       else
<span class="lineNum">    3735 </span><span class="lineCov">         37 :         {</span>
<span class="lineNum">    3736 </span>            :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,
<span class="lineNum">    3737 </span>            :                                      &quot;expected %&lt;)%&gt;&quot;);
<span class="lineNum">    3738 </span>            :           return NULL;
<span class="lineNum">    3739 </span><span class="lineCov">         37 :         }</span>
<span class="lineNum">    3740 </span><span class="lineCov">         37 :     }</span>
<span class="lineNum">    3741 </span>            :   else
<span class="lineNum">    3742 </span><span class="lineCov">         37 :     {</span>
<span class="lineNum">    3743 </span><span class="lineCov">         37 :       if (kind == C_DTR_NORMAL)</span>
<span class="lineNum">    3744 </span>            :         {
<span class="lineNum">    3745 </span>            :           c_parser_error (parser, &quot;expected identifier or %&lt;(%&gt;&quot;);
<span class="lineNum">    3746 </span>            :           return NULL;
<span class="lineNum">    3747 </span><span class="lineCov">     169176 :         }</span>
<span class="lineNum">    3748 </span><span class="lineCov">     169176 :       else</span>
<span class="lineNum">    3749 </span><span class="lineCov">         23 :         return build_id_declarator (NULL_TREE);</span>
<span class="lineNum">    3750 </span><span class="lineCov">     169176 :     }</span>
<span class="lineNum">    3751 </span>            : }
<span class="lineNum">    3752 </span><span class="lineCov">     169166 : </span>
<span class="lineNum">    3753 </span><span class="lineCov">     169166 : /* Parse part of a direct declarator or direct abstract declarator,</span>
<span class="lineNum">    3754 </span>            :    given that some (in INNER) has already been parsed; ID_PRESENT is
<span class="lineNum">    3755 </span>            :    true if an identifier is present, false for an abstract
<span class="lineNum">    3756 </span><span class="lineCov">     169166 :    declarator.  */</span>
<a name="3757"><span class="lineNum">    3757 </span>            : </a>
<span class="lineNum">    3758 </span>            : static struct c_declarator *
<span class="lineNum">    3759 </span>            : c_parser_direct_declarator_inner (c_parser *parser, bool id_present,
<span class="lineNum">    3760 </span><span class="lineCov">         10 :                                   struct c_declarator *inner)</span>
<span class="lineNum">    3761 </span>            : {
<span class="lineNum">    3762 </span><span class="lineCov">         10 :   /* Parse a sequence of array declarators and parameter lists.  */</span>
<span class="lineNum">    3763 </span>            :   if (c_parser_next_token_is (parser, CPP_OPEN_SQUARE))
<span class="lineNum">    3764 </span>            :     {
<span class="lineNum">    3765 </span>            :       location_t brace_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    3766 </span>            :       struct c_declarator *declarator;
<span class="lineNum">    3767 </span><span class="lineCov">   67955309 :       struct c_declspecs *quals_attrs = build_null_declspecs ();</span>
<span class="lineNum">    3768 </span>            :       bool static_seen;
<span class="lineNum">    3769 </span><span class="lineCov">         48 :       bool star_seen;</span>
<span class="lineNum">    3770 </span><span class="lineCov">         48 :       struct c_expr dimen;</span>
<span class="lineNum">    3771 </span>            :       dimen.value = NULL_TREE;
<span class="lineNum">    3772 </span>            :       dimen.original_code = ERROR_MARK;
<span class="lineNum">    3773 </span><span class="lineCov">   67955261 :       dimen.original_type = NULL_TREE;</span>
<span class="lineNum">    3774 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    3775 </span>            :       c_parser_declspecs (parser, quals_attrs, false, false, true,
<span class="lineNum">    3776 </span>            :                           false, false, cla_prefer_id);
<span class="lineNum">    3777 </span>            :       static_seen = c_parser_next_token_is_keyword (parser, RID_STATIC);
<span class="lineNum">    3778 </span>            :       if (static_seen)
<span class="lineNum">    3779 </span>            :         c_parser_consume_token (parser);
<span class="lineNum">    3780 </span>            :       if (static_seen &amp;&amp; !quals_attrs-&gt;declspecs_seen_p)
<span class="lineNum">    3781 </span>            :         c_parser_declspecs (parser, quals_attrs, false, false, true,
<span class="lineNum">    3782 </span>            :                             false, false, cla_prefer_id);
<span class="lineNum">    3783 </span><span class="lineCov">  127436646 :       if (!quals_attrs-&gt;declspecs_seen_p)</span>
<span class="lineNum">    3784 </span>            :         quals_attrs = NULL;
<span class="lineNum">    3785 </span>            :       /* If &quot;static&quot; is present, there must be an array dimension.
<span class="lineNum">    3786 </span>            :          Otherwise, there may be a dimension, &quot;*&quot;, or no
<span class="lineNum">    3787 </span><span class="lineCov">  127436646 :          dimension.  */</span>
<span class="lineNum">    3788 </span>            :       if (static_seen)
<span class="lineNum">    3789 </span><span class="lineCov">     695256 :         {</span>
<span class="lineNum">    3790 </span><span class="lineCov">     695256 :           star_seen = false;</span>
<span class="lineNum">    3791 </span><span class="lineCov">     695256 :           dimen = c_parser_expr_no_commas (parser, NULL);</span>
<span class="lineNum">    3792 </span><span class="lineCov">     695256 :         }</span>
<span class="lineNum">    3793 </span><span class="lineCov">     695256 :       else</span>
<span class="lineNum">    3794 </span><span class="lineCov">     695256 :         {</span>
<span class="lineNum">    3795 </span><span class="lineCov">     695256 :           if (c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))</span>
<span class="lineNum">    3796 </span><span class="lineCov">     695256 :             {</span>
<span class="lineNum">    3797 </span><span class="lineCov">     695256 :               dimen.value = NULL_TREE;</span>
<span class="lineNum">    3798 </span><span class="lineCov">     695256 :               star_seen = false;</span>
<span class="lineNum">    3799 </span><span class="lineCov">     695256 :             }</span>
<span class="lineNum">    3800 </span>            :           else if (c_parser_next_token_is (parser, CPP_MULT))
<span class="lineNum">    3801 </span><span class="lineCov">     695256 :             {</span>
<span class="lineNum">    3802 </span><span class="lineCov">     695256 :               if (c_parser_peek_2nd_token (parser)-&gt;type == CPP_CLOSE_SQUARE)</span>
<span class="lineNum">    3803 </span><span class="lineCov">         32 :                 {</span>
<span class="lineNum">    3804 </span><span class="lineCov">     695256 :                   dimen.value = NULL_TREE;</span>
<span class="lineNum">    3805 </span><span class="lineCov">         26 :                   star_seen = true;</span>
<span class="lineNum">    3806 </span>            :                   c_parser_consume_token (parser);
<span class="lineNum">    3807 </span><span class="lineCov">     695256 :                 }</span>
<span class="lineNum">    3808 </span><span class="lineCov">     695219 :               else</span>
<span class="lineNum">    3809 </span>            :                 {
<span class="lineNum">    3810 </span>            :                   star_seen = false;
<span class="lineNum">    3811 </span>            :                   dimen = c_parser_expr_no_commas (parser, NULL);
<span class="lineNum">    3812 </span><span class="lineCov">     695256 :                 }</span>
<span class="lineNum">    3813 </span>            :             }
<span class="lineNum">    3814 </span><span class="lineCov">         32 :           else</span>
<span class="lineNum">    3815 </span><span class="lineCov">         32 :             {</span>
<span class="lineNum">    3816 </span>            :               star_seen = false;
<span class="lineNum">    3817 </span>            :               dimen = c_parser_expr_no_commas (parser, NULL);
<span class="lineNum">    3818 </span>            :             }
<span class="lineNum">    3819 </span><span class="lineCov">     695224 :         }</span>
<span class="lineNum">    3820 </span>            :       if (c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))
<span class="lineNum">    3821 </span>            :         c_parser_consume_token (parser);
<span class="lineNum">    3822 </span>            :       else
<span class="lineNum">    3823 </span>            :         {
<span class="lineNum">    3824 </span><span class="lineCov">     590495 :           c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,</span>
<span class="lineNum">    3825 </span>            :                                      &quot;expected %&lt;]%&gt;&quot;);
<span class="lineNum">    3826 </span><span class="lineCov">         69 :           return NULL;</span>
<span class="lineNum">    3827 </span>            :         }
<span class="lineNum">    3828 </span><span class="lineCov">         36 :       if (dimen.value)</span>
<span class="lineNum">    3829 </span><span class="lineCov">         36 :         dimen = convert_lvalue_to_rvalue (brace_loc, dimen, true, true);</span>
<span class="lineNum">    3830 </span><span class="lineCov">         36 :       declarator = build_array_declarator (brace_loc, dimen.value, quals_attrs,</span>
<span class="lineNum">    3831 </span>            :                                            static_seen, star_seen);
<span class="lineNum">    3832 </span>            :       if (declarator == NULL)
<span class="lineNum">    3833 </span>            :         return NULL;
<span class="lineNum">    3834 </span><span class="lineCov">         33 :       inner = set_array_declarator_inner (declarator, inner);</span>
<span class="lineNum">    3835 </span><span class="lineCov">         33 :       return c_parser_direct_declarator_inner (parser, id_present, inner);</span>
<span class="lineNum">    3836 </span>            :     }
<span class="lineNum">    3837 </span>            :   else if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))
<span class="lineNum">    3838 </span>            :     {
<span class="lineNum">    3839 </span>            :       tree attrs;
<span class="lineNum">    3840 </span><span class="lineCov">     590426 :       struct c_arg_info *args;</span>
<span class="lineNum">    3841 </span><span class="lineCov">     590426 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    3842 </span>            :       attrs = c_parser_attributes (parser);
<span class="lineNum">    3843 </span>            :       args = c_parser_parms_declarator (parser, id_present, attrs);
<span class="lineNum">    3844 </span><span class="lineCov">     695256 :       if (args == NULL)</span>
<span class="lineNum">    3845 </span><span class="lineCov">     695242 :         return NULL;</span>
<span class="lineNum">    3846 </span>            :       else
<span class="lineNum">    3847 </span>            :         {
<span class="lineNum">    3848 </span><span class="lineCov">         14 :           inner = build_function_declarator (args, inner);</span>
<span class="lineNum">    3849 </span>            :           return c_parser_direct_declarator_inner (parser, id_present, inner);
<span class="lineNum">    3850 </span><span class="lineCov">         14 :         }</span>
<span class="lineNum">    3851 </span>            :     }
<span class="lineNum">    3852 </span><span class="lineCov">     695242 :   return inner;</span>
<span class="lineNum">    3853 </span><span class="lineCov">     590477 : }</span>
<span class="lineNum">    3854 </span><span class="lineCov">     695242 : </span>
<span class="lineNum">    3855 </span>            : /* Parse a parameter list or identifier list, including the closing
<span class="lineNum">    3856 </span><span class="lineCov">     695242 :    parenthesis but not the opening one.  ATTRS are the attributes at</span>
<span class="lineNum">    3857 </span>            :    the start of the list.  ID_LIST_OK is true if an identifier list is
<span class="lineNum">    3858 </span><span class="lineCov">     695238 :    acceptable; such a list must not have attributes at the start.  */</span>
<a name="3859"><span class="lineNum">    3859 </span><span class="lineCov">     695238 : </span></a>
<span class="lineNum">    3860 </span>            : static struct c_arg_info *
<span class="lineNum">    3861 </span><span class="lineCov">  126741390 : c_parser_parms_declarator (c_parser *parser, bool id_list_ok, tree attrs)</span>
<span class="lineNum">    3862 </span>            : {
<span class="lineNum">    3863 </span><span class="lineCov">   27376537 :   push_scope ();</span>
<span class="lineNum">    3864 </span><span class="lineCov">   27376537 :   declare_parm_level ();</span>
<span class="lineNum">    3865 </span><span class="lineCov">   27376537 :   /* If the list starts with an identifier, it is an identifier list.</span>
<span class="lineNum">    3866 </span><span class="lineCov">   27376537 :      Otherwise, it is either a prototype list or an empty list.  */</span>
<span class="lineNum">    3867 </span><span class="lineCov">   27376537 :   if (id_list_ok</span>
<span class="lineNum">    3868 </span><span class="lineCov">   27376537 :       &amp;&amp; !attrs</span>
<span class="lineNum">    3869 </span>            :       &amp;&amp; c_parser_next_token_is (parser, CPP_NAME)
<span class="lineNum">    3870 </span>            :       &amp;&amp; c_parser_peek_token (parser)-&gt;id_kind == C_ID_ID
<span class="lineNum">    3871 </span>            :       
<span class="lineNum">    3872 </span><span class="lineCov">   27376431 :       /* Look ahead to detect typos in type names.  */</span>
<span class="lineNum">    3873 </span><span class="lineCov">   27376431 :       &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type != CPP_NAME</span>
<span class="lineNum">    3874 </span>            :       &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type != CPP_MULT
<span class="lineNum">    3875 </span>            :       &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type != CPP_OPEN_PAREN
<span class="lineNum">    3876 </span>            :       &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type != CPP_OPEN_SQUARE
<span class="lineNum">    3877 </span>            :       &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type != CPP_KEYWORD)
<span class="lineNum">    3878 </span>            :     {
<span class="lineNum">    3879 </span>            :       tree list = NULL_TREE, *nextp = &amp;list;
<span class="lineNum">    3880 </span>            :       while (c_parser_next_token_is (parser, CPP_NAME)
<span class="lineNum">    3881 </span>            :              &amp;&amp; c_parser_peek_token (parser)-&gt;id_kind == C_ID_ID)
<span class="lineNum">    3882 </span>            :         {
<span class="lineNum">    3883 </span>            :           *nextp = build_tree_list (NULL_TREE,
<span class="lineNum">    3884 </span>            :                                     c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">    3885 </span><span class="lineCov">   27376574 :           nextp = &amp; TREE_CHAIN (*nextp);</span>
<span class="lineNum">    3886 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    3887 </span><span class="lineCov">   27376574 :           if (c_parser_next_token_is_not (parser, CPP_COMMA))</span>
<span class="lineNum">    3888 </span><span class="lineCov">   27376574 :             break;</span>
<span class="lineNum">    3889 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    3890 </span>            :           if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))
<span class="lineNum">    3891 </span><span class="lineCov">   27376574 :             {</span>
<span class="lineNum">    3892 </span><span class="lineCov">   27376574 :               c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">    3893 </span><span class="lineCov">   27368992 :               break;</span>
<span class="lineNum">    3894 </span><span class="lineCov">   17503935 :             }</span>
<span class="lineNum">    3895 </span>            :         }
<span class="lineNum">    3896 </span>            :       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))
<span class="lineNum">    3897 </span><span class="lineCov">       8691 :         {</span>
<span class="lineNum">    3898 </span><span class="lineCov">       8682 :           struct c_arg_info *ret = build_arg_info ();</span>
<span class="lineNum">    3899 </span><span class="lineCov">       8681 :           ret-&gt;types = list;</span>
<span class="lineNum">    3900 </span><span class="lineCov">       8680 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    3901 </span><span class="lineCov">   27385253 :           pop_scope ();</span>
<span class="lineNum">    3902 </span>            :           return ret;
<span class="lineNum">    3903 </span><span class="lineCov">       8678 :         }</span>
<span class="lineNum">    3904 </span><span class="lineCov">      34203 :       else</span>
<span class="lineNum">    3905 </span><span class="lineCov">      34203 :         {</span>
<span class="lineNum">    3906 </span>            :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,
<span class="lineNum">    3907 </span><span class="lineCov">      34203 :                                      &quot;expected %&lt;)%&gt;&quot;);</span>
<span class="lineNum">    3908 </span><span class="lineCov">      34203 :           pop_scope ();</span>
<span class="lineNum">    3909 </span><span class="lineCov">      34203 :           return NULL;</span>
<span class="lineNum">    3910 </span><span class="lineCov">      34203 :         }</span>
<span class="lineNum">    3911 </span><span class="lineCov">      34203 :     }</span>
<span class="lineNum">    3912 </span>            :   else
<span class="lineNum">    3913 </span><span class="lineCov">      25525 :     {</span>
<span class="lineNum">    3914 </span><span class="lineCov">      25525 :       struct c_arg_info *ret = c_parser_parms_list_declarator (parser, attrs,</span>
<span class="lineNum">    3915 </span>            :                                                                NULL);
<span class="lineNum">    3916 </span><span class="lineNoCov">          0 :       pop_scope ();</span>
<span class="lineNum">    3917 </span><span class="lineNoCov">          0 :       return ret;</span>
<span class="lineNum">    3918 </span>            :     }
<span class="lineNum">    3919 </span>            : }
<span class="lineNum">    3920 </span><span class="lineCov">       8678 : </span>
<span class="lineNum">    3921 </span>            : /* Parse a parameter list (possibly empty), including the closing
<span class="lineNum">    3922 </span><span class="lineCov">       8678 :    parenthesis but not the opening one.  ATTRS are the attributes at</span>
<span class="lineNum">    3923 </span><span class="lineCov">       8678 :    the start of the list.  EXPR is NULL or an expression that needs to</span>
<span class="lineNum">    3924 </span><span class="lineCov">       8678 :    be evaluated for the side effects of array size expressions in the</span>
<span class="lineNum">    3925 </span><span class="lineCov">       8678 :    parameters.  */</span>
<a name="3926"><span class="lineNum">    3926 </span><span class="lineCov">       8678 : </span></a>
<span class="lineNum">    3927 </span>            : static struct c_arg_info *
<span class="lineNum">    3928 </span>            : c_parser_parms_list_declarator (c_parser *parser, tree attrs, tree expr)
<span class="lineNum">    3929 </span>            : {
<span class="lineNum">    3930 </span><span class="lineNoCov">          0 :   bool bad_parm = false;</span>
<span class="lineNum">    3931 </span>            : 
<span class="lineNum">    3932 </span><span class="lineNoCov">          0 :   /* ??? Following the old parser, forward parameter declarations may</span>
<span class="lineNum">    3933 </span><span class="lineNoCov">          0 :      use abstract declarators, and if no real parameter declarations</span>
<span class="lineNum">    3934 </span>            :      follow the forward declarations then this is not diagnosed.  Also
<span class="lineNum">    3935 </span>            :      note as above that attributes are ignored as the only contents of
<span class="lineNum">    3936 </span>            :      the parentheses, or as the only contents after forward
<span class="lineNum">    3937 </span>            :      declarations.  */
<span class="lineNum">    3938 </span><span class="lineCov">   27367896 :   if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))</span>
<span class="lineNum">    3939 </span>            :     {
<span class="lineNum">    3940 </span><span class="lineCov">   27367896 :       struct c_arg_info *ret = build_arg_info ();</span>
<span class="lineNum">    3941 </span><span class="lineCov">   27367896 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    3942 </span>            :       return ret;
<span class="lineNum">    3943 </span>            :     }
<span class="lineNum">    3944 </span>            :   if (c_parser_next_token_is (parser, CPP_ELLIPSIS))
<span class="lineNum">    3945 </span>            :     {
<span class="lineNum">    3946 </span>            :       struct c_arg_info *ret = build_arg_info ();
<span class="lineNum">    3947 </span>            : 
<span class="lineNum">    3948 </span>            :       if (flag_allow_parameterless_variadic_functions)
<span class="lineNum">    3949 </span>            :         {
<span class="lineNum">    3950 </span>            :           /* F (...) is allowed.  */
<span class="lineNum">    3951 </span>            :           ret-&gt;types = NULL_TREE;
<span class="lineNum">    3952 </span><span class="lineCov">   27367932 :         }</span>
<span class="lineNum">    3953 </span>            :       else
<span class="lineNum">    3954 </span><span class="lineCov">   27367932 :         {</span>
<span class="lineNum">    3955 </span>            :           /* Suppress -Wold-style-definition for this case.  */
<span class="lineNum">    3956 </span>            :           ret-&gt;types = error_mark_node;
<span class="lineNum">    3957 </span>            :           error_at (c_parser_peek_token (parser)-&gt;location,
<span class="lineNum">    3958 </span>            :                     &quot;ISO C requires a named argument before %&lt;...%&gt;&quot;);
<span class="lineNum">    3959 </span>            :         }
<span class="lineNum">    3960 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    3961 </span>            :       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))
<span class="lineNum">    3962 </span><span class="lineCov">   27367932 :         {</span>
<span class="lineNum">    3963 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    3964 </span><span class="lineCov">     743791 :           return ret;</span>
<span class="lineNum">    3965 </span><span class="lineCov">     743791 :         }</span>
<span class="lineNum">    3966 </span><span class="lineCov">     743791 :       else</span>
<span class="lineNum">    3967 </span>            :         {
<span class="lineNum">    3968 </span><span class="lineCov">   26624141 :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,</span>
<span class="lineNum">    3969 </span>            :                                      &quot;expected %&lt;)%&gt;&quot;);
<span class="lineNum">    3970 </span><span class="lineCov">          6 :           return NULL;</span>
<span class="lineNum">    3971 </span>            :         }
<span class="lineNum">    3972 </span><span class="lineCov">          6 :     }</span>
<span class="lineNum">    3973 </span>            :   /* Nonempty list of parameters, either terminated with semicolon
<span class="lineNum">    3974 </span>            :      (forward declarations; recurse) or with close parenthesis (normal
<span class="lineNum">    3975 </span><span class="lineCov">          1 :      function) or with &quot;, ... )&quot; (variadic function).  */</span>
<span class="lineNum">    3976 </span>            :   while (true)
<span class="lineNum">    3977 </span>            :     {
<span class="lineNum">    3978 </span>            :       /* Parse a parameter.  */
<span class="lineNum">    3979 </span>            :       struct c_parm *parm = c_parser_parameter_declaration (parser, attrs);
<span class="lineNum">    3980 </span><span class="lineCov">          5 :       attrs = NULL_TREE;</span>
<span class="lineNum">    3981 </span><span class="lineCov">          5 :       if (parm == NULL)</span>
<span class="lineNum">    3982 </span>            :         bad_parm = true;
<span class="lineNum">    3983 </span>            :       else
<span class="lineNum">    3984 </span><span class="lineCov">          6 :         push_parm_decl (parm, &amp;expr);</span>
<span class="lineNum">    3985 </span><span class="lineCov">          6 :       if (c_parser_next_token_is (parser, CPP_SEMICOLON))</span>
<span class="lineNum">    3986 </span>            :         {
<span class="lineNum">    3987 </span><span class="lineCov">          6 :           tree new_attrs;</span>
<span class="lineNum">    3988 </span><span class="lineCov">          6 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    3989 </span>            :           mark_forward_parm_decls ();
<span class="lineNum">    3990 </span>            :           new_attrs = c_parser_attributes (parser);
<span class="lineNum">    3991 </span>            :           return c_parser_parms_list_declarator (parser, new_attrs, expr);
<span class="lineNum">    3992 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    3993 </span>            :       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))
<span class="lineNum">    3994 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    3995 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    3996 </span>            :           if (bad_parm)
<span class="lineNum">    3997 </span>            :             return NULL;
<span class="lineNum">    3998 </span>            :           else
<span class="lineNum">    3999 </span>            :             return get_parm_info (false, expr);
<span class="lineNum">    4000 </span><span class="lineCov">   65083478 :         }</span>
<span class="lineNum">    4001 </span>            :       if (!c_parser_require (parser, CPP_COMMA,
<span class="lineNum">    4002 </span>            :                              &quot;expected %&lt;;%&gt;, %&lt;,%&gt; or %&lt;)%&gt;&quot;,
<span class="lineNum">    4003 </span><span class="lineCov">   65083478 :                              UNKNOWN_LOCATION, false))</span>
<span class="lineNum">    4004 </span><span class="lineCov">   65083478 :         {</span>
<span class="lineNum">    4005 </span><span class="lineCov">   65083478 :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);</span>
<span class="lineNum">    4006 </span>            :           return NULL;
<span class="lineNum">    4007 </span>            :         }
<span class="lineNum">    4008 </span><span class="lineCov">   65083369 :       if (c_parser_next_token_is (parser, CPP_ELLIPSIS))</span>
<span class="lineNum">    4009 </span><span class="lineCov">   65083478 :         {</span>
<span class="lineNum">    4010 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    4011 </span><span class="lineCov">         36 :           if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))</span>
<span class="lineNum">    4012 </span><span class="lineCov">         36 :             {</span>
<span class="lineNum">    4013 </span><span class="lineCov">         36 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    4014 </span><span class="lineCov">         36 :               if (bad_parm)</span>
<span class="lineNum">    4015 </span><span class="lineCov">         36 :                 return NULL;</span>
<span class="lineNum">    4016 </span>            :               else
<span class="lineNum">    4017 </span><span class="lineCov">   65083442 :                 return get_parm_info (true, expr);</span>
<span class="lineNum">    4018 </span>            :             }
<span class="lineNum">    4019 </span><span class="lineCov">   26490176 :           else</span>
<span class="lineNum">    4020 </span><span class="lineCov">   26490176 :             {</span>
<span class="lineNum">    4021 </span>            :               c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,
<span class="lineNum">    4022 </span>            :                                          &quot;expected %&lt;)%&gt;&quot;);
<span class="lineNum">    4023 </span><span class="lineCov">   26490093 :               return NULL;</span>
<span class="lineNum">    4024 </span>            :             }
<span class="lineNum">    4025 </span><span class="lineCov">   38593266 :         }</span>
<span class="lineNum">    4026 </span>            :     }
<span class="lineNum">    4027 </span>            : }
<span class="lineNum">    4028 </span>            : 
<span class="lineNum">    4029 </span><span class="lineCov">          8 : /* Parse a parameter declaration.  ATTRS are the attributes at the</span>
<span class="lineNum">    4030 </span><span class="lineCov">          8 :    start of the declaration if it is the first parameter.  */</span>
<a name="4031"><span class="lineNum">    4031 </span>            : </a>
<span class="lineNum">    4032 </span><span class="lineCov">   38593258 : static struct c_parm *</span>
<span class="lineNum">    4033 </span>            : c_parser_parameter_declaration (c_parser *parser, tree attrs)
<span class="lineNum">    4034 </span><span class="lineCov">     133915 : {</span>
<span class="lineNum">    4035 </span><span class="lineCov">     133915 :   struct c_declspecs *specs;</span>
<span class="lineNum">    4036 </span>            :   struct c_declarator *declarator;
<span class="lineNum">    4037 </span><span class="lineCov">     133908 :   tree prefix_attrs;</span>
<span class="lineNum">    4038 </span><span class="lineCov">     133908 :   tree postfix_attrs = NULL_TREE;</span>
<span class="lineNum">    4039 </span>            :   bool dummy = false;
<span class="lineNum">    4040 </span>            : 
<span class="lineNum">    4041 </span><span class="lineCov">     133900 :   /* Accept #pragmas between parameter declarations.  */</span>
<span class="lineNum">    4042 </span>            :   while (c_parser_next_token_is (parser, CPP_PRAGMA))
<span class="lineNum">    4043 </span>            :     c_parser_pragma (parser, pragma_param, NULL);
<span class="lineNum">    4044 </span>            : 
<span class="lineNum">    4045 </span><span class="lineCov">          7 :   if (!c_parser_next_token_starts_declspecs (parser))</span>
<span class="lineNum">    4046 </span>            :     {
<span class="lineNum">    4047 </span><span class="lineCov">          7 :       c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">    4048 </span>            :       if (parser-&gt;error)
<span class="lineNum">    4049 </span>            :         return NULL;
<span class="lineNum">    4050 </span>            :       c_parser_set_source_position_from_token (token);
<span class="lineNum">    4051 </span>            :       if (c_parser_next_tokens_start_typename (parser, cla_prefer_type))
<span class="lineNum">    4052 </span>            :         {
<span class="lineNum">    4053 </span>            :           auto_diagnostic_group d;
<span class="lineNum">    4054 </span>            :           name_hint hint = lookup_name_fuzzy (token-&gt;value,
<span class="lineNum">    4055 </span>            :                                               FUZZY_LOOKUP_TYPENAME,
<span class="lineNum">    4056 </span>            :                                               token-&gt;location);
<span class="lineNum">    4057 </span><span class="lineCov">   65083478 :           if (hint)</span>
<span class="lineNum">    4058 </span>            :             {
<span class="lineNum">    4059 </span><span class="lineCov">   65083478 :               gcc_rich_location richloc (token-&gt;location);</span>
<span class="lineNum">    4060 </span><span class="lineCov">   65083478 :               richloc.add_fixit_replace (hint.suggestion ());</span>
<span class="lineNum">    4061 </span><span class="lineCov">   65083478 :               error_at (&amp;richloc,</span>
<span class="lineNum">    4062 </span><span class="lineCov">   65083478 :                         &quot;unknown type name %qE; did you mean %qs?&quot;,</span>
<span class="lineNum">    4063 </span><span class="lineCov">   65083478 :                         token-&gt;value, hint.suggestion ());</span>
<span class="lineNum">    4064 </span>            :             }
<span class="lineNum">    4065 </span>            :           else
<span class="lineNum">    4066 </span><span class="lineCov">   65083480 :             error_at (token-&gt;location, &quot;unknown type name %qE&quot;, token-&gt;value);</span>
<span class="lineNum">    4067 </span><span class="lineCov">          2 :           parser-&gt;error = true;</span>
<span class="lineNum">    4068 </span>            :         }
<span class="lineNum">    4069 </span><span class="lineCov">   65083478 :       /* ??? In some Objective-C cases '...' isn't applicable so there</span>
<span class="lineNum">    4070 </span>            :          should be a different message.  */
<span class="lineNum">    4071 </span><span class="lineCov">         98 :       else</span>
<span class="lineNum">    4072 </span><span class="lineCov">         98 :         c_parser_error (parser,</span>
<span class="lineNum">    4073 </span>            :                         &quot;expected declaration specifiers or %&lt;...%&gt;&quot;);
<span class="lineNum">    4074 </span><span class="lineCov">         98 :       c_parser_skip_to_end_of_parameter (parser);</span>
<span class="lineNum">    4075 </span><span class="lineCov">         98 :       return NULL;</span>
<span class="lineNum">    4076 </span>            :     }
<span class="lineNum">    4077 </span><span class="lineCov">         83 : </span>
<span class="lineNum">    4078 </span><span class="lineCov">         83 :   location_t start_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    4079 </span>            : 
<span class="lineNum">    4080 </span><span class="lineCov">        166 :   specs = build_null_declspecs ();</span>
<span class="lineNum">    4081 </span><span class="lineCov">        166 :   if (attrs)</span>
<span class="lineNum">    4082 </span>            :     {
<span class="lineNum">    4083 </span><span class="lineCov">         60 :       declspecs_add_attrs (input_location, specs, attrs);</span>
<span class="lineNum">    4084 </span><span class="lineCov">         60 :       attrs = NULL_TREE;</span>
<span class="lineNum">    4085 </span><span class="lineCov">         60 :     }</span>
<span class="lineNum">    4086 </span>            :   c_parser_declspecs (parser, specs, true, true, true, true, false,
<span class="lineNum">    4087 </span>            :                       cla_nonabstract_decl);
<span class="lineNum">    4088 </span>            :   finish_declspecs (specs);
<span class="lineNum">    4089 </span>            :   pending_xref_error ();
<span class="lineNum">    4090 </span><span class="lineCov">         53 :   prefix_attrs = specs-&gt;attrs;</span>
<span class="lineNum">    4091 </span><span class="lineCov">         83 :   specs-&gt;attrs = NULL_TREE;</span>
<span class="lineNum">    4092 </span>            :   declarator = c_parser_declarator (parser,
<span class="lineNum">    4093 </span>            :                                     specs-&gt;typespec_kind != ctsk_none,
<span class="lineNum">    4094 </span>            :                                     C_DTR_PARM, &amp;dummy);
<span class="lineNum">    4095 </span>            :   if (declarator == NULL)
<span class="lineNum">    4096 </span><span class="lineCov">         15 :     {</span>
<span class="lineNum">    4097 </span>            :       c_parser_skip_until_found (parser, CPP_COMMA, NULL);
<span class="lineNum">    4098 </span><span class="lineCov">         98 :       return NULL;</span>
<span class="lineNum">    4099 </span><span class="lineCov">         98 :     }</span>
<span class="lineNum">    4100 </span>            :   if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))
<span class="lineNum">    4101 </span>            :     postfix_attrs = c_parser_attributes (parser);
<span class="lineNum">    4102 </span><span class="lineCov">   65083380 : </span>
<span class="lineNum">    4103 </span>            :   /* Generate a location for the parameter, ranging from the start of the
<span class="lineNum">    4104 </span><span class="lineCov">   65083380 :      initial token to the end of the final token.</span>
<span class="lineNum">    4105 </span><span class="lineCov">   65083380 : </span>
<span class="lineNum">    4106 </span>            :      If we have a identifier, then use it for the caret location, e.g.
<span class="lineNum">    4107 </span><span class="lineCov">        273 : </span>
<span class="lineNum">    4108 </span><span class="lineCov">        273 :        extern int callee (int one, int (*two)(int, int), float three);</span>
<span class="lineNum">    4109 </span>            :                                    ~~~~~~^~~~~~~~~~~~~~
<span class="lineNum">    4110 </span><span class="lineCov">   65083380 : </span>
<span class="lineNum">    4111 </span>            :      otherwise, reuse the start location for the caret location e.g.:
<span class="lineNum">    4112 </span><span class="lineCov">   65083380 : </span>
<span class="lineNum">    4113 </span><span class="lineCov">   65083380 :        extern int callee (int one, int (*)(int, int), float three);</span>
<span class="lineNum">    4114 </span><span class="lineCov">   65083380 :                                    ^~~~~~~~~~~~~~~~~</span>
<span class="lineNum">    4115 </span><span class="lineCov">   65083380 :   */</span>
<span class="lineNum">    4116 </span><span class="lineCov">  195250140 :   location_t end_loc = parser-&gt;last_token_location;</span>
<span class="lineNum">    4117 </span><span class="lineCov">   65083380 : </span>
<span class="lineNum">    4118 </span>            :   /* Find any cdk_id declarator; determine if we have an identifier.  */
<span class="lineNum">    4119 </span><span class="lineCov">   65083380 :   c_declarator *id_declarator = declarator;</span>
<span class="lineNum">    4120 </span>            :   while (id_declarator &amp;&amp; id_declarator-&gt;kind != cdk_id)
<span class="lineNum">    4121 </span><span class="lineCov">         11 :     id_declarator = id_declarator-&gt;declarator;</span>
<span class="lineNum">    4122 </span><span class="lineCov">         11 :   location_t caret_loc = (id_declarator-&gt;u.id</span>
<span class="lineNum">    4123 </span>            :                           ? id_declarator-&gt;id_loc
<span class="lineNum">    4124 </span><span class="lineCov">   65083369 :                           : start_loc);</span>
<span class="lineNum">    4125 </span><span class="lineCov">       7926 :   location_t param_loc = make_location (caret_loc, start_loc, end_loc);</span>
<span class="lineNum">    4126 </span>            : 
<span class="lineNum">    4127 </span>            :   return build_c_parm (specs, chainon (postfix_attrs, prefix_attrs),
<span class="lineNum">    4128 </span>            :                        declarator, param_loc);
<span class="lineNum">    4129 </span>            : }
<span class="lineNum">    4130 </span>            : 
<span class="lineNum">    4131 </span>            : /* Parse a string literal in an asm expression.  It should not be
<span class="lineNum">    4132 </span>            :    translated, and wide string literals are an error although
<span class="lineNum">    4133 </span>            :    permitted by the syntax.  This is a GNU extension.
<span class="lineNum">    4134 </span>            : 
<span class="lineNum">    4135 </span>            :    asm-string-literal:
<span class="lineNum">    4136 </span>            :      string-literal
<span class="lineNum">    4137 </span>            : 
<span class="lineNum">    4138 </span>            :    ??? At present, following the old parser, the caller needs to have
<span class="lineNum">    4139 </span>            :    set lex_untranslated_string to 1.  It would be better to follow the
<span class="lineNum">    4140 </span><span class="lineCov">   65083369 :    C++ parser rather than using this kludge.  */</span>
<a name="4141"><span class="lineNum">    4141 </span>            : </a>
<span class="lineNum">    4142 </span>            : static tree
<span class="lineNum">    4143 </span><span class="lineCov">   65083369 : c_parser_asm_string_literal (c_parser *parser)</span>
<span class="lineNum">    4144 </span><span class="lineCov">   73014127 : {</span>
<span class="lineNum">    4145 </span><span class="lineCov">    7930758 :   tree str;</span>
<span class="lineNum">    4146 </span><span class="lineCov">  130166738 :   int save_flag = warn_overlength_strings;</span>
<span class="lineNum">    4147 </span><span class="lineCov">   65083369 :   warn_overlength_strings = 0;</span>
<span class="lineNum">    4148 </span>            :   if (c_parser_next_token_is (parser, CPP_STRING))
<span class="lineNum">    4149 </span><span class="lineCov">   65083369 :     {</span>
<span class="lineNum">    4150 </span>            :       str = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    4151 </span><span class="lineCov">   65083369 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    4152 </span><span class="lineCov">   65083369 :     }</span>
<span class="lineNum">    4153 </span>            :   else if (c_parser_next_token_is (parser, CPP_WSTRING))
<span class="lineNum">    4154 </span>            :     {
<span class="lineNum">    4155 </span>            :       error_at (c_parser_peek_token (parser)-&gt;location,
<span class="lineNum">    4156 </span>            :                 &quot;wide string literal in %&lt;asm%&gt;&quot;);
<span class="lineNum">    4157 </span>            :       str = build_string (1, &quot;&quot;);
<span class="lineNum">    4158 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    4159 </span>            :     }
<span class="lineNum">    4160 </span>            :   else
<span class="lineNum">    4161 </span>            :     {
<span class="lineNum">    4162 </span>            :       c_parser_error (parser, &quot;expected string literal&quot;);
<span class="lineNum">    4163 </span>            :       str = NULL_TREE;
<span class="lineNum">    4164 </span>            :     }
<span class="lineNum">    4165 </span>            :   warn_overlength_strings = save_flag;
<span class="lineNum">    4166 </span>            :   return str;
<span class="lineNum">    4167 </span><span class="lineCov">    1382299 : }</span>
<span class="lineNum">    4168 </span>            : 
<span class="lineNum">    4169 </span><span class="lineCov">    1382299 : /* Parse a simple asm expression.  This is used in restricted</span>
<span class="lineNum">    4170 </span><span class="lineCov">    1382299 :    contexts, where a full expression with inputs and outputs does not</span>
<span class="lineNum">    4171 </span><span class="lineCov">    1382299 :    make sense.  This is a GNU extension.</span>
<span class="lineNum">    4172 </span><span class="lineCov">    1382299 : </span>
<span class="lineNum">    4173 </span>            :    simple-asm-expr:
<span class="lineNum">    4174 </span><span class="lineCov">    1382276 :      asm ( asm-string-literal )</span>
<span class="lineNum">    4175 </span><span class="lineCov">    1382276 : */</span>
<a name="4176"><span class="lineNum">    4176 </span>            : </a>
<span class="lineNum">    4177 </span><span class="lineCov">         23 : static tree</span>
<span class="lineNum">    4178 </span>            : c_parser_simple_asm_expr (c_parser *parser)
<span class="lineNum">    4179 </span><span class="lineCov">         10 : {</span>
<span class="lineNum">    4180 </span>            :   tree str;
<span class="lineNum">    4181 </span><span class="lineCov">         10 :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ASM));</span>
<span class="lineNum">    4182 </span><span class="lineCov">         10 :   /* ??? Follow the C++ parser rather than using the</span>
<span class="lineNum">    4183 </span>            :      lex_untranslated_string kludge.  */
<span class="lineNum">    4184 </span>            :   parser-&gt;lex_untranslated_string = true;
<span class="lineNum">    4185 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    4186 </span><span class="lineCov">         13 :   matching_parens parens;</span>
<span class="lineNum">    4187 </span><span class="lineCov">         13 :   if (!parens.require_open (parser))</span>
<span class="lineNum">    4188 </span>            :     {
<span class="lineNum">    4189 </span><span class="lineCov">    1382299 :       parser-&gt;lex_untranslated_string = false;</span>
<span class="lineNum">    4190 </span><span class="lineCov">    1382299 :       return NULL_TREE;</span>
<span class="lineNum">    4191 </span>            :     }
<span class="lineNum">    4192 </span>            :   str = c_parser_asm_string_literal (parser);
<span class="lineNum">    4193 </span>            :   parser-&gt;lex_untranslated_string = false;
<span class="lineNum">    4194 </span>            :   if (!parens.require_close (parser))
<span class="lineNum">    4195 </span>            :     {
<span class="lineNum">    4196 </span>            :       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
<span class="lineNum">    4197 </span>            :       return NULL_TREE;
<span class="lineNum">    4198 </span>            :     }
<span class="lineNum">    4199 </span>            :   return str;
<span class="lineNum">    4200 </span>            : }
<a name="4201"><span class="lineNum">    4201 </span>            : </a>
<span class="lineNum">    4202 </span><span class="lineCov">     563021 : static tree</span>
<span class="lineNum">    4203 </span>            : c_parser_attribute_any_word (c_parser *parser)
<span class="lineNum">    4204 </span><span class="lineCov">     563021 : {</span>
<span class="lineNum">    4205 </span><span class="lineCov">     563021 :   tree attr_name = NULL_TREE;</span>
<span class="lineNum">    4206 </span>            : 
<span class="lineNum">    4207 </span>            :   if (c_parser_next_token_is (parser, CPP_KEYWORD))
<span class="lineNum">    4208 </span><span class="lineCov">     563021 :     {</span>
<span class="lineNum">    4209 </span><span class="lineCov">     563021 :       /* ??? See comment above about what keywords are accepted here.  */</span>
<span class="lineNum">    4210 </span><span class="lineCov">    1126042 :       bool ok;</span>
<span class="lineNum">    4211 </span><span class="lineCov">     563021 :       switch (c_parser_peek_token (parser)-&gt;keyword)</span>
<span class="lineNum">    4212 </span>            :         {
<span class="lineNum">    4213 </span><span class="lineNoCov">          0 :         case RID_STATIC:</span>
<span class="lineNum">    4214 </span><span class="lineNoCov">          0 :         case RID_UNSIGNED:</span>
<span class="lineNum">    4215 </span>            :         case RID_LONG:
<span class="lineNum">    4216 </span><span class="lineCov">     563021 :         case RID_CONST:</span>
<span class="lineNum">    4217 </span><span class="lineCov">     563021 :         case RID_EXTERN:</span>
<span class="lineNum">    4218 </span><span class="lineCov">     563021 :         case RID_REGISTER:</span>
<span class="lineNum">    4219 </span>            :         case RID_TYPEDEF:
<span class="lineNum">    4220 </span><span class="lineCov">          1 :         case RID_SHORT:</span>
<span class="lineNum">    4221 </span><span class="lineCov">          1 :         case RID_INLINE:</span>
<span class="lineNum">    4222 </span>            :         case RID_NORETURN:
<span class="lineNum">    4223 </span>            :         case RID_VOLATILE:
<span class="lineNum">    4224 </span>            :         case RID_SIGNED:
<span class="lineNum">    4225 </span>            :         case RID_AUTO:
<span class="lineNum">    4226 </span>            :         case RID_RESTRICT:
<span class="lineNum">    4227 </span><span class="lineCov">   70042754 :         case RID_COMPLEX:</span>
<span class="lineNum">    4228 </span>            :         case RID_THREAD:
<span class="lineNum">    4229 </span><span class="lineCov">   70042754 :         case RID_INT:</span>
<span class="lineNum">    4230 </span>            :         case RID_CHAR:
<span class="lineNum">    4231 </span><span class="lineCov">   70042754 :         case RID_FLOAT:</span>
<span class="lineNum">    4232 </span>            :         case RID_DOUBLE:
<span class="lineNum">    4233 </span>            :         case RID_VOID:
<span class="lineNum">    4234 </span><span class="lineCov">     794758 :         case RID_DFLOAT32:</span>
<span class="lineNum">    4235 </span><span class="lineCov">     794758 :         case RID_DFLOAT64:</span>
<span class="lineNum">    4236 </span>            :         case RID_DFLOAT128:
<span class="lineNum">    4237 </span>            :         CASE_RID_FLOATN_NX:
<span class="lineNum">    4238 </span>            :         case RID_BOOL:
<span class="lineNum">    4239 </span>            :         case RID_FRACT:
<span class="lineNum">    4240 </span>            :         case RID_ACCUM:
<span class="lineNum">    4241 </span>            :         case RID_SAT:
<span class="lineNum">    4242 </span>            :         case RID_TRANSACTION_ATOMIC:
<span class="lineNum">    4243 </span>            :         case RID_TRANSACTION_CANCEL:
<span class="lineNum">    4244 </span>            :         case RID_ATOMIC:
<span class="lineNum">    4245 </span>            :         case RID_AUTO_TYPE:
<span class="lineNum">    4246 </span>            :         case RID_INT_N_0:
<span class="lineNum">    4247 </span>            :         case RID_INT_N_1:
<span class="lineNum">    4248 </span>            :         case RID_INT_N_2:
<span class="lineNum">    4249 </span>            :         case RID_INT_N_3:
<span class="lineNum">    4250 </span>            :           ok = true;
<span class="lineNum">    4251 </span>            :           break;
<span class="lineNum">    4252 </span>            :         default:
<span class="lineNum">    4253 </span>            :           ok = false;
<span class="lineNum">    4254 </span>            :           break;
<span class="lineNum">    4255 </span>            :         }
<span class="lineNum">    4256 </span>            :       if (!ok)
<span class="lineNum">    4257 </span>            :         return NULL_TREE;
<span class="lineNum">    4258 </span>            : 
<span class="lineNum">    4259 </span>            :       /* Accept __attribute__((__const)) as __attribute__((const)) etc.  */
<span class="lineNum">    4260 </span>            :       attr_name = ridpointers[(int) c_parser_peek_token (parser)-&gt;keyword];
<span class="lineNum">    4261 </span>            :     }
<span class="lineNum">    4262 </span>            :   else if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">    4263 </span>            :     attr_name = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    4264 </span>            : 
<span class="lineNum">    4265 </span>            :   return attr_name;
<span class="lineNum">    4266 </span>            : }
<span class="lineNum">    4267 </span>            : 
<span class="lineNum">    4268 </span>            : /* Parse (possibly empty) attributes.  This is a GNU extension.
<span class="lineNum">    4269 </span>            : 
<span class="lineNum">    4270 </span>            :    attributes:
<span class="lineNum">    4271 </span>            :      empty
<span class="lineNum">    4272 </span>            :      attributes attribute
<span class="lineNum">    4273 </span>            : 
<span class="lineNum">    4274 </span>            :    attribute:
<span class="lineNum">    4275 </span>            :      __attribute__ ( ( attribute-list ) )
<span class="lineNum">    4276 </span>            : 
<span class="lineNum">    4277 </span>            :    attribute-list:
<span class="lineNum">    4278 </span>            :      attrib
<span class="lineNum">    4279 </span>            :      attribute_list , attrib
<span class="lineNum">    4280 </span><span class="lineCov">     794758 : </span>
<span class="lineNum">    4281 </span>            :    attrib:
<span class="lineNum">    4282 </span>            :      empty
<span class="lineNum">    4283 </span>            :      any-word
<span class="lineNum">    4284 </span><span class="lineCov">     794758 :      any-word ( identifier )</span>
<span class="lineNum">    4285 </span>            :      any-word ( identifier , nonempty-expr-list )
<span class="lineNum">    4286 </span><span class="lineCov">   69247996 :      any-word ( expr-list )</span>
<span class="lineNum">    4287 </span><span class="lineCov">   69247996 : </span>
<span class="lineNum">    4288 </span>            :    where the &quot;identifier&quot; must not be declared as a type, and
<span class="lineNum">    4289 </span>            :    &quot;any-word&quot; may be any identifier (including one declared as a
<span class="lineNum">    4290 </span>            :    type), a reserved word storage class specifier, type specifier or
<span class="lineNum">    4291 </span>            :    type qualifier.  ??? This still leaves out most reserved keywords
<span class="lineNum">    4292 </span>            :    (following the old parser), shouldn't we include them, and why not
<span class="lineNum">    4293 </span>            :    allow identifiers declared as types to start the arguments?  */
<a name="4294"><span class="lineNum">    4294 </span>            : </a>
<span class="lineNum">    4295 </span>            : static tree
<span class="lineNum">    4296 </span>            : c_parser_attributes (c_parser *parser)
<span class="lineNum">    4297 </span>            : {
<span class="lineNum">    4298 </span>            :   tree attrs = NULL_TREE;
<span class="lineNum">    4299 </span>            :   while (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))
<span class="lineNum">    4300 </span>            :     {
<span class="lineNum">    4301 </span>            :       /* ??? Follow the C++ parser rather than using the
<span class="lineNum">    4302 </span>            :          lex_untranslated_string kludge.  */
<span class="lineNum">    4303 </span>            :       parser-&gt;lex_untranslated_string = true;
<span class="lineNum">    4304 </span>            :       /* Consume the `__attribute__' keyword.  */
<span class="lineNum">    4305 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    4306 </span>            :       /* Look for the two `(' tokens.  */
<span class="lineNum">    4307 </span>            :       if (!c_parser_require (parser, CPP_OPEN_PAREN, &quot;expected %&lt;(%&gt;&quot;))
<span class="lineNum">    4308 </span>            :         {
<span class="lineNum">    4309 </span>            :           parser-&gt;lex_untranslated_string = false;
<span class="lineNum">    4310 </span>            :           return attrs;
<span class="lineNum">    4311 </span>            :         }
<span class="lineNum">    4312 </span>            :       if (!c_parser_require (parser, CPP_OPEN_PAREN, &quot;expected %&lt;(%&gt;&quot;))
<span class="lineNum">    4313 </span>            :         {
<span class="lineNum">    4314 </span>            :           parser-&gt;lex_untranslated_string = false;
<span class="lineNum">    4315 </span>            :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
<span class="lineNum">    4316 </span>            :           return attrs;
<span class="lineNum">    4317 </span>            :         }
<span class="lineNum">    4318 </span>            :       /* Parse the attribute list.  */
<span class="lineNum">    4319 </span>            :       while (c_parser_next_token_is (parser, CPP_COMMA)
<span class="lineNum">    4320 </span><span class="lineCov">   60023540 :              || c_parser_next_token_is (parser, CPP_NAME)</span>
<span class="lineNum">    4321 </span>            :              || c_parser_next_token_is (parser, CPP_KEYWORD))
<span class="lineNum">    4322 </span><span class="lineCov">   60023540 :         {</span>
<span class="lineNum">    4323 </span><span class="lineCov">   88273816 :           tree attr, attr_name, attr_args;</span>
<span class="lineNum">    4324 </span>            :           vec&lt;tree, va_gc&gt; *expr_list;
<span class="lineNum">    4325 </span>            :           if (c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">    4326 </span>            :             {
<span class="lineNum">    4327 </span><span class="lineCov">   28250284 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    4328 </span>            :               continue;
<span class="lineNum">    4329 </span><span class="lineCov">   28250284 :             }</span>
<span class="lineNum">    4330 </span>            : 
<span class="lineNum">    4331 </span><span class="lineCov">   28250284 :           attr_name = c_parser_attribute_any_word (parser);</span>
<span class="lineNum">    4332 </span>            :           if (attr_name == NULL)
<span class="lineNum">    4333 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    4334 </span><span class="lineNoCov">          0 :           attr_name = canonicalize_attr_name (attr_name);</span>
<span class="lineNum">    4335 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    4336 </span><span class="lineCov">   28250284 :           if (c_parser_next_token_is_not (parser, CPP_OPEN_PAREN))</span>
<span class="lineNum">    4337 </span>            :             {
<span class="lineNum">    4338 </span><span class="lineNoCov">          0 :               attr = build_tree_list (attr_name, NULL_TREE);</span>
<span class="lineNum">    4339 </span><span class="lineNoCov">          0 :               /* Add this attribute to the list.  */</span>
<span class="lineNum">    4340 </span><span class="lineNoCov">          0 :               attrs = chainon (attrs, attr);</span>
<span class="lineNum">    4341 </span>            :               /* If the next token isn't a comma, we're done.  */
<span class="lineNum">    4342 </span>            :               if (!c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">    4343 </span><span class="lineCov">  111835230 :                 break;</span>
<span class="lineNum">    4344 </span><span class="lineCov">   70042752 :               continue;</span>
<span class="lineNum">    4345 </span><span class="lineCov">  112629998 :             }</span>
<span class="lineNum">    4346 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    4347 </span><span class="lineCov">  111835220 :           /* Parse the attribute contents.  If they start with an</span>
<span class="lineNum">    4348 </span><span class="lineCov">  111835220 :              identifier which is followed by a comma or close</span>
<span class="lineNum">    4349 </span><span class="lineCov">  111835220 :              parenthesis, then the arguments start with that</span>
<span class="lineNum">    4350 </span>            :              identifier; otherwise they are an expression list.  
<span class="lineNum">    4351 </span><span class="lineCov">   41792478 :              In objective-c the identifier may be a classname.  */</span>
<span class="lineNum">    4352 </span><span class="lineCov">   41792478 :           if (c_parser_next_token_is (parser, CPP_NAME)</span>
<span class="lineNum">    4353 </span>            :               &amp;&amp; (c_parser_peek_token (parser)-&gt;id_kind == C_ID_ID
<span class="lineNum">    4354 </span>            :                   || (c_dialect_objc ()
<span class="lineNum">    4355 </span><span class="lineCov">   70042742 :                       &amp;&amp; c_parser_peek_token (parser)-&gt;id_kind</span>
<span class="lineNum">    4356 </span><span class="lineCov">   70042742 :                          == C_ID_CLASSNAME))</span>
<span class="lineNum">    4357 </span>            :               &amp;&amp; ((c_parser_peek_2nd_token (parser)-&gt;type == CPP_COMMA)
<span class="lineNum">    4358 </span><span class="lineCov">   70042742 :                   || (c_parser_peek_2nd_token (parser)-&gt;type</span>
<span class="lineNum">    4359 </span><span class="lineCov">   70042742 :                       == CPP_CLOSE_PAREN))</span>
<span class="lineNum">    4360 </span><span class="lineCov">   70042742 :               &amp;&amp; (attribute_takes_identifier_p (attr_name)</span>
<span class="lineNum">    4361 </span>            :                   || (c_dialect_objc ()
<span class="lineNum">    4362 </span><span class="lineCov">   67695335 :                       &amp;&amp; c_parser_peek_token (parser)-&gt;id_kind</span>
<span class="lineNum">    4363 </span>            :                          == C_ID_CLASSNAME)))
<span class="lineNum">    4364 </span><span class="lineCov">   67695335 :             {</span>
<span class="lineNum">    4365 </span>            :               tree arg1 = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    4366 </span><span class="lineCov">   67695335 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    4367 </span>            :               if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))
<span class="lineNum">    4368 </span>            :                 attr_args = build_tree_list (NULL_TREE, arg1);
<span class="lineNum">    4369 </span>            :               else
<span class="lineNum">    4370 </span><span class="lineCov">    2347407 :                 {</span>
<span class="lineNum">    4371 </span>            :                   tree tree_list;
<span class="lineNum">    4372 </span>            :                   c_parser_consume_token (parser);
<span class="lineNum">    4373 </span>            :                   expr_list = c_parser_expr_list (parser, false, true,
<span class="lineNum">    4374 </span>            :                                                   NULL, NULL, NULL, NULL);
<span class="lineNum">    4375 </span>            :                   tree_list = build_tree_list_vec (expr_list);
<span class="lineNum">    4376 </span><span class="lineCov">    2347407 :                   attr_args = tree_cons (NULL_TREE, arg1, tree_list);</span>
<span class="lineNum">    4377 </span><span class="lineCov">     172331 :                   release_tree_vector (expr_list);</span>
<span class="lineNum">    4378 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    4379 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    4380 </span>            :           else
<span class="lineNum">    4381 </span><span class="lineCov">     172331 :             {</span>
<span class="lineNum">    4382 </span><span class="lineCov">      74460 :               if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))</span>
<span class="lineNum">    4383 </span>            :                 attr_args = NULL_TREE;
<span class="lineNum">    4384 </span><span class="lineCov">    2519736 :               else</span>
<span class="lineNum">    4385 </span><span class="lineCov">         42 :                 {</span>
<span class="lineNum">    4386 </span><span class="lineNoCov">          0 :                   expr_list = c_parser_expr_list (parser, false, true,</span>
<span class="lineNum">    4387 </span>            :                                                   NULL, NULL, NULL, NULL);
<span class="lineNum">    4388 </span>            :                   attr_args = build_tree_list_vec (expr_list);
<span class="lineNum">    4389 </span><span class="lineCov">     172287 :                   release_tree_vector (expr_list);</span>
<span class="lineNum">    4390 </span><span class="lineCov">     172287 :                 }</span>
<span class="lineNum">    4391 </span><span class="lineCov">     172287 :             }</span>
<span class="lineNum">    4392 </span><span class="lineCov">      74417 : </span>
<span class="lineNum">    4393 </span>            :           attr = build_tree_list (attr_name, attr_args);
<span class="lineNum">    4394 </span>            :           if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))
<span class="lineNum">    4395 </span><span class="lineCov">      97870 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    4396 </span><span class="lineCov">      97870 :           else</span>
<span class="lineNum">    4397 </span><span class="lineCov">      97870 :             {</span>
<span class="lineNum">    4398 </span>            :               parser-&gt;lex_untranslated_string = false;
<span class="lineNum">    4399 </span><span class="lineCov">      97870 :               c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,</span>
<span class="lineNum">    4400 </span><span class="lineCov">      97870 :                                          &quot;expected %&lt;)%&gt;&quot;);</span>
<span class="lineNum">    4401 </span><span class="lineCov">      97870 :               return attrs;</span>
<span class="lineNum">    4402 </span>            :             }
<span class="lineNum">    4403 </span>            :           /* Add this attribute to the list.  */
<span class="lineNum">    4404 </span>            :           attrs = chainon (attrs, attr);
<span class="lineNum">    4405 </span>            :           /* If the next token isn't a comma, we're done.  */
<span class="lineNum">    4406 </span><span class="lineCov">    2175120 :           if (!c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">    4407 </span>            :             break;
<span class="lineNum">    4408 </span>            :         }
<span class="lineNum">    4409 </span>            :       /* Look for the two `)' tokens.  */
<span class="lineNum">    4410 </span><span class="lineCov">    2175115 :       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))</span>
<span class="lineNum">    4411 </span>            :         c_parser_consume_token (parser);
<span class="lineNum">    4412 </span><span class="lineCov">    2175115 :       else</span>
<span class="lineNum">    4413 </span><span class="lineCov">    2175115 :         {</span>
<span class="lineNum">    4414 </span>            :           parser-&gt;lex_untranslated_string = false;
<span class="lineNum">    4415 </span>            :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,
<span class="lineNum">    4416 </span>            :                                      &quot;expected %&lt;)%&gt;&quot;);
<span class="lineNum">    4417 </span><span class="lineCov">    2347407 :           return attrs;</span>
<span class="lineNum">    4418 </span><span class="lineCov">    2347407 :         }</span>
<span class="lineNum">    4419 </span><span class="lineCov">    2347407 :       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))</span>
<span class="lineNum">    4420 </span>            :         c_parser_consume_token (parser);
<span class="lineNum">    4421 </span>            :       else
<span class="lineNum">    4422 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    4423 </span><span class="lineNoCov">          0 :           parser-&gt;lex_untranslated_string = false;</span>
<span class="lineNum">    4424 </span>            :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,
<span class="lineNum">    4425 </span><span class="lineNoCov">          0 :                                      &quot;expected %&lt;)%&gt;&quot;);</span>
<span class="lineNum">    4426 </span>            :           return attrs;
<span class="lineNum">    4427 </span>            :         }
<span class="lineNum">    4428 </span><span class="lineCov">    2347407 :       parser-&gt;lex_untranslated_string = false;</span>
<span class="lineNum">    4429 </span>            :     }
<span class="lineNum">    4430 </span><span class="lineCov">    2347407 : </span>
<span class="lineNum">    4431 </span>            :   return attrs;
<span class="lineNum">    4432 </span>            : }
<span class="lineNum">    4433 </span>            : 
<span class="lineNum">    4434 </span><span class="lineCov">   28250284 : /* Parse a type name (C90 6.5.5, C99 6.7.6, C11 6.7.7).  ALIGNAS_OK</span>
<span class="lineNum">    4435 </span><span class="lineCov">   28250277 :    says whether alignment specifiers are OK (only in cases that might</span>
<span class="lineNum">    4436 </span>            :    be the type name of a compound literal).
<span class="lineNum">    4437 </span>            : 
<span class="lineNum">    4438 </span><span class="lineCov">          7 :    type-name:</span>
<span class="lineNum">    4439 </span><span class="lineCov">          7 :      specifier-qualifier-list abstract-declarator[opt]</span>
<span class="lineNum">    4440 </span>            : */
<a name="4441"><span class="lineNum">    4441 </span><span class="lineCov">          7 : </span></a>
<span class="lineNum">    4442 </span>            : struct c_type_name *
<span class="lineNum">    4443 </span><span class="lineCov">   28250277 : c_parser_type_name (c_parser *parser, bool alignas_ok)</span>
<span class="lineNum">    4444 </span><span class="lineCov">   28250276 : {</span>
<span class="lineNum">    4445 </span>            :   struct c_declspecs *specs = build_null_declspecs ();
<span class="lineNum">    4446 </span>            :   struct c_declarator *declarator;
<span class="lineNum">    4447 </span><span class="lineCov">          1 :   struct c_type_name *ret;</span>
<span class="lineNum">    4448 </span><span class="lineCov">          1 :   bool dummy = false;</span>
<span class="lineNum">    4449 </span>            :   c_parser_declspecs (parser, specs, false, true, true, alignas_ok, false,
<span class="lineNum">    4450 </span><span class="lineCov">          1 :                       cla_prefer_type);</span>
<span class="lineNum">    4451 </span>            :   if (!specs-&gt;declspecs_seen_p)
<span class="lineNum">    4452 </span><span class="lineCov">   28250276 :     {</span>
<span class="lineNum">    4453 </span>            :       c_parser_error (parser, &quot;expected specifier-qualifier-list&quot;);
<span class="lineNum">    4454 </span>            :       return NULL;
<span class="lineNum">    4455 </span>            :     }
<span class="lineNum">    4456 </span>            :   if (specs-&gt;type != error_mark_node)
<span class="lineNum">    4457 </span>            :     {
<span class="lineNum">    4458 </span>            :       pending_xref_error ();
<span class="lineNum">    4459 </span>            :       finish_declspecs (specs);
<span class="lineNum">    4460 </span>            :     }
<span class="lineNum">    4461 </span>            :   declarator = c_parser_declarator (parser,
<span class="lineNum">    4462 </span>            :                                     specs-&gt;typespec_kind != ctsk_none,
<span class="lineNum">    4463 </span>            :                                     C_DTR_ABSTRACT, &amp;dummy);
<span class="lineNum">    4464 </span>            :   if (declarator == NULL)
<span class="lineNum">    4465 </span>            :     return NULL;
<span class="lineNum">    4466 </span>            :   ret = XOBNEW (&amp;parser_obstack, struct c_type_name);
<span class="lineNum">    4467 </span><span class="lineCov">   64497129 :   ret-&gt;specs = specs;</span>
<span class="lineNum">    4468 </span>            :   ret-&gt;declarator = declarator;
<span class="lineNum">    4469 </span><span class="lineCov">   64497129 :   return ret;</span>
<span class="lineNum">    4470 </span><span class="lineCov">   64497129 : }</span>
<span class="lineNum">    4471 </span><span class="lineCov">   64497129 : </span>
<span class="lineNum">    4472 </span><span class="lineCov">   64497129 : /* Parse an initializer (C90 6.5.7, C99 6.7.8, C11 6.7.9).</span>
<span class="lineNum">    4473 </span><span class="lineCov">   64497129 : </span>
<span class="lineNum">    4474 </span>            :    initializer:
<span class="lineNum">    4475 </span><span class="lineCov">   64497129 :      assignment-expression</span>
<span class="lineNum">    4476 </span>            :      { initializer-list }
<span class="lineNum">    4477 </span><span class="lineCov">          3 :      { initializer-list , }</span>
<span class="lineNum">    4478 </span><span class="lineCov">          3 : </span>
<span class="lineNum">    4479 </span>            :    initializer-list:
<span class="lineNum">    4480 </span><span class="lineCov">   64497126 :      designation[opt] initializer</span>
<span class="lineNum">    4481 </span>            :      initializer-list , designation[opt] initializer
<span class="lineNum">    4482 </span><span class="lineCov">   64497117 : </span>
<span class="lineNum">    4483 </span><span class="lineCov">   64497117 :    designation:</span>
<span class="lineNum">    4484 </span>            :      designator-list =
<span class="lineNum">    4485 </span><span class="lineCov">  193491378 : </span>
<span class="lineNum">    4486 </span><span class="lineCov">   64497126 :    designator-list:</span>
<span class="lineNum">    4487 </span>            :      designator
<span class="lineNum">    4488 </span><span class="lineCov">   64497126 :      designator-list designator</span>
<span class="lineNum">    4489 </span>            : 
<span class="lineNum">    4490 </span><span class="lineCov">   64497125 :    designator:</span>
<span class="lineNum">    4491 </span><span class="lineCov">   64497125 :      array-designator</span>
<span class="lineNum">    4492 </span><span class="lineCov">   64497125 :      . identifier</span>
<span class="lineNum">    4493 </span><span class="lineCov">   64497125 : </span>
<span class="lineNum">    4494 </span>            :    array-designator:
<span class="lineNum">    4495 </span>            :      [ constant-expression ]
<span class="lineNum">    4496 </span>            : 
<span class="lineNum">    4497 </span>            :    GNU extensions:
<span class="lineNum">    4498 </span>            : 
<span class="lineNum">    4499 </span>            :    initializer:
<span class="lineNum">    4500 </span>            :      { }
<span class="lineNum">    4501 </span>            : 
<span class="lineNum">    4502 </span>            :    designation:
<span class="lineNum">    4503 </span>            :      array-designator
<span class="lineNum">    4504 </span>            :      identifier :
<span class="lineNum">    4505 </span>            : 
<span class="lineNum">    4506 </span>            :    array-designator:
<span class="lineNum">    4507 </span>            :      [ constant-expression ... constant-expression ]
<span class="lineNum">    4508 </span>            : 
<span class="lineNum">    4509 </span>            :    Any expression without commas is accepted in the syntax for the
<span class="lineNum">    4510 </span>            :    constant-expressions, with non-constant expressions rejected later.
<span class="lineNum">    4511 </span>            : 
<span class="lineNum">    4512 </span>            :    This function is only used for top-level initializers; for nested
<span class="lineNum">    4513 </span>            :    ones, see c_parser_initval.  */
<a name="4514"><span class="lineNum">    4514 </span>            : </a>
<span class="lineNum">    4515 </span>            : static struct c_expr
<span class="lineNum">    4516 </span>            : c_parser_initializer (c_parser *parser)
<span class="lineNum">    4517 </span>            : {
<span class="lineNum">    4518 </span>            :   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))
<span class="lineNum">    4519 </span>            :     return c_parser_braced_init (parser, NULL_TREE, false, NULL);
<span class="lineNum">    4520 </span>            :   else
<span class="lineNum">    4521 </span>            :     {
<span class="lineNum">    4522 </span>            :       struct c_expr ret;
<span class="lineNum">    4523 </span>            :       location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    4524 </span>            :       ret = c_parser_expr_no_commas (parser, NULL);
<span class="lineNum">    4525 </span>            :       if (TREE_CODE (ret.value) != STRING_CST
<span class="lineNum">    4526 </span>            :           &amp;&amp; TREE_CODE (ret.value) != COMPOUND_LITERAL_EXPR)
<span class="lineNum">    4527 </span>            :         ret = convert_lvalue_to_rvalue (loc, ret, true, true);
<span class="lineNum">    4528 </span>            :       return ret;
<span class="lineNum">    4529 </span>            :     }
<span class="lineNum">    4530 </span>            : }
<span class="lineNum">    4531 </span>            : 
<span class="lineNum">    4532 </span>            : /* The location of the last comma within the current initializer list,
<span class="lineNum">    4533 </span>            :    or UNKNOWN_LOCATION if not within one.  */
<span class="lineNum">    4534 </span>            : 
<span class="lineNum">    4535 </span>            : location_t last_init_list_comma;
<span class="lineNum">    4536 </span>            : 
<span class="lineNum">    4537 </span>            : /* Parse a braced initializer list.  TYPE is the type specified for a
<span class="lineNum">    4538 </span>            :    compound literal, and NULL_TREE for other initializers and for
<span class="lineNum">    4539 </span>            :    nested braced lists.  NESTED_P is true for nested braced lists,
<span class="lineNum">    4540 </span><span class="lineCov">    1904593 :    false for the list of a compound literal or the list that is the</span>
<span class="lineNum">    4541 </span>            :    top-level initializer in a declaration.  */
<a name="4542"><span class="lineNum">    4542 </span><span class="lineCov">    1904593 : </span></a>
<span class="lineNum">    4543 </span><span class="lineCov">      19295 : static struct c_expr</span>
<span class="lineNum">    4544 </span>            : c_parser_braced_init (c_parser *parser, tree type, bool nested_p,
<span class="lineNum">    4545 </span>            :                       struct obstack *outer_obstack)
<span class="lineNum">    4546 </span><span class="lineCov">    1885298 : {</span>
<span class="lineNum">    4547 </span><span class="lineCov">    1885298 :   struct c_expr ret;</span>
<span class="lineNum">    4548 </span><span class="lineCov">    1885298 :   struct obstack braced_init_obstack;</span>
<span class="lineNum">    4549 </span><span class="lineCov">    1885296 :   location_t brace_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    4550 </span><span class="lineCov">    1877343 :   gcc_obstack_init (&amp;braced_init_obstack);</span>
<span class="lineNum">    4551 </span><span class="lineCov">    1818835 :   gcc_assert (c_parser_next_token_is (parser, CPP_OPEN_BRACE));</span>
<span class="lineNum">    4552 </span><span class="lineCov">    1885296 :   matching_braces braces;</span>
<span class="lineNum">    4553 </span>            :   braces.consume_open (parser);
<span class="lineNum">    4554 </span>            :   if (nested_p)
<span class="lineNum">    4555 </span>            :     {
<span class="lineNum">    4556 </span>            :       finish_implicit_inits (brace_loc, outer_obstack);
<span class="lineNum">    4557 </span>            :       push_init_level (brace_loc, 0, &amp;braced_init_obstack);
<span class="lineNum">    4558 </span>            :     }
<span class="lineNum">    4559 </span>            :   else
<span class="lineNum">    4560 </span>            :     really_start_incremental_init (type);
<span class="lineNum">    4561 </span>            :   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))
<span class="lineNum">    4562 </span>            :     {
<span class="lineNum">    4563 </span>            :       pedwarn (brace_loc, OPT_Wpedantic, &quot;ISO C forbids empty initializer braces&quot;);
<span class="lineNum">    4564 </span>            :     }
<span class="lineNum">    4565 </span>            :   else
<span class="lineNum">    4566 </span>            :     {
<span class="lineNum">    4567 </span>            :       /* Parse a non-empty initializer list, possibly with a trailing
<span class="lineNum">    4568 </span><span class="lineCov">     764980 :          comma.  */</span>
<span class="lineNum">    4569 </span>            :       while (true)
<span class="lineNum">    4570 </span>            :         {
<span class="lineNum">    4571 </span><span class="lineCov">     764980 :           c_parser_initelt (parser, &amp;braced_init_obstack);</span>
<span class="lineNum">    4572 </span><span class="lineCov">     764980 :           if (parser-&gt;error)</span>
<span class="lineNum">    4573 </span><span class="lineCov">     764980 :             break;</span>
<span class="lineNum">    4574 </span><span class="lineCov">     764980 :           if (c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">    4575 </span><span class="lineCov">     764980 :             {</span>
<span class="lineNum">    4576 </span><span class="lineCov">    1529960 :               last_init_list_comma = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    4577 </span><span class="lineCov">     764980 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    4578 </span><span class="lineCov">     764980 :             }</span>
<span class="lineNum">    4579 </span>            :           else
<span class="lineNum">    4580 </span><span class="lineCov">     310400 :             break;</span>
<span class="lineNum">    4581 </span><span class="lineCov">     310400 :           if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))</span>
<span class="lineNum">    4582 </span>            :             break;
<span class="lineNum">    4583 </span>            :         }
<span class="lineNum">    4584 </span><span class="lineCov">     454580 :     }</span>
<span class="lineNum">    4585 </span><span class="lineCov">     764980 :   c_token *next_tok = c_parser_peek_token (parser);</span>
<span class="lineNum">    4586 </span>            :   if (next_tok-&gt;type != CPP_CLOSE_BRACE)
<span class="lineNum">    4587 </span><span class="lineCov">       1014 :     {</span>
<span class="lineNum">    4588 </span>            :       ret.set_error ();
<span class="lineNum">    4589 </span>            :       ret.original_code = ERROR_MARK;
<span class="lineNum">    4590 </span>            :       ret.original_type = NULL;
<span class="lineNum">    4591 </span>            :       braces.skip_until_found_close (parser);
<span class="lineNum">    4592 </span>            :       pop_init_level (brace_loc, 0, &amp;braced_init_obstack, last_init_list_comma);
<span class="lineNum">    4593 </span><span class="lineCov">    4824930 :       obstack_free (&amp;braced_init_obstack, NULL);</span>
<span class="lineNum">    4594 </span>            :       return ret;
<span class="lineNum">    4595 </span><span class="lineCov">    4824930 :     }</span>
<span class="lineNum">    4596 </span><span class="lineCov">    4824930 :   location_t close_loc = next_tok-&gt;location;</span>
<span class="lineNum">    4597 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    4598 </span><span class="lineCov">    4824900 :   ret = pop_init_level (brace_loc, 0, &amp;braced_init_obstack, close_loc);</span>
<span class="lineNum">    4599 </span>            :   obstack_free (&amp;braced_init_obstack, NULL);
<span class="lineNum">    4600 </span><span class="lineCov">    4069546 :   set_c_expr_source_range (&amp;ret, brace_loc, close_loc);</span>
<span class="lineNum">    4601 </span><span class="lineCov">    4069546 :   return ret;</span>
<span class="lineNum">    4602 </span>            : }
<span class="lineNum">    4603 </span>            : 
<span class="lineNum">    4604 </span>            : /* Parse a nested initializer, including designators.  */
<a name="4605"><span class="lineNum">    4605 </span><span class="lineCov">    4069546 : </span></a>
<span class="lineNum">    4606 </span>            : static void
<span class="lineNum">    4607 </span>            : c_parser_initelt (c_parser *parser, struct obstack * braced_init_obstack)
<span class="lineNum">    4608 </span>            : {
<span class="lineNum">    4609 </span><span class="lineCov">     764980 :   /* Parse any designator or designator list.  A single array</span>
<span class="lineNum">    4610 </span><span class="lineCov">     764980 :      designator may have the subsequent &quot;=&quot; omitted in GNU C, but a</span>
<span class="lineNum">    4611 </span>            :      longer list or a structure member designator may not.  */
<span class="lineNum">    4612 </span><span class="lineCov">         31 :   if (c_parser_next_token_is (parser, CPP_NAME)</span>
<span class="lineNum">    4613 </span><span class="lineCov">         31 :       &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type == CPP_COLON)</span>
<span class="lineNum">    4614 </span><span class="lineCov">         31 :     {</span>
<span class="lineNum">    4615 </span><span class="lineCov">         31 :       /* Old-style structure member designator.  */</span>
<span class="lineNum">    4616 </span><span class="lineCov">         31 :       set_init_label (c_parser_peek_token (parser)-&gt;location,</span>
<span class="lineNum">    4617 </span><span class="lineCov">         31 :                       c_parser_peek_token (parser)-&gt;value,</span>
<span class="lineNum">    4618 </span>            :                       c_parser_peek_token (parser)-&gt;location,
<span class="lineNum">    4619 </span>            :                       braced_init_obstack);
<span class="lineNum">    4620 </span><span class="lineCov">     764949 :       /* Use the colon as the error location.  */</span>
<span class="lineNum">    4621 </span><span class="lineCov">     764949 :       pedwarn (c_parser_peek_2nd_token (parser)-&gt;location, OPT_Wpedantic,</span>
<span class="lineNum">    4622 </span><span class="lineCov">     764949 :                &quot;obsolete use of designated initializer with %&lt;:%&gt;&quot;);</span>
<span class="lineNum">    4623 </span><span class="lineCov">     764949 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    4624 </span><span class="lineCov">     764949 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    4625 </span><span class="lineCov">     764949 :     }</span>
<span class="lineNum">    4626 </span>            :   else
<span class="lineNum">    4627 </span>            :     {
<span class="lineNum">    4628 </span>            :       /* des_seen is 0 if there have been no designators, 1 if there
<span class="lineNum">    4629 </span>            :          has been a single array designator and 2 otherwise.  */
<span class="lineNum">    4630 </span>            :       int des_seen = 0;
<span class="lineNum">    4631 </span><span class="lineCov">    4824930 :       /* Location of a designator.  */</span>
<span class="lineNum">    4632 </span>            :       location_t des_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */
<span class="lineNum">    4633 </span>            :       while (c_parser_next_token_is (parser, CPP_OPEN_SQUARE)
<span class="lineNum">    4634 </span>            :              || c_parser_next_token_is (parser, CPP_DOT))
<span class="lineNum">    4635 </span>            :         {
<span class="lineNum">    4636 </span><span class="lineCov">    4824930 :           int des_prev = des_seen;</span>
<span class="lineNum">    4637 </span><span class="lineCov">    4824930 :           if (!des_seen)</span>
<span class="lineNum">    4638 </span>            :             des_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    4639 </span>            :           if (des_seen &lt; 2)
<span class="lineNum">    4640 </span><span class="lineCov">       2588 :             des_seen++;</span>
<span class="lineNum">    4641 </span><span class="lineCov">       2588 :           if (c_parser_next_token_is (parser, CPP_DOT))</span>
<span class="lineNum">    4642 </span><span class="lineCov">       2588 :             {</span>
<span class="lineNum">    4643 </span>            :               des_seen = 2;
<span class="lineNum">    4644 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">    4645 </span><span class="lineCov">       2588 :               if (c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">    4646 </span>            :                 {
<span class="lineNum">    4647 </span><span class="lineCov">       2588 :                   set_init_label (des_loc, c_parser_peek_token (parser)-&gt;value,</span>
<span class="lineNum">    4648 </span><span class="lineCov">       2588 :                                   c_parser_peek_token (parser)-&gt;location,</span>
<span class="lineNum">    4649 </span>            :                                   braced_init_obstack);
<span class="lineNum">    4650 </span>            :                   c_parser_consume_token (parser);
<span class="lineNum">    4651 </span>            :                 }
<span class="lineNum">    4652 </span>            :               else
<span class="lineNum">    4653 </span>            :                 {
<span class="lineNum">    4654 </span>            :                   struct c_expr init;
<span class="lineNum">    4655 </span>            :                   init.set_error ();
<span class="lineNum">    4656 </span>            :                   init.original_code = ERROR_MARK;
<span class="lineNum">    4657 </span><span class="lineCov">    4824472 :                   init.original_type = NULL;</span>
<span class="lineNum">    4658 </span><span class="lineCov">    4824472 :                   c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">    4659 </span>            :                   c_parser_skip_until_found (parser, CPP_COMMA, NULL);
<span class="lineNum">    4660 </span><span class="lineCov">       2130 :                   process_init_element (input_location, init, false,</span>
<span class="lineNum">    4661 </span><span class="lineCov">       2130 :                                         braced_init_obstack);</span>
<span class="lineNum">    4662 </span><span class="lineCov">       1954 :                   return;</span>
<span class="lineNum">    4663 </span><span class="lineCov">       2130 :                 }</span>
<span class="lineNum">    4664 </span><span class="lineCov">       2009 :             }</span>
<span class="lineNum">    4665 </span><span class="lineCov">       2130 :           else</span>
<span class="lineNum">    4666 </span>            :             {
<span class="lineNum">    4667 </span><span class="lineCov">       1672 :               tree first, second;</span>
<span class="lineNum">    4668 </span><span class="lineCov">       1672 :               location_t ellipsis_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */</span>
<span class="lineNum">    4669 </span><span class="lineCov">       1672 :               location_t array_index_loc = UNKNOWN_LOCATION;</span>
<span class="lineNum">    4670 </span>            :               /* ??? Following the old parser, [ objc-receiver
<span class="lineNum">    4671 </span><span class="lineCov">       1672 :                  objc-message-args ] is accepted as an initializer,</span>
<span class="lineNum">    4672 </span><span class="lineCov">       1672 :                  being distinguished from a designator by what follows</span>
<span class="lineNum">    4673 </span>            :                  the first assignment expression inside the square
<span class="lineNum">    4674 </span><span class="lineCov">       1672 :                  brackets, but after a first array designator a</span>
<span class="lineNum">    4675 </span>            :                  subsequent square bracket is for Objective-C taken to
<span class="lineNum">    4676 </span>            :                  start an expression, using the obsolete form of
<span class="lineNum">    4677 </span>            :                  designated initializer without '=', rather than
<span class="lineNum">    4678 </span><span class="lineNoCov">          0 :                  possibly being a second level of designation: in LALR</span>
<span class="lineNum">    4679 </span><span class="lineNoCov">          0 :                  terms, the '[' is shifted rather than reducing</span>
<span class="lineNum">    4680 </span><span class="lineNoCov">          0 :                  designator to designator-list.  */</span>
<span class="lineNum">    4681 </span><span class="lineNoCov">          0 :               if (des_prev == 1 &amp;&amp; c_dialect_objc ())</span>
<span class="lineNum">    4682 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">    4683 </span><span class="lineNoCov">          0 :                   des_seen = des_prev;</span>
<span class="lineNum">    4684 </span><span class="lineNoCov">          0 :                   break;</span>
<span class="lineNum">    4685 </span>            :                 }
<span class="lineNum">    4686 </span><span class="lineNoCov">          0 :               if (des_prev == 0 &amp;&amp; c_dialect_objc ())</span>
<span class="lineNum">    4687 </span>            :                 {
<span class="lineNum">    4688 </span>            :                   /* This might be an array designator or an
<span class="lineNum">    4689 </span>            :                      Objective-C message expression.  If the former,
<span class="lineNum">    4690 </span>            :                      continue parsing here; if the latter, parse the
<span class="lineNum">    4691 </span><span class="lineCov">        458 :                      remainder of the initializer given the starting</span>
<span class="lineNum">    4692 </span><span class="lineCov">        458 :                      primary-expression.  ??? It might make sense to</span>
<span class="lineNum">    4693 </span><span class="lineCov">        458 :                      distinguish when des_prev == 1 as well; see</span>
<span class="lineNum">    4694 </span>            :                      previous comment.  */
<span class="lineNum">    4695 </span>            :                   tree rec, args;
<span class="lineNum">    4696 </span>            :                   struct c_expr mexpr;
<span class="lineNum">    4697 </span>            :                   c_parser_consume_token (parser);
<span class="lineNum">    4698 </span>            :                   if (c_parser_peek_token (parser)-&gt;type == CPP_NAME
<span class="lineNum">    4699 </span>            :                       &amp;&amp; ((c_parser_peek_token (parser)-&gt;id_kind
<span class="lineNum">    4700 </span>            :                            == C_ID_TYPENAME)
<span class="lineNum">    4701 </span>            :                           || (c_parser_peek_token (parser)-&gt;id_kind
<span class="lineNum">    4702 </span>            :                               == C_ID_CLASSNAME)))
<span class="lineNum">    4703 </span>            :                     {
<span class="lineNum">    4704 </span>            :                       /* Type name receiver.  */
<span class="lineNum">    4705 </span><span class="lineCov">        458 :                       tree id = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">    4706 </span>            :                       c_parser_consume_token (parser);
<span class="lineNum">    4707 </span>            :                       rec = objc_get_class_reference (id);
<span class="lineNum">    4708 </span>            :                       goto parse_message_args;
<span class="lineNum">    4709 </span>            :                     }
<span class="lineNum">    4710 </span><span class="lineCov">        458 :                   first = c_parser_expr_no_commas (parser, NULL).value;</span>
<span class="lineNum">    4711 </span>            :                   mark_exp_read (first);
<span class="lineNum">    4712 </span>            :                   if (c_parser_next_token_is (parser, CPP_ELLIPSIS)
<span class="lineNum">    4713 </span>            :                       || c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))
<span class="lineNum">    4714 </span>            :                     goto array_desig_after_first;
<span class="lineNum">    4715 </span>            :                   /* Expression receiver.  So far only one part
<span class="lineNum">    4716 </span>            :                      without commas has been parsed; there might be
<span class="lineNum">    4717 </span>            :                      more of the expression.  */
<span class="lineNum">    4718 </span>            :                   rec = first;
<span class="lineNum">    4719 </span><span class="lineNoCov">          0 :                   while (c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">    4720 </span><span class="lineNoCov">          0 :                     {</span>
<span class="lineNum">    4721 </span><span class="lineNoCov">          0 :                       struct c_expr next;</span>
<span class="lineNum">    4722 </span><span class="lineNoCov">          0 :                       location_t comma_loc, exp_loc;</span>
<span class="lineNum">    4723 </span><span class="lineNoCov">          0 :                       comma_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    4724 </span>            :                       c_parser_consume_token (parser);
<span class="lineNum">    4725 </span><span class="lineNoCov">          0 :                       exp_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    4726 </span>            :                       next = c_parser_expr_no_commas (parser, NULL);
<span class="lineNum">    4727 </span>            :                       next = convert_lvalue_to_rvalue (exp_loc, next,
<span class="lineNum">    4728 </span>            :                                                        true, true);
<span class="lineNum">    4729 </span><span class="lineNoCov">          0 :                       rec = build_compound_expr (comma_loc, rec, next.value);</span>
<span class="lineNum">    4730 </span><span class="lineNoCov">          0 :                     }</span>
<span class="lineNum">    4731 </span><span class="lineNoCov">          0 :                 parse_message_args:</span>
<span class="lineNum">    4732 </span><span class="lineNoCov">          0 :                   /* Now parse the objc-message-args.  */</span>
<span class="lineNum">    4733 </span>            :                   args = c_parser_objc_message_args (parser);
<span class="lineNum">    4734 </span><span class="lineNoCov">          0 :                   c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,</span>
<span class="lineNum">    4735 </span><span class="lineNoCov">          0 :                                              &quot;expected %&lt;]%&gt;&quot;);</span>
<span class="lineNum">    4736 </span><span class="lineNoCov">          0 :                   mexpr.value</span>
<span class="lineNum">    4737 </span><span class="lineNoCov">          0 :                     = objc_build_message_expr (rec, args);</span>
<span class="lineNum">    4738 </span><span class="lineNoCov">          0 :                   mexpr.original_code = ERROR_MARK;</span>
<span class="lineNum">    4739 </span>            :                   mexpr.original_type = NULL;
<span class="lineNum">    4740 </span>            :                   /* Now parse and process the remainder of the
<span class="lineNum">    4741 </span>            :                      initializer, starting with this message
<span class="lineNum">    4742 </span>            :                      expression as a primary-expression.  */
<span class="lineNum">    4743 </span><span class="lineNoCov">          0 :                   c_parser_initval (parser, &amp;mexpr, braced_init_obstack);</span>
<span class="lineNum">    4744 </span>            :                   return;
<span class="lineNum">    4745 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    4746 </span><span class="lineNoCov">          0 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    4747 </span><span class="lineNoCov">          0 :               array_index_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    4748 </span><span class="lineNoCov">          0 :               first = c_parser_expr_no_commas (parser, NULL).value;</span>
<span class="lineNum">    4749 </span><span class="lineNoCov">          0 :               mark_exp_read (first);</span>
<span class="lineNum">    4750 </span><span class="lineNoCov">          0 :             array_desig_after_first:</span>
<span class="lineNum">    4751 </span><span class="lineNoCov">          0 :               if (c_parser_next_token_is (parser, CPP_ELLIPSIS))</span>
<span class="lineNum">    4752 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">    4753 </span><span class="lineNoCov">          0 :                   ellipsis_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    4754 </span>            :                   c_parser_consume_token (parser);
<span class="lineNum">    4755 </span><span class="lineNoCov">          0 :                   second = c_parser_expr_no_commas (parser, NULL).value;</span>
<span class="lineNum">    4756 </span>            :                   mark_exp_read (second);
<span class="lineNum">    4757 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    4758 </span><span class="lineNoCov">          0 :               else</span>
<span class="lineNum">    4759 </span>            :                 second = NULL_TREE;
<span class="lineNum">    4760 </span><span class="lineNoCov">          0 :               if (c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))</span>
<span class="lineNum">    4761 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">    4762 </span><span class="lineNoCov">          0 :                   c_parser_consume_token (parser);</span>
<span class="lineNum">    4763 </span><span class="lineNoCov">          0 :                   set_init_index (array_index_loc, first, second,</span>
<span class="lineNum">    4764 </span>            :                                   braced_init_obstack);
<span class="lineNum">    4765 </span>            :                   if (second)
<span class="lineNum">    4766 </span>            :                     pedwarn (ellipsis_loc, OPT_Wpedantic,
<span class="lineNum">    4767 </span><span class="lineNoCov">          0 :                              &quot;ISO C forbids specifying range of elements to initialize&quot;);</span>
<span class="lineNum">    4768 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    4769 </span>            :               else
<span class="lineNum">    4770 </span><span class="lineCov">        458 :                 c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,</span>
<span class="lineNum">    4771 </span><span class="lineCov">        458 :                                            &quot;expected %&lt;]%&gt;&quot;);</span>
<span class="lineNum">    4772 </span><span class="lineCov">        458 :             }</span>
<span class="lineNum">    4773 </span><span class="lineCov">        458 :         }</span>
<span class="lineNum">    4774 </span><span class="lineCov">        458 :       if (des_seen &gt;= 1)</span>
<span class="lineNum">    4775 </span><span class="lineCov">        458 :         {</span>
<span class="lineNum">    4776 </span>            :           if (c_parser_next_token_is (parser, CPP_EQ))
<span class="lineNum">    4777 </span><span class="lineCov">         53 :             {</span>
<span class="lineNum">    4778 </span><span class="lineCov">         53 :               pedwarn_c90 (des_loc, OPT_Wpedantic,</span>
<span class="lineNum">    4779 </span><span class="lineCov">         53 :                            &quot;ISO C90 forbids specifying subobject &quot;</span>
<span class="lineNum">    4780 </span><span class="lineCov">         53 :                            &quot;to initialize&quot;);</span>
<span class="lineNum">    4781 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">    4782 </span>            :             }
<span class="lineNum">    4783 </span>            :           else
<span class="lineNum">    4784 </span><span class="lineCov">        458 :             {</span>
<span class="lineNum">    4785 </span>            :               if (des_seen == 1)
<span class="lineNum">    4786 </span><span class="lineCov">        458 :                 pedwarn (c_parser_peek_token (parser)-&gt;location, OPT_Wpedantic,</span>
<span class="lineNum">    4787 </span><span class="lineCov">        458 :                          &quot;obsolete use of designated initializer without %&lt;=%&gt;&quot;);</span>
<span class="lineNum">    4788 </span>            :               else
<span class="lineNum">    4789 </span><span class="lineCov">        458 :                 {</span>
<span class="lineNum">    4790 </span><span class="lineCov">         53 :                   struct c_expr init;</span>
<span class="lineNum">    4791 </span>            :                   init.set_error ();
<span class="lineNum">    4792 </span>            :                   init.original_code = ERROR_MARK;
<span class="lineNum">    4793 </span>            :                   init.original_type = NULL;
<span class="lineNum">    4794 </span><span class="lineNoCov">          0 :                   c_parser_error (parser, &quot;expected %&lt;=%&gt;&quot;);</span>
<span class="lineNum">    4795 </span>            :                   c_parser_skip_until_found (parser, CPP_COMMA, NULL);
<span class="lineNum">    4796 </span>            :                   process_init_element (input_location, init, false,
<span class="lineNum">    4797 </span>            :                                         braced_init_obstack);
<span class="lineNum">    4798 </span><span class="lineCov">    4822342 :                   return;</span>
<span class="lineNum">    4799 </span>            :                 }
<span class="lineNum">    4800 </span><span class="lineCov">       1954 :             }</span>
<span class="lineNum">    4801 </span>            :         }
<span class="lineNum">    4802 </span><span class="lineCov">       1933 :     }</span>
<span class="lineNum">    4803 </span>            :   c_parser_initval (parser, NULL, braced_init_obstack);
<span class="lineNum">    4804 </span>            : }
<span class="lineNum">    4805 </span><span class="lineCov">       1933 : </span>
<span class="lineNum">    4806 </span>            : /* Parse a nested initializer; as c_parser_initializer but parses
<span class="lineNum">    4807 </span>            :    initializers within braced lists, after any designators have been
<span class="lineNum">    4808 </span>            :    applied.  If AFTER is not NULL then it is an Objective-C message
<span class="lineNum">    4809 </span><span class="lineCov">         21 :    expression which is the primary-expression starting the</span>
<span class="lineNum">    4810 </span><span class="lineCov">         19 :    initializer.  */</span>
<a name="4811"><span class="lineNum">    4811 </span>            : </a>
<span class="lineNum">    4812 </span>            : static void
<span class="lineNum">    4813 </span>            : c_parser_initval (c_parser *parser, struct c_expr *after,
<span class="lineNum">    4814 </span><span class="lineCov">          2 :                   struct obstack * braced_init_obstack)</span>
<span class="lineNum">    4815 </span><span class="lineCov">          2 : {</span>
<span class="lineNum">    4816 </span><span class="lineCov">          2 :   struct c_expr init;</span>
<span class="lineNum">    4817 </span><span class="lineCov">          2 :   gcc_assert (!after || c_dialect_objc ());</span>
<span class="lineNum">    4818 </span><span class="lineCov">          2 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    4819 </span><span class="lineCov">          2 : </span>
<span class="lineNum">    4820 </span><span class="lineCov">          2 :   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE) &amp;&amp; !after)</span>
<span class="lineNum">    4821 </span>            :     init = c_parser_braced_init (parser, NULL_TREE, true,
<span class="lineNum">    4822 </span><span class="lineCov">          2 :                                  braced_init_obstack);</span>
<span class="lineNum">    4823 </span>            :   else
<span class="lineNum">    4824 </span>            :     {
<span class="lineNum">    4825 </span>            :       init = c_parser_expr_no_commas (parser, after);
<span class="lineNum">    4826 </span>            :       if (init.value != NULL_TREE
<span class="lineNum">    4827 </span><span class="lineCov">    4824928 :           &amp;&amp; TREE_CODE (init.value) != STRING_CST</span>
<span class="lineNum">    4828 </span>            :           &amp;&amp; TREE_CODE (init.value) != COMPOUND_LITERAL_EXPR)
<span class="lineNum">    4829 </span>            :         init = convert_lvalue_to_rvalue (loc, init, true, true);
<span class="lineNum">    4830 </span>            :     }
<span class="lineNum">    4831 </span>            :   process_init_element (loc, init, false, braced_init_obstack);
<span class="lineNum">    4832 </span>            : }
<span class="lineNum">    4833 </span>            : 
<span class="lineNum">    4834 </span>            : /* Parse a compound statement (possibly a function body) (C90 6.6.2,
<span class="lineNum">    4835 </span>            :    C99 6.8.2, C11 6.8.2).
<span class="lineNum">    4836 </span>            : 
<span class="lineNum">    4837 </span><span class="lineCov">    4824928 :    compound-statement:</span>
<span class="lineNum">    4838 </span>            :      { block-item-list[opt] }
<span class="lineNum">    4839 </span>            :      { label-declarations block-item-list }
<span class="lineNum">    4840 </span><span class="lineCov">    4824928 : </span>
<span class="lineNum">    4841 </span><span class="lineCov">    4824928 :    block-item-list:</span>
<span class="lineNum">    4842 </span><span class="lineCov">    4824928 :      block-item</span>
<span class="lineNum">    4843 </span>            :      block-item-list block-item
<span class="lineNum">    4844 </span><span class="lineCov">    4824928 : </span>
<span class="lineNum">    4845 </span><span class="lineCov">     310400 :    block-item:</span>
<span class="lineNum">    4846 </span><span class="lineCov">     310400 :      nested-declaration</span>
<span class="lineNum">    4847 </span>            :      statement
<span class="lineNum">    4848 </span>            : 
<span class="lineNum">    4849 </span><span class="lineCov">    4514528 :    nested-declaration:</span>
<span class="lineNum">    4850 </span><span class="lineCov">    4514528 :      declaration</span>
<span class="lineNum">    4851 </span><span class="lineCov">    4514528 : </span>
<span class="lineNum">    4852 </span><span class="lineCov">    4493467 :    GNU extensions:</span>
<span class="lineNum">    4853 </span><span class="lineCov">    4493330 : </span>
<span class="lineNum">    4854 </span>            :    compound-statement:
<span class="lineNum">    4855 </span><span class="lineCov">    4824928 :      { label-declarations block-item-list }</span>
<span class="lineNum">    4856 </span><span class="lineCov">    4824928 : </span>
<span class="lineNum">    4857 </span>            :    nested-declaration:
<span class="lineNum">    4858 </span>            :      __extension__ nested-declaration
<span class="lineNum">    4859 </span>            :      nested-function-definition
<span class="lineNum">    4860 </span>            : 
<span class="lineNum">    4861 </span>            :    label-declarations:
<span class="lineNum">    4862 </span>            :      label-declaration
<span class="lineNum">    4863 </span>            :      label-declarations label-declaration
<span class="lineNum">    4864 </span>            : 
<span class="lineNum">    4865 </span>            :    label-declaration:
<span class="lineNum">    4866 </span>            :      __label__ identifier-list ;
<span class="lineNum">    4867 </span>            : 
<span class="lineNum">    4868 </span>            :    Allowing the mixing of declarations and code is new in C99.  The
<span class="lineNum">    4869 </span>            :    GNU syntax also permits (not shown above) labels at the end of
<span class="lineNum">    4870 </span>            :    compound statements, which yield an error.  We don't allow labels
<span class="lineNum">    4871 </span>            :    on declarations; this might seem like a natural extension, but
<span class="lineNum">    4872 </span>            :    there would be a conflict between attributes on the label and
<span class="lineNum">    4873 </span>            :    prefix attributes on the declaration.  ??? The syntax follows the
<span class="lineNum">    4874 </span>            :    old parser in requiring something after label declarations.
<span class="lineNum">    4875 </span>            :    Although they are erroneous if the labels declared aren't defined,
<span class="lineNum">    4876 </span>            :    is it useful for the syntax to be this way?
<span class="lineNum">    4877 </span>            : 
<span class="lineNum">    4878 </span>            :    OpenACC:
<span class="lineNum">    4879 </span>            : 
<span class="lineNum">    4880 </span>            :    block-item:
<span class="lineNum">    4881 </span>            :      openacc-directive
<span class="lineNum">    4882 </span>            : 
<span class="lineNum">    4883 </span>            :    openacc-directive:
<span class="lineNum">    4884 </span>            :      update-directive
<span class="lineNum">    4885 </span>            : 
<span class="lineNum">    4886 </span>            :    OpenMP:
<span class="lineNum">    4887 </span>            : 
<span class="lineNum">    4888 </span>            :    block-item:
<span class="lineNum">    4889 </span>            :      openmp-directive
<span class="lineNum">    4890 </span>            : 
<span class="lineNum">    4891 </span>            :    openmp-directive:
<span class="lineNum">    4892 </span>            :      barrier-directive
<span class="lineNum">    4893 </span>            :      flush-directive
<span class="lineNum">    4894 </span>            :      taskwait-directive
<span class="lineNum">    4895 </span>            :      taskyield-directive
<span class="lineNum">    4896 </span>            :      cancel-directive
<span class="lineNum">    4897 </span>            :      cancellation-point-directive  */
<a name="4898"><span class="lineNum">    4898 </span>            : </a>
<span class="lineNum">    4899 </span>            : static tree
<span class="lineNum">    4900 </span>            : c_parser_compound_statement (c_parser *parser)
<span class="lineNum">    4901 </span>            : {
<span class="lineNum">    4902 </span>            :   tree stmt;
<span class="lineNum">    4903 </span>            :   location_t brace_loc;
<span class="lineNum">    4904 </span>            :   brace_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    4905 </span>            :   if (!c_parser_require (parser, CPP_OPEN_BRACE, &quot;expected %&lt;{%&gt;&quot;))
<span class="lineNum">    4906 </span>            :     {
<span class="lineNum">    4907 </span>            :       /* Ensure a scope is entered and left anyway to avoid confusion
<span class="lineNum">    4908 </span>            :          if we have just prepared to enter a function body.  */
<span class="lineNum">    4909 </span>            :       stmt = c_begin_compound_stmt (true);
<span class="lineNum">    4910 </span>            :       c_end_compound_stmt (brace_loc, stmt, true);
<span class="lineNum">    4911 </span>            :       return error_mark_node;
<span class="lineNum">    4912 </span>            :     }
<span class="lineNum">    4913 </span>            :   stmt = c_begin_compound_stmt (true);
<span class="lineNum">    4914 </span>            :   c_parser_compound_statement_nostart (parser);
<span class="lineNum">    4915 </span>            : 
<span class="lineNum">    4916 </span>            :   return c_end_compound_stmt (brace_loc, stmt, true);
<span class="lineNum">    4917 </span>            : }
<span class="lineNum">    4918 </span>            : 
<span class="lineNum">    4919 </span>            : /* Parse a compound statement except for the opening brace.  This is
<span class="lineNum">    4920 </span>            :    used for parsing both compound statements and statement expressions
<span class="lineNum">    4921 </span>            :    (which follow different paths to handling the opening).  */
<a name="4922"><span class="lineNum">    4922 </span>            : </a>
<span class="lineNum">    4923 </span>            : static void
<span class="lineNum">    4924 </span><span class="lineCov">   18582546 : c_parser_compound_statement_nostart (c_parser *parser)</span>
<span class="lineNum">    4925 </span>            : {
<span class="lineNum">    4926 </span><span class="lineCov">   18582546 :   bool last_stmt = false;</span>
<span class="lineNum">    4927 </span><span class="lineCov">   18582546 :   bool last_label = false;</span>
<span class="lineNum">    4928 </span><span class="lineCov">   18582546 :   bool save_valid_for_pragma = valid_location_for_stdc_pragma_p ();</span>
<span class="lineNum">    4929 </span><span class="lineCov">   18582546 :   location_t label_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */</span>
<span class="lineNum">    4930 </span>            :   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))
<span class="lineNum">    4931 </span>            :     {
<span class="lineNum">    4932 </span>            :       add_debug_begin_stmt (c_parser_peek_token (parser)-&gt;location);
<span class="lineNum">    4933 </span><span class="lineCov">         16 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    4934 </span><span class="lineCov">         16 :       return;</span>
<span class="lineNum">    4935 </span><span class="lineCov">         16 :     }</span>
<span class="lineNum">    4936 </span>            :   mark_valid_location_for_stdc_pragma (true);
<span class="lineNum">    4937 </span><span class="lineCov">   18582530 :   if (c_parser_next_token_is_keyword (parser, RID_LABEL))</span>
<span class="lineNum">    4938 </span><span class="lineCov">   18582530 :     {</span>
<span class="lineNum">    4939 </span>            :       /* Read zero or more forward-declarations for labels that nested
<span class="lineNum">    4940 </span><span class="lineCov">   18582529 :          functions can jump to.  */</span>
<span class="lineNum">    4941 </span>            :       mark_valid_location_for_stdc_pragma (false);
<span class="lineNum">    4942 </span>            :       while (c_parser_next_token_is_keyword (parser, RID_LABEL))
<span class="lineNum">    4943 </span>            :         {
<span class="lineNum">    4944 </span>            :           label_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    4945 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    4946 </span>            :           /* Any identifiers, including those declared as type names,
<span class="lineNum">    4947 </span>            :              are OK here.  */
<span class="lineNum">    4948 </span><span class="lineCov">   18611647 :           while (true)</span>
<span class="lineNum">    4949 </span>            :             {
<span class="lineNum">    4950 </span><span class="lineCov">   18611647 :               tree label;</span>
<span class="lineNum">    4951 </span><span class="lineCov">   18611647 :               if (c_parser_next_token_is_not (parser, CPP_NAME))</span>
<span class="lineNum">    4952 </span><span class="lineCov">   18611647 :                 {</span>
<span class="lineNum">    4953 </span><span class="lineCov">   18611647 :                   c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">    4954 </span><span class="lineCov">   18611647 :                   break;</span>
<span class="lineNum">    4955 </span>            :                 }
<span class="lineNum">    4956 </span><span class="lineCov">      18256 :               label</span>
<span class="lineNum">    4957 </span><span class="lineCov">      18256 :                 = declare_label (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">    4958 </span><span class="lineCov">      18256 :               C_DECLARED_LABEL_FLAG (label) = 1;</span>
<span class="lineNum">    4959 </span>            :               add_stmt (build_stmt (label_loc, DECL_EXPR, label));
<span class="lineNum">    4960 </span><span class="lineCov">   18593391 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    4961 </span><span class="lineCov">   18593391 :               if (c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">    4962 </span>            :                 c_parser_consume_token (parser);
<span class="lineNum">    4963 </span>            :               else
<span class="lineNum">    4964 </span>            :                 break;
<span class="lineNum">    4965 </span><span class="lineCov">        675 :             }</span>
<span class="lineNum">    4966 </span><span class="lineCov">       1472 :           c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);</span>
<span class="lineNum">    4967 </span>            :         }
<span class="lineNum">    4968 </span><span class="lineCov">        797 :       pedwarn (label_loc, OPT_Wpedantic, &quot;ISO C forbids label declarations&quot;);</span>
<span class="lineNum">    4969 </span><span class="lineCov">        797 :     }</span>
<span class="lineNum">    4970 </span>            :   /* We must now have at least one statement, label or declaration.  */
<span class="lineNum">    4971 </span>            :   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))
<span class="lineNum">    4972 </span><span class="lineCov">       1122 :     {</span>
<span class="lineNum">    4973 </span>            :       mark_valid_location_for_stdc_pragma (save_valid_for_pragma);
<span class="lineNum">    4974 </span><span class="lineCov">       1122 :       c_parser_error (parser, &quot;expected declaration or statement&quot;);</span>
<span class="lineNum">    4975 </span><span class="lineCov">       1122 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    4976 </span>            :       return;
<span class="lineNum">    4977 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    4978 </span><span class="lineNoCov">          0 :   while (c_parser_next_token_is_not (parser, CPP_CLOSE_BRACE))</span>
<span class="lineNum">    4979 </span>            :     {
<span class="lineNum">    4980 </span><span class="lineCov">       1122 :       location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    4981 </span><span class="lineCov">       1122 :       loc = expansion_point_location_if_in_system_header (loc);</span>
<span class="lineNum">    4982 </span><span class="lineCov">       1122 :       if (c_parser_next_token_is_keyword (parser, RID_CASE)</span>
<span class="lineNum">    4983 </span><span class="lineCov">       1122 :           || c_parser_next_token_is_keyword (parser, RID_DEFAULT)</span>
<span class="lineNum">    4984 </span><span class="lineCov">       1122 :           || (c_parser_next_token_is (parser, CPP_NAME)</span>
<span class="lineNum">    4985 </span><span class="lineCov">       1122 :               &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type == CPP_COLON))</span>
<span class="lineNum">    4986 </span><span class="lineCov">        325 :         {</span>
<span class="lineNum">    4987 </span>            :           if (c_parser_next_token_is_keyword (parser, RID_CASE))
<span class="lineNum">    4988 </span>            :             label_loc = c_parser_peek_2nd_token (parser)-&gt;location;
<span class="lineNum">    4989 </span><span class="lineCov">        325 :           else</span>
<span class="lineNum">    4990 </span><span class="lineCov">        797 :             label_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    4991 </span>            :           last_label = true;
<span class="lineNum">    4992 </span><span class="lineCov">        675 :           last_stmt = false;</span>
<span class="lineNum">    4993 </span>            :           mark_valid_location_for_stdc_pragma (false);
<span class="lineNum">    4994 </span>            :           c_parser_label (parser);
<span class="lineNum">    4995 </span><span class="lineCov">   18593391 :         }</span>
<span class="lineNum">    4996 </span>            :       else if (!last_label
<span class="lineNum">    4997 </span><span class="lineNoCov">          0 :                &amp;&amp; c_parser_next_tokens_start_declaration (parser))</span>
<span class="lineNum">    4998 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    4999 </span><span class="lineNoCov">          0 :           last_label = false;</span>
<span class="lineNum">    5000 </span><span class="lineNoCov">          0 :           mark_valid_location_for_stdc_pragma (false);</span>
<span class="lineNum">    5001 </span>            :           bool fallthru_attr_p = false;
<span class="lineNum">    5002 </span><span class="lineCov">   44249611 :           c_parser_declaration_or_fndef (parser, true, true, true, true,</span>
<span class="lineNum">    5003 </span>            :                                          true, NULL, vNULL, NULL,
<span class="lineNum">    5004 </span><span class="lineCov">   25656254 :                                          &amp;fallthru_attr_p);</span>
<span class="lineNum">    5005 </span><span class="lineCov">   25656254 :           if (last_stmt &amp;&amp; !fallthru_attr_p)</span>
<span class="lineNum">    5006 </span><span class="lineCov">   25656254 :             pedwarn_c90 (loc, OPT_Wdeclaration_after_statement,</span>
<span class="lineNum">    5007 </span><span class="lineCov">   24783446 :                          &quot;ISO C90 forbids mixed declarations and code&quot;);</span>
<span class="lineNum">    5008 </span><span class="lineCov">   50420581 :           last_stmt = fallthru_attr_p;</span>
<span class="lineNum">    5009 </span><span class="lineCov">    4415482 :         }</span>
<span class="lineNum">    5010 </span>            :       else if (!last_label
<span class="lineNum">    5011 </span><span class="lineCov">     912357 :                &amp;&amp; c_parser_next_token_is_keyword (parser, RID_EXTENSION))</span>
<span class="lineNum">    5012 </span><span class="lineCov">     872808 :         {</span>
<span class="lineNum">    5013 </span>            :           /* __extension__ can start a declaration, but is also an
<span class="lineNum">    5014 </span><span class="lineCov">      39549 :              unary operator that can start an expression.  Consume all</span>
<span class="lineNum">    5015 </span><span class="lineCov">     912357 :              but the last of a possible series of __extension__ to</span>
<span class="lineNum">    5016 </span><span class="lineCov">     912357 :              determine which.  */</span>
<span class="lineNum">    5017 </span><span class="lineCov">     912357 :           while (c_parser_peek_2nd_token (parser)-&gt;type == CPP_KEYWORD</span>
<span class="lineNum">    5018 </span><span class="lineCov">     912357 :                  &amp;&amp; (c_parser_peek_2nd_token (parser)-&gt;keyword</span>
<span class="lineNum">    5019 </span>            :                      == RID_EXTENSION))
<span class="lineNum">    5020 </span><span class="lineCov">   24743897 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    5021 </span><span class="lineCov">   24743897 :           if (c_token_starts_declaration (c_parser_peek_2nd_token (parser)))</span>
<span class="lineNum">    5022 </span>            :             {
<span class="lineNum">    5023 </span><span class="lineCov">    3190975 :               int ext;</span>
<span class="lineNum">    5024 </span><span class="lineCov">    3190975 :               ext = disable_extension_diagnostics ();</span>
<span class="lineNum">    5025 </span><span class="lineCov">    3190975 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    5026 </span><span class="lineCov">    3190975 :               last_label = false;</span>
<span class="lineNum">    5027 </span>            :               mark_valid_location_for_stdc_pragma (false);
<span class="lineNum">    5028 </span>            :               c_parser_declaration_or_fndef (parser, true, true, true, true,
<span class="lineNum">    5029 </span><span class="lineCov">    3190975 :                                              true, NULL, vNULL);</span>
<span class="lineNum">    5030 </span><span class="lineCov">     106567 :               /* Following the old parser, __extension__ does not</span>
<span class="lineNum">    5031 </span>            :                  disable this diagnostic.  */
<span class="lineNum">    5032 </span><span class="lineCov">    3190975 :               restore_extension_diagnostics (ext);</span>
<span class="lineNum">    5033 </span>            :               if (last_stmt)
<span class="lineNum">    5034 </span><span class="lineCov">   21552922 :                 pedwarn_c90 (loc, OPT_Wdeclaration_after_statement,</span>
<span class="lineNum">    5035 </span><span class="lineCov">   21552922 :                              &quot;ISO C90 forbids mixed declarations and code&quot;);</span>
<span class="lineNum">    5036 </span>            :               last_stmt = false;
<span class="lineNum">    5037 </span>            :             }
<span class="lineNum">    5038 </span>            :           else
<span class="lineNum">    5039 </span>            :             goto statement;
<span class="lineNum">    5040 </span>            :         }
<span class="lineNum">    5041 </span><span class="lineCov">       1951 :       else if (c_parser_next_token_is (parser, CPP_PRAGMA))</span>
<span class="lineNum">    5042 </span><span class="lineCov">       1951 :         {</span>
<span class="lineNum">    5043 </span>            :           /* External pragmas, and some omp pragmas, are not associated
<span class="lineNum">    5044 </span><span class="lineNoCov">          0 :              with regular c code, and so are not to be considered statements</span>
<span class="lineNum">    5045 </span><span class="lineCov">       1951 :              syntactically.  This ensures that the user doesn't put them</span>
<span class="lineNum">    5046 </span>            :              places that would turn into syntax errors if the directive
<span class="lineNum">    5047 </span><span class="lineCov">       1262 :              were ignored.  */</span>
<span class="lineNum">    5048 </span><span class="lineCov">       1262 :           if (c_parser_pragma (parser,</span>
<span class="lineNum">    5049 </span><span class="lineCov">       1262 :                                last_label ? pragma_stmt : pragma_compound,</span>
<span class="lineNum">    5050 </span><span class="lineCov">       1262 :                                NULL))</span>
<span class="lineNum">    5051 </span><span class="lineCov">       1262 :             last_label = false, last_stmt = true;</span>
<span class="lineNum">    5052 </span><span class="lineCov">       1262 :         }</span>
<span class="lineNum">    5053 </span>            :       else if (c_parser_next_token_is (parser, CPP_EOF))
<span class="lineNum">    5054 </span>            :         {
<span class="lineNum">    5055 </span>            :           mark_valid_location_for_stdc_pragma (save_valid_for_pragma);
<span class="lineNum">    5056 </span><span class="lineCov">       1262 :           c_parser_error (parser, &quot;expected declaration or statement&quot;);</span>
<span class="lineNum">    5057 </span><span class="lineCov">       1262 :           return;</span>
<span class="lineNum">    5058 </span><span class="lineCov">          6 :         }</span>
<span class="lineNum">    5059 </span>            :       else if (c_parser_next_token_is_keyword (parser, RID_ELSE))
<span class="lineNum">    5060 </span>            :         {
<span class="lineNum">    5061 </span>            :           if (parser-&gt;in_if_block)
<span class="lineNum">    5062 </span>            :             {
<span class="lineNum">    5063 </span>            :               mark_valid_location_for_stdc_pragma (save_valid_for_pragma);
<span class="lineNum">    5064 </span>            :               error_at (loc, &quot;expected %&lt;}%&gt; before %&lt;else%&gt;&quot;);
<span class="lineNum">    5065 </span><span class="lineCov">   21550971 :               return;</span>
<span class="lineNum">    5066 </span>            :             }
<span class="lineNum">    5067 </span>            :           else
<span class="lineNum">    5068 </span>            :             {
<span class="lineNum">    5069 </span>            :               error_at (loc, &quot;%&lt;else%&gt; without a previous %&lt;if%&gt;&quot;);
<span class="lineNum">    5070 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">    5071 </span>            :               continue;
<span class="lineNum">    5072 </span><span class="lineCov">      21161 :             }</span>
<span class="lineNum">    5073 </span>            :         }
<span class="lineNum">    5074 </span>            :       else
<span class="lineNum">    5075 </span><span class="lineCov">       8314 :         {</span>
<span class="lineNum">    5076 </span>            :         statement:
<span class="lineNum">    5077 </span><span class="lineCov">   21540362 :           last_label = false;</span>
<span class="lineNum">    5078 </span>            :           last_stmt = true;
<span class="lineNum">    5079 </span><span class="lineCov">         31 :           mark_valid_location_for_stdc_pragma (false);</span>
<span class="lineNum">    5080 </span><span class="lineCov">         31 :           c_parser_statement_after_labels (parser, NULL);</span>
<span class="lineNum">    5081 </span><span class="lineCov">         31 :         }</span>
<span class="lineNum">    5082 </span>            : 
<span class="lineNum">    5083 </span><span class="lineCov">   21540331 :       parser-&gt;error = false;</span>
<span class="lineNum">    5084 </span>            :     }
<span class="lineNum">    5085 </span><span class="lineCov">          5 :   if (last_label)</span>
<span class="lineNum">    5086 </span>            :     error_at (label_loc, &quot;label at end of compound statement&quot;);
<span class="lineNum">    5087 </span><span class="lineCov">          2 :   c_parser_consume_token (parser);</span>
<span class="lineNum">    5088 </span><span class="lineCov">          2 :   /* Restore the value we started with.  */</span>
<span class="lineNum">    5089 </span><span class="lineCov">          2 :   mark_valid_location_for_stdc_pragma (save_valid_for_pragma);</span>
<span class="lineNum">    5090 </span>            : }
<span class="lineNum">    5091 </span>            : 
<span class="lineNum">    5092 </span>            : /* Parse all consecutive labels. */
<a name="5093"><span class="lineNum">    5093 </span><span class="lineCov">          3 : </span></a>
<span class="lineNum">    5094 </span><span class="lineCov">          3 : static void</span>
<span class="lineNum">    5095 </span><span class="lineCov">          3 : c_parser_all_labels (c_parser *parser)</span>
<span class="lineNum">    5096 </span>            : {
<span class="lineNum">    5097 </span>            :   while (c_parser_next_token_is_keyword (parser, RID_CASE)
<span class="lineNum">    5098 </span>            :          || c_parser_next_token_is_keyword (parser, RID_DEFAULT)
<span class="lineNum">    5099 </span>            :          || (c_parser_next_token_is (parser, CPP_NAME)
<span class="lineNum">    5100 </span><span class="lineCov">   21540326 :              &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type == CPP_COLON))</span>
<span class="lineNum">    5101 </span><span class="lineCov">   21541015 :     c_parser_label (parser);</span>
<span class="lineNum">    5102 </span><span class="lineCov">   21541015 : }</span>
<span class="lineNum">    5103 </span><span class="lineCov">   21541015 : </span>
<span class="lineNum">    5104 </span><span class="lineCov">   21541015 : /* Parse a label (C90 6.6.1, C99 6.8.1, C11 6.8.1).</span>
<span class="lineNum">    5105 </span>            : 
<span class="lineNum">    5106 </span>            :    label:
<span class="lineNum">    5107 </span><span class="lineCov">   25656217 :      identifier : attributes[opt]</span>
<span class="lineNum">    5108 </span>            :      case constant-expression :
<span class="lineNum">    5109 </span><span class="lineCov">   18593357 :      default :</span>
<span class="lineNum">    5110 </span><span class="lineCov">          4 : </span>
<span class="lineNum">    5111 </span><span class="lineCov">   18593357 :    GNU extensions:</span>
<span class="lineNum">    5112 </span>            : 
<span class="lineNum">    5113 </span><span class="lineCov">   18593357 :    label:</span>
<span class="lineNum">    5114 </span>            :      case constant-expression ... constant-expression :
<span class="lineNum">    5115 </span>            : 
<span class="lineNum">    5116 </span>            :    The use of attributes on labels is a GNU extension.  The syntax in
<span class="lineNum">    5117 </span>            :    GNU C accepts any expressions without commas, non-constant
<span class="lineNum">    5118 </span>            :    expressions being rejected later.  */
<a name="5119"><span class="lineNum">    5119 </span><span class="lineCov">    1361543 : </span></a>
<span class="lineNum">    5120 </span>            : static void
<span class="lineNum">    5121 </span><span class="lineCov">    1361899 : c_parser_label (c_parser *parser)</span>
<span class="lineNum">    5122 </span><span class="lineCov">    1361821 : {</span>
<span class="lineNum">    5123 </span><span class="lineCov">    2723716 :   location_t loc1 = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    5124 </span><span class="lineCov">     392629 :   tree label = NULL_TREE;</span>
<span class="lineNum">    5125 </span><span class="lineCov">        356 : </span>
<span class="lineNum">    5126 </span><span class="lineCov">    1361543 :   /* Remember whether this case or a user-defined label is allowed to fall</span>
<span class="lineNum">    5127 </span>            :      through to.  */
<span class="lineNum">    5128 </span>            :   bool fallthrough_p = c_parser_peek_token (parser)-&gt;flags &amp; PREV_FALLTHROUGH;
<span class="lineNum">    5129 </span>            : 
<span class="lineNum">    5130 </span>            :   if (c_parser_next_token_is_keyword (parser, RID_CASE))
<span class="lineNum">    5131 </span>            :     {
<span class="lineNum">    5132 </span>            :       tree exp1, exp2;
<span class="lineNum">    5133 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    5134 </span>            :       exp1 = c_parser_expr_no_commas (parser, NULL).value;
<span class="lineNum">    5135 </span>            :       if (c_parser_next_token_is (parser, CPP_COLON))
<span class="lineNum">    5136 </span>            :         {
<span class="lineNum">    5137 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    5138 </span>            :           label = do_case (loc1, exp1, NULL_TREE);
<span class="lineNum">    5139 </span>            :         }
<span class="lineNum">    5140 </span>            :       else if (c_parser_next_token_is (parser, CPP_ELLIPSIS))
<span class="lineNum">    5141 </span>            :         {
<span class="lineNum">    5142 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    5143 </span>            :           exp2 = c_parser_expr_no_commas (parser, NULL).value;
<span class="lineNum">    5144 </span>            :           if (c_parser_require (parser, CPP_COLON, &quot;expected %&lt;:%&gt;&quot;))
<span class="lineNum">    5145 </span><span class="lineCov">     912713 :             label = do_case (loc1, exp1, exp2);</span>
<span class="lineNum">    5146 </span>            :         }
<span class="lineNum">    5147 </span><span class="lineCov">     912713 :       else</span>
<span class="lineNum">    5148 </span><span class="lineCov">     912713 :         c_parser_error (parser, &quot;expected %&lt;:%&gt; or %&lt;...%&gt;&quot;);</span>
<span class="lineNum">    5149 </span>            :     }
<span class="lineNum">    5150 </span>            :   else if (c_parser_next_token_is_keyword (parser, RID_DEFAULT))
<span class="lineNum">    5151 </span>            :     {
<span class="lineNum">    5152 </span><span class="lineCov">     912713 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    5153 </span>            :       if (c_parser_require (parser, CPP_COLON, &quot;expected %&lt;:%&gt;&quot;))
<span class="lineNum">    5154 </span><span class="lineCov">     912713 :         label = do_case (loc1, NULL_TREE, NULL_TREE);</span>
<span class="lineNum">    5155 </span>            :     }
<span class="lineNum">    5156 </span><span class="lineCov">     872886 :   else</span>
<span class="lineNum">    5157 </span><span class="lineCov">     872886 :     {</span>
<span class="lineNum">    5158 </span><span class="lineCov">     872886 :       tree name = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">    5159 </span><span class="lineCov">     872886 :       tree tlab;</span>
<span class="lineNum">    5160 </span>            :       tree attrs;
<span class="lineNum">    5161 </span><span class="lineCov">     872740 :       location_t loc2 = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    5162 </span><span class="lineCov">     872740 :       gcc_assert (c_parser_next_token_is (parser, CPP_NAME));</span>
<span class="lineNum">    5163 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    5164 </span><span class="lineCov">        146 :       gcc_assert (c_parser_next_token_is (parser, CPP_COLON));</span>
<span class="lineNum">    5165 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    5166 </span><span class="lineCov">        138 :       attrs = c_parser_attributes (parser);</span>
<span class="lineNum">    5167 </span><span class="lineCov">        138 :       tlab = define_label (loc2, name);</span>
<span class="lineNum">    5168 </span><span class="lineCov">        138 :       if (tlab)</span>
<span class="lineNum">    5169 </span><span class="lineCov">        138 :         {</span>
<span class="lineNum">    5170 </span>            :           decl_attributes (&amp;tlab, attrs, 0);
<span class="lineNum">    5171 </span>            :           label = add_stmt (build_stmt (loc1, LABEL_EXPR, tlab));
<span class="lineNum">    5172 </span><span class="lineCov">          8 :         }</span>
<span class="lineNum">    5173 </span>            :     }
<span class="lineNum">    5174 </span><span class="lineCov">      39827 :   if (label)</span>
<span class="lineNum">    5175 </span>            :     {
<span class="lineNum">    5176 </span><span class="lineCov">      19123 :       if (TREE_CODE (label) == LABEL_EXPR)</span>
<span class="lineNum">    5177 </span><span class="lineCov">      19123 :         FALLTHROUGH_LABEL_P (LABEL_EXPR_LABEL (label)) = fallthrough_p;</span>
<span class="lineNum">    5178 </span><span class="lineCov">      19123 :       else</span>
<span class="lineNum">    5179 </span>            :         FALLTHROUGH_LABEL_P (CASE_LABEL (label)) = fallthrough_p;
<span class="lineNum">    5180 </span>            : 
<span class="lineNum">    5181 </span>            :       /* Allow '__attribute__((fallthrough));'.  */
<span class="lineNum">    5182 </span><span class="lineCov">      20704 :       if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))</span>
<span class="lineNum">    5183 </span><span class="lineCov">      20704 :         {</span>
<span class="lineNum">    5184 </span><span class="lineCov">      20704 :           location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    5185 </span><span class="lineCov">      20704 :           tree attrs = c_parser_attributes (parser);</span>
<span class="lineNum">    5186 </span><span class="lineCov">      20704 :           if (attribute_fallthrough_p (attrs))</span>
<span class="lineNum">    5187 </span><span class="lineCov">      20704 :             {</span>
<span class="lineNum">    5188 </span><span class="lineCov">      20704 :               if (c_parser_next_token_is (parser, CPP_SEMICOLON))</span>
<span class="lineNum">    5189 </span><span class="lineCov">      20704 :                 {</span>
<span class="lineNum">    5190 </span><span class="lineCov">      20704 :                   tree fn = build_call_expr_internal_loc (loc,</span>
<span class="lineNum">    5191 </span><span class="lineCov">      20704 :                                                           IFN_FALLTHROUGH,</span>
<span class="lineNum">    5192 </span><span class="lineCov">      20704 :                                                           void_type_node, 0);</span>
<span class="lineNum">    5193 </span>            :                   add_stmt (fn);
<span class="lineNum">    5194 </span><span class="lineCov">      20676 :                 }</span>
<span class="lineNum">    5195 </span><span class="lineCov">      20676 :               else</span>
<span class="lineNum">    5196 </span>            :                 warning_at (loc, OPT_Wattributes, &quot;%&lt;fallthrough%&gt; attribute &quot;
<span class="lineNum">    5197 </span>            :                             &quot;not followed by %&lt;;%&gt;&quot;);
<span class="lineNum">    5198 </span><span class="lineCov">     912713 :             }</span>
<span class="lineNum">    5199 </span>            :           else if (attrs != NULL_TREE)
<span class="lineNum">    5200 </span><span class="lineCov">     912563 :             warning_at (loc, OPT_Wattributes, &quot;only attribute %&lt;fallthrough%&gt;&quot;</span>
<span class="lineNum">    5201 </span><span class="lineCov">      41352 :                         &quot; can be applied to a null statement&quot;);</span>
<span class="lineNum">    5202 </span>            :         }
<span class="lineNum">    5203 </span><span class="lineCov">     891887 :       if (c_parser_next_tokens_start_declaration (parser))</span>
<span class="lineNum">    5204 </span>            :         {
<span class="lineNum">    5205 </span>            :           error_at (c_parser_peek_token (parser)-&gt;location,
<span class="lineNum">    5206 </span><span class="lineCov">     912563 :                     &quot;a label can only be part of a statement and &quot;</span>
<span class="lineNum">    5207 </span>            :                     &quot;a declaration is not a statement&quot;);
<span class="lineNum">    5208 </span><span class="lineCov">          7 :           c_parser_declaration_or_fndef (parser, /*fndef_ok*/ false,</span>
<span class="lineNum">    5209 </span><span class="lineCov">          7 :                                          /*static_assert_ok*/ true,</span>
<span class="lineNum">    5210 </span><span class="lineCov">          7 :                                          /*empty_ok*/ true, /*nested*/ true,</span>
<span class="lineNum">    5211 </span>            :                                          /*start_attr_ok*/ true, NULL,
<span class="lineNum">    5212 </span><span class="lineCov">          4 :                                          vNULL);</span>
<span class="lineNum">    5213 </span>            :         }
<span class="lineNum">    5214 </span><span class="lineCov">          4 :     }</span>
<span class="lineNum">    5215 </span>            : }
<span class="lineNum">    5216 </span>            : 
<span class="lineNum">    5217 </span><span class="lineCov">          4 : /* Parse a statement (C90 6.6, C99 6.8, C11 6.8).</span>
<span class="lineNum">    5218 </span>            : 
<span class="lineNum">    5219 </span>            :    statement:
<span class="lineNum">    5220 </span><span class="lineNoCov">          0 :      labeled-statement</span>
<span class="lineNum">    5221 </span>            :      compound-statement
<span class="lineNum">    5222 </span>            :      expression-statement
<span class="lineNum">    5223 </span><span class="lineCov">          3 :      selection-statement</span>
<span class="lineNum">    5224 </span><span class="lineCov">          3 :      iteration-statement</span>
<span class="lineNum">    5225 </span>            :      jump-statement
<span class="lineNum">    5226 </span>            : 
<span class="lineNum">    5227 </span><span class="lineCov">     912563 :    labeled-statement:</span>
<span class="lineNum">    5228 </span>            :      label statement
<span class="lineNum">    5229 </span><span class="lineCov">          5 : </span>
<span class="lineNum">    5230 </span>            :    expression-statement:
<span class="lineNum">    5231 </span>            :      expression[opt] ;
<span class="lineNum">    5232 </span><span class="lineCov">          5 : </span>
<span class="lineNum">    5233 </span>            :    selection-statement:
<span class="lineNum">    5234 </span>            :      if-statement
<span class="lineNum">    5235 </span>            :      switch-statement
<span class="lineNum">    5236 </span>            : 
<span class="lineNum">    5237 </span>            :    iteration-statement:
<span class="lineNum">    5238 </span>            :      while-statement
<span class="lineNum">    5239 </span><span class="lineCov">     912713 :      do-statement</span>
<span class="lineNum">    5240 </span>            :      for-statement
<span class="lineNum">    5241 </span>            : 
<span class="lineNum">    5242 </span>            :    jump-statement:
<span class="lineNum">    5243 </span>            :      goto identifier ;
<span class="lineNum">    5244 </span>            :      continue ;
<span class="lineNum">    5245 </span>            :      break ;
<span class="lineNum">    5246 </span>            :      return expression[opt] ;
<span class="lineNum">    5247 </span>            : 
<span class="lineNum">    5248 </span>            :    GNU extensions:
<span class="lineNum">    5249 </span>            : 
<span class="lineNum">    5250 </span>            :    statement:
<span class="lineNum">    5251 </span>            :      asm-statement
<span class="lineNum">    5252 </span>            : 
<span class="lineNum">    5253 </span>            :    jump-statement:
<span class="lineNum">    5254 </span>            :      goto * expression ;
<span class="lineNum">    5255 </span>            : 
<span class="lineNum">    5256 </span>            :    expression-statement:
<span class="lineNum">    5257 </span>            :      attributes ;
<span class="lineNum">    5258 </span>            : 
<span class="lineNum">    5259 </span>            :    Objective-C:
<span class="lineNum">    5260 </span>            : 
<span class="lineNum">    5261 </span>            :    statement:
<span class="lineNum">    5262 </span>            :      objc-throw-statement
<span class="lineNum">    5263 </span>            :      objc-try-catch-statement
<span class="lineNum">    5264 </span>            :      objc-synchronized-statement
<span class="lineNum">    5265 </span>            : 
<span class="lineNum">    5266 </span>            :    objc-throw-statement:
<span class="lineNum">    5267 </span>            :      @throw expression ;
<span class="lineNum">    5268 </span>            :      @throw ;
<span class="lineNum">    5269 </span>            : 
<span class="lineNum">    5270 </span>            :    OpenACC:
<span class="lineNum">    5271 </span>            : 
<span class="lineNum">    5272 </span>            :    statement:
<span class="lineNum">    5273 </span>            :      openacc-construct
<span class="lineNum">    5274 </span>            : 
<span class="lineNum">    5275 </span>            :    openacc-construct:
<span class="lineNum">    5276 </span>            :      parallel-construct
<span class="lineNum">    5277 </span>            :      kernels-construct
<span class="lineNum">    5278 </span>            :      data-construct
<span class="lineNum">    5279 </span>            :      loop-construct
<span class="lineNum">    5280 </span>            : 
<span class="lineNum">    5281 </span>            :    parallel-construct:
<span class="lineNum">    5282 </span>            :      parallel-directive structured-block
<span class="lineNum">    5283 </span>            : 
<span class="lineNum">    5284 </span>            :    kernels-construct:
<span class="lineNum">    5285 </span>            :      kernels-directive structured-block
<span class="lineNum">    5286 </span>            : 
<span class="lineNum">    5287 </span>            :    data-construct:
<span class="lineNum">    5288 </span>            :      data-directive structured-block
<span class="lineNum">    5289 </span>            : 
<span class="lineNum">    5290 </span>            :    loop-construct:
<span class="lineNum">    5291 </span>            :      loop-directive structured-block
<span class="lineNum">    5292 </span>            : 
<span class="lineNum">    5293 </span>            :    OpenMP:
<span class="lineNum">    5294 </span>            : 
<span class="lineNum">    5295 </span>            :    statement:
<span class="lineNum">    5296 </span>            :      openmp-construct
<span class="lineNum">    5297 </span>            : 
<span class="lineNum">    5298 </span>            :    openmp-construct:
<span class="lineNum">    5299 </span>            :      parallel-construct
<span class="lineNum">    5300 </span>            :      for-construct
<span class="lineNum">    5301 </span>            :      simd-construct
<span class="lineNum">    5302 </span>            :      for-simd-construct
<span class="lineNum">    5303 </span>            :      sections-construct
<span class="lineNum">    5304 </span>            :      single-construct
<span class="lineNum">    5305 </span>            :      parallel-for-construct
<span class="lineNum">    5306 </span>            :      parallel-for-simd-construct
<span class="lineNum">    5307 </span>            :      parallel-sections-construct
<span class="lineNum">    5308 </span>            :      master-construct
<span class="lineNum">    5309 </span>            :      critical-construct
<span class="lineNum">    5310 </span>            :      atomic-construct
<span class="lineNum">    5311 </span>            :      ordered-construct
<span class="lineNum">    5312 </span>            : 
<span class="lineNum">    5313 </span>            :    parallel-construct:
<span class="lineNum">    5314 </span>            :      parallel-directive structured-block
<span class="lineNum">    5315 </span>            : 
<span class="lineNum">    5316 </span>            :    for-construct:
<span class="lineNum">    5317 </span>            :      for-directive iteration-statement
<span class="lineNum">    5318 </span>            : 
<span class="lineNum">    5319 </span>            :    simd-construct:
<span class="lineNum">    5320 </span>            :      simd-directive iteration-statements
<span class="lineNum">    5321 </span>            : 
<span class="lineNum">    5322 </span>            :    for-simd-construct:
<span class="lineNum">    5323 </span>            :      for-simd-directive iteration-statements
<span class="lineNum">    5324 </span>            : 
<span class="lineNum">    5325 </span>            :    sections-construct:
<span class="lineNum">    5326 </span>            :      sections-directive section-scope
<span class="lineNum">    5327 </span>            : 
<span class="lineNum">    5328 </span>            :    single-construct:
<span class="lineNum">    5329 </span>            :      single-directive structured-block
<span class="lineNum">    5330 </span>            : 
<span class="lineNum">    5331 </span>            :    parallel-for-construct:
<span class="lineNum">    5332 </span>            :      parallel-for-directive iteration-statement
<span class="lineNum">    5333 </span>            : 
<span class="lineNum">    5334 </span>            :    parallel-for-simd-construct:
<span class="lineNum">    5335 </span>            :      parallel-for-simd-directive iteration-statement
<span class="lineNum">    5336 </span>            : 
<span class="lineNum">    5337 </span>            :    parallel-sections-construct:
<span class="lineNum">    5338 </span>            :      parallel-sections-directive section-scope
<span class="lineNum">    5339 </span>            : 
<span class="lineNum">    5340 </span>            :    master-construct:
<span class="lineNum">    5341 </span>            :      master-directive structured-block
<span class="lineNum">    5342 </span>            : 
<span class="lineNum">    5343 </span>            :    critical-construct:
<span class="lineNum">    5344 </span>            :      critical-directive structured-block
<span class="lineNum">    5345 </span>            : 
<span class="lineNum">    5346 </span>            :    atomic-construct:
<span class="lineNum">    5347 </span>            :      atomic-directive expression-statement
<span class="lineNum">    5348 </span>            : 
<span class="lineNum">    5349 </span>            :    ordered-construct:
<span class="lineNum">    5350 </span>            :      ordered-directive structured-block
<span class="lineNum">    5351 </span>            : 
<span class="lineNum">    5352 </span>            :    Transactional Memory:
<span class="lineNum">    5353 </span>            : 
<span class="lineNum">    5354 </span>            :    statement:
<span class="lineNum">    5355 </span>            :      transaction-statement
<span class="lineNum">    5356 </span>            :      transaction-cancel-statement
<span class="lineNum">    5357 </span>            : 
<span class="lineNum">    5358 </span>            :    IF_P is used to track whether there's a (possibly labeled) if statement
<span class="lineNum">    5359 </span>            :    which is not enclosed in braces and has an else clause.  This is used to
<span class="lineNum">    5360 </span>            :    implement -Wparentheses.  */
<a name="5361"><span class="lineNum">    5361 </span>            : </a>
<span class="lineNum">    5362 </span>            : static void
<span class="lineNum">    5363 </span>            : c_parser_statement (c_parser *parser, bool *if_p, location_t *loc_after_labels)
<span class="lineNum">    5364 </span>            : {
<span class="lineNum">    5365 </span>            :   c_parser_all_labels (parser);
<span class="lineNum">    5366 </span>            :   if (loc_after_labels)
<span class="lineNum">    5367 </span>            :     *loc_after_labels = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    5368 </span>            :   c_parser_statement_after_labels (parser, if_p, NULL);
<span class="lineNum">    5369 </span>            : }
<span class="lineNum">    5370 </span>            : 
<span class="lineNum">    5371 </span>            : /* Parse a statement, other than a labeled statement.  CHAIN is a vector
<span class="lineNum">    5372 </span>            :    of if-else-if conditions.
<span class="lineNum">    5373 </span>            : 
<span class="lineNum">    5374 </span>            :    IF_P is used to track whether there's a (possibly labeled) if statement
<span class="lineNum">    5375 </span>            :    which is not enclosed in braces and has an else clause.  This is used to
<span class="lineNum">    5376 </span>            :    implement -Wparentheses.  */
<a name="5377"><span class="lineNum">    5377 </span>            : </a>
<span class="lineNum">    5378 </span>            : static void
<span class="lineNum">    5379 </span>            : c_parser_statement_after_labels (c_parser *parser, bool *if_p,
<span class="lineNum">    5380 </span>            :                                  vec&lt;tree&gt; *chain)
<span class="lineNum">    5381 </span>            : {
<span class="lineNum">    5382 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    5383 </span>            :   tree stmt = NULL_TREE;
<span class="lineNum">    5384 </span>            :   bool in_if_block = parser-&gt;in_if_block;
<span class="lineNum">    5385 </span>            :   parser-&gt;in_if_block = false;
<span class="lineNum">    5386 </span>            :   if (if_p != NULL)
<span class="lineNum">    5387 </span><span class="lineCov">     361807 :     *if_p = false;</span>
<span class="lineNum">    5388 </span>            : 
<span class="lineNum">    5389 </span><span class="lineCov">     361807 :   if (c_parser_peek_token (parser)-&gt;type != CPP_OPEN_BRACE)</span>
<span class="lineNum">    5390 </span><span class="lineCov">     361807 :     add_debug_begin_stmt (loc);</span>
<span class="lineNum">    5391 </span><span class="lineCov">     257959 : </span>
<span class="lineNum">    5392 </span><span class="lineCov">     365653 :   switch (c_parser_peek_token (parser)-&gt;type)</span>
<span class="lineNum">    5393 </span><span class="lineCov">     361807 :     {</span>
<span class="lineNum">    5394 </span>            :     case CPP_OPEN_BRACE:
<span class="lineNum">    5395 </span>            :       add_stmt (c_parser_compound_statement (parser));
<span class="lineNum">    5396 </span>            :       break;
<span class="lineNum">    5397 </span>            :     case CPP_KEYWORD:
<span class="lineNum">    5398 </span>            :       switch (c_parser_peek_token (parser)-&gt;keyword)
<span class="lineNum">    5399 </span>            :         {
<span class="lineNum">    5400 </span>            :         case RID_IF:
<span class="lineNum">    5401 </span>            :           c_parser_if_statement (parser, if_p, chain);
<span class="lineNum">    5402 </span>            :           break;
<span class="lineNum">    5403 </span><span class="lineCov">   22695562 :         case RID_SWITCH:</span>
<span class="lineNum">    5404 </span>            :           c_parser_switch_statement (parser, if_p);
<span class="lineNum">    5405 </span>            :           break;
<span class="lineNum">    5406 </span><span class="lineCov">   22695562 :         case RID_WHILE:</span>
<span class="lineNum">    5407 </span><span class="lineCov">   22695562 :           c_parser_while_statement (parser, false, 0, if_p);</span>
<span class="lineNum">    5408 </span><span class="lineCov">   22695562 :           break;</span>
<span class="lineNum">    5409 </span><span class="lineCov">   22695562 :         case RID_DO:</span>
<span class="lineNum">    5410 </span><span class="lineCov">   22695562 :           c_parser_do_statement (parser, 0, false);</span>
<span class="lineNum">    5411 </span><span class="lineCov">     676952 :           break;</span>
<span class="lineNum">    5412 </span>            :         case RID_FOR:
<span class="lineNum">    5413 </span><span class="lineCov">   22695562 :           c_parser_for_statement (parser, false, 0, if_p);</span>
<span class="lineNum">    5414 </span><span class="lineCov">   22403838 :           break;</span>
<span class="lineNum">    5415 </span>            :         case RID_GOTO:
<span class="lineNum">    5416 </span><span class="lineCov">   22695562 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    5417 </span>            :           if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">    5418 </span><span class="lineCov">     291724 :             {</span>
<span class="lineNum">    5419 </span><span class="lineCov">     291724 :               stmt = c_finish_goto_label (loc,</span>
<span class="lineNum">    5420 </span><span class="lineCov">     291724 :                                           c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">    5421 </span><span class="lineCov">   18684993 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    5422 </span><span class="lineCov">   18684993 :             }</span>
<span class="lineNum">    5423 </span>            :           else if (c_parser_next_token_is (parser, CPP_MULT))
<span class="lineNum">    5424 </span><span class="lineCov">     881727 :             {</span>
<span class="lineNum">    5425 </span><span class="lineCov">     881727 :               struct c_expr val;</span>
<span class="lineNum">    5426 </span><span class="lineCov">     881727 : </span>
<span class="lineNum">    5427 </span><span class="lineCov">      21532 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    5428 </span><span class="lineCov">      21532 :               val = c_parser_expression (parser);</span>
<span class="lineNum">    5429 </span><span class="lineCov">      21532 :               val = convert_lvalue_to_rvalue (loc, val, false, true);</span>
<span class="lineNum">    5430 </span><span class="lineCov">      34888 :               stmt = c_finish_goto_ptr (loc, val.value);</span>
<span class="lineNum">    5431 </span><span class="lineCov">      34888 :             }</span>
<span class="lineNum">    5432 </span><span class="lineCov">      34888 :           else</span>
<span class="lineNum">    5433 </span><span class="lineCov">      99296 :             c_parser_error (parser, &quot;expected identifier or %&lt;*%&gt;&quot;);</span>
<span class="lineNum">    5434 </span><span class="lineCov">      99296 :           goto expect_semicolon;</span>
<span class="lineNum">    5435 </span><span class="lineCov">      99296 :         case RID_CONTINUE:</span>
<span class="lineNum">    5436 </span><span class="lineCov">     201497 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    5437 </span><span class="lineCov">     201497 :           stmt = c_finish_bc_stmt (loc, &amp;c_cont_label, false);</span>
<span class="lineNum">    5438 </span><span class="lineCov">     201497 :           goto expect_semicolon;</span>
<span class="lineNum">    5439 </span><span class="lineCov">      80591 :         case RID_BREAK:</span>
<span class="lineNum">    5440 </span><span class="lineCov">      80591 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    5441 </span><span class="lineCov">      80591 :           stmt = c_finish_bc_stmt (loc, &amp;c_break_label, true);</span>
<span class="lineNum">    5442 </span>            :           goto expect_semicolon;
<span class="lineNum">    5443 </span><span class="lineCov">      79773 :         case RID_RETURN:</span>
<span class="lineNum">    5444 </span><span class="lineCov">      79773 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    5445 </span><span class="lineCov">      79773 :           if (c_parser_next_token_is (parser, CPP_SEMICOLON))</span>
<span class="lineNum">    5446 </span>            :             {
<span class="lineNum">    5447 </span><span class="lineCov">        818 :               stmt = c_finish_return (loc, NULL_TREE, NULL_TREE);</span>
<span class="lineNum">    5448 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">    5449 </span><span class="lineCov">        818 :             }</span>
<span class="lineNum">    5450 </span>            :           else
<span class="lineNum">    5451 </span><span class="lineCov">        818 :             {</span>
<span class="lineNum">    5452 </span><span class="lineCov">        818 :               location_t xloc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    5453 </span><span class="lineCov">        818 :               struct c_expr expr = c_parser_expression_conv (parser);</span>
<span class="lineNum">    5454 </span><span class="lineCov">        818 :               mark_exp_read (expr.value);</span>
<span class="lineNum">    5455 </span>            :               stmt = c_finish_return (EXPR_LOC_OR_LOC (expr.value, xloc),
<span class="lineNum">    5456 </span>            :                                       expr.value, expr.original_type);
<span class="lineNum">    5457 </span><span class="lineNoCov">          0 :               goto expect_semicolon;</span>
<span class="lineNum">    5458 </span><span class="lineCov">      80591 :             }</span>
<span class="lineNum">    5459 </span><span class="lineCov">      10119 :           break;</span>
<span class="lineNum">    5460 </span><span class="lineCov">      10119 :         case RID_ASM:</span>
<span class="lineNum">    5461 </span><span class="lineCov">      10119 :           stmt = c_parser_asm_statement (parser);</span>
<span class="lineNum">    5462 </span><span class="lineCov">      10119 :           break;</span>
<span class="lineNum">    5463 </span><span class="lineCov">      89277 :         case RID_TRANSACTION_ATOMIC:</span>
<span class="lineNum">    5464 </span><span class="lineCov">      89277 :         case RID_TRANSACTION_RELAXED:</span>
<span class="lineNum">    5465 </span><span class="lineCov">      89277 :           stmt = c_parser_transaction (parser,</span>
<span class="lineNum">    5466 </span><span class="lineCov">      89277 :               c_parser_peek_token (parser)-&gt;keyword);</span>
<span class="lineNum">    5467 </span><span class="lineCov">   17104738 :           break;</span>
<span class="lineNum">    5468 </span><span class="lineCov">   17104738 :         case RID_TRANSACTION_CANCEL:</span>
<span class="lineNum">    5469 </span><span class="lineCov">   17104738 :           stmt = c_parser_transaction_cancel (parser);</span>
<span class="lineNum">    5470 </span>            :           goto expect_semicolon;
<span class="lineNum">    5471 </span><span class="lineCov">      13237 :         case RID_AT_THROW:</span>
<span class="lineNum">    5472 </span><span class="lineCov">      13237 :           gcc_assert (c_dialect_objc ());</span>
<span class="lineNum">    5473 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    5474 </span>            :           if (c_parser_next_token_is (parser, CPP_SEMICOLON))
<span class="lineNum">    5475 </span>            :             {
<span class="lineNum">    5476 </span><span class="lineCov">   17091501 :               stmt = objc_build_throw_stmt (loc, NULL_TREE);</span>
<span class="lineNum">    5477 </span><span class="lineCov">   17091501 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    5478 </span><span class="lineCov">   17091501 :             }</span>
<span class="lineNum">    5479 </span><span class="lineCov">   17091501 :           else</span>
<span class="lineNum">    5480 </span>            :             {
<span class="lineNum">    5481 </span><span class="lineCov">   17091501 :               struct c_expr expr = c_parser_expression (parser);</span>
<span class="lineNum">    5482 </span>            :               expr = convert_lvalue_to_rvalue (loc, expr, false, false);
<span class="lineNum">    5483 </span><span class="lineCov">      13237 :               expr.value = c_fully_fold (expr.value, false, NULL);</span>
<span class="lineNum">    5484 </span><span class="lineCov">     156073 :               stmt = objc_build_throw_stmt (loc, expr.value);</span>
<span class="lineNum">    5485 </span><span class="lineCov">     156073 :               goto expect_semicolon;</span>
<span class="lineNum">    5486 </span><span class="lineCov">     156073 :             }</span>
<span class="lineNum">    5487 </span><span class="lineCov">        128 :           break;</span>
<span class="lineNum">    5488 </span><span class="lineCov">        128 :         case RID_AT_TRY:</span>
<span class="lineNum">    5489 </span><span class="lineCov">        256 :           gcc_assert (c_dialect_objc ());</span>
<span class="lineNum">    5490 </span><span class="lineCov">        128 :           c_parser_objc_try_catch_finally_statement (parser);</span>
<span class="lineNum">    5491 </span><span class="lineCov">        128 :           break;</span>
<span class="lineNum">    5492 </span><span class="lineCov">         26 :         case RID_AT_SYNCHRONIZED:</span>
<span class="lineNum">    5493 </span><span class="lineCov">         26 :           gcc_assert (c_dialect_objc ());</span>
<span class="lineNum">    5494 </span><span class="lineCov">         26 :           c_parser_objc_synchronized_statement (parser);</span>
<span class="lineNum">    5495 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    5496 </span><span class="lineNoCov">          0 :         case RID_ATTRIBUTE:</span>
<span class="lineNum">    5497 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">    5498 </span><span class="lineNoCov">          0 :             /* Allow '__attribute__((fallthrough));'.  */</span>
<span class="lineNum">    5499 </span>            :             tree attrs = c_parser_attributes (parser);
<span class="lineNum">    5500 </span><span class="lineNoCov">          0 :             if (attribute_fallthrough_p (attrs))</span>
<span class="lineNum">    5501 </span><span class="lineNoCov">          0 :               {</span>
<span class="lineNum">    5502 </span>            :                 if (c_parser_next_token_is (parser, CPP_SEMICOLON))
<span class="lineNum">    5503 </span>            :                   {
<span class="lineNum">    5504 </span>            :                     tree fn = build_call_expr_internal_loc (loc,
<span class="lineNum">    5505 </span><span class="lineNoCov">          0 :                                                             IFN_FALLTHROUGH,</span>
<span class="lineNum">    5506 </span><span class="lineNoCov">          0 :                                                             void_type_node, 0);</span>
<span class="lineNum">    5507 </span><span class="lineNoCov">          0 :                     add_stmt (fn);</span>
<span class="lineNum">    5508 </span><span class="lineNoCov">          0 :                     /* Eat the ';'.  */</span>
<span class="lineNum">    5509 </span><span class="lineNoCov">          0 :                     c_parser_consume_token (parser);</span>
<span class="lineNum">    5510 </span>            :                   }
<span class="lineNum">    5511 </span><span class="lineNoCov">          0 :                 else</span>
<span class="lineNum">    5512 </span><span class="lineNoCov">          0 :                   warning_at (loc, OPT_Wattributes,</span>
<span class="lineNum">    5513 </span><span class="lineNoCov">          0 :                               &quot;%&lt;fallthrough%&gt; attribute not followed &quot;</span>
<span class="lineNum">    5514 </span><span class="lineNoCov">          0 :                               &quot;by %&lt;;%&gt;&quot;);</span>
<span class="lineNum">    5515 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">    5516 </span><span class="lineNoCov">          0 :             else if (attrs != NULL_TREE)</span>
<span class="lineNum">    5517 </span><span class="lineNoCov">          0 :               warning_at (loc, OPT_Wattributes, &quot;only attribute %&lt;fallthrough%&gt;&quot;</span>
<span class="lineNum">    5518 </span><span class="lineNoCov">          0 :                           &quot; can be applied to a null statement&quot;);</span>
<span class="lineNum">    5519 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    5520 </span><span class="lineCov">          5 :           }</span>
<span class="lineNum">    5521 </span><span class="lineCov">          5 :         default:</span>
<span class="lineNum">    5522 </span>            :           goto expr_stmt;
<span class="lineNum">    5523 </span><span class="lineCov">          5 :         }</span>
<span class="lineNum">    5524 </span><span class="lineCov">          5 :       break;</span>
<span class="lineNum">    5525 </span>            :     case CPP_SEMICOLON:
<span class="lineNum">    5526 </span><span class="lineCov">          5 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    5527 </span>            :       break;
<span class="lineNum">    5528 </span><span class="lineCov">          5 :     case CPP_CLOSE_PAREN:</span>
<span class="lineNum">    5529 </span>            :     case CPP_CLOSE_SQUARE:
<span class="lineNum">    5530 </span>            :       /* Avoid infinite loop in error recovery:
<span class="lineNum">    5531 </span><span class="lineCov">          5 :          c_parser_skip_until_found stops at a closing nesting</span>
<span class="lineNum">    5532 </span>            :          delimiter without consuming it, but here we need to consume
<span class="lineNum">    5533 </span><span class="lineCov">          5 :          it to proceed further.  */</span>
<span class="lineNum">    5534 </span>            :       c_parser_error (parser, &quot;expected statement&quot;);
<span class="lineNum">    5535 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    5536 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    5537 </span>            :     case CPP_PRAGMA:
<span class="lineNum">    5538 </span>            :       c_parser_pragma (parser, pragma_stmt, if_p);
<span class="lineNum">    5539 </span>            :       break;
<span class="lineNum">    5540 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    5541 </span><span class="lineNoCov">          0 :     expr_stmt:</span>
<span class="lineNum">    5542 </span>            :       stmt = c_finish_expr_stmt (loc, c_parser_expression_conv (parser).value);
<span class="lineNum">    5543 </span>            :     expect_semicolon:
<span class="lineNum">    5544 </span>            :       c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);
<span class="lineNum">    5545 </span>            :       break;
<span class="lineNum">    5546 </span>            :     }
<span class="lineNum">    5547 </span>            :   /* Two cases cannot and do not have line numbers associated: If stmt
<span class="lineNum">    5548 </span>            :      is degenerate, such as &quot;2;&quot;, then stmt is an INTEGER_CST, which
<span class="lineNum">    5549 </span><span class="lineCov">     167601 :      cannot hold line numbers.  But that's OK because the statement</span>
<span class="lineNum">    5550 </span><span class="lineCov">     167601 :      will either be changed to a MODIFY_EXPR during gimplification of</span>
<span class="lineNum">    5551 </span><span class="lineCov">     167601 :      the statement expr, or discarded.  If stmt was compound, but</span>
<span class="lineNum">    5552 </span><span class="lineCov">          2 :      without new variables, we will have skipped the creation of a</span>
<span class="lineNum">    5553 </span><span class="lineCov">          2 :      BIND and will have a bare STATEMENT_LIST.  But that's OK because</span>
<span class="lineNum">    5554 </span>            :      (recursively) all of the component statements should already have
<span class="lineNum">    5555 </span>            :      line numbers assigned.  ??? Can we discard no-op statements
<span class="lineNum">    5556 </span>            :      earlier?  */
<span class="lineNum">    5557 </span>            :   if (EXPR_LOCATION (stmt) == UNKNOWN_LOCATION)
<span class="lineNum">    5558 </span><span class="lineCov">          2 :     protected_set_expr_location (stmt, loc);</span>
<span class="lineNum">    5559 </span><span class="lineCov">          2 : </span>
<span class="lineNum">    5560 </span><span class="lineCov">          2 :   parser-&gt;in_if_block = in_if_block;</span>
<span class="lineNum">    5561 </span><span class="lineCov">       1256 : }</span>
<span class="lineNum">    5562 </span><span class="lineCov">       1256 : </span>
<span class="lineNum">    5563 </span><span class="lineCov">       1256 : /* Parse the condition from an if, do, while or for statements.  */</span>
<a name="5564"><span class="lineNum">    5564 </span><span class="lineCov">    3555082 : </span></a>
<span class="lineNum">    5565 </span><span class="lineCov">    7110164 : static tree</span>
<span class="lineNum">    5566 </span><span class="lineCov">    3555082 : c_parser_condition (c_parser *parser)</span>
<span class="lineNum">    5567 </span><span class="lineCov">   20826595 : {</span>
<span class="lineNum">    5568 </span><span class="lineCov">   20826595 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    5569 </span><span class="lineCov">   20826595 :   tree cond;</span>
<span class="lineNum">    5570 </span>            :   cond = c_parser_expression_conv (parser).value;
<span class="lineNum">    5571 </span>            :   cond = c_objc_common_truthvalue_conversion (loc, cond);
<span class="lineNum">    5572 </span>            :   cond = c_fully_fold (cond, false, NULL);
<span class="lineNum">    5573 </span>            :   if (warn_sequence_point)
<span class="lineNum">    5574 </span>            :     verify_sequence_points (cond);
<span class="lineNum">    5575 </span>            :   return cond;
<span class="lineNum">    5576 </span>            : }
<span class="lineNum">    5577 </span>            : 
<span class="lineNum">    5578 </span>            : /* Parse a parenthesized condition from an if, do or while statement.
<span class="lineNum">    5579 </span>            : 
<span class="lineNum">    5580 </span>            :    condition:
<span class="lineNum">    5581 </span><span class="lineCov">   22695561 :      ( expression )</span>
<a name="5582"><span class="lineNum">    5582 </span><span class="lineCov">    1701531 : */</span></a>
<span class="lineNum">    5583 </span>            : static tree
<span class="lineNum">    5584 </span><span class="lineCov">   22695561 : c_parser_paren_condition (c_parser *parser)</span>
<span class="lineNum">    5585 </span><span class="lineCov">   22695561 : {</span>
<span class="lineNum">    5586 </span>            :   tree cond;
<span class="lineNum">    5587 </span>            :   matching_parens parens;
<span class="lineNum">    5588 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">    5589 </span>            :     return error_mark_node;
<span class="lineNum">    5590 </span><span class="lineCov">    1215421 :   cond = c_parser_condition (parser);</span>
<span class="lineNum">    5591 </span>            :   parens.skip_until_found_close (parser);
<span class="lineNum">    5592 </span><span class="lineCov">    1215421 :   return cond;</span>
<span class="lineNum">    5593 </span><span class="lineCov">    1215421 : }</span>
<span class="lineNum">    5594 </span><span class="lineCov">    1215421 : </span>
<span class="lineNum">    5595 </span><span class="lineCov">    1215421 : /* Parse a statement which is a block in C99.</span>
<span class="lineNum">    5596 </span><span class="lineCov">    1215421 : </span>
<span class="lineNum">    5597 </span><span class="lineCov">    1215421 :    IF_P is used to track whether there's a (possibly labeled) if statement</span>
<span class="lineNum">    5598 </span><span class="lineCov">     193690 :    which is not enclosed in braces and has an else clause.  This is used to</span>
<span class="lineNum">    5599 </span><span class="lineCov">    1215421 :    implement -Wparentheses.  */</span>
<a name="5600"><span class="lineNum">    5600 </span>            : </a>
<span class="lineNum">    5601 </span>            : static tree
<span class="lineNum">    5602 </span>            : c_parser_c99_block_statement (c_parser *parser, bool *if_p,
<span class="lineNum">    5603 </span>            :                               location_t *loc_after_labels)
<span class="lineNum">    5604 </span>            : {
<span class="lineNum">    5605 </span>            :   tree block = c_begin_compound_stmt (flag_isoc99);
<span class="lineNum">    5606 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    5607 </span>            :   c_parser_statement (parser, if_p, loc_after_labels);
<span class="lineNum">    5608 </span><span class="lineCov">    1015924 :   return c_end_compound_stmt (loc, block, flag_isoc99);</span>
<span class="lineNum">    5609 </span>            : }
<span class="lineNum">    5610 </span><span class="lineCov">    1015924 : </span>
<span class="lineNum">    5611 </span><span class="lineCov">    2031848 : /* Parse the body of an if statement.  This is just parsing a</span>
<span class="lineNum">    5612 </span><span class="lineCov">    1015924 :    statement but (a) it is a block in C99, (b) we track whether the</span>
<span class="lineNum">    5613 </span><span class="lineCov">          1 :    body is an if statement for the sake of -Wparentheses warnings, (c)</span>
<span class="lineNum">    5614 </span><span class="lineCov">    1015923 :    we handle an empty body specially for the sake of -Wempty-body</span>
<span class="lineNum">    5615 </span><span class="lineCov">    2031846 :    warnings, and (d) we call parser_compound_statement directly</span>
<span class="lineNum">    5616 </span><span class="lineCov">    1015923 :    because c_parser_statement_after_labels resets</span>
<span class="lineNum">    5617 </span>            :    parser-&gt;in_if_block.
<span class="lineNum">    5618 </span>            : 
<span class="lineNum">    5619 </span>            :    IF_P is used to track whether there's a (possibly labeled) if statement
<span class="lineNum">    5620 </span>            :    which is not enclosed in braces and has an else clause.  This is used to
<span class="lineNum">    5621 </span>            :    implement -Wparentheses.  */
<a name="5622"><span class="lineNum">    5622 </span>            : </a>
<span class="lineNum">    5623 </span>            : static tree
<span class="lineNum">    5624 </span>            : c_parser_if_body (c_parser *parser, bool *if_p,
<span class="lineNum">    5625 </span>            :                   const token_indent_info &amp;if_tinfo)
<span class="lineNum">    5626 </span><span class="lineCov">     361807 : {</span>
<span class="lineNum">    5627 </span>            :   tree block = c_begin_compound_stmt (flag_isoc99);
<span class="lineNum">    5628 </span>            :   location_t body_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    5629 </span><span class="lineCov">     361807 :   location_t body_loc_after_labels = UNKNOWN_LOCATION;</span>
<span class="lineNum">    5630 </span><span class="lineCov">     361807 :   token_indent_info body_tinfo</span>
<span class="lineNum">    5631 </span><span class="lineCov">     361807 :     = get_token_indent_info (c_parser_peek_token (parser));</span>
<span class="lineNum">    5632 </span><span class="lineCov">     361807 : </span>
<span class="lineNum">    5633 </span>            :   c_parser_all_labels (parser);
<span class="lineNum">    5634 </span>            :   if (c_parser_next_token_is (parser, CPP_SEMICOLON))
<span class="lineNum">    5635 </span>            :     {
<span class="lineNum">    5636 </span>            :       location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    5637 </span>            :       add_stmt (build_empty_stmt (loc));
<span class="lineNum">    5638 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    5639 </span>            :       if (!c_parser_next_token_is_keyword (parser, RID_ELSE))
<span class="lineNum">    5640 </span>            :         warning_at (loc, OPT_Wempty_body,
<span class="lineNum">    5641 </span>            :                     &quot;suggest braces around empty body in an %&lt;if%&gt; statement&quot;);
<span class="lineNum">    5642 </span>            :     }
<span class="lineNum">    5643 </span>            :   else if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))
<span class="lineNum">    5644 </span>            :     add_stmt (c_parser_compound_statement (parser));
<span class="lineNum">    5645 </span>            :   else
<span class="lineNum">    5646 </span>            :     {
<span class="lineNum">    5647 </span>            :       body_loc_after_labels = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    5648 </span><span class="lineCov">     881727 :       c_parser_statement_after_labels (parser, if_p);</span>
<span class="lineNum">    5649 </span>            :     }
<span class="lineNum">    5650 </span>            : 
<span class="lineNum">    5651 </span><span class="lineCov">     881727 :   token_indent_info next_tinfo</span>
<span class="lineNum">    5652 </span><span class="lineCov">     881727 :     = get_token_indent_info (c_parser_peek_token (parser));</span>
<span class="lineNum">    5653 </span><span class="lineCov">     881727 :   warn_for_misleading_indentation (if_tinfo, body_tinfo, next_tinfo);</span>
<span class="lineNum">    5654 </span><span class="lineCov">     881727 :   if (body_loc_after_labels != UNKNOWN_LOCATION</span>
<span class="lineNum">    5655 </span><span class="lineCov">     881727 :       &amp;&amp; next_tinfo.type != CPP_SEMICOLON)</span>
<span class="lineNum">    5656 </span>            :     warn_for_multistatement_macros (body_loc_after_labels, next_tinfo.location,
<span class="lineNum">    5657 </span><span class="lineCov">     881727 :                                     if_tinfo.location, RID_IF);</span>
<span class="lineNum">    5658 </span><span class="lineCov">     881727 : </span>
<span class="lineNum">    5659 </span>            :   return c_end_compound_stmt (body_loc, block, flag_isoc99);
<span class="lineNum">    5660 </span><span class="lineCov">       2178 : }</span>
<span class="lineNum">    5661 </span><span class="lineCov">       2178 : </span>
<span class="lineNum">    5662 </span><span class="lineCov">       2178 : /* Parse the else body of an if statement.  This is just parsing a</span>
<span class="lineNum">    5663 </span><span class="lineCov">       2178 :    statement but (a) it is a block in C99, (b) we handle an empty body</span>
<span class="lineNum">    5664 </span><span class="lineCov">        346 :    specially for the sake of -Wempty-body warnings.  CHAIN is a vector</span>
<span class="lineNum">    5665 </span>            :    of if-else-if conditions.  */
<a name="5666"><span class="lineNum">    5666 </span>            : </a>
<span class="lineNum">    5667 </span><span class="lineCov">     879549 : static tree</span>
<span class="lineNum">    5668 </span><span class="lineCov">     204788 : c_parser_else_body (c_parser *parser, const token_indent_info &amp;else_tinfo,</span>
<span class="lineNum">    5669 </span>            :                     vec&lt;tree&gt; *chain)
<span class="lineNum">    5670 </span>            : {
<span class="lineNum">    5671 </span><span class="lineCov">     674761 :   location_t body_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    5672 </span><span class="lineCov">     674761 :   tree block = c_begin_compound_stmt (flag_isoc99);</span>
<span class="lineNum">    5673 </span>            :   token_indent_info body_tinfo
<span class="lineNum">    5674 </span>            :     = get_token_indent_info (c_parser_peek_token (parser));
<span class="lineNum">    5675 </span><span class="lineCov">     881727 :   location_t body_loc_after_labels = UNKNOWN_LOCATION;</span>
<span class="lineNum">    5676 </span><span class="lineCov">     881727 : </span>
<span class="lineNum">    5677 </span><span class="lineCov">     881727 :   c_parser_all_labels (parser);</span>
<span class="lineNum">    5678 </span><span class="lineCov">     881727 :   if (c_parser_next_token_is (parser, CPP_SEMICOLON))</span>
<span class="lineNum">    5679 </span><span class="lineCov">     674761 :     {</span>
<span class="lineNum">    5680 </span><span class="lineCov">    1341140 :       location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    5681 </span><span class="lineCov">     670570 :       warning_at (loc,</span>
<span class="lineNum">    5682 </span>            :                   OPT_Wempty_body,
<span class="lineNum">    5683 </span><span class="lineCov">     881727 :                  &quot;suggest braces around empty body in an %&lt;else%&gt; statement&quot;);</span>
<span class="lineNum">    5684 </span>            :       add_stmt (build_empty_stmt (loc));
<span class="lineNum">    5685 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    5686 </span>            :     }
<span class="lineNum">    5687 </span>            :   else
<span class="lineNum">    5688 </span>            :     {
<span class="lineNum">    5689 </span>            :       if (!c_parser_next_token_is (parser, CPP_OPEN_BRACE))
<span class="lineNum">    5690 </span>            :         body_loc_after_labels = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    5691 </span>            :       c_parser_statement_after_labels (parser, NULL, chain);
<span class="lineNum">    5692 </span><span class="lineCov">     114163 :     }</span>
<span class="lineNum">    5693 </span>            : 
<span class="lineNum">    5694 </span>            :   token_indent_info next_tinfo
<span class="lineNum">    5695 </span><span class="lineCov">     114163 :     = get_token_indent_info (c_parser_peek_token (parser));</span>
<span class="lineNum">    5696 </span><span class="lineCov">     114163 :   warn_for_misleading_indentation (else_tinfo, body_tinfo, next_tinfo);</span>
<span class="lineNum">    5697 </span><span class="lineCov">     114163 :   if (body_loc_after_labels != UNKNOWN_LOCATION</span>
<span class="lineNum">    5698 </span><span class="lineCov">     114163 :       &amp;&amp; next_tinfo.type != CPP_SEMICOLON)</span>
<span class="lineNum">    5699 </span><span class="lineCov">     114163 :     warn_for_multistatement_macros (body_loc_after_labels, next_tinfo.location,</span>
<span class="lineNum">    5700 </span>            :                                     else_tinfo.location, RID_ELSE);
<span class="lineNum">    5701 </span><span class="lineCov">     114163 : </span>
<span class="lineNum">    5702 </span><span class="lineCov">     114163 :   return c_end_compound_stmt (body_loc, block, flag_isoc99);</span>
<span class="lineNum">    5703 </span>            : }
<span class="lineNum">    5704 </span><span class="lineCov">         30 : </span>
<span class="lineNum">    5705 </span><span class="lineCov">         30 : /* We might need to reclassify any previously-lexed identifier, e.g.</span>
<span class="lineNum">    5706 </span>            :    when we've left a for loop with an if-statement without else in the
<span class="lineNum">    5707 </span>            :    body - we might have used a wrong scope for the token.  See PR67784.  */
<a name="5708"><span class="lineNum">    5708 </span><span class="lineCov">         30 : </span></a>
<span class="lineNum">    5709 </span><span class="lineCov">         30 : static void</span>
<span class="lineNum">    5710 </span>            : c_parser_maybe_reclassify_token (c_parser *parser)
<span class="lineNum">    5711 </span>            : {
<span class="lineNum">    5712 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">    5713 </span><span class="lineCov">     114133 :     {</span>
<span class="lineNum">    5714 </span><span class="lineCov">      87888 :       c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">    5715 </span><span class="lineCov">     114133 : </span>
<span class="lineNum">    5716 </span>            :       if (token-&gt;id_kind != C_ID_CLASSNAME)
<span class="lineNum">    5717 </span>            :         {
<span class="lineNum">    5718 </span><span class="lineCov">     114163 :           tree decl = lookup_name (token-&gt;value);</span>
<span class="lineNum">    5719 </span><span class="lineCov">     114163 : </span>
<span class="lineNum">    5720 </span><span class="lineCov">     114163 :           token-&gt;id_kind = C_ID_ID;</span>
<span class="lineNum">    5721 </span><span class="lineCov">     114163 :           if (decl)</span>
<span class="lineNum">    5722 </span><span class="lineCov">      87888 :             {</span>
<span class="lineNum">    5723 </span><span class="lineCov">     175758 :               if (TREE_CODE (decl) == TYPE_DECL)</span>
<span class="lineNum">    5724 </span><span class="lineCov">      87879 :                 token-&gt;id_kind = C_ID_TYPENAME;</span>
<span class="lineNum">    5725 </span>            :             }
<span class="lineNum">    5726 </span><span class="lineCov">     114163 :           else if (c_dialect_objc ())</span>
<span class="lineNum">    5727 </span>            :             {
<span class="lineNum">    5728 </span>            :               tree objc_interface_decl = objc_is_class_name (token-&gt;value);
<span class="lineNum">    5729 </span>            :               /* Objective-C class names are in the same namespace as
<span class="lineNum">    5730 </span>            :                  variables and typedefs, and hence are shadowed by local
<span class="lineNum">    5731 </span>            :                  declarations.  */
<span class="lineNum">    5732 </span>            :               if (objc_interface_decl)
<span class="lineNum">    5733 </span>            :                 {
<span class="lineNum">    5734 </span><span class="lineCov">    1139686 :                   token-&gt;value = objc_interface_decl;</span>
<span class="lineNum">    5735 </span>            :                   token-&gt;id_kind = C_ID_CLASSNAME;
<span class="lineNum">    5736 </span><span class="lineCov">    1139686 :                 }</span>
<span class="lineNum">    5737 </span>            :             }
<span class="lineNum">    5738 </span><span class="lineCov">     138009 :         }</span>
<span class="lineNum">    5739 </span>            :     }
<span class="lineNum">    5740 </span><span class="lineCov">     138009 : }</span>
<span class="lineNum">    5741 </span>            : 
<span class="lineNum">    5742 </span><span class="lineCov">     138009 : /* Parse an if statement (C90 6.6.4, C99 6.8.4, C11 6.8.4).</span>
<span class="lineNum">    5743 </span>            : 
<span class="lineNum">    5744 </span><span class="lineCov">     138009 :    if-statement:</span>
<span class="lineNum">    5745 </span><span class="lineCov">     138009 :      if ( expression ) statement</span>
<span class="lineNum">    5746 </span>            :      if ( expression ) statement else statement
<span class="lineNum">    5747 </span><span class="lineCov">     132876 : </span>
<span class="lineNum">    5748 </span><span class="lineCov">       1024 :    CHAIN is a vector of if-else-if conditions.</span>
<span class="lineNum">    5749 </span>            :    IF_P is used to track whether there's a (possibly labeled) if statement
<span class="lineNum">    5750 </span><span class="lineCov">       5133 :    which is not enclosed in braces and has an else clause.  This is used to</span>
<span class="lineNum">    5751 </span>            :    implement -Wparentheses.  */
<a name="5752"><span class="lineNum">    5752 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">    5753 </span>            : static void
<span class="lineNum">    5754 </span>            : c_parser_if_statement (c_parser *parser, bool *if_p, vec&lt;tree&gt; *chain)
<span class="lineNum">    5755 </span>            : {
<span class="lineNum">    5756 </span><span class="lineNoCov">          0 :   tree block;</span>
<span class="lineNum">    5757 </span>            :   location_t loc;
<span class="lineNum">    5758 </span><span class="lineNoCov">          0 :   tree cond;</span>
<span class="lineNum">    5759 </span><span class="lineNoCov">          0 :   bool nested_if = false;</span>
<span class="lineNum">    5760 </span>            :   tree first_body, second_body;
<span class="lineNum">    5761 </span>            :   bool in_if_block;
<span class="lineNum">    5762 </span>            : 
<span class="lineNum">    5763 </span>            :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_IF));
<span class="lineNum">    5764 </span><span class="lineCov">    1139686 :   token_indent_info if_tinfo</span>
<span class="lineNum">    5765 </span>            :     = get_token_indent_info (c_parser_peek_token (parser));
<span class="lineNum">    5766 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    5767 </span>            :   block = c_begin_compound_stmt (flag_isoc99);
<span class="lineNum">    5768 </span>            :   loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    5769 </span>            :   cond = c_parser_paren_condition (parser);
<span class="lineNum">    5770 </span>            :   in_if_block = parser-&gt;in_if_block;
<span class="lineNum">    5771 </span>            :   parser-&gt;in_if_block = true;
<span class="lineNum">    5772 </span>            :   first_body = c_parser_if_body (parser, &amp;nested_if, if_tinfo);
<span class="lineNum">    5773 </span>            :   parser-&gt;in_if_block = in_if_block;
<span class="lineNum">    5774 </span>            : 
<span class="lineNum">    5775 </span>            :   if (warn_duplicated_cond)
<span class="lineNum">    5776 </span>            :     warn_duplicated_cond_add_or_warn (EXPR_LOCATION (cond), cond, &amp;chain);
<span class="lineNum">    5777 </span>            : 
<span class="lineNum">    5778 </span><span class="lineCov">     881727 :   if (c_parser_next_token_is_keyword (parser, RID_ELSE))</span>
<span class="lineNum">    5779 </span>            :     {
<span class="lineNum">    5780 </span><span class="lineCov">     881727 :       token_indent_info else_tinfo</span>
<span class="lineNum">    5781 </span><span class="lineCov">     881727 :         = get_token_indent_info (c_parser_peek_token (parser));</span>
<span class="lineNum">    5782 </span><span class="lineCov">     881727 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    5783 </span><span class="lineCov">     881727 :       if (warn_duplicated_cond)</span>
<span class="lineNum">    5784 </span><span class="lineCov">     881727 :         {</span>
<span class="lineNum">    5785 </span><span class="lineCov">     881727 :           if (c_parser_next_token_is_keyword (parser, RID_IF)</span>
<span class="lineNum">    5786 </span>            :               &amp;&amp; chain == NULL)
<span class="lineNum">    5787 </span><span class="lineCov">     881727 :             {</span>
<span class="lineNum">    5788 </span><span class="lineCov">     881727 :               /* We've got &quot;if (COND) else if (COND2)&quot;.  Start the</span>
<span class="lineNum">    5789 </span><span class="lineCov">     881727 :                  condition chain and add COND as the first element.  */</span>
<span class="lineNum">    5790 </span><span class="lineCov">     881727 :               chain = new vec&lt;tree&gt; ();</span>
<span class="lineNum">    5791 </span><span class="lineCov">     881727 :               if (!CONSTANT_CLASS_P (cond) &amp;&amp; !TREE_SIDE_EFFECTS (cond))</span>
<span class="lineNum">    5792 </span><span class="lineCov">     881727 :                 chain-&gt;safe_push (cond);</span>
<span class="lineNum">    5793 </span><span class="lineCov">     881727 :             }</span>
<span class="lineNum">    5794 </span><span class="lineCov">     881727 :           else if (!c_parser_next_token_is_keyword (parser, RID_IF))</span>
<span class="lineNum">    5795 </span><span class="lineCov">     881727 :             {</span>
<span class="lineNum">    5796 </span><span class="lineCov">     881727 :               /* This is if-else without subsequent if.  Zap the condition</span>
<span class="lineNum">    5797 </span><span class="lineCov">     881727 :                  chain; we would have already warned at this point.  */</span>
<span class="lineNum">    5798 </span>            :               delete chain;
<span class="lineNum">    5799 </span><span class="lineCov">     881727 :               chain = NULL;</span>
<span class="lineNum">    5800 </span><span class="lineCov">         62 :             }</span>
<span class="lineNum">    5801 </span>            :         }
<span class="lineNum">    5802 </span><span class="lineCov">     881727 :       second_body = c_parser_else_body (parser, else_tinfo, chain);</span>
<span class="lineNum">    5803 </span>            :       /* Set IF_P to true to indicate that this if statement has an
<span class="lineNum">    5804 </span><span class="lineCov">     114163 :          else clause.  This may trigger the Wparentheses warning</span>
<span class="lineNum">    5805 </span><span class="lineCov">     114163 :          below when we get back up to the parent if statement.  */</span>
<span class="lineNum">    5806 </span><span class="lineCov">     114163 :       if (if_p != NULL)</span>
<span class="lineNum">    5807 </span><span class="lineCov">     114163 :         *if_p = true;</span>
<span class="lineNum">    5808 </span>            :     }
<span class="lineNum">    5809 </span><span class="lineCov">         43 :   else</span>
<span class="lineNum">    5810 </span><span class="lineCov">         43 :     {</span>
<span class="lineNum">    5811 </span>            :       second_body = NULL_TREE;
<span class="lineNum">    5812 </span>            : 
<span class="lineNum">    5813 </span>            :       /* Diagnose an ambiguous else if if-then-else is nested inside
<span class="lineNum">    5814 </span><span class="lineCov">         18 :          if-then.  */</span>
<span class="lineNum">    5815 </span><span class="lineCov">         18 :       if (nested_if)</span>
<span class="lineNum">    5816 </span><span class="lineCov">         12 :         warning_at (loc, OPT_Wdangling_else,</span>
<span class="lineNum">    5817 </span>            :                     &quot;suggest explicit braces to avoid ambiguous %&lt;else%&gt;&quot;);
<span class="lineNum">    5818 </span><span class="lineCov">         25 : </span>
<span class="lineNum">    5819 </span>            :       if (warn_duplicated_cond)
<span class="lineNum">    5820 </span>            :         {
<span class="lineNum">    5821 </span>            :           /* This if statement does not have an else clause.  We don't
<span class="lineNum">    5822 </span><span class="lineCov">          4 :              need the condition chain anymore.  */</span>
<span class="lineNum">    5823 </span><span class="lineCov">          4 :           delete chain;</span>
<span class="lineNum">    5824 </span>            :           chain = NULL;
<span class="lineNum">    5825 </span>            :         }
<span class="lineNum">    5826 </span><span class="lineCov">     114163 :     }</span>
<span class="lineNum">    5827 </span>            :   c_finish_if_stmt (loc, cond, first_body, second_body);
<span class="lineNum">    5828 </span>            :   add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));
<span class="lineNum">    5829 </span>            : 
<span class="lineNum">    5830 </span><span class="lineCov">     114163 :   c_parser_maybe_reclassify_token (parser);</span>
<span class="lineNum">    5831 </span><span class="lineCov">        181 : }</span>
<span class="lineNum">    5832 </span>            : 
<span class="lineNum">    5833 </span>            : /* Parse a switch statement (C90 6.6.4, C99 6.8.4, C11 6.8.4).
<span class="lineNum">    5834 </span>            : 
<span class="lineNum">    5835 </span><span class="lineCov">     767564 :    switch-statement:</span>
<span class="lineNum">    5836 </span>            :      switch (expression) statement
<span class="lineNum">    5837 </span>            : */
<a name="5838"><span class="lineNum">    5838 </span>            : </a>
<span class="lineNum">    5839 </span><span class="lineCov">     767564 : static void</span>
<span class="lineNum">    5840 </span><span class="lineCov">        134 : c_parser_switch_statement (c_parser *parser, bool *if_p)</span>
<span class="lineNum">    5841 </span>            : {
<span class="lineNum">    5842 </span>            :   struct c_expr ce;
<span class="lineNum">    5843 </span><span class="lineCov">     767564 :   tree block, expr, body, save_break;</span>
<span class="lineNum">    5844 </span>            :   location_t switch_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    5845 </span>            :   location_t switch_cond_loc;
<span class="lineNum">    5846 </span>            :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_SWITCH));
<span class="lineNum">    5847 </span><span class="lineCov">         19 :   c_parser_consume_token (parser);</span>
<span class="lineNum">    5848 </span><span class="lineCov">         19 :   block = c_begin_compound_stmt (flag_isoc99);</span>
<span class="lineNum">    5849 </span>            :   bool explicit_cast_p = false;
<span class="lineNum">    5850 </span>            :   matching_parens parens;
<span class="lineNum">    5851 </span><span class="lineCov">     881727 :   if (parens.require_open (parser))</span>
<span class="lineNum">    5852 </span><span class="lineCov">     881727 :     {</span>
<span class="lineNum">    5853 </span>            :       switch_cond_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    5854 </span><span class="lineCov">     881727 :       if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)</span>
<span class="lineNum">    5855 </span><span class="lineCov">     881727 :           &amp;&amp; c_token_starts_typename (c_parser_peek_2nd_token (parser)))</span>
<span class="lineNum">    5856 </span>            :         explicit_cast_p = true;
<span class="lineNum">    5857 </span>            :       ce = c_parser_expression (parser);
<span class="lineNum">    5858 </span>            :       ce = convert_lvalue_to_rvalue (switch_cond_loc, ce, true, false);
<span class="lineNum">    5859 </span>            :       expr = ce.value;
<span class="lineNum">    5860 </span>            :       /* ??? expr has no valid location?  */
<span class="lineNum">    5861 </span>            :       parens.skip_until_found_close (parser);
<span class="lineNum">    5862 </span>            :     }
<span class="lineNum">    5863 </span>            :   else
<span class="lineNum">    5864 </span><span class="lineCov">      21532 :     {</span>
<span class="lineNum">    5865 </span>            :       switch_cond_loc = UNKNOWN_LOCATION;
<span class="lineNum">    5866 </span><span class="lineCov">      21532 :       expr = error_mark_node;</span>
<span class="lineNum">    5867 </span><span class="lineCov">      21532 :       ce.original_type = error_mark_node;</span>
<span class="lineNum">    5868 </span><span class="lineCov">      21532 :     }</span>
<span class="lineNum">    5869 </span><span class="lineCov">      21532 :   c_start_case (switch_loc, switch_cond_loc, expr, explicit_cast_p);</span>
<span class="lineNum">    5870 </span><span class="lineCov">      21532 :   save_break = c_break_label;</span>
<span class="lineNum">    5871 </span><span class="lineCov">      21532 :   c_break_label = NULL_TREE;</span>
<span class="lineNum">    5872 </span><span class="lineCov">      21532 :   location_t loc_after_labels;</span>
<span class="lineNum">    5873 </span><span class="lineCov">      21532 :   bool open_brace_p = c_parser_peek_token (parser)-&gt;type == CPP_OPEN_BRACE;</span>
<span class="lineNum">    5874 </span><span class="lineCov">      43064 :   body = c_parser_c99_block_statement (parser, if_p, &amp;loc_after_labels);</span>
<span class="lineNum">    5875 </span><span class="lineCov">      21532 :   location_t next_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    5876 </span>            :   if (!open_brace_p &amp;&amp; c_parser_peek_token (parser)-&gt;type != CPP_SEMICOLON)
<span class="lineNum">    5877 </span><span class="lineCov">      21525 :     warn_for_multistatement_macros (loc_after_labels, next_loc, switch_loc,</span>
<span class="lineNum">    5878 </span><span class="lineCov">      21525 :                                     RID_SWITCH);</span>
<span class="lineNum">    5879 </span><span class="lineCov">      21525 :   if (c_break_label)</span>
<span class="lineNum">    5880 </span>            :     {
<span class="lineNum">    5881 </span><span class="lineCov">      21525 :       location_t here = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    5882 </span><span class="lineCov">      21525 :       tree t = build1 (LABEL_EXPR, void_type_node, c_break_label);</span>
<span class="lineNum">    5883 </span><span class="lineCov">      21525 :       SET_EXPR_LOCATION (t, here);</span>
<span class="lineNum">    5884 </span>            :       SWITCH_BREAK_LABEL_P (c_break_label) = 1;
<span class="lineNum">    5885 </span><span class="lineCov">      21525 :       append_to_statement_list_force (t, &amp;body);</span>
<span class="lineNum">    5886 </span>            :     }
<span class="lineNum">    5887 </span>            :   c_finish_case (body, ce.original_type);
<span class="lineNum">    5888 </span>            :   c_break_label = save_break;
<span class="lineNum">    5889 </span><span class="lineCov">          7 :   add_stmt (c_end_compound_stmt (switch_loc, block, flag_isoc99));</span>
<span class="lineNum">    5890 </span><span class="lineCov">          7 :   c_parser_maybe_reclassify_token (parser);</span>
<span class="lineNum">    5891 </span><span class="lineCov">          7 : }</span>
<span class="lineNum">    5892 </span>            : 
<span class="lineNum">    5893 </span><span class="lineCov">      21532 : /* Parse a while statement (C90 6.6.5, C99 6.8.5, C11 6.8.5).</span>
<span class="lineNum">    5894 </span><span class="lineCov">      21532 : </span>
<span class="lineNum">    5895 </span><span class="lineCov">      21532 :    while-statement:</span>
<span class="lineNum">    5896 </span><span class="lineCov">      21532 :       while (expression) statement</span>
<span class="lineNum">    5897 </span><span class="lineCov">      21532 : </span>
<span class="lineNum">    5898 </span><span class="lineCov">      21532 :    IF_P is used to track whether there's a (possibly labeled) if statement</span>
<span class="lineNum">    5899 </span><span class="lineCov">      21532 :    which is not enclosed in braces and has an else clause.  This is used to</span>
<span class="lineNum">    5900 </span><span class="lineCov">      21532 :    implement -Wparentheses.  */</span>
<a name="5901"><span class="lineNum">    5901 </span><span class="lineCov">        130 : </span></a>
<span class="lineNum">    5902 </span>            : static void
<span class="lineNum">    5903 </span><span class="lineCov">      21532 : c_parser_while_statement (c_parser *parser, bool ivdep, unsigned short unroll,</span>
<span class="lineNum">    5904 </span>            :                           bool *if_p)
<span class="lineNum">    5905 </span><span class="lineCov">      19836 : {</span>
<span class="lineNum">    5906 </span><span class="lineCov">      19836 :   tree block, cond, body, save_break, save_cont;</span>
<span class="lineNum">    5907 </span><span class="lineCov">      19836 :   location_t loc;</span>
<span class="lineNum">    5908 </span><span class="lineCov">      19836 :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_WHILE));</span>
<span class="lineNum">    5909 </span><span class="lineCov">      19836 :   token_indent_info while_tinfo</span>
<span class="lineNum">    5910 </span>            :     = get_token_indent_info (c_parser_peek_token (parser));
<span class="lineNum">    5911 </span><span class="lineCov">      21532 :   c_parser_consume_token (parser);</span>
<span class="lineNum">    5912 </span><span class="lineCov">      21532 :   block = c_begin_compound_stmt (flag_isoc99);</span>
<span class="lineNum">    5913 </span><span class="lineCov">      21532 :   loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    5914 </span><span class="lineCov">      21532 :   cond = c_parser_paren_condition (parser);</span>
<span class="lineNum">    5915 </span><span class="lineCov">      21532 :   if (ivdep &amp;&amp; cond != error_mark_node)</span>
<span class="lineNum">    5916 </span>            :     cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
<span class="lineNum">    5917 </span>            :                    build_int_cst (integer_type_node,
<span class="lineNum">    5918 </span>            :                                   annot_expr_ivdep_kind),
<span class="lineNum">    5919 </span>            :                    integer_zero_node);
<span class="lineNum">    5920 </span>            :   if (unroll &amp;&amp; cond != error_mark_node)
<span class="lineNum">    5921 </span>            :     cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
<span class="lineNum">    5922 </span>            :                    build_int_cst (integer_type_node,
<span class="lineNum">    5923 </span>            :                                   annot_expr_unroll_kind),
<span class="lineNum">    5924 </span>            :                    build_int_cst (integer_type_node, unroll));
<span class="lineNum">    5925 </span>            :   save_break = c_break_label;
<span class="lineNum">    5926 </span>            :   c_break_label = NULL_TREE;
<span class="lineNum">    5927 </span><span class="lineCov">      34891 :   save_cont = c_cont_label;</span>
<span class="lineNum">    5928 </span>            :   c_cont_label = NULL_TREE;
<span class="lineNum">    5929 </span>            : 
<span class="lineNum">    5930 </span><span class="lineCov">      34891 :   token_indent_info body_tinfo</span>
<span class="lineNum">    5931 </span><span class="lineCov">      34891 :     = get_token_indent_info (c_parser_peek_token (parser));</span>
<span class="lineNum">    5932 </span><span class="lineCov">      34891 : </span>
<span class="lineNum">    5933 </span><span class="lineCov">      34891 :   location_t loc_after_labels;</span>
<span class="lineNum">    5934 </span><span class="lineCov">      34891 :   bool open_brace = c_parser_next_token_is (parser, CPP_OPEN_BRACE);</span>
<span class="lineNum">    5935 </span><span class="lineCov">      34891 :   body = c_parser_c99_block_statement (parser, if_p, &amp;loc_after_labels);</span>
<span class="lineNum">    5936 </span><span class="lineCov">      34891 :   c_finish_loop (loc, cond, NULL, body, c_break_label, c_cont_label, true);</span>
<span class="lineNum">    5937 </span><span class="lineCov">      34891 :   add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));</span>
<span class="lineNum">    5938 </span><span class="lineCov">      34891 :   c_parser_maybe_reclassify_token (parser);</span>
<span class="lineNum">    5939 </span><span class="lineCov">      34891 : </span>
<span class="lineNum">    5940 </span><span class="lineCov">          3 :   token_indent_info next_tinfo</span>
<span class="lineNum">    5941 </span>            :     = get_token_indent_info (c_parser_peek_token (parser));
<span class="lineNum">    5942 </span><span class="lineCov">          3 :   warn_for_misleading_indentation (while_tinfo, body_tinfo, next_tinfo);</span>
<span class="lineNum">    5943 </span>            : 
<span class="lineNum">    5944 </span><span class="lineCov">      34891 :   if (next_tinfo.type != CPP_SEMICOLON &amp;&amp; !open_brace)</span>
<span class="lineNum">    5945 </span><span class="lineNoCov">          0 :     warn_for_multistatement_macros (loc_after_labels, next_tinfo.location,</span>
<span class="lineNum">    5946 </span>            :                                     while_tinfo.location, RID_WHILE);
<span class="lineNum">    5947 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    5948 </span>            :   c_break_label = save_break;
<span class="lineNum">    5949 </span><span class="lineCov">      34891 :   c_cont_label = save_cont;</span>
<span class="lineNum">    5950 </span><span class="lineCov">      34891 : }</span>
<span class="lineNum">    5951 </span><span class="lineCov">      34891 : </span>
<span class="lineNum">    5952 </span><span class="lineCov">      34891 : /* Parse a do statement (C90 6.6.5, C99 6.8.5, C11 6.8.5).</span>
<span class="lineNum">    5953 </span>            : 
<span class="lineNum">    5954 </span><span class="lineCov">      34891 :    do-statement:</span>
<span class="lineNum">    5955 </span><span class="lineCov">      34891 :      do statement while ( expression ) ;</span>
<span class="lineNum">    5956 </span>            : */
<a name="5957"><span class="lineNum">    5957 </span><span class="lineCov">      34891 : </span></a>
<span class="lineNum">    5958 </span><span class="lineCov">      34891 : static void</span>
<span class="lineNum">    5959 </span><span class="lineCov">      34891 : c_parser_do_statement (c_parser *parser, bool ivdep, unsigned short unroll)</span>
<span class="lineNum">    5960 </span><span class="lineCov">      34891 : {</span>
<span class="lineNum">    5961 </span><span class="lineCov">      34891 :   tree block, cond, body, save_break, save_cont, new_break, new_cont;</span>
<span class="lineNum">    5962 </span><span class="lineCov">      34891 :   location_t loc;</span>
<span class="lineNum">    5963 </span>            :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_DO));
<span class="lineNum">    5964 </span><span class="lineCov">      34891 :   c_parser_consume_token (parser);</span>
<span class="lineNum">    5965 </span><span class="lineCov">      34891 :   if (c_parser_next_token_is (parser, CPP_SEMICOLON))</span>
<span class="lineNum">    5966 </span><span class="lineCov">      34891 :     warning_at (c_parser_peek_token (parser)-&gt;location,</span>
<span class="lineNum">    5967 </span>            :                 OPT_Wempty_body,
<span class="lineNum">    5968 </span><span class="lineCov">      34891 :                 &quot;suggest braces around empty body in %&lt;do%&gt; statement&quot;);</span>
<span class="lineNum">    5969 </span><span class="lineCov">       9107 :   block = c_begin_compound_stmt (flag_isoc99);</span>
<span class="lineNum">    5970 </span>            :   loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    5971 </span>            :   save_break = c_break_label;
<span class="lineNum">    5972 </span><span class="lineCov">      34891 :   c_break_label = NULL_TREE;</span>
<span class="lineNum">    5973 </span><span class="lineCov">      34891 :   save_cont = c_cont_label;</span>
<span class="lineNum">    5974 </span><span class="lineCov">      34891 :   c_cont_label = NULL_TREE;</span>
<span class="lineNum">    5975 </span>            :   body = c_parser_c99_block_statement (parser, NULL);
<span class="lineNum">    5976 </span>            :   c_parser_require_keyword (parser, RID_WHILE, &quot;expected %&lt;while%&gt;&quot;);
<span class="lineNum">    5977 </span>            :   new_break = c_break_label;
<span class="lineNum">    5978 </span>            :   c_break_label = save_break;
<span class="lineNum">    5979 </span>            :   new_cont = c_cont_label;
<span class="lineNum">    5980 </span>            :   c_cont_label = save_cont;
<span class="lineNum">    5981 </span>            :   cond = c_parser_paren_condition (parser);
<span class="lineNum">    5982 </span>            :   if (ivdep &amp;&amp; cond != error_mark_node)
<span class="lineNum">    5983 </span><span class="lineCov">      99301 :     cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,</span>
<span class="lineNum">    5984 </span>            :                    build_int_cst (integer_type_node,
<span class="lineNum">    5985 </span><span class="lineCov">      99301 :                                   annot_expr_ivdep_kind),</span>
<span class="lineNum">    5986 </span><span class="lineCov">      99301 :                    integer_zero_node);</span>
<span class="lineNum">    5987 </span><span class="lineCov">      99301 :   if (unroll &amp;&amp; cond != error_mark_node)</span>
<span class="lineNum">    5988 </span><span class="lineCov">      99301 :     cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,</span>
<span class="lineNum">    5989 </span><span class="lineCov">      99301 :                    build_int_cst (integer_type_node,</span>
<span class="lineNum">    5990 </span><span class="lineCov">         45 :                                   annot_expr_unroll_kind),</span>
<span class="lineNum">    5991 </span>            :                    build_int_cst (integer_type_node, unroll));
<span class="lineNum">    5992 </span>            :   if (!c_parser_require (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;))
<span class="lineNum">    5993 </span><span class="lineCov">      99301 :     c_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">    5994 </span><span class="lineCov">      99301 :   c_finish_loop (loc, cond, NULL, body, new_break, new_cont, false);</span>
<span class="lineNum">    5995 </span><span class="lineCov">      99301 :   add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));</span>
<span class="lineNum">    5996 </span><span class="lineCov">      99301 : }</span>
<span class="lineNum">    5997 </span><span class="lineCov">      99301 : </span>
<span class="lineNum">    5998 </span><span class="lineCov">      99301 : /* Parse a for statement (C90 6.6.5, C99 6.8.5, C11 6.8.5).</span>
<span class="lineNum">    5999 </span><span class="lineCov">      99301 : </span>
<span class="lineNum">    6000 </span><span class="lineCov">      99301 :    for-statement:</span>
<span class="lineNum">    6001 </span><span class="lineCov">      99301 :      for ( expression[opt] ; expression[opt] ; expression[opt] ) statement</span>
<span class="lineNum">    6002 </span><span class="lineCov">      99301 :      for ( nested-declaration expression[opt] ; expression[opt] ) statement</span>
<span class="lineNum">    6003 </span><span class="lineCov">      99301 : </span>
<span class="lineNum">    6004 </span><span class="lineCov">      99301 :    The form with a declaration is new in C99.</span>
<span class="lineNum">    6005 </span><span class="lineCov">      99301 : </span>
<span class="lineNum">    6006 </span><span class="lineCov">      99301 :    ??? In accordance with the old parser, the declaration may be a</span>
<span class="lineNum">    6007 </span><span class="lineCov">          2 :    nested function, which is then rejected in check_for_loop_decls,</span>
<span class="lineNum">    6008 </span>            :    but does it make any sense for this to be included in the grammar?
<span class="lineNum">    6009 </span><span class="lineCov">          2 :    Note in particular that the nested function does not include a</span>
<span class="lineNum">    6010 </span>            :    trailing ';', whereas the &quot;declaration&quot; production includes one.
<span class="lineNum">    6011 </span><span class="lineCov">      99301 :    Also, can we reject bad declarations earlier and cheaper than</span>
<span class="lineNum">    6012 </span><span class="lineCov">          6 :    check_for_loop_decls?</span>
<span class="lineNum">    6013 </span>            : 
<span class="lineNum">    6014 </span><span class="lineCov">          3 :    In Objective-C, there are two additional variants:</span>
<span class="lineNum">    6015 </span>            : 
<span class="lineNum">    6016 </span><span class="lineCov">      99301 :    foreach-statement:</span>
<span class="lineNum">    6017 </span><span class="lineNoCov">          0 :      for ( expression in expresssion ) statement</span>
<span class="lineNum">    6018 </span><span class="lineCov">      99301 :      for ( declaration in expression ) statement</span>
<span class="lineNum">    6019 </span><span class="lineCov">      99301 : </span>
<span class="lineNum">    6020 </span><span class="lineCov">      99301 :    This is inconsistent with C, because the second variant is allowed</span>
<span class="lineNum">    6021 </span>            :    even if c99 is not enabled.
<span class="lineNum">    6022 </span>            : 
<span class="lineNum">    6023 </span>            :    The rest of the comment documents these Objective-C foreach-statement.
<span class="lineNum">    6024 </span>            : 
<span class="lineNum">    6025 </span>            :    Here is the canonical example of the first variant:
<span class="lineNum">    6026 </span>            :     for (object in array)    { do something with object }
<span class="lineNum">    6027 </span>            :    we call the first expression (&quot;object&quot;) the &quot;object_expression&quot; and 
<span class="lineNum">    6028 </span>            :    the second expression (&quot;array&quot;) the &quot;collection_expression&quot;.
<span class="lineNum">    6029 </span>            :    object_expression must be an lvalue of type &quot;id&quot; (a generic Objective-C
<span class="lineNum">    6030 </span>            :    object) because the loop works by assigning to object_expression the
<span class="lineNum">    6031 </span>            :    various objects from the collection_expression.  collection_expression
<span class="lineNum">    6032 </span>            :    must evaluate to something of type &quot;id&quot; which responds to the method
<span class="lineNum">    6033 </span>            :    countByEnumeratingWithState:objects:count:.
<span class="lineNum">    6034 </span>            : 
<span class="lineNum">    6035 </span>            :    The canonical example of the second variant is:
<span class="lineNum">    6036 </span>            :     for (id object in array)    { do something with object }
<span class="lineNum">    6037 </span>            :    which is completely equivalent to
<span class="lineNum">    6038 </span>            :     {
<span class="lineNum">    6039 </span>            :       id object;
<span class="lineNum">    6040 </span>            :       for (object in array) { do something with object }
<span class="lineNum">    6041 </span>            :     }
<span class="lineNum">    6042 </span>            :    Note that initizializing 'object' in some way (eg, &quot;for ((object =
<span class="lineNum">    6043 </span>            :    xxx) in array) { do something with object }&quot;) is possibly
<span class="lineNum">    6044 </span>            :    technically valid, but completely pointless as 'object' will be
<span class="lineNum">    6045 </span>            :    assigned to something else as soon as the loop starts.  We should
<span class="lineNum">    6046 </span>            :    most likely reject it (TODO).
<span class="lineNum">    6047 </span>            : 
<span class="lineNum">    6048 </span>            :    The beginning of the Objective-C foreach-statement looks exactly
<span class="lineNum">    6049 </span>            :    like the beginning of the for-statement, and we can tell it is a
<span class="lineNum">    6050 </span>            :    foreach-statement only because the initial declaration or
<span class="lineNum">    6051 </span>            :    expression is terminated by 'in' instead of ';'.
<span class="lineNum">    6052 </span>            : 
<span class="lineNum">    6053 </span>            :    IF_P is used to track whether there's a (possibly labeled) if statement
<span class="lineNum">    6054 </span>            :    which is not enclosed in braces and has an else clause.  This is used to
<span class="lineNum">    6055 </span>            :    implement -Wparentheses.  */
<a name="6056"><span class="lineNum">    6056 </span>            : </a>
<span class="lineNum">    6057 </span>            : static void
<span class="lineNum">    6058 </span>            : c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,
<span class="lineNum">    6059 </span>            :                         bool *if_p)
<span class="lineNum">    6060 </span>            : {
<span class="lineNum">    6061 </span>            :   tree block, cond, incr, save_break, save_cont, body;
<span class="lineNum">    6062 </span>            :   /* The following are only used when parsing an ObjC foreach statement.  */
<span class="lineNum">    6063 </span>            :   tree object_expression;
<span class="lineNum">    6064 </span>            :   /* Silence the bogus uninitialized warning.  */
<span class="lineNum">    6065 </span>            :   tree collection_expression = NULL;
<span class="lineNum">    6066 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    6067 </span>            :   location_t for_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    6068 </span>            :   bool is_foreach_statement = false;
<span class="lineNum">    6069 </span>            :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_FOR));
<span class="lineNum">    6070 </span>            :   token_indent_info for_tinfo
<span class="lineNum">    6071 </span>            :     = get_token_indent_info (c_parser_peek_token (parser));
<span class="lineNum">    6072 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    6073 </span>            :   /* Open a compound statement in Objective-C as well, just in case this is
<span class="lineNum">    6074 </span>            :      as foreach expression.  */
<span class="lineNum">    6075 </span>            :   block = c_begin_compound_stmt (flag_isoc99 || c_dialect_objc ());
<span class="lineNum">    6076 </span>            :   cond = error_mark_node;
<span class="lineNum">    6077 </span>            :   incr = error_mark_node;
<span class="lineNum">    6078 </span>            :   matching_parens parens;
<span class="lineNum">    6079 </span>            :   if (parens.require_open (parser))
<span class="lineNum">    6080 </span>            :     {
<span class="lineNum">    6081 </span>            :       /* Parse the initialization declaration or expression.  */
<span class="lineNum">    6082 </span><span class="lineCov">     201536 :       object_expression = error_mark_node;</span>
<span class="lineNum">    6083 </span>            :       parser-&gt;objc_could_be_foreach_context = c_dialect_objc ();
<span class="lineNum">    6084 </span>            :       if (c_parser_next_token_is (parser, CPP_SEMICOLON))
<span class="lineNum">    6085 </span><span class="lineCov">     201536 :         {</span>
<span class="lineNum">    6086 </span>            :           parser-&gt;objc_could_be_foreach_context = false;
<span class="lineNum">    6087 </span><span class="lineCov">     201536 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    6088 </span>            :           c_finish_expr_stmt (loc, NULL_TREE);
<span class="lineNum">    6089 </span><span class="lineCov">     201536 :         }</span>
<span class="lineNum">    6090 </span><span class="lineCov">     201536 :       else if (c_parser_next_tokens_start_declaration (parser))</span>
<span class="lineNum">    6091 </span><span class="lineCov">     201536 :         {</span>
<span class="lineNum">    6092 </span><span class="lineCov">     201536 :           c_parser_declaration_or_fndef (parser, true, true, true, true, true, </span>
<span class="lineNum">    6093 </span><span class="lineCov">     201536 :                                          &amp;object_expression, vNULL);</span>
<span class="lineNum">    6094 </span><span class="lineCov">     201536 :           parser-&gt;objc_could_be_foreach_context = false;</span>
<span class="lineNum">    6095 </span><span class="lineCov">     201536 :           </span>
<span class="lineNum">    6096 </span><span class="lineCov">     201536 :           if (c_parser_next_token_is_keyword (parser, RID_IN))</span>
<span class="lineNum">    6097 </span>            :             {
<span class="lineNum">    6098 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">    6099 </span><span class="lineCov">     201664 :               is_foreach_statement = true;</span>
<span class="lineNum">    6100 </span><span class="lineCov">     201536 :               if (check_for_loop_decls (for_loc, true) == NULL_TREE)</span>
<span class="lineNum">    6101 </span><span class="lineCov">     201536 :                 c_parser_error (parser, &quot;multiple iterating variables in fast enumeration&quot;);</span>
<span class="lineNum">    6102 </span><span class="lineCov">     403072 :             }</span>
<span class="lineNum">    6103 </span><span class="lineCov">     201536 :           else</span>
<span class="lineNum">    6104 </span>            :             check_for_loop_decls (for_loc, flag_isoc99);
<span class="lineNum">    6105 </span>            :         }
<span class="lineNum">    6106 </span><span class="lineCov">     201535 :       else if (c_parser_next_token_is_keyword (parser, RID_EXTENSION))</span>
<span class="lineNum">    6107 </span><span class="lineCov">     201535 :         {</span>
<span class="lineNum">    6108 </span><span class="lineCov">     201535 :           /* __extension__ can start a declaration, but is also an</span>
<span class="lineNum">    6109 </span>            :              unary operator that can start an expression.  Consume all
<span class="lineNum">    6110 </span><span class="lineCov">       8059 :              but the last of a possible series of __extension__ to</span>
<span class="lineNum">    6111 </span><span class="lineCov">       8059 :              determine which.  */</span>
<span class="lineNum">    6112 </span><span class="lineCov">       8059 :           while (c_parser_peek_2nd_token (parser)-&gt;type == CPP_KEYWORD</span>
<span class="lineNum">    6113 </span>            :                  &amp;&amp; (c_parser_peek_2nd_token (parser)-&gt;keyword
<span class="lineNum">    6114 </span><span class="lineCov">     193476 :                      == RID_EXTENSION))</span>
<span class="lineNum">    6115 </span>            :             c_parser_consume_token (parser);
<span class="lineNum">    6116 </span><span class="lineCov">       5446 :           if (c_token_starts_declaration (c_parser_peek_2nd_token (parser)))</span>
<span class="lineNum">    6117 </span>            :             {
<span class="lineNum">    6118 </span><span class="lineCov">       5446 :               int ext;</span>
<span class="lineNum">    6119 </span>            :               ext = disable_extension_diagnostics ();
<span class="lineNum">    6120 </span><span class="lineCov">       5446 :               c_parser_consume_token (parser);</span>
<span class="lineNum">    6121 </span>            :               c_parser_declaration_or_fndef (parser, true, true, true, true,
<span class="lineNum">    6122 </span><span class="lineNoCov">          0 :                                              true, &amp;object_expression, vNULL);</span>
<span class="lineNum">    6123 </span><span class="lineNoCov">          0 :               parser-&gt;objc_could_be_foreach_context = false;</span>
<span class="lineNum">    6124 </span><span class="lineNoCov">          0 :               </span>
<span class="lineNum">    6125 </span><span class="lineNoCov">          0 :               restore_extension_diagnostics (ext);</span>
<span class="lineNum">    6126 </span>            :               if (c_parser_next_token_is_keyword (parser, RID_IN))
<span class="lineNum">    6127 </span>            :                 {
<span class="lineNum">    6128 </span><span class="lineCov">       5446 :                   c_parser_consume_token (parser);</span>
<span class="lineNum">    6129 </span>            :                   is_foreach_statement = true;
<span class="lineNum">    6130 </span><span class="lineCov">     188030 :                   if (check_for_loop_decls (for_loc, true) == NULL_TREE)</span>
<span class="lineNum">    6131 </span>            :                     c_parser_error (parser, &quot;multiple iterating variables in fast enumeration&quot;);
<span class="lineNum">    6132 </span>            :                 }
<span class="lineNum">    6133 </span>            :               else
<span class="lineNum">    6134 </span>            :                 check_for_loop_decls (for_loc, flag_isoc99);
<span class="lineNum">    6135 </span>            :             }
<span class="lineNum">    6136 </span><span class="lineNoCov">          0 :           else</span>
<span class="lineNum">    6137 </span><span class="lineNoCov">          0 :             goto init_expr;</span>
<span class="lineNum">    6138 </span>            :         }
<span class="lineNum">    6139 </span><span class="lineNoCov">          0 :       else</span>
<span class="lineNum">    6140 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    6141 </span>            :         init_expr:
<span class="lineNum">    6142 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">    6143 </span><span class="lineNoCov">          0 :             struct c_expr ce;</span>
<span class="lineNum">    6144 </span><span class="lineNoCov">          0 :             tree init_expression;</span>
<span class="lineNum">    6145 </span><span class="lineNoCov">          0 :             ce = c_parser_expression (parser);</span>
<span class="lineNum">    6146 </span>            :             init_expression = ce.value;
<span class="lineNum">    6147 </span><span class="lineNoCov">          0 :             parser-&gt;objc_could_be_foreach_context = false;</span>
<span class="lineNum">    6148 </span>            :             if (c_parser_next_token_is_keyword (parser, RID_IN))
<span class="lineNum">    6149 </span><span class="lineNoCov">          0 :               {</span>
<span class="lineNum">    6150 </span><span class="lineNoCov">          0 :                 c_parser_consume_token (parser);</span>
<span class="lineNum">    6151 </span>            :                 is_foreach_statement = true;
<span class="lineNum">    6152 </span><span class="lineNoCov">          0 :                 if (! lvalue_p (init_expression))</span>
<span class="lineNum">    6153 </span><span class="lineNoCov">          0 :                   c_parser_error (parser, &quot;invalid iterating variable in fast enumeration&quot;);</span>
<span class="lineNum">    6154 </span><span class="lineNoCov">          0 :                 object_expression = c_fully_fold (init_expression, false, NULL);</span>
<span class="lineNum">    6155 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">    6156 </span>            :             else
<span class="lineNum">    6157 </span>            :               {
<span class="lineNum">    6158 </span><span class="lineNoCov">          0 :                 ce = convert_lvalue_to_rvalue (loc, ce, true, false);</span>
<span class="lineNum">    6159 </span>            :                 init_expression = ce.value;
<span class="lineNum">    6160 </span>            :                 c_finish_expr_stmt (loc, init_expression);
<span class="lineNum">    6161 </span>            :                 c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);
<span class="lineNum">    6162 </span>            :               }
<span class="lineNum">    6163 </span>            :           }
<span class="lineNum">    6164 </span>            :         }
<span class="lineNum">    6165 </span><span class="lineCov">     188030 :       /* Parse the loop condition.  In the case of a foreach</span>
<span class="lineNum">    6166 </span><span class="lineCov">     188030 :          statement, there is no loop condition.  */</span>
<span class="lineNum">    6167 </span><span class="lineCov">     188030 :       gcc_assert (!parser-&gt;objc_could_be_foreach_context);</span>
<span class="lineNum">    6168 </span><span class="lineCov">     188030 :       if (!is_foreach_statement)</span>
<span class="lineNum">    6169 </span><span class="lineCov">     188030 :         {</span>
<span class="lineNum">    6170 </span><span class="lineCov">     188030 :           if (c_parser_next_token_is (parser, CPP_SEMICOLON))</span>
<span class="lineNum">    6171 </span><span class="lineCov">     188030 :             {</span>
<span class="lineNum">    6172 </span><span class="lineCov">     188030 :               if (ivdep)</span>
<span class="lineNum">    6173 </span>            :                 {
<span class="lineNum">    6174 </span><span class="lineNoCov">          0 :                   c_parser_error (parser, &quot;missing loop condition in loop with &quot;</span>
<span class="lineNum">    6175 </span><span class="lineNoCov">          0 :                                   &quot;%&lt;GCC ivdep%&gt; pragma&quot;);</span>
<span class="lineNum">    6176 </span><span class="lineNoCov">          0 :                   cond = error_mark_node;</span>
<span class="lineNum">    6177 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    6178 </span><span class="lineNoCov">          0 :               else if (unroll)</span>
<span class="lineNum">    6179 </span>            :                 {
<span class="lineNum">    6180 </span>            :                   c_parser_error (parser, &quot;missing loop condition in loop with &quot;
<span class="lineNum">    6181 </span>            :                                   &quot;%&lt;GCC unroll%&gt; pragma&quot;);
<span class="lineNum">    6182 </span><span class="lineCov">     188030 :                   cond = error_mark_node;</span>
<span class="lineNum">    6183 </span><span class="lineCov">     188030 :                 }</span>
<span class="lineNum">    6184 </span><span class="lineCov">     188030 :               else</span>
<span class="lineNum">    6185 </span><span class="lineCov">     188030 :                 {</span>
<span class="lineNum">    6186 </span>            :                   c_parser_consume_token (parser);
<span class="lineNum">    6187 </span>            :                   cond = NULL_TREE;
<span class="lineNum">    6188 </span>            :                 }
<span class="lineNum">    6189 </span>            :             }
<span class="lineNum">    6190 </span>            :           else
<span class="lineNum">    6191 </span><span class="lineCov">     201535 :             {</span>
<span class="lineNum">    6192 </span><span class="lineCov">     201535 :               cond = c_parser_condition (parser);</span>
<span class="lineNum">    6193 </span>            :               c_parser_skip_until_found (parser, CPP_SEMICOLON,
<span class="lineNum">    6194 </span><span class="lineCov">     201535 :                                          &quot;expected %&lt;;%&gt;&quot;);</span>
<span class="lineNum">    6195 </span>            :             }
<span class="lineNum">    6196 </span><span class="lineCov">       2334 :           if (ivdep &amp;&amp; cond != error_mark_node)</span>
<span class="lineNum">    6197 </span>            :             cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
<span class="lineNum">    6198 </span><span class="lineCov">          1 :                            build_int_cst (integer_type_node,</span>
<span class="lineNum">    6199 </span>            :                                           annot_expr_ivdep_kind),
<span class="lineNum">    6200 </span><span class="lineCov">          1 :                            integer_zero_node);</span>
<span class="lineNum">    6201 </span>            :           if (unroll &amp;&amp; cond != error_mark_node)
<span class="lineNum">    6202 </span><span class="lineCov">       2333 :             cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,</span>
<span class="lineNum">    6203 </span>            :                            build_int_cst (integer_type_node,
<span class="lineNum">    6204 </span><span class="lineNoCov">          0 :                                           annot_expr_unroll_kind),</span>
<span class="lineNum">    6205 </span>            :                            build_int_cst (integer_type_node, unroll));
<span class="lineNum">    6206 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    6207 </span>            :       /* Parse the increment expression (the third expression in a
<span class="lineNum">    6208 </span>            :          for-statement).  In the case of a foreach-statement, this is
<span class="lineNum">    6209 </span>            :          the expression that follows the 'in'.  */
<span class="lineNum">    6210 </span><span class="lineCov">       2333 :       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))</span>
<span class="lineNum">    6211 </span><span class="lineCov">       2333 :         {</span>
<span class="lineNum">    6212 </span>            :           if (is_foreach_statement)
<span class="lineNum">    6213 </span>            :             {
<span class="lineNum">    6214 </span>            :               c_parser_error (parser, &quot;missing collection in fast enumeration&quot;);
<span class="lineNum">    6215 </span>            :               collection_expression = error_mark_node;
<span class="lineNum">    6216 </span><span class="lineCov">     199201 :             }</span>
<span class="lineNum">    6217 </span><span class="lineCov">     199201 :           else</span>
<span class="lineNum">    6218 </span>            :             incr = c_process_expr_stmt (loc, NULL_TREE);
<span class="lineNum">    6219 </span>            :         }
<span class="lineNum">    6220 </span><span class="lineCov">     201535 :       else</span>
<span class="lineNum">    6221 </span><span class="lineCov">         18 :         {</span>
<span class="lineNum">    6222 </span>            :           if (is_foreach_statement)
<span class="lineNum">    6223 </span><span class="lineCov">         18 :             collection_expression = c_fully_fold (c_parser_expression (parser).value,</span>
<span class="lineNum">    6224 </span>            :                                                   false, NULL);
<span class="lineNum">    6225 </span><span class="lineCov">     201535 :           else</span>
<span class="lineNum">    6226 </span><span class="lineCov">         36 :             {</span>
<span class="lineNum">    6227 </span>            :               struct c_expr ce = c_parser_expression (parser);
<span class="lineNum">    6228 </span><span class="lineCov">         18 :               ce = convert_lvalue_to_rvalue (loc, ce, true, false);</span>
<span class="lineNum">    6229 </span>            :               incr = c_process_expr_stmt (loc, ce.value);
<span class="lineNum">    6230 </span>            :             }
<span class="lineNum">    6231 </span>            :         }
<span class="lineNum">    6232 </span>            :       parens.skip_until_found_close (parser);
<span class="lineNum">    6233 </span>            :     }
<span class="lineNum">    6234 </span><span class="lineCov">     201535 :   save_break = c_break_label;</span>
<span class="lineNum">    6235 </span>            :   c_break_label = NULL_TREE;
<span class="lineNum">    6236 </span><span class="lineCov">       3122 :   save_cont = c_cont_label;</span>
<span class="lineNum">    6237 </span>            :   c_cont_label = NULL_TREE;
<span class="lineNum">    6238 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    6239 </span><span class="lineNoCov">          0 :   token_indent_info body_tinfo</span>
<span class="lineNum">    6240 </span>            :     = get_token_indent_info (c_parser_peek_token (parser));
<span class="lineNum">    6241 </span>            : 
<span class="lineNum">    6242 </span><span class="lineCov">       3122 :   location_t loc_after_labels;</span>
<span class="lineNum">    6243 </span>            :   bool open_brace = c_parser_next_token_is (parser, CPP_OPEN_BRACE);
<span class="lineNum">    6244 </span>            :   body = c_parser_c99_block_statement (parser, if_p, &amp;loc_after_labels);
<span class="lineNum">    6245 </span>            : 
<span class="lineNum">    6246 </span><span class="lineCov">     198413 :   if (is_foreach_statement)</span>
<span class="lineNum">    6247 </span><span class="lineNoCov">          0 :     objc_finish_foreach_loop (loc, object_expression, collection_expression, body, c_break_label, c_cont_label);</span>
<span class="lineNum">    6248 </span>            :   else
<span class="lineNum">    6249 </span>            :     c_finish_loop (loc, cond, incr, body, c_break_label, c_cont_label, true);
<span class="lineNum">    6250 </span>            :   add_stmt (c_end_compound_stmt (loc, block, flag_isoc99 || c_dialect_objc ()));
<span class="lineNum">    6251 </span><span class="lineCov">     198413 :   c_parser_maybe_reclassify_token (parser);</span>
<span class="lineNum">    6252 </span><span class="lineCov">     198413 : </span>
<span class="lineNum">    6253 </span><span class="lineCov">     198413 :   token_indent_info next_tinfo</span>
<span class="lineNum">    6254 </span>            :     = get_token_indent_info (c_parser_peek_token (parser));
<span class="lineNum">    6255 </span>            :   warn_for_misleading_indentation (for_tinfo, body_tinfo, next_tinfo);
<span class="lineNum">    6256 </span><span class="lineCov">     201535 : </span>
<span class="lineNum">    6257 </span>            :   if (next_tinfo.type != CPP_SEMICOLON &amp;&amp; !open_brace)
<span class="lineNum">    6258 </span><span class="lineCov">     201536 :     warn_for_multistatement_macros (loc_after_labels, next_tinfo.location,</span>
<span class="lineNum">    6259 </span><span class="lineCov">     201536 :                                     for_tinfo.location, RID_FOR);</span>
<span class="lineNum">    6260 </span><span class="lineCov">     201536 : </span>
<span class="lineNum">    6261 </span><span class="lineCov">     201536 :   c_break_label = save_break;</span>
<span class="lineNum">    6262 </span>            :   c_cont_label = save_cont;
<span class="lineNum">    6263 </span><span class="lineCov">     201536 : }</span>
<span class="lineNum">    6264 </span><span class="lineCov">     201536 : </span>
<span class="lineNum">    6265 </span>            : /* Parse an asm statement, a GNU extension.  This is a full-blown asm
<span class="lineNum">    6266 </span><span class="lineCov">     201536 :    statement with inputs, outputs, clobbers, and volatile tag</span>
<span class="lineNum">    6267 </span><span class="lineCov">     201536 :    allowed.</span>
<span class="lineNum">    6268 </span><span class="lineCov">     201536 : </span>
<span class="lineNum">    6269 </span>            :    asm-statement:
<span class="lineNum">    6270 </span><span class="lineCov">     201536 :      asm type-qualifier[opt] ( asm-argument ) ;</span>
<span class="lineNum">    6271 </span><span class="lineNoCov">          0 :      asm type-qualifier[opt] goto ( asm-goto-argument ) ;</span>
<span class="lineNum">    6272 </span>            : 
<span class="lineNum">    6273 </span><span class="lineCov">     201536 :    asm-argument:</span>
<span class="lineNum">    6274 </span><span class="lineCov">     201664 :      asm-string-literal</span>
<span class="lineNum">    6275 </span><span class="lineCov">     201536 :      asm-string-literal : asm-operands[opt]</span>
<span class="lineNum">    6276 </span>            :      asm-string-literal : asm-operands[opt] : asm-operands[opt]
<span class="lineNum">    6277 </span><span class="lineCov">     201536 :      asm-string-literal : asm-operands[opt] : asm-operands[opt] : asm-clobbers[opt]</span>
<span class="lineNum">    6278 </span><span class="lineCov">     201536 : </span>
<span class="lineNum">    6279 </span><span class="lineCov">     201536 :    asm-goto-argument:</span>
<span class="lineNum">    6280 </span>            :      asm-string-literal : : asm-operands[opt] : asm-clobbers[opt] \
<span class="lineNum">    6281 </span><span class="lineCov">     201536 :        : asm-goto-operands</span>
<span class="lineNum">    6282 </span><span class="lineCov">     125464 : </span>
<span class="lineNum">    6283 </span>            :    Qualifiers other than volatile are accepted in the syntax but
<span class="lineNum">    6284 </span>            :    warned for.  */
<a name="6285"><span class="lineNum">    6285 </span><span class="lineCov">     201536 : </span></a>
<span class="lineNum">    6286 </span><span class="lineCov">     201536 : static tree</span>
<span class="lineNum">    6287 </span><span class="lineCov">     201536 : c_parser_asm_statement (c_parser *parser)</span>
<span class="lineNum">    6288 </span>            : {
<span class="lineNum">    6289 </span>            :   tree quals, str, outputs, inputs, clobbers, labels, ret;
<span class="lineNum">    6290 </span>            :   bool simple, is_goto;
<span class="lineNum">    6291 </span>            :   location_t asm_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    6292 </span>            :   int section, nsections;
<span class="lineNum">    6293 </span>            : 
<span class="lineNum">    6294 </span>            :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ASM));
<span class="lineNum">    6295 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    6296 </span>            :   if (c_parser_next_token_is_keyword (parser, RID_VOLATILE))
<span class="lineNum">    6297 </span>            :     {
<span class="lineNum">    6298 </span>            :       quals = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    6299 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    6300 </span>            :     }
<span class="lineNum">    6301 </span>            :   else if (c_parser_next_token_is_keyword (parser, RID_CONST)
<span class="lineNum">    6302 </span>            :            || c_parser_next_token_is_keyword (parser, RID_RESTRICT))
<span class="lineNum">    6303 </span>            :     {
<span class="lineNum">    6304 </span>            :       warning_at (c_parser_peek_token (parser)-&gt;location,
<span class="lineNum">    6305 </span>            :                   0,
<span class="lineNum">    6306 </span>            :                   &quot;%E qualifier ignored on asm&quot;,
<span class="lineNum">    6307 </span>            :                   c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">    6308 </span>            :       quals = NULL_TREE;
<span class="lineNum">    6309 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    6310 </span>            :     }
<span class="lineNum">    6311 </span><span class="lineCov">     156073 :   else</span>
<span class="lineNum">    6312 </span>            :     quals = NULL_TREE;
<span class="lineNum">    6313 </span><span class="lineCov">     156073 : </span>
<span class="lineNum">    6314 </span><span class="lineCov">     156073 :   is_goto = false;</span>
<span class="lineNum">    6315 </span><span class="lineCov">     156073 :   if (c_parser_next_token_is_keyword (parser, RID_GOTO))</span>
<span class="lineNum">    6316 </span><span class="lineCov">     156073 :     {</span>
<span class="lineNum">    6317 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    6318 </span><span class="lineCov">     156073 :       is_goto = true;</span>
<span class="lineNum">    6319 </span><span class="lineCov">     156073 :     }</span>
<span class="lineNum">    6320 </span><span class="lineCov">     156073 : </span>
<span class="lineNum">    6321 </span>            :   /* ??? Follow the C++ parser rather than using the
<span class="lineNum">    6322 </span><span class="lineCov">     116865 :      lex_untranslated_string kludge.  */</span>
<span class="lineNum">    6323 </span><span class="lineCov">     116865 :   parser-&gt;lex_untranslated_string = true;</span>
<span class="lineNum">    6324 </span>            :   ret = NULL;
<span class="lineNum">    6325 </span><span class="lineCov">      39208 : </span>
<span class="lineNum">    6326 </span><span class="lineCov">      39208 :   matching_parens parens;</span>
<span class="lineNum">    6327 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">    6328 </span><span class="lineCov">          2 :     goto error;</span>
<span class="lineNum">    6329 </span>            : 
<span class="lineNum">    6330 </span>            :   str = c_parser_asm_string_literal (parser);
<span class="lineNum">    6331 </span><span class="lineCov">          2 :   if (str == NULL_TREE)</span>
<span class="lineNum">    6332 </span><span class="lineCov">          2 :     goto error_close_paren;</span>
<span class="lineNum">    6333 </span><span class="lineCov">          2 : </span>
<span class="lineNum">    6334 </span>            :   simple = true;
<span class="lineNum">    6335 </span>            :   outputs = NULL_TREE;
<span class="lineNum">    6336 </span>            :   inputs = NULL_TREE;
<span class="lineNum">    6337 </span>            :   clobbers = NULL_TREE;
<span class="lineNum">    6338 </span><span class="lineCov">     156073 :   labels = NULL_TREE;</span>
<span class="lineNum">    6339 </span><span class="lineCov">     156073 : </span>
<span class="lineNum">    6340 </span>            :   if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN) &amp;&amp; !is_goto)
<span class="lineNum">    6341 </span><span class="lineCov">        146 :     goto done_asm;</span>
<span class="lineNum">    6342 </span><span class="lineCov">        146 : </span>
<span class="lineNum">    6343 </span>            :   /* Parse each colon-delimited section of operands.  */
<span class="lineNum">    6344 </span>            :   nsections = 3 + is_goto;
<span class="lineNum">    6345 </span>            :   for (section = 0; section &lt; nsections; ++section)
<span class="lineNum">    6346 </span>            :     {
<span class="lineNum">    6347 </span><span class="lineCov">     156073 :       if (!c_parser_require (parser, CPP_COLON,</span>
<span class="lineNum">    6348 </span><span class="lineCov">     156073 :                              is_goto</span>
<span class="lineNum">    6349 </span>            :                              ? G_(&quot;expected %&lt;:%&gt;&quot;)
<span class="lineNum">    6350 </span><span class="lineCov">     312146 :                              : G_(&quot;expected %&lt;:%&gt; or %&lt;)%&gt;&quot;),</span>
<span class="lineNum">    6351 </span><span class="lineCov">     156073 :                              UNKNOWN_LOCATION, is_goto))</span>
<span class="lineNum">    6352 </span>            :         goto error_close_paren;
<span class="lineNum">    6353 </span>            : 
<span class="lineNum">    6354 </span><span class="lineCov">     156073 :       /* Once past any colon, we're no longer a simple asm.  */</span>
<span class="lineNum">    6355 </span><span class="lineCov">     156073 :       simple = false;</span>
<span class="lineNum">    6356 </span>            : 
<span class="lineNum">    6357 </span>            :       if ((!c_parser_next_token_is (parser, CPP_COLON)
<span class="lineNum">    6358 </span><span class="lineCov">     156061 :            &amp;&amp; !c_parser_next_token_is (parser, CPP_CLOSE_PAREN))</span>
<span class="lineNum">    6359 </span><span class="lineCov">     156061 :           || section == 3)</span>
<span class="lineNum">    6360 </span><span class="lineCov">     156061 :         switch (section)</span>
<span class="lineNum">    6361 </span><span class="lineCov">     156061 :           {</span>
<span class="lineNum">    6362 </span><span class="lineCov">     156061 :           case 0:</span>
<span class="lineNum">    6363 </span>            :             /* For asm goto, we don't allow output operands, but reserve
<span class="lineNum">    6364 </span><span class="lineCov">     156061 :                the slot for a future extension that does allow them.  */</span>
<span class="lineNum">    6365 </span>            :             if (!is_goto)
<span class="lineNum">    6366 </span>            :               outputs = c_parser_asm_operands (parser);
<span class="lineNum">    6367 </span>            :             break;
<span class="lineNum">    6368 </span><span class="lineCov">     154703 :           case 1:</span>
<span class="lineNum">    6369 </span><span class="lineCov">     423509 :             inputs = c_parser_asm_operands (parser);</span>
<span class="lineNum">    6370 </span>            :             break;
<span class="lineNum">    6371 </span><span class="lineCov">     846169 :           case 2:</span>
<span class="lineNum">    6372 </span>            :             clobbers = c_parser_asm_clobbers (parser);
<span class="lineNum">    6373 </span>            :             break;
<span class="lineNum">    6374 </span>            :           case 3:
<span class="lineNum">    6375 </span>            :             labels = c_parser_asm_goto_operands (parser);
<span class="lineNum">    6376 </span>            :             break;
<span class="lineNum">    6377 </span>            :           default:
<span class="lineNum">    6378 </span>            :             gcc_unreachable ();
<span class="lineNum">    6379 </span><span class="lineCov">     423363 :           }</span>
<span class="lineNum">    6380 </span>            : 
<span class="lineNum">    6381 </span><span class="lineCov">     423363 :       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN) &amp;&amp; !is_goto)</span>
<span class="lineNum">    6382 </span><span class="lineCov">     324043 :         goto done_asm;</span>
<span class="lineNum">    6383 </span><span class="lineCov">     423396 :     }</span>
<span class="lineNum">    6384 </span><span class="lineCov">     324011 : </span>
<span class="lineNum">    6385 </span>            :  done_asm:
<span class="lineNum">    6386 </span><span class="lineCov">     103078 :   if (!parens.require_close (parser))</span>
<span class="lineNum">    6387 </span>            :     {
<span class="lineNum">    6388 </span>            :       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
<span class="lineNum">    6389 </span><span class="lineCov">     103078 :       goto error;</span>
<span class="lineNum">    6390 </span><span class="lineCov">     103076 :     }</span>
<span class="lineNum">    6391 </span>            : 
<span class="lineNum">    6392 </span><span class="lineCov">     103371 :   if (!c_parser_require (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;))</span>
<span class="lineNum">    6393 </span><span class="lineCov">     103371 :     c_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">    6394 </span><span class="lineCov">     103371 : </span>
<span class="lineNum">    6395 </span><span class="lineCov">     117424 :   ret = build_asm_stmt (quals, build_asm_expr (asm_loc, str, outputs, inputs,</span>
<span class="lineNum">    6396 </span><span class="lineCov">     117424 :                                                clobbers, labels, simple));</span>
<span class="lineNum">    6397 </span><span class="lineCov">     117424 : </span>
<span class="lineNum">    6398 </span><span class="lineCov">        138 :  error:</span>
<span class="lineNum">    6399 </span><span class="lineCov">        138 :   parser-&gt;lex_untranslated_string = false;</span>
<span class="lineNum">    6400 </span><span class="lineCov">        138 :   return ret;</span>
<span class="lineNum">    6401 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    6402 </span><span class="lineNoCov">          0 :  error_close_paren:</span>
<span class="lineNum">    6403 </span>            :   c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
<span class="lineNum">    6404 </span>            :   goto error;
<span class="lineNum">    6405 </span><span class="lineCov">     423363 : }</span>
<span class="lineNum">    6406 </span><span class="lineCov">     154557 : </span>
<span class="lineNum">    6407 </span>            : /* Parse asm operands, a GNU extension.
<span class="lineNum">    6408 </span>            : 
<span class="lineNum">    6409 </span><span class="lineCov">        138 :    asm-operands:</span>
<span class="lineNum">    6410 </span><span class="lineCov">     156053 :      asm-operand</span>
<span class="lineNum">    6411 </span>            :      asm-operands , asm-operand
<span class="lineNum">    6412 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    6413 </span><span class="lineNoCov">          0 :    asm-operand:</span>
<span class="lineNum">    6414 </span>            :      asm-string-literal ( expression )
<span class="lineNum">    6415 </span>            :      [ identifier ] asm-string-literal ( expression )
<span class="lineNum">    6416 </span><span class="lineCov">     156053 : */</span>
<a name="6417"><span class="lineNum">    6417 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">    6418 </span>            : static tree
<span class="lineNum">    6419 </span><span class="lineCov">     156053 : c_parser_asm_operands (c_parser *parser)</span>
<span class="lineNum">    6420 </span>            : {
<span class="lineNum">    6421 </span>            :   tree list = NULL_TREE;
<span class="lineNum">    6422 </span><span class="lineCov">     156073 :   while (true)</span>
<span class="lineNum">    6423 </span><span class="lineCov">     156073 :     {</span>
<span class="lineNum">    6424 </span><span class="lineCov">     156073 :       tree name, str;</span>
<span class="lineNum">    6425 </span>            :       struct c_expr expr;
<span class="lineNum">    6426 </span><span class="lineCov">         20 :       if (c_parser_next_token_is (parser, CPP_OPEN_SQUARE))</span>
<span class="lineNum">    6427 </span><span class="lineCov">         20 :         {</span>
<span class="lineNum">    6428 </span><span class="lineCov">         20 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    6429 </span>            :           if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">    6430 </span>            :             {
<span class="lineNum">    6431 </span>            :               tree id = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    6432 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">    6433 </span>            :               name = build_string (IDENTIFIER_LENGTH (id),
<span class="lineNum">    6434 </span>            :                                    IDENTIFIER_POINTER (id));
<span class="lineNum">    6435 </span>            :             }
<span class="lineNum">    6436 </span>            :           else
<span class="lineNum">    6437 </span>            :             {
<span class="lineNum">    6438 </span>            :               c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">    6439 </span>            :               c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);
<span class="lineNum">    6440 </span>            :               return NULL_TREE;
<span class="lineNum">    6441 </span>            :             }
<span class="lineNum">    6442 </span>            :           c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,
<span class="lineNum">    6443 </span><span class="lineCov">     206447 :                                      &quot;expected %&lt;]%&gt;&quot;);</span>
<span class="lineNum">    6444 </span>            :         }
<span class="lineNum">    6445 </span><span class="lineCov">     206447 :       else</span>
<span class="lineNum">    6446 </span><span class="lineCov">     520789 :         name = NULL_TREE;</span>
<span class="lineNum">    6447 </span>            :       str = c_parser_asm_string_literal (parser);
<span class="lineNum">    6448 </span><span class="lineCov">     520789 :       if (str == NULL_TREE)</span>
<span class="lineNum">    6449 </span><span class="lineCov">     520789 :         return NULL_TREE;</span>
<span class="lineNum">    6450 </span><span class="lineCov">     520789 :       parser-&gt;lex_untranslated_string = false;</span>
<span class="lineNum">    6451 </span>            :       matching_parens parens;
<span class="lineNum">    6452 </span><span class="lineCov">        418 :       if (!parens.require_open (parser))</span>
<span class="lineNum">    6453 </span><span class="lineCov">        418 :         {</span>
<span class="lineNum">    6454 </span>            :           parser-&gt;lex_untranslated_string = true;
<span class="lineNum">    6455 </span><span class="lineCov">        418 :           return NULL_TREE;</span>
<span class="lineNum">    6456 </span><span class="lineCov">        418 :         }</span>
<span class="lineNum">    6457 </span><span class="lineCov">        418 :       expr = c_parser_expression (parser);</span>
<span class="lineNum">    6458 </span><span class="lineCov">        418 :       mark_exp_read (expr.value);</span>
<span class="lineNum">    6459 </span>            :       parser-&gt;lex_untranslated_string = true;
<span class="lineNum">    6460 </span>            :       if (!parens.require_close (parser))
<span class="lineNum">    6461 </span>            :         {
<span class="lineNum">    6462 </span><span class="lineNoCov">          0 :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);</span>
<span class="lineNum">    6463 </span><span class="lineNoCov">          0 :           return NULL_TREE;</span>
<span class="lineNum">    6464 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    6465 </span>            :       list = chainon (list, build_tree_list (build_tree_list (name, str),
<span class="lineNum">    6466 </span><span class="lineCov">        418 :                                              expr.value));</span>
<span class="lineNum">    6467 </span>            :       if (c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">    6468 </span>            :         c_parser_consume_token (parser);
<span class="lineNum">    6469 </span>            :       else
<span class="lineNum">    6470 </span>            :         break;
<span class="lineNum">    6471 </span><span class="lineCov">     520789 :     }</span>
<span class="lineNum">    6472 </span><span class="lineCov">     520789 :   return list;</span>
<span class="lineNum">    6473 </span>            : }
<span class="lineNum">    6474 </span><span class="lineCov">     520789 : </span>
<span class="lineNum">    6475 </span><span class="lineCov">    1041578 : /* Parse asm clobbers, a GNU extension.</span>
<span class="lineNum">    6476 </span><span class="lineCov">     520789 : </span>
<span class="lineNum">    6477 </span>            :    asm-clobbers:
<span class="lineNum">    6478 </span><span class="lineNoCov">          0 :      asm-string-literal</span>
<span class="lineNum">    6479 </span><span class="lineNoCov">          0 :      asm-clobbers , asm-string-literal</span>
<span class="lineNum">    6480 </span>            : */
<a name="6481"><span class="lineNum">    6481 </span><span class="lineCov">     520789 : </span></a>
<span class="lineNum">    6482 </span><span class="lineCov">     520789 : static tree</span>
<span class="lineNum">    6483 </span><span class="lineCov">     520789 : c_parser_asm_clobbers (c_parser *parser)</span>
<span class="lineNum">    6484 </span><span class="lineCov">     520789 : {</span>
<span class="lineNum">    6485 </span>            :   tree list = NULL_TREE;
<span class="lineNum">    6486 </span><span class="lineNoCov">          0 :   while (true)</span>
<span class="lineNum">    6487 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    6488 </span>            :       tree str = c_parser_asm_string_literal (parser);
<span class="lineNum">    6489 </span><span class="lineCov">     520789 :       if (str)</span>
<span class="lineNum">    6490 </span>            :         list = tree_cons (NULL_TREE, str, list);
<span class="lineNum">    6491 </span><span class="lineCov">     520789 :       else</span>
<span class="lineNum">    6492 </span><span class="lineCov">     314342 :         return NULL_TREE;</span>
<span class="lineNum">    6493 </span>            :       if (c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">    6494 </span>            :         c_parser_consume_token (parser);
<span class="lineNum">    6495 </span><span class="lineCov">     314342 :       else</span>
<span class="lineNum">    6496 </span><span class="lineCov">     206447 :         break;</span>
<span class="lineNum">    6497 </span>            :     }
<span class="lineNum">    6498 </span>            :   return list;
<span class="lineNum">    6499 </span>            : }
<span class="lineNum">    6500 </span>            : 
<span class="lineNum">    6501 </span>            : /* Parse asm goto labels, a GNU extension.
<span class="lineNum">    6502 </span>            : 
<span class="lineNum">    6503 </span>            :    asm-goto-operands:
<span class="lineNum">    6504 </span>            :      identifier
<span class="lineNum">    6505 </span>            :      asm-goto-operands , identifier
<span class="lineNum">    6506 </span>            : */
<a name="6507"><span class="lineNum">    6507 </span><span class="lineCov">     117424 : </span></a>
<span class="lineNum">    6508 </span>            : static tree
<span class="lineNum">    6509 </span><span class="lineCov">     117424 : c_parser_asm_goto_operands (c_parser *parser)</span>
<span class="lineNum">    6510 </span><span class="lineCov">     142416 : {</span>
<span class="lineNum">    6511 </span>            :   tree list = NULL_TREE;
<span class="lineNum">    6512 </span><span class="lineCov">     142416 :   while (true)</span>
<span class="lineNum">    6513 </span><span class="lineCov">     142416 :     {</span>
<span class="lineNum">    6514 </span><span class="lineCov">     142416 :       tree name, label;</span>
<span class="lineNum">    6515 </span>            : 
<span class="lineNum">    6516 </span>            :       if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">    6517 </span><span class="lineCov">     142416 :         {</span>
<span class="lineNum">    6518 </span><span class="lineCov">      24992 :           c_token *tok = c_parser_peek_token (parser);</span>
<span class="lineNum">    6519 </span>            :           name = tok-&gt;value;
<span class="lineNum">    6520 </span>            :           label = lookup_label_for_goto (tok-&gt;location, name);
<span class="lineNum">    6521 </span><span class="lineCov">      24992 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    6522 </span>            :           TREE_USED (label) = 1;
<span class="lineNum">    6523 </span>            :         }
<span class="lineNum">    6524 </span>            :       else
<span class="lineNum">    6525 </span>            :         {
<span class="lineNum">    6526 </span>            :           c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">    6527 </span>            :           return NULL_TREE;
<span class="lineNum">    6528 </span>            :         }
<span class="lineNum">    6529 </span>            : 
<span class="lineNum">    6530 </span>            :       name = build_string (IDENTIFIER_LENGTH (name),
<span class="lineNum">    6531 </span>            :                            IDENTIFIER_POINTER (name));
<span class="lineNum">    6532 </span>            :       list = tree_cons (name, label, list);
<span class="lineNum">    6533 </span><span class="lineCov">        138 :       if (c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">    6534 </span>            :         c_parser_consume_token (parser);
<span class="lineNum">    6535 </span><span class="lineCov">        138 :       else</span>
<span class="lineNum">    6536 </span><span class="lineCov">        227 :         return nreverse (list);</span>
<span class="lineNum">    6537 </span>            :     }
<span class="lineNum">    6538 </span><span class="lineCov">        227 : }</span>
<span class="lineNum">    6539 </span>            : 
<span class="lineNum">    6540 </span><span class="lineCov">        227 : /* Parse an expression other than a compound expression; that is, an</span>
<span class="lineNum">    6541 </span>            :    assignment expression (C90 6.3.16, C99 6.5.16, C11 6.5.16).  If
<span class="lineNum">    6542 </span><span class="lineCov">        226 :    AFTER is not NULL then it is an Objective-C message expression which</span>
<span class="lineNum">    6543 </span><span class="lineCov">        226 :    is the primary-expression starting the expression as an initializer.</span>
<span class="lineNum">    6544 </span><span class="lineCov">        226 : </span>
<span class="lineNum">    6545 </span><span class="lineCov">        226 :    assignment-expression:</span>
<span class="lineNum">    6546 </span><span class="lineCov">        226 :      conditional-expression</span>
<span class="lineNum">    6547 </span>            :      unary-expression assignment-operator assignment-expression
<span class="lineNum">    6548 </span>            : 
<span class="lineNum">    6549 </span>            :    assignment-operator: one of
<span class="lineNum">    6550 </span><span class="lineCov">          1 :      = *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</span>
<span class="lineNum">    6551 </span><span class="lineCov">          1 : </span>
<span class="lineNum">    6552 </span>            :    In GNU C we accept any conditional expression on the LHS and
<span class="lineNum">    6553 </span>            :    diagnose the invalid lvalue rather than producing a syntax
<span class="lineNum">    6554 </span><span class="lineCov">        226 :    error.  */</span>
<a name="6555"><span class="lineNum">    6555 </span><span class="lineCov">        226 : </span></a>
<span class="lineNum">    6556 </span><span class="lineCov">        226 : static struct c_expr</span>
<span class="lineNum">    6557 </span><span class="lineCov">        226 : c_parser_expr_no_commas (c_parser *parser, struct c_expr *after,</span>
<span class="lineNum">    6558 </span><span class="lineCov">         89 :                          tree omp_atomic_lhs)</span>
<span class="lineNum">    6559 </span>            : {
<span class="lineNum">    6560 </span><span class="lineCov">        137 :   struct c_expr lhs, rhs, ret;</span>
<span class="lineNum">    6561 </span>            :   enum tree_code code;
<span class="lineNum">    6562 </span>            :   location_t op_location, exp_location;
<span class="lineNum">    6563 </span>            :   gcc_assert (!after || c_dialect_objc ());
<span class="lineNum">    6564 </span>            :   lhs = c_parser_conditional_expression (parser, after, omp_atomic_lhs);
<span class="lineNum">    6565 </span>            :   op_location = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    6566 </span>            :   switch (c_parser_peek_token (parser)-&gt;type)
<span class="lineNum">    6567 </span>            :     {
<span class="lineNum">    6568 </span>            :     case CPP_EQ:
<span class="lineNum">    6569 </span>            :       code = NOP_EXPR;
<span class="lineNum">    6570 </span>            :       break;
<span class="lineNum">    6571 </span>            :     case CPP_MULT_EQ:
<span class="lineNum">    6572 </span>            :       code = MULT_EXPR;
<span class="lineNum">    6573 </span>            :       break;
<span class="lineNum">    6574 </span>            :     case CPP_DIV_EQ:
<span class="lineNum">    6575 </span>            :       code = TRUNC_DIV_EXPR;
<span class="lineNum">    6576 </span>            :       break;
<span class="lineNum">    6577 </span>            :     case CPP_MOD_EQ:
<span class="lineNum">    6578 </span>            :       code = TRUNC_MOD_EXPR;
<span class="lineNum">    6579 </span>            :       break;
<span class="lineNum">    6580 </span>            :     case CPP_PLUS_EQ:
<span class="lineNum">    6581 </span><span class="lineCov">  107275819 :       code = PLUS_EXPR;</span>
<span class="lineNum">    6582 </span>            :       break;
<span class="lineNum">    6583 </span>            :     case CPP_MINUS_EQ:
<span class="lineNum">    6584 </span><span class="lineCov">  107275819 :       code = MINUS_EXPR;</span>
<span class="lineNum">    6585 </span><span class="lineCov">  107275819 :       break;</span>
<span class="lineNum">    6586 </span><span class="lineCov">  107275819 :     case CPP_LSHIFT_EQ:</span>
<span class="lineNum">    6587 </span><span class="lineCov">  107275819 :       code = LSHIFT_EXPR;</span>
<span class="lineNum">    6588 </span><span class="lineCov">  107275819 :       break;</span>
<span class="lineNum">    6589 </span><span class="lineCov">  107275817 :     case CPP_RSHIFT_EQ:</span>
<span class="lineNum">    6590 </span><span class="lineCov">  107275817 :       code = RSHIFT_EXPR;</span>
<span class="lineNum">    6591 </span>            :       break;
<span class="lineNum">    6592 </span>            :     case CPP_AND_EQ:
<span class="lineNum">    6593 </span>            :       code = BIT_AND_EXPR;
<span class="lineNum">    6594 </span>            :       break;
<span class="lineNum">    6595 </span><span class="lineCov">       5959 :     case CPP_XOR_EQ:</span>
<span class="lineNum">    6596 </span><span class="lineCov">       5959 :       code = BIT_XOR_EXPR;</span>
<span class="lineNum">    6597 </span><span class="lineCov">       5959 :       break;</span>
<span class="lineNum">    6598 </span><span class="lineCov">       3638 :     case CPP_OR_EQ:</span>
<span class="lineNum">    6599 </span><span class="lineCov">       3638 :       code = BIT_IOR_EXPR;</span>
<span class="lineNum">    6600 </span><span class="lineCov">       3638 :       break;</span>
<span class="lineNum">    6601 </span><span class="lineCov">       2130 :     default:</span>
<span class="lineNum">    6602 </span><span class="lineCov">       2130 :       return lhs;</span>
<span class="lineNum">    6603 </span><span class="lineCov">       2130 :     }</span>
<span class="lineNum">    6604 </span><span class="lineCov">      61663 :   c_parser_consume_token (parser);</span>
<span class="lineNum">    6605 </span><span class="lineCov">      61663 :   exp_location = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    6606 </span><span class="lineCov">      61663 :   rhs = c_parser_expr_no_commas (parser, NULL);</span>
<span class="lineNum">    6607 </span><span class="lineCov">      17837 :   rhs = convert_lvalue_to_rvalue (exp_location, rhs, true, true);</span>
<span class="lineNum">    6608 </span><span class="lineCov">      17837 :   </span>
<span class="lineNum">    6609 </span><span class="lineCov">      17837 :   ret.value = build_modify_expr (op_location, lhs.value, lhs.original_type,</span>
<span class="lineNum">    6610 </span><span class="lineCov">       3115 :                                  code, exp_location, rhs.value,</span>
<span class="lineNum">    6611 </span><span class="lineCov">       3115 :                                  rhs.original_type);</span>
<span class="lineNum">    6612 </span><span class="lineCov">       3115 :   set_c_expr_source_range (&amp;ret, lhs.get_start (), rhs.get_finish ());</span>
<span class="lineNum">    6613 </span><span class="lineCov">       2046 :   if (code == NOP_EXPR)</span>
<span class="lineNum">    6614 </span><span class="lineCov">       2046 :     ret.original_code = MODIFY_EXPR;</span>
<span class="lineNum">    6615 </span><span class="lineCov">       2046 :   else</span>
<span class="lineNum">    6616 </span><span class="lineCov">       5319 :     {</span>
<span class="lineNum">    6617 </span><span class="lineCov">       5319 :       TREE_NO_WARNING (ret.value) = 1;</span>
<span class="lineNum">    6618 </span><span class="lineCov">       5319 :       ret.original_code = ERROR_MARK;</span>
<span class="lineNum">    6619 </span><span class="lineCov">       2479 :     }</span>
<span class="lineNum">    6620 </span><span class="lineCov">       2479 :   ret.original_type = NULL;</span>
<span class="lineNum">    6621 </span><span class="lineCov">       2479 :   return ret;</span>
<span class="lineNum">    6622 </span><span class="lineCov">      65158 : }</span>
<span class="lineNum">    6623 </span><span class="lineCov">      65158 : </span>
<span class="lineNum">    6624 </span><span class="lineCov">      65158 : /* Parse a conditional expression (C90 6.3.15, C99 6.5.15, C11 6.5.15).  If</span>
<span class="lineNum">    6625 </span><span class="lineCov">  105344387 :    AFTER is not NULL then it is an Objective-C message expression which is</span>
<span class="lineNum">    6626 </span><span class="lineCov">  105344387 :    the primary-expression starting the expression as an initializer.</span>
<span class="lineNum">    6627 </span>            : 
<span class="lineNum">    6628 </span><span class="lineCov">    1931430 :    conditional-expression:</span>
<span class="lineNum">    6629 </span><span class="lineCov">    1931430 :      logical-OR-expression</span>
<span class="lineNum">    6630 </span><span class="lineCov">    1931430 :      logical-OR-expression ? expression : conditional-expression</span>
<span class="lineNum">    6631 </span><span class="lineCov">    1931430 : </span>
<span class="lineNum">    6632 </span>            :    GNU extensions:
<span class="lineNum">    6633 </span><span class="lineCov">    1931430 : </span>
<span class="lineNum">    6634 </span>            :    conditional-expression:
<span class="lineNum">    6635 </span>            :      logical-OR-expression ? : conditional-expression
<span class="lineNum">    6636 </span><span class="lineCov">    5794290 : */</span>
<a name="6637"><span class="lineNum">    6637 </span><span class="lineCov">    1931430 : </span></a>
<span class="lineNum">    6638 </span><span class="lineCov">    1762086 : static struct c_expr</span>
<span class="lineNum">    6639 </span>            : c_parser_conditional_expression (c_parser *parser, struct c_expr *after,
<span class="lineNum">    6640 </span>            :                                  tree omp_atomic_lhs)
<span class="lineNum">    6641 </span><span class="lineCov">     169344 : {</span>
<span class="lineNum">    6642 </span><span class="lineCov">     169344 :   struct c_expr cond, exp1, exp2, ret;</span>
<span class="lineNum">    6643 </span>            :   location_t start, cond_loc, colon_loc;
<span class="lineNum">    6644 </span><span class="lineCov">    1931430 : </span>
<span class="lineNum">    6645 </span><span class="lineCov">    1931430 :   gcc_assert (!after || c_dialect_objc ());</span>
<span class="lineNum">    6646 </span>            : 
<span class="lineNum">    6647 </span>            :   cond = c_parser_binary_expression (parser, after, omp_atomic_lhs);
<span class="lineNum">    6648 </span>            : 
<span class="lineNum">    6649 </span>            :   if (c_parser_next_token_is_not (parser, CPP_QUERY))
<span class="lineNum">    6650 </span>            :     return cond;
<span class="lineNum">    6651 </span>            :   if (cond.value != error_mark_node)
<span class="lineNum">    6652 </span>            :     start = cond.get_start ();
<span class="lineNum">    6653 </span>            :   else
<span class="lineNum">    6654 </span>            :     start = UNKNOWN_LOCATION;
<span class="lineNum">    6655 </span>            :   cond_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    6656 </span>            :   cond = convert_lvalue_to_rvalue (cond_loc, cond, true, true);
<span class="lineNum">    6657 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    6658 </span>            :   if (c_parser_next_token_is (parser, CPP_COLON))
<span class="lineNum">    6659 </span>            :     {
<span class="lineNum">    6660 </span>            :       tree eptype = NULL_TREE;
<span class="lineNum">    6661 </span>            : 
<span class="lineNum">    6662 </span>            :       location_t middle_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    6663 </span><span class="lineCov">  107510474 :       pedwarn (middle_loc, OPT_Wpedantic,</span>
<span class="lineNum">    6664 </span>            :                &quot;ISO C forbids omitting the middle term of a ?: expression&quot;);
<span class="lineNum">    6665 </span>            :       if (TREE_CODE (cond.value) == EXCESS_PRECISION_EXPR)
<span class="lineNum">    6666 </span><span class="lineCov">  107510474 :         {</span>
<span class="lineNum">    6667 </span><span class="lineCov">  107510474 :           eptype = TREE_TYPE (cond.value);</span>
<span class="lineNum">    6668 </span>            :           cond.value = TREE_OPERAND (cond.value, 0);
<span class="lineNum">    6669 </span><span class="lineCov">  107510474 :         }</span>
<span class="lineNum">    6670 </span>            :       tree e = cond.value;
<span class="lineNum">    6671 </span><span class="lineCov">  107510474 :       while (TREE_CODE (e) == COMPOUND_EXPR)</span>
<span class="lineNum">    6672 </span>            :         e = TREE_OPERAND (e, 1);
<span class="lineNum">    6673 </span><span class="lineCov">  107510472 :       warn_for_omitted_condop (middle_loc, e);</span>
<span class="lineNum">    6674 </span><span class="lineCov">  107275808 :       /* Make sure first operand is calculated only once.  */</span>
<span class="lineNum">    6675 </span><span class="lineCov">     234664 :       exp1.value = save_expr (default_conversion (cond.value));</span>
<span class="lineNum">    6676 </span><span class="lineCov">     469306 :       if (eptype)</span>
<span class="lineNum">    6677 </span>            :         exp1.value = build1 (EXCESS_PRECISION_EXPR, eptype, exp1.value);
<span class="lineNum">    6678 </span>            :       exp1.original_type = NULL;
<span class="lineNum">    6679 </span><span class="lineCov">     234664 :       exp1.src_range = cond.src_range;</span>
<span class="lineNum">    6680 </span><span class="lineCov">     234664 :       cond.value = c_objc_common_truthvalue_conversion (cond_loc, exp1.value);</span>
<span class="lineNum">    6681 </span><span class="lineCov">     234664 :       c_inhibit_evaluation_warnings += cond.value == truthvalue_true_node;</span>
<span class="lineNum">    6682 </span><span class="lineCov">     234664 :     }</span>
<span class="lineNum">    6683 </span>            :   else
<span class="lineNum">    6684 </span><span class="lineCov">        574 :     {</span>
<span class="lineNum">    6685 </span>            :       cond.value
<span class="lineNum">    6686 </span><span class="lineCov">        574 :         = c_objc_common_truthvalue_conversion</span>
<span class="lineNum">    6687 </span><span class="lineCov">        574 :         (cond_loc, default_conversion (cond.value));</span>
<span class="lineNum">    6688 </span>            :       c_inhibit_evaluation_warnings += cond.value == truthvalue_false_node;
<span class="lineNum">    6689 </span><span class="lineCov">        574 :       exp1 = c_parser_expression_conv (parser);</span>
<span class="lineNum">    6690 </span>            :       mark_exp_read (exp1.value);
<span class="lineNum">    6691 </span><span class="lineCov">          1 :       c_inhibit_evaluation_warnings +=</span>
<span class="lineNum">    6692 </span><span class="lineCov">          1 :         ((cond.value == truthvalue_true_node)</span>
<span class="lineNum">    6693 </span>            :          - (cond.value == truthvalue_false_node));
<span class="lineNum">    6694 </span><span class="lineCov">        574 :     }</span>
<span class="lineNum">    6695 </span><span class="lineCov">        576 : </span>
<span class="lineNum">    6696 </span><span class="lineCov">          2 :   colon_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    6697 </span><span class="lineCov">        574 :   if (!c_parser_require (parser, CPP_COLON, &quot;expected %&lt;:%&gt;&quot;))</span>
<span class="lineNum">    6698 </span>            :     {
<span class="lineNum">    6699 </span><span class="lineCov">        574 :       c_inhibit_evaluation_warnings -= cond.value == truthvalue_true_node;</span>
<span class="lineNum">    6700 </span><span class="lineCov">        574 :       ret.set_error ();</span>
<span class="lineNum">    6701 </span><span class="lineCov">          1 :       ret.original_code = ERROR_MARK;</span>
<span class="lineNum">    6702 </span><span class="lineCov">        574 :       ret.original_type = NULL;</span>
<span class="lineNum">    6703 </span><span class="lineCov">        574 :       return ret;</span>
<span class="lineNum">    6704 </span><span class="lineCov">        574 :     }</span>
<span class="lineNum">    6705 </span><span class="lineCov">        574 :   {</span>
<span class="lineNum">    6706 </span>            :     location_t exp2_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    6707 </span>            :     exp2 = c_parser_conditional_expression (parser, NULL, NULL_TREE);
<span class="lineNum">    6708 </span>            :     exp2 = convert_lvalue_to_rvalue (exp2_loc, exp2, true, true);
<span class="lineNum">    6709 </span><span class="lineCov">     234090 :   }</span>
<span class="lineNum">    6710 </span><span class="lineCov">     234090 :   c_inhibit_evaluation_warnings -= cond.value == truthvalue_true_node;</span>
<span class="lineNum">    6711 </span><span class="lineCov">     234090 :   location_t loc1 = make_location (exp1.get_start (), exp1.src_range);</span>
<span class="lineNum">    6712 </span><span class="lineCov">     234090 :   location_t loc2 = make_location (exp2.get_start (), exp2.src_range);</span>
<span class="lineNum">    6713 </span><span class="lineCov">     234090 :   ret.value = build_conditional_expr (colon_loc, cond.value,</span>
<span class="lineNum">    6714 </span><span class="lineCov">     234090 :                                       cond.original_code == C_MAYBE_CONST_EXPR,</span>
<span class="lineNum">    6715 </span><span class="lineCov">     468180 :                                       exp1.value, exp1.original_type, loc1,</span>
<span class="lineNum">    6716 </span><span class="lineCov">     234090 :                                       exp2.value, exp2.original_type, loc2);</span>
<span class="lineNum">    6717 </span><span class="lineCov">     234090 :   ret.original_code = ERROR_MARK;</span>
<span class="lineNum">    6718 </span>            :   if (exp1.value == error_mark_node || exp2.value == error_mark_node)
<span class="lineNum">    6719 </span>            :     ret.original_type = NULL;
<span class="lineNum">    6720 </span><span class="lineCov">     234664 :   else</span>
<span class="lineNum">    6721 </span><span class="lineCov">     234664 :     {</span>
<span class="lineNum">    6722 </span>            :       tree t1, t2;
<span class="lineNum">    6723 </span><span class="lineCov">          9 : </span>
<span class="lineNum">    6724 </span><span class="lineCov">          9 :       /* If both sides are enum type, the default conversion will have</span>
<span class="lineNum">    6725 </span><span class="lineCov">          9 :          made the type of the result be an integer type.  We want to</span>
<span class="lineNum">    6726 </span><span class="lineCov">          9 :          remember the enum types we started with.  */</span>
<span class="lineNum">    6727 </span><span class="lineCov">          9 :       t1 = exp1.original_type ? exp1.original_type : TREE_TYPE (exp1.value);</span>
<span class="lineNum">    6728 </span>            :       t2 = exp2.original_type ? exp2.original_type : TREE_TYPE (exp2.value);
<span class="lineNum">    6729 </span><span class="lineCov">     234655 :       ret.original_type = ((t1 != error_mark_node</span>
<span class="lineNum">    6730 </span><span class="lineCov">     234655 :                             &amp;&amp; t2 != error_mark_node</span>
<span class="lineNum">    6731 </span><span class="lineCov">     234655 :                             &amp;&amp; (TYPE_MAIN_VARIANT (t1)</span>
<span class="lineNum">    6732 </span><span class="lineCov">     234655 :                                 == TYPE_MAIN_VARIANT (t2)))</span>
<span class="lineNum">    6733 </span>            :                            ? t1
<span class="lineNum">    6734 </span><span class="lineCov">     234655 :                            : NULL);</span>
<span class="lineNum">    6735 </span><span class="lineCov">     469310 :     }</span>
<span class="lineNum">    6736 </span><span class="lineCov">     469310 :   set_c_expr_source_range (&amp;ret, start, exp2.get_finish ());</span>
<span class="lineNum">    6737 </span><span class="lineCov">     703965 :   return ret;</span>
<span class="lineNum">    6738 </span><span class="lineCov">     234655 : }</span>
<span class="lineNum">    6739 </span>            : 
<span class="lineNum">    6740 </span>            : /* Parse a binary expression; that is, a logical-OR-expression (C90
<span class="lineNum">    6741 </span><span class="lineCov">     234655 :    6.3.5-6.3.14, C99 6.5.5-6.5.14, C11 6.5.5-6.5.14).  If AFTER is not</span>
<span class="lineNum">    6742 </span><span class="lineCov">     234655 :    NULL then it is an Objective-C message expression which is the</span>
<span class="lineNum">    6743 </span><span class="lineCov">          8 :    primary-expression starting the expression as an initializer.</span>
<span class="lineNum">    6744 </span>            : 
<span class="lineNum">    6745 </span>            :    OMP_ATOMIC_LHS is NULL, unless parsing OpenMP #pragma omp atomic,
<span class="lineNum">    6746 </span><span class="lineCov">     234647 :    when it should be the unfolded lhs.  In a valid OpenMP source,</span>
<span class="lineNum">    6747 </span>            :    one of the operands of the toplevel binary expression must be equal
<span class="lineNum">    6748 </span>            :    to it.  In that case, just return a build2 created binary operation
<span class="lineNum">    6749 </span>            :    rather than result of parser_build_binary_op.
<span class="lineNum">    6750 </span>            : 
<span class="lineNum">    6751 </span><span class="lineCov">     234647 :    multiplicative-expression:</span>
<span class="lineNum">    6752 </span><span class="lineCov">     234647 :      cast-expression</span>
<span class="lineNum">    6753 </span><span class="lineCov">     234647 :      multiplicative-expression * cast-expression</span>
<span class="lineNum">    6754 </span><span class="lineCov">     234647 :      multiplicative-expression / cast-expression</span>
<span class="lineNum">    6755 </span><span class="lineCov">     234647 :      multiplicative-expression % cast-expression</span>
<span class="lineNum">    6756 </span><span class="lineCov">     234647 : </span>
<span class="lineNum">    6757 </span><span class="lineCov">     234647 :    additive-expression:</span>
<span class="lineNum">    6758 </span>            :      multiplicative-expression
<span class="lineNum">    6759 </span>            :      additive-expression + multiplicative-expression
<span class="lineNum">    6760 </span><span class="lineCov">     469310 :      additive-expression - multiplicative-expression</span>
<span class="lineNum">    6761 </span><span class="lineCov">     234655 : </span>
<span class="lineNum">    6762 </span>            :    shift-expression:
<span class="lineNum">    6763 </span>            :      additive-expression
<span class="lineNum">    6764 </span>            :      shift-expression &lt;&lt; additive-expression
<span class="lineNum">    6765 </span>            :      shift-expression &gt;&gt; additive-expression
<span class="lineNum">    6766 </span>            : 
<span class="lineNum">    6767 </span>            :    relational-expression:
<span class="lineNum">    6768 </span>            :      shift-expression
<span class="lineNum">    6769 </span>            :      relational-expression &lt; shift-expression
<span class="lineNum">    6770 </span>            :      relational-expression &gt; shift-expression
<span class="lineNum">    6771 </span>            :      relational-expression &lt;= shift-expression
<span class="lineNum">    6772 </span>            :      relational-expression &gt;= shift-expression
<span class="lineNum">    6773 </span>            : 
<span class="lineNum">    6774 </span>            :    equality-expression:
<span class="lineNum">    6775 </span>            :      relational-expression
<span class="lineNum">    6776 </span>            :      equality-expression == relational-expression
<span class="lineNum">    6777 </span>            :      equality-expression != relational-expression
<span class="lineNum">    6778 </span>            : 
<span class="lineNum">    6779 </span>            :    AND-expression:
<span class="lineNum">    6780 </span>            :      equality-expression
<span class="lineNum">    6781 </span>            :      AND-expression &amp; equality-expression
<span class="lineNum">    6782 </span>            : 
<span class="lineNum">    6783 </span>            :    exclusive-OR-expression:
<span class="lineNum">    6784 </span>            :      AND-expression
<span class="lineNum">    6785 </span>            :      exclusive-OR-expression ^ AND-expression
<span class="lineNum">    6786 </span>            : 
<span class="lineNum">    6787 </span>            :    inclusive-OR-expression:
<span class="lineNum">    6788 </span>            :      exclusive-OR-expression
<span class="lineNum">    6789 </span>            :      inclusive-OR-expression | exclusive-OR-expression
<span class="lineNum">    6790 </span>            : 
<span class="lineNum">    6791 </span>            :    logical-AND-expression:
<span class="lineNum">    6792 </span>            :      inclusive-OR-expression
<span class="lineNum">    6793 </span>            :      logical-AND-expression &amp;&amp; inclusive-OR-expression
<span class="lineNum">    6794 </span>            : 
<span class="lineNum">    6795 </span>            :    logical-OR-expression:
<span class="lineNum">    6796 </span>            :      logical-AND-expression
<span class="lineNum">    6797 </span>            :      logical-OR-expression || logical-AND-expression
<span class="lineNum">    6798 </span>            : */
<a name="6799"><span class="lineNum">    6799 </span>            : </a>
<span class="lineNum">    6800 </span>            : static struct c_expr
<span class="lineNum">    6801 </span>            : c_parser_binary_expression (c_parser *parser, struct c_expr *after,
<span class="lineNum">    6802 </span>            :                             tree omp_atomic_lhs)
<span class="lineNum">    6803 </span>            : {
<span class="lineNum">    6804 </span>            :   /* A binary expression is parsed using operator-precedence parsing,
<span class="lineNum">    6805 </span>            :      with the operands being cast expressions.  All the binary
<span class="lineNum">    6806 </span>            :      operators are left-associative.  Thus a binary expression is of
<span class="lineNum">    6807 </span>            :      form:
<span class="lineNum">    6808 </span>            : 
<span class="lineNum">    6809 </span>            :      E0 op1 E1 op2 E2 ...
<span class="lineNum">    6810 </span>            : 
<span class="lineNum">    6811 </span>            :      which we represent on a stack.  On the stack, the precedence
<span class="lineNum">    6812 </span>            :      levels are strictly increasing.  When a new operator is
<span class="lineNum">    6813 </span>            :      encountered of higher precedence than that at the top of the
<span class="lineNum">    6814 </span>            :      stack, it is pushed; its LHS is the top expression, and its RHS
<span class="lineNum">    6815 </span>            :      is everything parsed until it is popped.  When a new operator is
<span class="lineNum">    6816 </span>            :      encountered with precedence less than or equal to that at the top
<span class="lineNum">    6817 </span>            :      of the stack, triples E[i-1] op[i] E[i] are popped and replaced
<span class="lineNum">    6818 </span>            :      by the result of the operation until the operator at the top of
<span class="lineNum">    6819 </span>            :      the stack has lower precedence than the new operator or there is
<span class="lineNum">    6820 </span>            :      only one element on the stack; then the top expression is the LHS
<span class="lineNum">    6821 </span>            :      of the new operator.  In the case of logical AND and OR
<span class="lineNum">    6822 </span>            :      expressions, we also need to adjust c_inhibit_evaluation_warnings
<span class="lineNum">    6823 </span>            :      as appropriate when the operators are pushed and popped.  */
<span class="lineNum">    6824 </span>            : 
<span class="lineNum">    6825 </span><span class="lineCov">  107517139 :   struct {</span>
<span class="lineNum">    6826 </span>            :     /* The expression at this stack level.  */
<span class="lineNum">    6827 </span>            :     struct c_expr expr;
<span class="lineNum">    6828 </span>            :     /* The precedence of the operator on its left, PREC_NONE at the
<span class="lineNum">    6829 </span>            :        bottom of the stack.  */
<span class="lineNum">    6830 </span>            :     enum c_parser_prec prec;
<span class="lineNum">    6831 </span>            :     /* The operation on its left.  */
<span class="lineNum">    6832 </span>            :     enum tree_code op;
<span class="lineNum">    6833 </span>            :     /* The source location of this operation.  */
<span class="lineNum">    6834 </span>            :     location_t loc;
<span class="lineNum">    6835 </span>            :     /* The sizeof argument if expr.original_code == SIZEOF_EXPR.  */
<span class="lineNum">    6836 </span>            :     tree sizeof_arg;
<span class="lineNum">    6837 </span>            :   } stack[NUM_PRECS];
<span class="lineNum">    6838 </span>            :   int sp;
<span class="lineNum">    6839 </span>            :   /* Location of the binary operator.  */
<span class="lineNum">    6840 </span>            :   location_t binary_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */
<span class="lineNum">    6841 </span>            : #define POP                                                                   \
<span class="lineNum">    6842 </span>            :   do {                                                                        \
<span class="lineNum">    6843 </span>            :     switch (stack[sp].op)                                                     \
<span class="lineNum">    6844 </span>            :       {                                                                       \
<span class="lineNum">    6845 </span>            :       case TRUTH_ANDIF_EXPR:                                                  \
<span class="lineNum">    6846 </span>            :         c_inhibit_evaluation_warnings -= (stack[sp - 1].expr.value            \
<span class="lineNum">    6847 </span>            :                                           == truthvalue_false_node);          \
<span class="lineNum">    6848 </span>            :         break;                                                                \
<span class="lineNum">    6849 </span><span class="lineCov">  107517139 :       case TRUTH_ORIF_EXPR:                                                   \</span>
<span class="lineNum">    6850 </span>            :         c_inhibit_evaluation_warnings -= (stack[sp - 1].expr.value            \
<span class="lineNum">    6851 </span>            :                                           == truthvalue_true_node);           \
<span class="lineNum">    6852 </span>            :         break;                                                                \
<span class="lineNum">    6853 </span>            :       case TRUNC_DIV_EXPR:                                                    \
<span class="lineNum">    6854 </span>            :         if (stack[sp - 1].expr.original_code == SIZEOF_EXPR                   \
<span class="lineNum">    6855 </span>            :             &amp;&amp; stack[sp].expr.original_code == SIZEOF_EXPR)                   \
<span class="lineNum">    6856 </span>            :           {                                                                   \
<span class="lineNum">    6857 </span>            :             tree type0 = stack[sp - 1].sizeof_arg;                            \
<span class="lineNum">    6858 </span>            :             tree type1 = stack[sp].sizeof_arg;                                \
<span class="lineNum">    6859 </span>            :             tree first_arg = type0;                                           \
<span class="lineNum">    6860 </span>            :             if (!TYPE_P (type0))                                              \
<span class="lineNum">    6861 </span>            :               type0 = TREE_TYPE (type0);                                      \
<span class="lineNum">    6862 </span><span class="lineCov">  107517139 :             if (!TYPE_P (type1))                                              \</span>
<span class="lineNum">    6863 </span>            :               type1 = TREE_TYPE (type1);                                      \
<span class="lineNum">    6864 </span><span class="lineCov">  107517139 :             if (POINTER_TYPE_P (type0)                                        \</span>
<span class="lineNum">    6865 </span>            :                 &amp;&amp; comptypes (TREE_TYPE (type0), type1)                       \
<span class="lineNum">    6866 </span>            :                 &amp;&amp; !(TREE_CODE (first_arg) == PARM_DECL                       \
<span class="lineNum">    6867 </span>            :                      &amp;&amp; C_ARRAY_PARAMETER (first_arg)                         \
<span class="lineNum">    6868 </span>            :                      &amp;&amp; warn_sizeof_array_argument))                          \
<span class="lineNum">    6869 </span>            :               {                                                         \
<span class="lineNum">    6870 </span>            :                 auto_diagnostic_group d;                                        \
<span class="lineNum">    6871 </span>            :                 if (warning_at (stack[sp].loc, OPT_Wsizeof_pointer_div, \
<span class="lineNum">    6872 </span>            :                                   &quot;division %&lt;sizeof (%T) / sizeof (%T)%&gt; &quot; \
<span class="lineNum">    6873 </span>            :                                   &quot;does not compute the number of array &quot; \
<span class="lineNum">    6874 </span>            :                                   &quot;elements&quot;,                         \
<span class="lineNum">    6875 </span>            :                                   type0, type1))                        \
<span class="lineNum">    6876 </span>            :                   if (DECL_P (first_arg))                               \
<span class="lineNum">    6877 </span>            :                     inform (DECL_SOURCE_LOCATION (first_arg),           \
<span class="lineNum">    6878 </span>            :                               &quot;first %&lt;sizeof%&gt; operand was declared here&quot;); \
<span class="lineNum">    6879 </span>            :               }                                                         \
<span class="lineNum">    6880 </span>            :           }                                                             \
<span class="lineNum">    6881 </span>            :         break;                                                                \
<span class="lineNum">    6882 </span>            :       default:                                                                \
<span class="lineNum">    6883 </span>            :         break;                                                                \
<span class="lineNum">    6884 </span>            :       }                                                                       \
<span class="lineNum">    6885 </span>            :     stack[sp - 1].expr                                                        \
<span class="lineNum">    6886 </span>            :       = convert_lvalue_to_rvalue (stack[sp - 1].loc,                          \
<span class="lineNum">    6887 </span>            :                                   stack[sp - 1].expr, true, true);            \
<span class="lineNum">    6888 </span>            :     stack[sp].expr                                                            \
<span class="lineNum">    6889 </span>            :       = convert_lvalue_to_rvalue (stack[sp].loc,                              \
<span class="lineNum">    6890 </span>            :                                   stack[sp].expr, true, true);                \
<span class="lineNum">    6891 </span>            :     if (__builtin_expect (omp_atomic_lhs != NULL_TREE, 0) &amp;&amp; sp == 1          \
<span class="lineNum">    6892 </span>            :         &amp;&amp; c_parser_peek_token (parser)-&gt;type == CPP_SEMICOLON                     \
<span class="lineNum">    6893 </span>            :         &amp;&amp; ((1 &lt;&lt; stack[sp].prec)                                       \
<span class="lineNum">    6894 </span>            :             &amp; ((1 &lt;&lt; PREC_BITOR) | (1 &lt;&lt; PREC_BITXOR) | (1 &lt;&lt; PREC_BITAND)    \
<span class="lineNum">    6895 </span>            :                | (1 &lt;&lt; PREC_SHIFT) | (1 &lt;&lt; PREC_ADD) | (1 &lt;&lt; PREC_MULT)))     \
<span class="lineNum">    6896 </span>            :         &amp;&amp; stack[sp].op != TRUNC_MOD_EXPR                                     \
<span class="lineNum">    6897 </span>            :         &amp;&amp; stack[0].expr.value != error_mark_node                             \
<span class="lineNum">    6898 </span>            :         &amp;&amp; stack[1].expr.value != error_mark_node                             \
<span class="lineNum">    6899 </span>            :         &amp;&amp; (c_tree_equal (stack[0].expr.value, omp_atomic_lhs)                \
<span class="lineNum">    6900 </span>            :             || c_tree_equal (stack[1].expr.value, omp_atomic_lhs)))           \
<span class="lineNum">    6901 </span>            :       stack[0].expr.value                                                     \
<span class="lineNum">    6902 </span>            :         = build2 (stack[1].op, TREE_TYPE (stack[0].expr.value),               \
<span class="lineNum">    6903 </span>            :                   stack[0].expr.value, stack[1].expr.value);                  \
<span class="lineNum">    6904 </span>            :     else                                                                      \
<span class="lineNum">    6905 </span>            :       stack[sp - 1].expr = parser_build_binary_op (stack[sp].loc,             \
<span class="lineNum">    6906 </span>            :                                                    stack[sp].op,              \
<span class="lineNum">    6907 </span>            :                                                    stack[sp - 1].expr,        \
<span class="lineNum">    6908 </span>            :                                                    stack[sp].expr);           \
<span class="lineNum">    6909 </span>            :     sp--;                                                                     \
<span class="lineNum">    6910 </span>            :   } while (0)
<span class="lineNum">    6911 </span>            :   gcc_assert (!after || c_dialect_objc ());
<span class="lineNum">    6912 </span>            :   stack[0].loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    6913 </span>            :   stack[0].expr = c_parser_cast_expression (parser, after);
<span class="lineNum">    6914 </span>            :   stack[0].prec = PREC_NONE;
<span class="lineNum">    6915 </span>            :   stack[0].sizeof_arg = c_last_sizeof_arg;
<span class="lineNum">    6916 </span>            :   sp = 0;
<span class="lineNum">    6917 </span>            :   while (true)
<span class="lineNum">    6918 </span>            :     {
<span class="lineNum">    6919 </span>            :       enum c_parser_prec oprec;
<span class="lineNum">    6920 </span>            :       enum tree_code ocode;
<span class="lineNum">    6921 </span>            :       source_range src_range;
<span class="lineNum">    6922 </span>            :       if (parser-&gt;error)
<span class="lineNum">    6923 </span>            :         goto out;
<span class="lineNum">    6924 </span>            :       switch (c_parser_peek_token (parser)-&gt;type)
<span class="lineNum">    6925 </span>            :         {
<span class="lineNum">    6926 </span>            :         case CPP_MULT:
<span class="lineNum">    6927 </span>            :           oprec = PREC_MULT;
<span class="lineNum">    6928 </span>            :           ocode = MULT_EXPR;
<span class="lineNum">    6929 </span>            :           break;
<span class="lineNum">    6930 </span>            :         case CPP_DIV:
<span class="lineNum">    6931 </span>            :           oprec = PREC_MULT;
<span class="lineNum">    6932 </span>            :           ocode = TRUNC_DIV_EXPR;
<span class="lineNum">    6933 </span>            :           break;
<span class="lineNum">    6934 </span>            :         case CPP_MOD:
<span class="lineNum">    6935 </span><span class="lineCov">  107517139 :           oprec = PREC_MULT;</span>
<span class="lineNum">    6936 </span><span class="lineCov">  107517139 :           ocode = TRUNC_MOD_EXPR;</span>
<span class="lineNum">    6937 </span><span class="lineCov">  107517139 :           break;</span>
<span class="lineNum">    6938 </span><span class="lineCov">  107517139 :         case CPP_PLUS:</span>
<span class="lineNum">    6939 </span><span class="lineCov">  107517139 :           oprec = PREC_ADD;</span>
<span class="lineNum">    6940 </span><span class="lineCov">  107517139 :           ocode = PLUS_EXPR;</span>
<span class="lineNum">    6941 </span><span class="lineCov">  113163740 :           break;</span>
<span class="lineNum">    6942 </span>            :         case CPP_MINUS:
<span class="lineNum">    6943 </span><span class="lineCov">  113163740 :           oprec = PREC_ADD;</span>
<span class="lineNum">    6944 </span><span class="lineCov">  113163740 :           ocode = MINUS_EXPR;</span>
<span class="lineNum">    6945 </span><span class="lineCov">  113163740 :           break;</span>
<span class="lineNum">    6946 </span><span class="lineCov">  113163740 :         case CPP_LSHIFT:</span>
<span class="lineNum">    6947 </span><span class="lineCov">  107517139 :           oprec = PREC_SHIFT;</span>
<span class="lineNum">    6948 </span><span class="lineCov">  113163048 :           ocode = LSHIFT_EXPR;</span>
<span class="lineNum">    6949 </span>            :           break;
<span class="lineNum">    6950 </span>            :         case CPP_RSHIFT:
<span class="lineNum">    6951 </span>            :           oprec = PREC_SHIFT;
<span class="lineNum">    6952 </span>            :           ocode = RSHIFT_EXPR;
<span class="lineNum">    6953 </span>            :           break;
<span class="lineNum">    6954 </span><span class="lineCov">     192977 :         case CPP_LESS:</span>
<span class="lineNum">    6955 </span><span class="lineCov">     192977 :           oprec = PREC_REL;</span>
<span class="lineNum">    6956 </span><span class="lineCov">     192977 :           ocode = LT_EXPR;</span>
<span class="lineNum">    6957 </span><span class="lineCov">     192977 :           break;</span>
<span class="lineNum">    6958 </span><span class="lineCov">      39073 :         case CPP_GREATER:</span>
<span class="lineNum">    6959 </span><span class="lineCov">      39073 :           oprec = PREC_REL;</span>
<span class="lineNum">    6960 </span><span class="lineCov">      39073 :           ocode = GT_EXPR;</span>
<span class="lineNum">    6961 </span><span class="lineCov">      39073 :           break;</span>
<span class="lineNum">    6962 </span><span class="lineCov">     911130 :         case CPP_LESS_EQ:</span>
<span class="lineNum">    6963 </span><span class="lineCov">     911130 :           oprec = PREC_REL;</span>
<span class="lineNum">    6964 </span><span class="lineCov">     911130 :           ocode = LE_EXPR;</span>
<span class="lineNum">    6965 </span><span class="lineCov">     911130 :           break;</span>
<span class="lineNum">    6966 </span><span class="lineCov">     561382 :         case CPP_GREATER_EQ:</span>
<span class="lineNum">    6967 </span><span class="lineCov">     561382 :           oprec = PREC_REL;</span>
<span class="lineNum">    6968 </span><span class="lineCov">     561382 :           ocode = GE_EXPR;</span>
<span class="lineNum">    6969 </span><span class="lineCov">     561382 :           break;</span>
<span class="lineNum">    6970 </span><span class="lineCov">     436904 :         case CPP_EQ_EQ:</span>
<span class="lineNum">    6971 </span><span class="lineCov">     436904 :           oprec = PREC_EQ;</span>
<span class="lineNum">    6972 </span><span class="lineCov">     436904 :           ocode = EQ_EXPR;</span>
<span class="lineNum">    6973 </span><span class="lineCov">     436904 :           break;</span>
<span class="lineNum">    6974 </span><span class="lineCov">     145086 :         case CPP_NOT_EQ:</span>
<span class="lineNum">    6975 </span><span class="lineCov">     145086 :           oprec = PREC_EQ;</span>
<span class="lineNum">    6976 </span><span class="lineCov">     145086 :           ocode = NE_EXPR;</span>
<span class="lineNum">    6977 </span><span class="lineCov">     145086 :           break;</span>
<span class="lineNum">    6978 </span><span class="lineCov">     327583 :         case CPP_AND:</span>
<span class="lineNum">    6979 </span><span class="lineCov">     327583 :           oprec = PREC_BITAND;</span>
<span class="lineNum">    6980 </span><span class="lineCov">     327583 :           ocode = BIT_AND_EXPR;</span>
<span class="lineNum">    6981 </span><span class="lineCov">     327583 :           break;</span>
<span class="lineNum">    6982 </span><span class="lineCov">     147774 :         case CPP_XOR:</span>
<span class="lineNum">    6983 </span><span class="lineCov">     147774 :           oprec = PREC_BITXOR;</span>
<span class="lineNum">    6984 </span><span class="lineCov">     147774 :           ocode = BIT_XOR_EXPR;</span>
<span class="lineNum">    6985 </span><span class="lineCov">     147774 :           break;</span>
<span class="lineNum">    6986 </span><span class="lineCov">      96586 :         case CPP_OR:</span>
<span class="lineNum">    6987 </span><span class="lineCov">      96586 :           oprec = PREC_BITOR;</span>
<span class="lineNum">    6988 </span><span class="lineCov">      96586 :           ocode = BIT_IOR_EXPR;</span>
<span class="lineNum">    6989 </span><span class="lineCov">      96586 :           break;</span>
<span class="lineNum">    6990 </span><span class="lineCov">     128956 :         case CPP_AND_AND:</span>
<span class="lineNum">    6991 </span><span class="lineCov">     128956 :           oprec = PREC_LOGAND;</span>
<span class="lineNum">    6992 </span><span class="lineCov">     128956 :           ocode = TRUTH_ANDIF_EXPR;</span>
<span class="lineNum">    6993 </span><span class="lineCov">     128956 :           break;</span>
<span class="lineNum">    6994 </span><span class="lineCov">     258352 :         case CPP_OR_OR:</span>
<span class="lineNum">    6995 </span><span class="lineCov">     258352 :           oprec = PREC_LOGOR;</span>
<span class="lineNum">    6996 </span><span class="lineCov">     258352 :           ocode = TRUTH_ORIF_EXPR;</span>
<span class="lineNum">    6997 </span><span class="lineCov">     258352 :           break;</span>
<span class="lineNum">    6998 </span><span class="lineCov">     632991 :         default:</span>
<span class="lineNum">    6999 </span><span class="lineCov">     632991 :           /* Not a binary operator, so end of the binary</span>
<span class="lineNum">    7000 </span><span class="lineCov">     632991 :              expression.  */</span>
<span class="lineNum">    7001 </span><span class="lineCov">     632991 :           goto out;</span>
<span class="lineNum">    7002 </span><span class="lineCov">     339516 :         }</span>
<span class="lineNum">    7003 </span><span class="lineCov">     339516 :       binary_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7004 </span><span class="lineCov">     339516 :       while (oprec &lt;= stack[sp].prec)</span>
<span class="lineNum">    7005 </span><span class="lineCov">     339516 :         POP;</span>
<span class="lineNum">    7006 </span><span class="lineCov">      31793 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    7007 </span><span class="lineCov">      31793 :       switch (ocode)</span>
<span class="lineNum">    7008 </span><span class="lineCov">      31793 :         {</span>
<span class="lineNum">    7009 </span><span class="lineCov">      31793 :         case TRUTH_ANDIF_EXPR:</span>
<span class="lineNum">    7010 </span><span class="lineCov">     350742 :           src_range = stack[sp].expr.src_range;</span>
<span class="lineNum">    7011 </span><span class="lineCov">     350742 :           stack[sp].expr</span>
<span class="lineNum">    7012 </span><span class="lineCov">     350742 :             = convert_lvalue_to_rvalue (stack[sp].loc,</span>
<span class="lineNum">    7013 </span><span class="lineCov">     350742 :                                         stack[sp].expr, true, true);</span>
<span class="lineNum">    7014 </span><span class="lineCov">     122431 :           stack[sp].expr.value = c_objc_common_truthvalue_conversion</span>
<span class="lineNum">    7015 </span><span class="lineCov">     122431 :             (stack[sp].loc, default_conversion (stack[sp].expr.value));</span>
<span class="lineNum">    7016 </span><span class="lineCov">     122431 :           c_inhibit_evaluation_warnings += (stack[sp].expr.value</span>
<span class="lineNum">    7017 </span><span class="lineCov">     122431 :                                             == truthvalue_false_node);</span>
<span class="lineNum">    7018 </span><span class="lineCov">     258766 :           set_c_expr_source_range (&amp;stack[sp].expr, src_range);</span>
<span class="lineNum">    7019 </span><span class="lineCov">     258766 :           break;</span>
<span class="lineNum">    7020 </span><span class="lineCov">     258766 :         case TRUTH_ORIF_EXPR:</span>
<span class="lineNum">    7021 </span><span class="lineCov">     258766 :           src_range = stack[sp].expr.src_range;</span>
<span class="lineNum">    7022 </span><span class="lineCov">  107516447 :           stack[sp].expr</span>
<span class="lineNum">    7023 </span>            :             = convert_lvalue_to_rvalue (stack[sp].loc,
<span class="lineNum">    7024 </span>            :                                         stack[sp].expr, true, true);
<span class="lineNum">    7025 </span><span class="lineCov">  107516447 :           stack[sp].expr.value = c_objc_common_truthvalue_conversion</span>
<span class="lineNum">    7026 </span>            :             (stack[sp].loc, default_conversion (stack[sp].expr.value));
<span class="lineNum">    7027 </span><span class="lineCov">    5646601 :           c_inhibit_evaluation_warnings += (stack[sp].expr.value</span>
<span class="lineNum">    7028 </span><span class="lineCov">    6570830 :                                             == truthvalue_true_node);</span>
<span class="lineNum">    7029 </span><span class="lineCov">     924229 :           set_c_expr_source_range (&amp;stack[sp].expr, src_range);</span>
<span class="lineNum">    7030 </span><span class="lineCov">    5646601 :           break;</span>
<span class="lineNum">    7031 </span><span class="lineCov">    5646601 :         default:</span>
<span class="lineNum">    7032 </span>            :           break;
<span class="lineNum">    7033 </span><span class="lineCov">     122431 :         }</span>
<span class="lineNum">    7034 </span><span class="lineCov">     122431 :       sp++;</span>
<span class="lineNum">    7035 </span><span class="lineCov">     122431 :       stack[sp].loc = binary_loc;</span>
<span class="lineNum">    7036 </span>            :       stack[sp].expr = c_parser_cast_expression (parser, NULL);
<span class="lineNum">    7037 </span><span class="lineCov">     122431 :       stack[sp].prec = oprec;</span>
<span class="lineNum">    7038 </span><span class="lineCov">     244862 :       stack[sp].op = ocode;</span>
<span class="lineNum">    7039 </span><span class="lineCov">     122431 :       stack[sp].sizeof_arg = c_last_sizeof_arg;</span>
<span class="lineNum">    7040 </span><span class="lineCov">     244862 :     }</span>
<span class="lineNum">    7041 </span><span class="lineCov">     122431 :  out:</span>
<span class="lineNum">    7042 </span><span class="lineCov">     122431 :   while (sp &gt; 0)</span>
<span class="lineNum">    7043 </span><span class="lineCov">     122431 :     POP;</span>
<span class="lineNum">    7044 </span><span class="lineCov">     258766 :   return stack[0].expr;</span>
<span class="lineNum">    7045 </span><span class="lineCov">     258766 : #undef POP</span>
<span class="lineNum">    7046 </span><span class="lineCov">     258766 : }</span>
<span class="lineNum">    7047 </span>            : 
<span class="lineNum">    7048 </span><span class="lineCov">     258766 : /* Parse a cast expression (C90 6.3.4, C99 6.5.4, C11 6.5.4).  If AFTER</span>
<span class="lineNum">    7049 </span><span class="lineCov">     517532 :    is not NULL then it is an Objective-C message expression which is the</span>
<span class="lineNum">    7050 </span><span class="lineCov">     258766 :    primary-expression starting the expression as an initializer.</span>
<span class="lineNum">    7051 </span><span class="lineCov">     517532 : </span>
<span class="lineNum">    7052 </span><span class="lineCov">     258766 :    cast-expression:</span>
<span class="lineNum">    7053 </span><span class="lineCov">     258766 :      unary-expression</span>
<span class="lineNum">    7054 </span><span class="lineCov">     258766 :      ( type-name ) unary-expression</span>
<span class="lineNum">    7055 </span>            : */
<a name="7056"><span class="lineNum">    7056 </span>            : </a>
<span class="lineNum">    7057 </span>            : static struct c_expr
<span class="lineNum">    7058 </span><span class="lineCov">    5646601 : c_parser_cast_expression (c_parser *parser, struct c_expr *after)</span>
<span class="lineNum">    7059 </span><span class="lineCov">    5646601 : {</span>
<span class="lineNum">    7060 </span><span class="lineCov">    5646601 :   location_t cast_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7061 </span><span class="lineCov">    5646601 :   gcc_assert (!after || c_dialect_objc ());</span>
<span class="lineNum">    7062 </span><span class="lineCov">    5646601 :   if (after)</span>
<span class="lineNum">    7063 </span><span class="lineCov">    5646601 :     return c_parser_postfix_expression_after_primary (parser,</span>
<span class="lineNum">    7064 </span><span class="lineCov">    5646601 :                                                       cast_loc, *after);</span>
<span class="lineNum">    7065 </span><span class="lineCov">    4722370 :   /* If the expression begins with a parenthesized type name, it may</span>
<span class="lineNum">    7066 </span><span class="lineCov">  112239509 :      be either a cast or a compound literal; we need to see whether</span>
<span class="lineNum">    7067 </span><span class="lineCov">    4722378 :      the next character is '{' to tell the difference.  If not, it is</span>
<span class="lineNum">    7068 </span><span class="lineCov">  107517137 :      an unary expression.  Full detection of unknown typenames here</span>
<span class="lineNum">    7069 </span>            :      would require a 3-token lookahead.  */
<span class="lineNum">    7070 </span>            :   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)
<span class="lineNum">    7071 </span>            :       &amp;&amp; c_token_starts_typename (c_parser_peek_2nd_token (parser)))
<span class="lineNum">    7072 </span>            :     {
<span class="lineNum">    7073 </span>            :       struct c_type_name *type_name;
<span class="lineNum">    7074 </span>            :       struct c_expr ret;
<span class="lineNum">    7075 </span>            :       struct c_expr expr;
<span class="lineNum">    7076 </span>            :       matching_parens parens;
<span class="lineNum">    7077 </span>            :       parens.consume_open (parser);
<span class="lineNum">    7078 </span>            :       type_name = c_parser_type_name (parser, true);
<span class="lineNum">    7079 </span>            :       parens.skip_until_found_close (parser);
<span class="lineNum">    7080 </span>            :       if (type_name == NULL)
<span class="lineNum">    7081 </span>            :         {
<span class="lineNum">    7082 </span><span class="lineCov">  181883416 :           ret.set_error ();</span>
<span class="lineNum">    7083 </span>            :           ret.original_code = ERROR_MARK;
<span class="lineNum">    7084 </span><span class="lineCov">  181883416 :           ret.original_type = NULL;</span>
<span class="lineNum">    7085 </span><span class="lineCov">  181883416 :           return ret;</span>
<span class="lineNum">    7086 </span><span class="lineCov">  181883416 :         }</span>
<span class="lineNum">    7087 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    7088 </span><span class="lineNoCov">          0 :       /* Save casted types in the function's used types hash table.  */</span>
<span class="lineNum">    7089 </span>            :       used_types_insert (type_name-&gt;specs-&gt;type);
<span class="lineNum">    7090 </span>            : 
<span class="lineNum">    7091 </span>            :       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))
<span class="lineNum">    7092 </span>            :         return c_parser_postfix_expression_after_paren_type (parser, type_name,
<span class="lineNum">    7093 </span>            :                                                              cast_loc);
<span class="lineNum">    7094 </span><span class="lineCov">  181883416 :       if (type_name-&gt;specs-&gt;alignas_p)</span>
<span class="lineNum">    7095 </span><span class="lineCov">  181883416 :         error_at (type_name-&gt;specs-&gt;locations[cdw_alignas],</span>
<span class="lineNum">    7096 </span>            :                   &quot;alignment specified for type name in cast&quot;);
<span class="lineNum">    7097 </span><span class="lineCov">   64185529 :       {</span>
<span class="lineNum">    7098 </span><span class="lineCov">   64185529 :         location_t expr_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7099 </span><span class="lineCov">   64185529 :         expr = c_parser_cast_expression (parser, NULL);</span>
<span class="lineNum">    7100 </span><span class="lineCov">  128371058 :         expr = convert_lvalue_to_rvalue (expr_loc, expr, true, true);</span>
<span class="lineNum">    7101 </span><span class="lineCov">   64185529 :       }</span>
<span class="lineNum">    7102 </span><span class="lineCov">   64185529 :       ret.value = c_cast_expr (cast_loc, type_name, expr.value);</span>
<span class="lineNum">    7103 </span><span class="lineCov">   64185529 :       if (ret.value &amp;&amp; expr.value)</span>
<span class="lineNum">    7104 </span><span class="lineCov">   64185529 :         set_c_expr_source_range (&amp;ret, cast_loc, expr.get_finish ());</span>
<span class="lineNum">    7105 </span>            :       ret.original_code = ERROR_MARK;
<span class="lineNum">    7106 </span><span class="lineCov">          1 :       ret.original_type = NULL;</span>
<span class="lineNum">    7107 </span><span class="lineCov">          1 :       return ret;</span>
<span class="lineNum">    7108 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">    7109 </span><span class="lineCov">          1 :   else</span>
<span class="lineNum">    7110 </span>            :     return c_parser_unary_expression (parser);
<span class="lineNum">    7111 </span>            : }
<span class="lineNum">    7112 </span>            : 
<span class="lineNum">    7113 </span><span class="lineCov">   64185528 : /* Parse an unary expression (C90 6.3.3, C99 6.5.3, C11 6.5.3).</span>
<span class="lineNum">    7114 </span>            : 
<span class="lineNum">    7115 </span><span class="lineCov">   64185528 :    unary-expression:</span>
<span class="lineNum">    7116 </span><span class="lineCov">     435270 :      postfix-expression</span>
<span class="lineNum">    7117 </span><span class="lineCov">     435270 :      ++ unary-expression</span>
<span class="lineNum">    7118 </span><span class="lineCov">   63750258 :      -- unary-expression</span>
<span class="lineNum">    7119 </span><span class="lineCov">          1 :      unary-operator cast-expression</span>
<span class="lineNum">    7120 </span>            :      sizeof unary-expression
<span class="lineNum">    7121 </span><span class="lineCov">   63750258 :      sizeof ( type-name )</span>
<span class="lineNum">    7122 </span><span class="lineCov">   63750258 : </span>
<span class="lineNum">    7123 </span><span class="lineCov">   63750258 :    unary-operator: one of</span>
<span class="lineNum">    7124 </span><span class="lineCov">   63750258 :      &amp; * + - ~ !</span>
<span class="lineNum">    7125 </span>            : 
<span class="lineNum">    7126 </span><span class="lineCov">   63750258 :    GNU extensions:</span>
<span class="lineNum">    7127 </span><span class="lineCov">   63750258 : </span>
<span class="lineNum">    7128 </span><span class="lineCov">  127500516 :    unary-expression:</span>
<span class="lineNum">    7129 </span><span class="lineCov">   63750258 :      __alignof__ unary-expression</span>
<span class="lineNum">    7130 </span><span class="lineCov">   63750258 :      __alignof__ ( type-name )</span>
<span class="lineNum">    7131 </span><span class="lineCov">   63750258 :      &amp;&amp; identifier</span>
<span class="lineNum">    7132 </span>            : 
<span class="lineNum">    7133 </span>            :    (C11 permits _Alignof with type names only.)
<span class="lineNum">    7134 </span><span class="lineCov">  117697887 : </span>
<span class="lineNum">    7135 </span>            :    unary-operator: one of
<span class="lineNum">    7136 </span>            :      __extension__ __real__ __imag__
<span class="lineNum">    7137 </span>            : 
<span class="lineNum">    7138 </span>            :    Transactional Memory:
<span class="lineNum">    7139 </span>            : 
<span class="lineNum">    7140 </span>            :    unary-expression:
<span class="lineNum">    7141 </span>            :      transaction-expression
<span class="lineNum">    7142 </span>            : 
<span class="lineNum">    7143 </span>            :    In addition, the GNU syntax treats ++ and -- as unary operators, so
<span class="lineNum">    7144 </span>            :    they may be applied to cast expressions with errors for non-lvalues
<span class="lineNum">    7145 </span>            :    given later.  */
<a name="7146"><span class="lineNum">    7146 </span>            : </a>
<span class="lineNum">    7147 </span>            : static struct c_expr
<span class="lineNum">    7148 </span>            : c_parser_unary_expression (c_parser *parser)
<span class="lineNum">    7149 </span>            : {
<span class="lineNum">    7150 </span>            :   int ext;
<span class="lineNum">    7151 </span>            :   struct c_expr ret, op;
<span class="lineNum">    7152 </span>            :   location_t op_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    7153 </span>            :   location_t exp_loc;
<span class="lineNum">    7154 </span>            :   location_t finish;
<span class="lineNum">    7155 </span>            :   ret.original_code = ERROR_MARK;
<span class="lineNum">    7156 </span>            :   ret.original_type = NULL;
<span class="lineNum">    7157 </span>            :   switch (c_parser_peek_token (parser)-&gt;type)
<span class="lineNum">    7158 </span>            :     {
<span class="lineNum">    7159 </span>            :     case CPP_PLUS_PLUS:
<span class="lineNum">    7160 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    7161 </span>            :       exp_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    7162 </span>            :       op = c_parser_cast_expression (parser, NULL);
<span class="lineNum">    7163 </span>            : 
<span class="lineNum">    7164 </span>            :       op = default_function_array_read_conversion (exp_loc, op);
<span class="lineNum">    7165 </span>            :       return parser_build_unary_op (op_loc, PREINCREMENT_EXPR, op);
<span class="lineNum">    7166 </span>            :     case CPP_MINUS_MINUS:
<span class="lineNum">    7167 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    7168 </span>            :       exp_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    7169 </span>            :       op = c_parser_cast_expression (parser, NULL);
<span class="lineNum">    7170 </span>            :       
<span class="lineNum">    7171 </span>            :       op = default_function_array_read_conversion (exp_loc, op);
<span class="lineNum">    7172 </span><span class="lineCov">  117970160 :       return parser_build_unary_op (op_loc, PREDECREMENT_EXPR, op);</span>
<span class="lineNum">    7173 </span>            :     case CPP_AND:
<span class="lineNum">    7174 </span><span class="lineCov">  117970160 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    7175 </span><span class="lineCov">  117970160 :       op = c_parser_cast_expression (parser, NULL);</span>
<span class="lineNum">    7176 </span><span class="lineCov">  117970160 :       mark_exp_read (op.value);</span>
<span class="lineNum">    7177 </span><span class="lineCov">  117970160 :       return parser_build_unary_op (op_loc, ADDR_EXPR, op);</span>
<span class="lineNum">    7178 </span><span class="lineCov">  117970160 :     case CPP_MULT:</span>
<span class="lineNum">    7179 </span><span class="lineCov">  117970160 :       {</span>
<span class="lineNum">    7180 </span><span class="lineCov">  117970160 :         c_parser_consume_token (parser);</span>
<span class="lineNum">    7181 </span><span class="lineCov">  117970160 :         exp_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7182 </span>            :         op = c_parser_cast_expression (parser, NULL);
<span class="lineNum">    7183 </span><span class="lineCov">     207502 :         finish = op.get_finish ();</span>
<span class="lineNum">    7184 </span><span class="lineCov">     207502 :         op = convert_lvalue_to_rvalue (exp_loc, op, true, true);</span>
<span class="lineNum">    7185 </span><span class="lineCov">     207502 :         location_t combined_loc = make_location (op_loc, op_loc, finish);</span>
<span class="lineNum">    7186 </span><span class="lineCov">     207502 :         ret.value = build_indirect_ref (combined_loc, op.value, RO_UNARY_STAR);</span>
<span class="lineNum">    7187 </span>            :         ret.src_range.m_start = op_loc;
<span class="lineNum">    7188 </span><span class="lineCov">     207502 :         ret.src_range.m_finish = finish;</span>
<span class="lineNum">    7189 </span><span class="lineCov">     207502 :         return ret;</span>
<span class="lineNum">    7190 </span><span class="lineCov">       4540 :       }</span>
<span class="lineNum">    7191 </span><span class="lineCov">       4540 :     case CPP_PLUS:</span>
<span class="lineNum">    7192 </span><span class="lineCov">       4540 :       if (!c_dialect_objc () &amp;&amp; !in_system_header_at (input_location))</span>
<span class="lineNum">    7193 </span><span class="lineCov">       4540 :         warning_at (op_loc,</span>
<span class="lineNum">    7194 </span>            :                     OPT_Wtraditional,
<span class="lineNum">    7195 </span><span class="lineCov">       4540 :                     &quot;traditional C rejects the unary plus operator&quot;);</span>
<span class="lineNum">    7196 </span><span class="lineCov">       4540 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    7197 </span><span class="lineCov">     301979 :       exp_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7198 </span><span class="lineCov">     301979 :       op = c_parser_cast_expression (parser, NULL);</span>
<span class="lineNum">    7199 </span><span class="lineCov">     301979 :       op = convert_lvalue_to_rvalue (exp_loc, op, true, true);</span>
<span class="lineNum">    7200 </span><span class="lineCov">     301979 :       return parser_build_unary_op (op_loc, CONVERT_EXPR, op);</span>
<span class="lineNum">    7201 </span><span class="lineCov">     301979 :     case CPP_MINUS:</span>
<span class="lineNum">    7202 </span><span class="lineCov">     444284 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    7203 </span><span class="lineCov">     444284 :       exp_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7204 </span><span class="lineCov">     444284 :       op = c_parser_cast_expression (parser, NULL);</span>
<span class="lineNum">    7205 </span><span class="lineCov">     444284 :       op = convert_lvalue_to_rvalue (exp_loc, op, true, true);</span>
<span class="lineNum">    7206 </span><span class="lineCov">     444284 :       return parser_build_unary_op (op_loc, NEGATE_EXPR, op);</span>
<span class="lineNum">    7207 </span><span class="lineCov">     444284 :     case CPP_COMPL:</span>
<span class="lineNum">    7208 </span><span class="lineCov">     444284 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    7209 </span><span class="lineCov">     444284 :       exp_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7210 </span><span class="lineCov">     444284 :       op = c_parser_cast_expression (parser, NULL);</span>
<span class="lineNum">    7211 </span><span class="lineCov">     444284 :       op = convert_lvalue_to_rvalue (exp_loc, op, true, true);</span>
<span class="lineNum">    7212 </span><span class="lineCov">     444284 :       return parser_build_unary_op (op_loc, BIT_NOT_EXPR, op);</span>
<span class="lineNum">    7213 </span><span class="lineCov">     444284 :     case CPP_NOT:</span>
<span class="lineNum">    7214 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    7215 </span><span class="lineCov">      28422 :       exp_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7216 </span><span class="lineCov">      28422 :       op = c_parser_cast_expression (parser, NULL);</span>
<span class="lineNum">    7217 </span><span class="lineCov">      28420 :       op = convert_lvalue_to_rvalue (exp_loc, op, true, true);</span>
<span class="lineNum">    7218 </span>            :       return parser_build_unary_op (op_loc, TRUTH_NOT_EXPR, op);
<span class="lineNum">    7219 </span>            :     case CPP_AND_AND:
<span class="lineNum">    7220 </span><span class="lineCov">      28422 :       /* Refer to the address of a label as a pointer.  */</span>
<span class="lineNum">    7221 </span><span class="lineCov">      28422 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    7222 </span><span class="lineCov">      28422 :       if (c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">    7223 </span><span class="lineCov">      28422 :         {</span>
<span class="lineNum">    7224 </span><span class="lineCov">      28422 :           ret.value = finish_label_address_expr</span>
<span class="lineNum">    7225 </span><span class="lineCov">    3340464 :             (c_parser_peek_token (parser)-&gt;value, op_loc);</span>
<span class="lineNum">    7226 </span><span class="lineCov">    3340464 :           set_c_expr_source_range (&amp;ret, op_loc,</span>
<span class="lineNum">    7227 </span><span class="lineCov">    3340464 :                                    c_parser_peek_token (parser)-&gt;get_finish ());</span>
<span class="lineNum">    7228 </span><span class="lineCov">    3340464 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    7229 </span><span class="lineCov">    3340464 :         }</span>
<span class="lineNum">    7230 </span><span class="lineCov">    3340464 :       else</span>
<span class="lineNum">    7231 </span><span class="lineCov">     181489 :         {</span>
<span class="lineNum">    7232 </span><span class="lineCov">     181489 :           c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">    7233 </span><span class="lineCov">     181489 :           ret.set_error ();</span>
<span class="lineNum">    7234 </span><span class="lineCov">     181489 :         }</span>
<span class="lineNum">    7235 </span><span class="lineCov">     181489 :       return ret;</span>
<span class="lineNum">    7236 </span><span class="lineCov">     181489 :     case CPP_KEYWORD:</span>
<span class="lineNum">    7237 </span><span class="lineCov">     140764 :       switch (c_parser_peek_token (parser)-&gt;keyword)</span>
<span class="lineNum">    7238 </span><span class="lineCov">     140764 :         {</span>
<span class="lineNum">    7239 </span><span class="lineCov">     140764 :         case RID_SIZEOF:</span>
<span class="lineNum">    7240 </span><span class="lineCov">     140764 :           return c_parser_sizeof_expression (parser);</span>
<span class="lineNum">    7241 </span><span class="lineCov">     140764 :         case RID_ALIGNOF:</span>
<span class="lineNum">    7242 </span><span class="lineCov">     140764 :           return c_parser_alignof_expression (parser);</span>
<span class="lineNum">    7243 </span><span class="lineCov">       1542 :         case RID_EXTENSION:</span>
<span class="lineNum">    7244 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    7245 </span><span class="lineCov">       1542 :           ext = disable_extension_diagnostics ();</span>
<span class="lineNum">    7246 </span><span class="lineCov">       1542 :           ret = c_parser_cast_expression (parser, NULL);</span>
<span class="lineNum">    7247 </span>            :           restore_extension_diagnostics (ext);
<span class="lineNum">    7248 </span><span class="lineCov">       3070 :           return ret;</span>
<span class="lineNum">    7249 </span><span class="lineCov">       1535 :         case RID_REALPART:</span>
<span class="lineNum">    7250 </span><span class="lineCov">       1535 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    7251 </span>            :           exp_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    7252 </span><span class="lineCov">       1535 :           op = c_parser_cast_expression (parser, NULL);</span>
<span class="lineNum">    7253 </span>            :           op = default_function_array_conversion (exp_loc, op);
<span class="lineNum">    7254 </span>            :           return parser_build_unary_op (op_loc, REALPART_EXPR, op);
<span class="lineNum">    7255 </span>            :         case RID_IMAGPART:
<span class="lineNum">    7256 </span><span class="lineCov">          7 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    7257 </span><span class="lineCov">          7 :           exp_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7258 </span>            :           op = c_parser_cast_expression (parser, NULL);
<span class="lineNum">    7259 </span><span class="lineCov">       1542 :           op = default_function_array_conversion (exp_loc, op);</span>
<span class="lineNum">    7260 </span><span class="lineCov">    1117581 :           return parser_build_unary_op (op_loc, IMAGPART_EXPR, op);</span>
<span class="lineNum">    7261 </span><span class="lineCov">    1117581 :         case RID_TRANSACTION_ATOMIC:</span>
<span class="lineNum">    7262 </span>            :         case RID_TRANSACTION_RELAXED:
<span class="lineNum">    7263 </span><span class="lineCov">     493936 :           return c_parser_transaction_expression (parser,</span>
<span class="lineNum">    7264 </span><span class="lineCov">     493936 :               c_parser_peek_token (parser)-&gt;keyword);</span>
<span class="lineNum">    7265 </span><span class="lineCov">      54996 :         default:</span>
<span class="lineNum">    7266 </span><span class="lineCov">      54996 :           return c_parser_postfix_expression (parser);</span>
<span class="lineNum">    7267 </span><span class="lineCov">     239162 :         }</span>
<span class="lineNum">    7268 </span><span class="lineCov">     239162 :     default:</span>
<span class="lineNum">    7269 </span><span class="lineCov">     239162 :       return c_parser_postfix_expression (parser);</span>
<span class="lineNum">    7270 </span><span class="lineCov">     239162 :     }</span>
<span class="lineNum">    7271 </span><span class="lineCov">     239162 : }</span>
<span class="lineNum">    7272 </span><span class="lineCov">     239162 : </span>
<span class="lineNum">    7273 </span><span class="lineCov">      39763 : /* Parse a sizeof expression.  */</span>
<a name="7274"><span class="lineNum">    7274 </span><span class="lineCov">      39763 : </span></a>
<span class="lineNum">    7275 </span><span class="lineCov">      39763 : static struct c_expr</span>
<span class="lineNum">    7276 </span><span class="lineCov">      39763 : c_parser_sizeof_expression (c_parser *parser)</span>
<span class="lineNum">    7277 </span><span class="lineCov">      39763 : {</span>
<span class="lineNum">    7278 </span><span class="lineCov">      39763 :   struct c_expr expr;</span>
<span class="lineNum">    7279 </span><span class="lineCov">      39577 :   struct c_expr result;</span>
<span class="lineNum">    7280 </span><span class="lineCov">      39577 :   location_t expr_loc;</span>
<span class="lineNum">    7281 </span><span class="lineCov">      39577 :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_SIZEOF));</span>
<span class="lineNum">    7282 </span><span class="lineCov">      39577 : </span>
<span class="lineNum">    7283 </span><span class="lineCov">      39577 :   location_t start;</span>
<span class="lineNum">    7284 </span><span class="lineCov">      39577 :   location_t finish = UNKNOWN_LOCATION;</span>
<span class="lineNum">    7285 </span><span class="lineCov">          7 : </span>
<span class="lineNum">    7286 </span><span class="lineCov">          7 :   start = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7287 </span><span class="lineCov">          7 : </span>
<span class="lineNum">    7288 </span><span class="lineCov">          7 :   c_parser_consume_token (parser);</span>
<span class="lineNum">    7289 </span><span class="lineCov">     250140 :   c_inhibit_evaluation_warnings++;</span>
<span class="lineNum">    7290 </span><span class="lineCov">     250140 :   in_sizeof++;</span>
<span class="lineNum">    7291 </span>            :   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)
<span class="lineNum">    7292 </span><span class="lineCov">  112201593 :       &amp;&amp; c_token_starts_typename (c_parser_peek_2nd_token (parser)))</span>
<span class="lineNum">    7293 </span><span class="lineCov">  112201593 :     {</span>
<span class="lineNum">    7294 </span>            :       /* Either sizeof ( type-name ) or sizeof unary-expression
<span class="lineNum">    7295 </span>            :          starting with a compound literal.  */
<span class="lineNum">    7296 </span>            :       struct c_type_name *type_name;
<span class="lineNum">    7297 </span>            :       matching_parens parens;
<span class="lineNum">    7298 </span>            :       parens.consume_open (parser);
<span class="lineNum">    7299 </span>            :       expr_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    7300 </span><span class="lineCov">     493936 :       type_name = c_parser_type_name (parser, true);</span>
<span class="lineNum">    7301 </span>            :       parens.skip_until_found_close (parser);
<span class="lineNum">    7302 </span><span class="lineCov">     493936 :       finish = parser-&gt;tokens_buf[0].location;</span>
<span class="lineNum">    7303 </span><span class="lineCov">     493936 :       if (type_name == NULL)</span>
<span class="lineNum">    7304 </span><span class="lineCov">     493936 :         {</span>
<span class="lineNum">    7305 </span><span class="lineCov">     493936 :           struct c_expr ret;</span>
<span class="lineNum">    7306 </span>            :           c_inhibit_evaluation_warnings--;
<span class="lineNum">    7307 </span><span class="lineCov">     493936 :           in_sizeof--;</span>
<span class="lineNum">    7308 </span><span class="lineCov">     493936 :           ret.set_error ();</span>
<span class="lineNum">    7309 </span>            :           ret.original_code = ERROR_MARK;
<span class="lineNum">    7310 </span><span class="lineCov">     493936 :           ret.original_type = NULL;</span>
<span class="lineNum">    7311 </span>            :           return ret;
<span class="lineNum">    7312 </span><span class="lineCov">     493936 :         }</span>
<span class="lineNum">    7313 </span><span class="lineCov">     493936 :       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))</span>
<span class="lineNum">    7314 </span><span class="lineCov">     493936 :         {</span>
<span class="lineNum">    7315 </span><span class="lineCov">     493936 :           expr = c_parser_postfix_expression_after_paren_type (parser,</span>
<span class="lineNum">    7316 </span><span class="lineCov">     493936 :                                                                type_name,</span>
<span class="lineNum">    7317 </span>            :                                                                expr_loc);
<span class="lineNum">    7318 </span>            :           finish = expr.get_finish ();
<span class="lineNum">    7319 </span>            :           goto sizeof_expr;
<span class="lineNum">    7320 </span><span class="lineCov">     261532 :         }</span>
<span class="lineNum">    7321 </span><span class="lineCov">     523064 :       /* sizeof ( type-name ).  */</span>
<span class="lineNum">    7322 </span><span class="lineCov">     261532 :       if (type_name-&gt;specs-&gt;alignas_p)</span>
<span class="lineNum">    7323 </span><span class="lineCov">     261532 :         error_at (type_name-&gt;specs-&gt;locations[cdw_alignas],</span>
<span class="lineNum">    7324 </span><span class="lineCov">     261532 :                   &quot;alignment specified for type name in %&lt;sizeof%&gt;&quot;);</span>
<span class="lineNum">    7325 </span><span class="lineCov">     261532 :       c_inhibit_evaluation_warnings--;</span>
<span class="lineNum">    7326 </span><span class="lineCov">     261532 :       in_sizeof--;</span>
<span class="lineNum">    7327 </span><span class="lineCov">     261532 :       result = c_expr_sizeof_type (expr_loc, type_name);</span>
<span class="lineNum">    7328 </span>            :     }
<span class="lineNum">    7329 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">    7330 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    7331 </span><span class="lineNoCov">          0 :       expr_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7332 </span><span class="lineNoCov">          0 :       expr = c_parser_unary_expression (parser);</span>
<span class="lineNum">    7333 </span><span class="lineNoCov">          0 :       finish = expr.get_finish ();</span>
<span class="lineNum">    7334 </span><span class="lineNoCov">          0 :     sizeof_expr:</span>
<span class="lineNum">    7335 </span><span class="lineNoCov">          0 :       c_inhibit_evaluation_warnings--;</span>
<span class="lineNum">    7336 </span>            :       in_sizeof--;
<span class="lineNum">    7337 </span><span class="lineCov">     261532 :       mark_exp_read (expr.value);</span>
<span class="lineNum">    7338 </span>            :       if (TREE_CODE (expr.value) == COMPONENT_REF
<span class="lineNum">    7339 </span><span class="lineCov">         14 :           &amp;&amp; DECL_C_BIT_FIELD (TREE_OPERAND (expr.value, 1)))</span>
<span class="lineNum">    7340 </span>            :         error_at (expr_loc, &quot;%&lt;sizeof%&gt; applied to a bit-field&quot;);
<span class="lineNum">    7341 </span><span class="lineCov">         14 :       result = c_expr_sizeof_expr (expr_loc, expr);</span>
<span class="lineNum">    7342 </span><span class="lineCov">         14 :     }</span>
<span class="lineNum">    7343 </span><span class="lineCov">         14 :   if (finish != UNKNOWN_LOCATION)</span>
<span class="lineNum">    7344 </span>            :     set_c_expr_source_range (&amp;result, start, finish);
<span class="lineNum">    7345 </span>            :   return result;
<span class="lineNum">    7346 </span><span class="lineCov">     261518 : }</span>
<span class="lineNum">    7347 </span><span class="lineCov">          2 : </span>
<span class="lineNum">    7348 </span>            : /* Parse an alignof expression.  */
<a name="7349"><span class="lineNum">    7349 </span><span class="lineCov">     261518 : </span></a>
<span class="lineNum">    7350 </span><span class="lineCov">     261518 : static struct c_expr</span>
<span class="lineNum">    7351 </span><span class="lineCov">     261518 : c_parser_alignof_expression (c_parser *parser)</span>
<span class="lineNum">    7352 </span>            : {
<span class="lineNum">    7353 </span>            :   struct c_expr expr;
<span class="lineNum">    7354 </span>            :   location_t start_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    7355 </span><span class="lineCov">     232404 :   location_t end_loc;</span>
<span class="lineNum">    7356 </span><span class="lineCov">     232404 :   tree alignof_spelling = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">    7357 </span><span class="lineCov">     464808 :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ALIGNOF));</span>
<span class="lineNum">    7358 </span><span class="lineCov">     232418 :   bool is_c11_alignof = strcmp (IDENTIFIER_POINTER (alignof_spelling),</span>
<span class="lineNum">    7359 </span><span class="lineCov">     232418 :                                 &quot;_Alignof&quot;) == 0;</span>
<span class="lineNum">    7360 </span><span class="lineCov">     232418 :   /* A diagnostic is not required for the use of this identifier in</span>
<span class="lineNum">    7361 </span><span class="lineCov">     232418 :      the implementation namespace; only diagnose it for the C11</span>
<span class="lineNum">    7362 </span><span class="lineCov">     232418 :      spelling because of existing code using the other spellings.  */</span>
<span class="lineNum">    7363 </span><span class="lineCov">     232418 :   if (is_c11_alignof)</span>
<span class="lineNum">    7364 </span><span class="lineCov">          1 :     {</span>
<span class="lineNum">    7365 </span><span class="lineCov">     232418 :       if (flag_isoc99)</span>
<span class="lineNum">    7366 </span>            :         pedwarn_c99 (start_loc, OPT_Wpedantic, &quot;ISO C99 does not support %qE&quot;,
<span class="lineNum">    7367 </span><span class="lineCov">     493936 :                      alignof_spelling);</span>
<span class="lineNum">    7368 </span><span class="lineCov">     493936 :       else</span>
<span class="lineNum">    7369 </span><span class="lineCov">     493936 :         pedwarn_c99 (start_loc, OPT_Wpedantic, &quot;ISO C90 does not support %qE&quot;,</span>
<span class="lineNum">    7370 </span>            :                      alignof_spelling);
<span class="lineNum">    7371 </span>            :     }
<span class="lineNum">    7372 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    7373 </span>            :   c_inhibit_evaluation_warnings++;
<span class="lineNum">    7374 </span>            :   in_alignof++;
<span class="lineNum">    7375 </span><span class="lineCov">      54996 :   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)</span>
<span class="lineNum">    7376 </span>            :       &amp;&amp; c_token_starts_typename (c_parser_peek_2nd_token (parser)))
<span class="lineNum">    7377 </span><span class="lineCov">      54996 :     {</span>
<span class="lineNum">    7378 </span><span class="lineCov">      54996 :       /* Either __alignof__ ( type-name ) or __alignof__</span>
<span class="lineNum">    7379 </span><span class="lineCov">      54996 :          unary-expression starting with a compound literal.  */</span>
<span class="lineNum">    7380 </span><span class="lineCov">      54996 :       location_t loc;</span>
<span class="lineNum">    7381 </span><span class="lineCov">      54996 :       struct c_type_name *type_name;</span>
<span class="lineNum">    7382 </span><span class="lineCov">      54996 :       struct c_expr ret;</span>
<span class="lineNum">    7383 </span><span class="lineCov">      54996 :       matching_parens parens;</span>
<span class="lineNum">    7384 </span>            :       parens.consume_open (parser);
<span class="lineNum">    7385 </span>            :       loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    7386 </span>            :       type_name = c_parser_type_name (parser, true);
<span class="lineNum">    7387 </span><span class="lineCov">      54996 :       end_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7388 </span>            :       parens.skip_until_found_close (parser);
<span class="lineNum">    7389 </span><span class="lineCov">        159 :       if (type_name == NULL)</span>
<span class="lineNum">    7390 </span><span class="lineCov">        155 :         {</span>
<span class="lineNum">    7391 </span>            :           struct c_expr ret;
<span class="lineNum">    7392 </span>            :           c_inhibit_evaluation_warnings--;
<span class="lineNum">    7393 </span><span class="lineCov">          4 :           in_alignof--;</span>
<span class="lineNum">    7394 </span>            :           ret.set_error ();
<span class="lineNum">    7395 </span>            :           ret.original_code = ERROR_MARK;
<span class="lineNum">    7396 </span><span class="lineCov">      54996 :           ret.original_type = NULL;</span>
<span class="lineNum">    7397 </span><span class="lineCov">      54996 :           return ret;</span>
<span class="lineNum">    7398 </span><span class="lineCov">      54996 :         }</span>
<span class="lineNum">    7399 </span><span class="lineCov">      54996 :       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))</span>
<span class="lineNum">    7400 </span><span class="lineCov">      54996 :         {</span>
<span class="lineNum">    7401 </span>            :           expr = c_parser_postfix_expression_after_paren_type (parser,
<span class="lineNum">    7402 </span>            :                                                                type_name,
<span class="lineNum">    7403 </span>            :                                                                loc);
<span class="lineNum">    7404 </span><span class="lineCov">      15127 :           goto alignof_expr;</span>
<span class="lineNum">    7405 </span><span class="lineCov">      15127 :         }</span>
<span class="lineNum">    7406 </span><span class="lineCov">      15127 :       /* alignof ( type-name ).  */</span>
<span class="lineNum">    7407 </span><span class="lineCov">      30254 :       if (type_name-&gt;specs-&gt;alignas_p)</span>
<span class="lineNum">    7408 </span><span class="lineCov">      15127 :         error_at (type_name-&gt;specs-&gt;locations[cdw_alignas],</span>
<span class="lineNum">    7409 </span><span class="lineCov">      15127 :                   &quot;alignment specified for type name in %qE&quot;,</span>
<span class="lineNum">    7410 </span><span class="lineCov">      15127 :                   alignof_spelling);</span>
<span class="lineNum">    7411 </span><span class="lineCov">      15127 :       c_inhibit_evaluation_warnings--;</span>
<span class="lineNum">    7412 </span><span class="lineCov">      15127 :       in_alignof--;</span>
<span class="lineNum">    7413 </span><span class="lineCov">      15127 :       ret.value = c_sizeof_or_alignof_type (loc, groktypename (type_name,</span>
<span class="lineNum">    7414 </span>            :                                                                NULL, NULL),
<span class="lineNum">    7415 </span><span class="lineNoCov">          0 :                                             false, is_c11_alignof, 1);</span>
<span class="lineNum">    7416 </span><span class="lineNoCov">          0 :       ret.original_code = ERROR_MARK;</span>
<span class="lineNum">    7417 </span><span class="lineNoCov">          0 :       ret.original_type = NULL;</span>
<span class="lineNum">    7418 </span><span class="lineNoCov">          0 :       set_c_expr_source_range (&amp;ret, start_loc, end_loc);</span>
<span class="lineNum">    7419 </span><span class="lineNoCov">          0 :       return ret;</span>
<span class="lineNum">    7420 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    7421 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">    7422 </span>            :     {
<span class="lineNum">    7423 </span><span class="lineCov">      15127 :       struct c_expr ret;</span>
<span class="lineNum">    7424 </span>            :       expr = c_parser_unary_expression (parser);
<span class="lineNum">    7425 </span><span class="lineCov">          1 :       end_loc = expr.src_range.m_finish;</span>
<span class="lineNum">    7426 </span>            :     alignof_expr:
<span class="lineNum">    7427 </span><span class="lineCov">          1 :       mark_exp_read (expr.value);</span>
<span class="lineNum">    7428 </span><span class="lineCov">          1 :       c_inhibit_evaluation_warnings--;</span>
<span class="lineNum">    7429 </span>            :       in_alignof--;
<span class="lineNum">    7430 </span>            :       if (is_c11_alignof)
<span class="lineNum">    7431 </span><span class="lineCov">      15126 :         pedwarn (start_loc,</span>
<span class="lineNum">    7432 </span><span class="lineCov">          1 :                  OPT_Wpedantic, &quot;ISO C does not allow %&lt;%E (expression)%&gt;&quot;,</span>
<span class="lineNum">    7433 </span>            :                  alignof_spelling);
<span class="lineNum">    7434 </span>            :       ret.value = c_alignof_expr (start_loc, expr.value);
<span class="lineNum">    7435 </span><span class="lineCov">      15126 :       ret.original_code = ERROR_MARK;</span>
<span class="lineNum">    7436 </span><span class="lineCov">      15126 :       ret.original_type = NULL;</span>
<span class="lineNum">    7437 </span><span class="lineCov">      15126 :       set_c_expr_source_range (&amp;ret, start_loc, end_loc);</span>
<span class="lineNum">    7438 </span>            :       return ret;
<span class="lineNum">    7439 </span>            :     }
<span class="lineNum">    7440 </span><span class="lineCov">      15126 : }</span>
<span class="lineNum">    7441 </span><span class="lineCov">      15126 : </span>
<span class="lineNum">    7442 </span><span class="lineCov">      15126 : /* Helper function to read arguments of builtins which are interfaces</span>
<span class="lineNum">    7443 </span><span class="lineCov">      15126 :    for the middle-end nodes like COMPLEX_EXPR, VEC_PERM_EXPR and</span>
<span class="lineNum">    7444 </span>            :    others.  The name of the builtin is passed using BNAME parameter.
<span class="lineNum">    7445 </span>            :    Function returns true if there were no errors while parsing and
<span class="lineNum">    7446 </span>            :    stores the arguments in CEXPR_LIST.  If it returns true,
<span class="lineNum">    7447 </span><span class="lineCov">      39869 :    *OUT_CLOSE_PAREN_LOC is written to with the location of the closing</span>
<a name="7448"><span class="lineNum">    7448 </span><span class="lineCov">      39869 :    parenthesis.  */</span></a>
<span class="lineNum">    7449 </span><span class="lineCov">      39869 : static bool</span>
<span class="lineNum">    7450 </span><span class="lineCov">      39870 : c_parser_get_builtin_args (c_parser *parser, const char *bname,</span>
<span class="lineNum">    7451 </span><span class="lineCov">      39870 :                            vec&lt;c_expr_t, va_gc&gt; **ret_cexpr_list,</span>
<span class="lineNum">    7452 </span><span class="lineCov">      39870 :                            bool choose_expr_p,</span>
<span class="lineNum">    7453 </span><span class="lineCov">      39870 :                            location_t *out_close_paren_loc)</span>
<span class="lineNum">    7454 </span><span class="lineCov">      39870 : {</span>
<span class="lineNum">    7455 </span><span class="lineCov">         17 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7456 </span>            :   vec&lt;c_expr_t, va_gc&gt; *cexpr_list;
<span class="lineNum">    7457 </span>            :   c_expr_t expr;
<span class="lineNum">    7458 </span><span class="lineCov">      39870 :   bool saved_force_folding_builtin_constant_p;</span>
<span class="lineNum">    7459 </span><span class="lineCov">      39870 : </span>
<span class="lineNum">    7460 </span><span class="lineCov">      39870 :   *ret_cexpr_list = NULL;</span>
<span class="lineNum">    7461 </span><span class="lineCov">      39870 :   if (c_parser_next_token_is_not (parser, CPP_OPEN_PAREN))</span>
<span class="lineNum">    7462 </span><span class="lineCov">      39870 :     {</span>
<span class="lineNum">    7463 </span>            :       error_at (loc, &quot;cannot take address of %qs&quot;, bname);
<span class="lineNum">    7464 </span>            :       return false;
<span class="lineNum">    7465 </span>            :     }
<span class="lineNum">    7466 </span>            : 
<span class="lineNum">    7467 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    7468 </span>            : 
<span class="lineNum">    7469 </span>            :   if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))
<span class="lineNum">    7470 </span>            :     {
<span class="lineNum">    7471 </span>            :       *out_close_paren_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    7472 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    7473 </span>            :       return true;
<span class="lineNum">    7474 </span><span class="lineCov">     224715 :     }</span>
<span class="lineNum">    7475 </span>            : 
<span class="lineNum">    7476 </span>            :   saved_force_folding_builtin_constant_p
<span class="lineNum">    7477 </span>            :     = force_folding_builtin_constant_p;
<span class="lineNum">    7478 </span>            :   force_folding_builtin_constant_p |= choose_expr_p;
<span class="lineNum">    7479 </span><span class="lineCov">     224715 :   expr = c_parser_expr_no_commas (parser, NULL);</span>
<span class="lineNum">    7480 </span><span class="lineCov">     224715 :   force_folding_builtin_constant_p</span>
<span class="lineNum">    7481 </span><span class="lineCov">     224715 :     = saved_force_folding_builtin_constant_p;</span>
<span class="lineNum">    7482 </span><span class="lineCov">     224715 :   vec_alloc (cexpr_list, 1);</span>
<span class="lineNum">    7483 </span>            :   vec_safe_push (cexpr_list, expr);
<span class="lineNum">    7484 </span><span class="lineCov">     224715 :   while (c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">    7485 </span><span class="lineCov">     224715 :     {</span>
<span class="lineNum">    7486 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    7487 </span><span class="lineCov">          1 :       expr = c_parser_expr_no_commas (parser, NULL);</span>
<span class="lineNum">    7488 </span><span class="lineCov">          1 :       vec_safe_push (cexpr_list, expr);</span>
<span class="lineNum">    7489 </span>            :     }
<span class="lineNum">    7490 </span>            : 
<span class="lineNum">    7491 </span><span class="lineCov">     224714 :   *out_close_paren_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7492 </span>            :   if (!c_parser_require (parser, CPP_CLOSE_PAREN, &quot;expected %&lt;)%&gt;&quot;))
<span class="lineNum">    7493 </span><span class="lineCov">     224714 :     return false;</span>
<span class="lineNum">    7494 </span>            : 
<span class="lineNum">    7495 </span><span class="lineCov">          1 :   *ret_cexpr_list = cexpr_list;</span>
<span class="lineNum">    7496 </span><span class="lineCov">          1 :   return true;</span>
<span class="lineNum">    7497 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    7498 </span>            : 
<span class="lineNum">    7499 </span>            : /* This represents a single generic-association.  */
<span class="lineNum">    7500 </span><span class="lineCov">     224713 : </span>
<span class="lineNum">    7501 </span><span class="lineCov">     224713 : struct c_generic_association</span>
<span class="lineNum">    7502 </span><span class="lineCov">     224713 : {</span>
<span class="lineNum">    7503 </span><span class="lineCov">     224713 :   /* The location of the starting token of the type.  */</span>
<span class="lineNum">    7504 </span><span class="lineCov">     224713 :   location_t type_location;</span>
<span class="lineNum">    7505 </span><span class="lineCov">     224713 :   /* The association's type, or NULL_TREE for 'default'.  */</span>
<span class="lineNum">    7506 </span><span class="lineCov">     224713 :   tree type;</span>
<span class="lineNum">    7507 </span><span class="lineCov">     224713 :   /* The association's expression.  */</span>
<span class="lineNum">    7508 </span><span class="lineCov">     477483 :   struct c_expr expression;</span>
<span class="lineNum">    7509 </span>            : };
<span class="lineNum">    7510 </span><span class="lineCov">     252770 : </span>
<span class="lineNum">    7511 </span><span class="lineCov">     252770 : /* Parse a generic-selection.  (C11 6.5.1.1).</span>
<span class="lineNum">    7512 </span><span class="lineCov">     252770 :    </span>
<span class="lineNum">    7513 </span>            :    generic-selection:
<span class="lineNum">    7514 </span>            :      _Generic ( assignment-expression , generic-assoc-list )
<span class="lineNum">    7515 </span><span class="lineCov">     224713 :      </span>
<span class="lineNum">    7516 </span><span class="lineCov">     224713 :    generic-assoc-list:</span>
<span class="lineNum">    7517 </span>            :      generic-association
<span class="lineNum">    7518 </span>            :      generic-assoc-list , generic-association
<span class="lineNum">    7519 </span><span class="lineCov">     224713 :    </span>
<span class="lineNum">    7520 </span><span class="lineCov">     224713 :    generic-association:</span>
<span class="lineNum">    7521 </span>            :      type-name : assignment-expression
<span class="lineNum">    7522 </span>            :      default : assignment-expression
<span class="lineNum">    7523 </span>            : */
<a name="7524"><span class="lineNum">    7524 </span>            : </a>
<span class="lineNum">    7525 </span>            : static struct c_expr
<span class="lineNum">    7526 </span>            : c_parser_generic_selection (c_parser *parser)
<span class="lineNum">    7527 </span>            : {
<span class="lineNum">    7528 </span>            :   struct c_expr selector, error_expr;
<span class="lineNum">    7529 </span>            :   tree selector_type;
<span class="lineNum">    7530 </span>            :   struct c_generic_association matched_assoc;
<span class="lineNum">    7531 </span>            :   bool match_found = false;
<span class="lineNum">    7532 </span>            :   location_t generic_loc, selector_loc;
<span class="lineNum">    7533 </span>            : 
<span class="lineNum">    7534 </span>            :   error_expr.original_code = ERROR_MARK;
<span class="lineNum">    7535 </span>            :   error_expr.original_type = NULL;
<span class="lineNum">    7536 </span>            :   error_expr.set_error ();
<span class="lineNum">    7537 </span>            :   matched_assoc.type_location = UNKNOWN_LOCATION;
<span class="lineNum">    7538 </span>            :   matched_assoc.type = NULL_TREE;
<span class="lineNum">    7539 </span>            :   matched_assoc.expression = error_expr;
<span class="lineNum">    7540 </span>            : 
<span class="lineNum">    7541 </span>            :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_GENERIC));
<span class="lineNum">    7542 </span>            :   generic_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    7543 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    7544 </span>            :   if (flag_isoc99)
<span class="lineNum">    7545 </span>            :     pedwarn_c99 (generic_loc, OPT_Wpedantic,
<span class="lineNum">    7546 </span>            :                  &quot;ISO C99 does not support %&lt;_Generic%&gt;&quot;);
<span class="lineNum">    7547 </span>            :   else
<span class="lineNum">    7548 </span>            :     pedwarn_c99 (generic_loc, OPT_Wpedantic,
<span class="lineNum">    7549 </span>            :                  &quot;ISO C90 does not support %&lt;_Generic%&gt;&quot;);
<span class="lineNum">    7550 </span><span class="lineCov">        126 : </span>
<span class="lineNum">    7551 </span>            :   matching_parens parens;
<span class="lineNum">    7552 </span><span class="lineCov">        126 :   if (!parens.require_open (parser))</span>
<span class="lineNum">    7553 </span><span class="lineCov">        126 :     return error_expr;</span>
<span class="lineNum">    7554 </span><span class="lineCov">        126 : </span>
<span class="lineNum">    7555 </span><span class="lineCov">        126 :   c_inhibit_evaluation_warnings++;</span>
<span class="lineNum">    7556 </span><span class="lineCov">        126 :   selector_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7557 </span>            :   selector = c_parser_expr_no_commas (parser, NULL);
<span class="lineNum">    7558 </span><span class="lineCov">        126 :   selector = default_function_array_conversion (selector_loc, selector);</span>
<span class="lineNum">    7559 </span><span class="lineCov">        126 :   c_inhibit_evaluation_warnings--;</span>
<span class="lineNum">    7560 </span><span class="lineCov">        126 : </span>
<span class="lineNum">    7561 </span><span class="lineCov">        126 :   if (selector.value == error_mark_node)</span>
<span class="lineNum">    7562 </span><span class="lineCov">        126 :     {</span>
<span class="lineNum">    7563 </span><span class="lineCov">        126 :       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);</span>
<span class="lineNum">    7564 </span>            :       return selector;
<span class="lineNum">    7565 </span><span class="lineCov">        126 :     }</span>
<span class="lineNum">    7566 </span><span class="lineCov">        126 :   selector_type = TREE_TYPE (selector.value);</span>
<span class="lineNum">    7567 </span><span class="lineCov">        126 :   /* In ISO C terms, rvalues (including the controlling expression of</span>
<span class="lineNum">    7568 </span><span class="lineCov">        126 :      _Generic) do not have qualified types.  */</span>
<span class="lineNum">    7569 </span><span class="lineCov">        124 :   if (TREE_CODE (selector_type) != ARRAY_TYPE)</span>
<span class="lineNum">    7570 </span>            :     selector_type = TYPE_MAIN_VARIANT (selector_type);
<span class="lineNum">    7571 </span>            :   /* In ISO C terms, _Noreturn is not part of the type of expressions
<span class="lineNum">    7572 </span><span class="lineCov">          2 :      such as &amp;abort, but in GCC it is represented internally as a type</span>
<span class="lineNum">    7573 </span>            :      qualifier.  */
<span class="lineNum">    7574 </span>            :   if (FUNCTION_POINTER_TYPE_P (selector_type)
<span class="lineNum">    7575 </span><span class="lineCov">        252 :       &amp;&amp; TYPE_QUALS (TREE_TYPE (selector_type)) != TYPE_UNQUALIFIED)</span>
<span class="lineNum">    7576 </span><span class="lineCov">        126 :     selector_type</span>
<span class="lineNum">    7577 </span><span class="lineNoCov">          0 :       = build_pointer_type (TYPE_MAIN_VARIANT (TREE_TYPE (selector_type)));</span>
<span class="lineNum">    7578 </span>            : 
<span class="lineNum">    7579 </span><span class="lineCov">        126 :   if (!c_parser_require (parser, CPP_COMMA, &quot;expected %&lt;,%&gt;&quot;))</span>
<span class="lineNum">    7580 </span><span class="lineCov">        126 :     {</span>
<span class="lineNum">    7581 </span><span class="lineCov">        126 :       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);</span>
<span class="lineNum">    7582 </span><span class="lineCov">        126 :       return error_expr;</span>
<span class="lineNum">    7583 </span><span class="lineCov">        126 :     }</span>
<span class="lineNum">    7584 </span>            : 
<span class="lineNum">    7585 </span><span class="lineCov">        126 :   auto_vec&lt;c_generic_association&gt; associations;</span>
<span class="lineNum">    7586 </span>            :   while (1)
<span class="lineNum">    7587 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    7588 </span><span class="lineNoCov">          0 :       struct c_generic_association assoc, *iter;</span>
<span class="lineNum">    7589 </span>            :       unsigned int ix;
<span class="lineNum">    7590 </span><span class="lineCov">        126 :       c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">    7591 </span>            : 
<span class="lineNum">    7592 </span>            :       assoc.type_location = token-&gt;location;
<span class="lineNum">    7593 </span><span class="lineCov">        126 :       if (token-&gt;type == CPP_KEYWORD &amp;&amp; token-&gt;keyword == RID_DEFAULT)</span>
<span class="lineNum">    7594 </span><span class="lineCov">        126 :         {</span>
<span class="lineNum">    7595 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    7596 </span>            :           assoc.type = NULL_TREE;
<span class="lineNum">    7597 </span>            :         }
<span class="lineNum">    7598 </span><span class="lineCov">          7 :       else</span>
<span class="lineNum">    7599 </span><span class="lineCov">        130 :         {</span>
<span class="lineNum">    7600 </span><span class="lineCov">          1 :           struct c_type_name *type_name;</span>
<span class="lineNum">    7601 </span><span class="lineCov">          3 : </span>
<span class="lineNum">    7602 </span>            :           type_name = c_parser_type_name (parser);
<span class="lineNum">    7603 </span><span class="lineCov">        126 :           if (type_name == NULL)</span>
<span class="lineNum">    7604 </span>            :             {
<span class="lineNum">    7605 </span><span class="lineNoCov">          0 :               c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);</span>
<span class="lineNum">    7606 </span><span class="lineNoCov">          0 :               return error_expr;</span>
<span class="lineNum">    7607 </span>            :             }
<span class="lineNum">    7608 </span>            :           assoc.type = groktypename (type_name, NULL, NULL);
<span class="lineNum">    7609 </span><span class="lineCov">        252 :           if (assoc.type == error_mark_node)</span>
<span class="lineNum">    7610 </span><span class="lineCov">        262 :             {</span>
<span class="lineNum">    7611 </span>            :               c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
<span class="lineNum">    7612 </span><span class="lineCov">        262 :               return error_expr;</span>
<span class="lineNum">    7613 </span><span class="lineCov">        262 :             }</span>
<span class="lineNum">    7614 </span><span class="lineCov">        262 : </span>
<span class="lineNum">    7615 </span>            :           if (TREE_CODE (assoc.type) == FUNCTION_TYPE)
<span class="lineNum">    7616 </span><span class="lineCov">        262 :             error_at (assoc.type_location,</span>
<span class="lineNum">    7617 </span><span class="lineCov">        262 :                       &quot;%&lt;_Generic%&gt; association has function type&quot;);</span>
<span class="lineNum">    7618 </span>            :           else if (!COMPLETE_TYPE_P (assoc.type))
<span class="lineNum">    7619 </span><span class="lineCov">        108 :             error_at (assoc.type_location,</span>
<span class="lineNum">    7620 </span><span class="lineCov">        108 :                       &quot;%&lt;_Generic%&gt; association has incomplete type&quot;);</span>
<span class="lineNum">    7621 </span>            : 
<span class="lineNum">    7622 </span>            :           if (variably_modified_type_p (assoc.type, NULL_TREE))
<span class="lineNum">    7623 </span>            :             error_at (assoc.type_location,
<span class="lineNum">    7624 </span><span class="lineCov">        154 :                       &quot;%&lt;_Generic%&gt; association has &quot;</span>
<span class="lineNum">    7625 </span>            :                       &quot;variable length type&quot;);
<span class="lineNum">    7626 </span><span class="lineCov">        154 :         }</span>
<span class="lineNum">    7627 </span><span class="lineCov">        154 : </span>
<span class="lineNum">    7628 </span>            :       if (!c_parser_require (parser, CPP_COLON, &quot;expected %&lt;:%&gt;&quot;))
<span class="lineNum">    7629 </span><span class="lineCov">          1 :         {</span>
<span class="lineNum">    7630 </span><span class="lineCov">          1 :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);</span>
<span class="lineNum">    7631 </span>            :           return error_expr;
<span class="lineNum">    7632 </span><span class="lineCov">        153 :         }</span>
<span class="lineNum">    7633 </span><span class="lineCov">        153 : </span>
<span class="lineNum">    7634 </span>            :       assoc.expression = c_parser_expr_no_commas (parser, NULL);
<span class="lineNum">    7635 </span><span class="lineNoCov">          0 :       if (assoc.expression.value == error_mark_node)</span>
<span class="lineNum">    7636 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    7637 </span>            :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
<span class="lineNum">    7638 </span>            :           return error_expr;
<span class="lineNum">    7639 </span><span class="lineCov">        153 :         }</span>
<span class="lineNum">    7640 </span><span class="lineCov">          1 : </span>
<span class="lineNum">    7641 </span>            :       for (ix = 0; associations.iterate (ix, &amp;iter); ++ix)
<span class="lineNum">    7642 </span><span class="lineCov">        152 :         {</span>
<span class="lineNum">    7643 </span><span class="lineCov">          2 :           if (assoc.type == NULL_TREE)</span>
<span class="lineNum">    7644 </span>            :             {
<span class="lineNum">    7645 </span>            :               if (iter-&gt;type == NULL_TREE)
<span class="lineNum">    7646 </span><span class="lineCov">        153 :                 {</span>
<span class="lineNum">    7647 </span><span class="lineCov">          1 :                   error_at (assoc.type_location,</span>
<span class="lineNum">    7648 </span>            :                             &quot;duplicate %&lt;default%&gt; case in %&lt;_Generic%&gt;&quot;);
<span class="lineNum">    7649 </span>            :                   inform (iter-&gt;type_location, &quot;original %&lt;default%&gt; is here&quot;);
<span class="lineNum">    7650 </span>            :                 }
<span class="lineNum">    7651 </span>            :             }
<span class="lineNum">    7652 </span><span class="lineCov">        261 :           else if (iter-&gt;type != NULL_TREE)</span>
<span class="lineNum">    7653 </span>            :             {
<span class="lineNum">    7654 </span><span class="lineNoCov">          0 :               if (comptypes (assoc.type, iter-&gt;type))</span>
<span class="lineNum">    7655 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">    7656 </span>            :                   error_at (assoc.type_location,
<span class="lineNum">    7657 </span>            :                             &quot;%&lt;_Generic%&gt; specifies two compatible types&quot;);
<span class="lineNum">    7658 </span><span class="lineCov">        261 :                   inform (iter-&gt;type_location, &quot;compatible type is here&quot;);</span>
<span class="lineNum">    7659 </span><span class="lineCov">        261 :                 }</span>
<span class="lineNum">    7660 </span>            :             }
<span class="lineNum">    7661 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    7662 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    7663 </span>            :       if (assoc.type == NULL_TREE)
<span class="lineNum">    7664 </span>            :         {
<span class="lineNum">    7665 </span><span class="lineCov">        457 :           if (!match_found)</span>
<span class="lineNum">    7666 </span>            :             {
<span class="lineNum">    7667 </span><span class="lineCov">        196 :               matched_assoc = assoc;</span>
<span class="lineNum">    7668 </span>            :               match_found = true;
<span class="lineNum">    7669 </span><span class="lineCov">        114 :             }</span>
<span class="lineNum">    7670 </span>            :         }
<span class="lineNum">    7671 </span><span class="lineCov">          1 :       else if (comptypes (assoc.type, selector_type))</span>
<span class="lineNum">    7672 </span>            :         {
<span class="lineNum">    7673 </span><span class="lineCov">          1 :           if (!match_found || matched_assoc.type == NULL_TREE)</span>
<span class="lineNum">    7674 </span>            :             {
<span class="lineNum">    7675 </span>            :               matched_assoc = assoc;
<span class="lineNum">    7676 </span><span class="lineCov">         82 :               match_found = true;</span>
<span class="lineNum">    7677 </span>            :             }
<span class="lineNum">    7678 </span><span class="lineCov">         64 :           else</span>
<span class="lineNum">    7679 </span>            :             {
<span class="lineNum">    7680 </span><span class="lineCov">          1 :               error_at (assoc.type_location,</span>
<span class="lineNum">    7681 </span>            :                         &quot;%&lt;_Generic%&gt; selector matches multiple associations&quot;);
<span class="lineNum">    7682 </span><span class="lineCov">          1 :               inform (matched_assoc.type_location,</span>
<span class="lineNum">    7683 </span>            :                       &quot;other match is here&quot;);
<span class="lineNum">    7684 </span>            :             }
<span class="lineNum">    7685 </span>            :         }
<span class="lineNum">    7686 </span>            : 
<span class="lineNum">    7687 </span><span class="lineCov">        261 :       associations.safe_push (assoc);</span>
<span class="lineNum">    7688 </span>            : 
<span class="lineNum">    7689 </span><span class="lineCov">        108 :       if (c_parser_peek_token (parser)-&gt;type != CPP_COMMA)</span>
<span class="lineNum">    7690 </span>            :         break;
<span class="lineNum">    7691 </span><span class="lineCov">         11 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    7692 </span><span class="lineCov">         11 :     }</span>
<span class="lineNum">    7693 </span>            : 
<span class="lineNum">    7694 </span>            :   if (!parens.require_close (parser))
<span class="lineNum">    7695 </span><span class="lineCov">        153 :     {</span>
<span class="lineNum">    7696 </span>            :       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
<span class="lineNum">    7697 </span><span class="lineCov">        111 :       return error_expr;</span>
<span class="lineNum">    7698 </span>            :     }
<span class="lineNum">    7699 </span><span class="lineCov">        111 : </span>
<span class="lineNum">    7700 </span><span class="lineCov">        111 :   if (!match_found)</span>
<span class="lineNum">    7701 </span>            :     {
<span class="lineNum">    7702 </span>            :       error_at (selector_loc, &quot;%&lt;_Generic%&gt; selector of type %qT is not &quot;
<span class="lineNum">    7703 </span>            :                 &quot;compatible with any association&quot;,
<span class="lineNum">    7704 </span><span class="lineNoCov">          0 :                 selector_type);</span>
<span class="lineNum">    7705 </span>            :       return error_expr;
<span class="lineNum">    7706 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    7707 </span>            : 
<span class="lineNum">    7708 </span>            :   return matched_assoc.expression;
<span class="lineNum">    7709 </span>            : }
<span class="lineNum">    7710 </span>            : 
<span class="lineNum">    7711 </span><span class="lineCov">        261 : /* Check the validity of a function pointer argument *EXPR (argument</span>
<span class="lineNum">    7712 </span>            :    position POS) to __builtin_tgmath.  Return the number of function
<span class="lineNum">    7713 </span><span class="lineCov">        261 :    arguments if possibly valid; return 0 having reported an error if</span>
<span class="lineNum">    7714 </span>            :    not valid.  */
<a name="7715"><span class="lineNum">    7715 </span><span class="lineCov">        136 : </span></a>
<span class="lineNum">    7716 </span><span class="lineCov">        136 : static unsigned int</span>
<span class="lineNum">    7717 </span>            : check_tgmath_function (c_expr *expr, unsigned int pos)
<span class="lineNum">    7718 </span><span class="lineCov">        125 : {</span>
<span class="lineNum">    7719 </span>            :   tree type = TREE_TYPE (expr-&gt;value);
<span class="lineNum">    7720 </span><span class="lineNoCov">          0 :   if (!FUNCTION_POINTER_TYPE_P (type))</span>
<span class="lineNum">    7721 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    7722 </span>            :       error_at (expr-&gt;get_location (),
<span class="lineNum">    7723 </span>            :                 &quot;argument %u of %&lt;__builtin_tgmath%&gt; is not a function pointer&quot;,
<span class="lineNum">    7724 </span><span class="lineCov">        125 :                 pos);</span>
<span class="lineNum">    7725 </span>            :       return 0;
<span class="lineNum">    7726 </span><span class="lineCov">          4 :     }</span>
<span class="lineNum">    7727 </span>            :   type = TREE_TYPE (type);
<span class="lineNum">    7728 </span>            :   if (!prototype_p (type))
<span class="lineNum">    7729 </span><span class="lineCov">          4 :     {</span>
<span class="lineNum">    7730 </span>            :       error_at (expr-&gt;get_location (),
<span class="lineNum">    7731 </span>            :                 &quot;argument %u of %&lt;__builtin_tgmath%&gt; is unprototyped&quot;, pos);
<span class="lineNum">    7732 </span><span class="lineCov">        121 :       return 0;</span>
<span class="lineNum">    7733 </span>            :     }
<span class="lineNum">    7734 </span>            :   if (stdarg_p (type))
<span class="lineNum">    7735 </span>            :     {
<span class="lineNum">    7736 </span>            :       error_at (expr-&gt;get_location (),
<span class="lineNum">    7737 </span>            :                 &quot;argument %u of %&lt;__builtin_tgmath%&gt; has variable arguments&quot;,
<span class="lineNum">    7738 </span>            :                 pos);
<span class="lineNum">    7739 </span>            :       return 0;
<span class="lineNum">    7740 </span>            :     }
<span class="lineNum">    7741 </span><span class="lineCov">       1659 :   unsigned int nargs = 0;</span>
<span class="lineNum">    7742 </span>            :   function_args_iterator iter;
<span class="lineNum">    7743 </span><span class="lineCov">       1659 :   tree t;</span>
<span class="lineNum">    7744 </span><span class="lineCov">       1659 :   FOREACH_FUNCTION_ARGS (type, t, iter)</span>
<span class="lineNum">    7745 </span>            :     {
<span class="lineNum">    7746 </span><span class="lineCov">          2 :       if (t == void_type_node)</span>
<span class="lineNum">    7747 </span>            :         break;
<span class="lineNum">    7748 </span>            :       nargs++;
<span class="lineNum">    7749 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">    7750 </span>            :   if (nargs == 0)
<span class="lineNum">    7751 </span><span class="lineCov">       1657 :     {</span>
<span class="lineNum">    7752 </span><span class="lineCov">       1657 :       error_at (expr-&gt;get_location (),</span>
<span class="lineNum">    7753 </span>            :                 &quot;argument %u of %&lt;__builtin_tgmath%&gt; has no arguments&quot;, pos);
<span class="lineNum">    7754 </span><span class="lineCov">          2 :       return 0;</span>
<span class="lineNum">    7755 </span>            :     }
<span class="lineNum">    7756 </span><span class="lineCov">          2 :   return nargs;</span>
<span class="lineNum">    7757 </span>            : }
<span class="lineNum">    7758 </span><span class="lineCov">       1655 : </span>
<span class="lineNum">    7759 </span>            : /* Ways in which a parameter or return value of a type-generic macro
<span class="lineNum">    7760 </span><span class="lineCov">          2 :    may vary between the different functions the macro may call.  */</span>
<span class="lineNum">    7761 </span>            : enum tgmath_parm_kind
<span class="lineNum">    7762 </span>            :   {
<span class="lineNum">    7763 </span><span class="lineCov">          2 :     tgmath_fixed, tgmath_real, tgmath_complex</span>
<span class="lineNum">    7764 </span>            :   };
<span class="lineNum">    7765 </span><span class="lineCov">       1653 : </span>
<span class="lineNum">    7766 </span><span class="lineCov">       1653 : /* Parse a postfix expression (C90 6.3.1-6.3.2, C99 6.5.1-6.5.2,</span>
<span class="lineNum">    7767 </span><span class="lineCov">       1653 :    C11 6.5.1-6.5.2).  Compound literals aren't handled here; callers have to</span>
<span class="lineNum">    7768 </span><span class="lineCov">       3888 :    call c_parser_postfix_expression_after_paren_type on encountering them.</span>
<span class="lineNum">    7769 </span>            : 
<span class="lineNum">    7770 </span><span class="lineCov">       3888 :    postfix-expression:</span>
<span class="lineNum">    7771 </span>            :      primary-expression
<span class="lineNum">    7772 </span><span class="lineCov">       2235 :      postfix-expression [ expression ]</span>
<span class="lineNum">    7773 </span>            :      postfix-expression ( argument-expression-list[opt] )
<span class="lineNum">    7774 </span><span class="lineCov">       1653 :      postfix-expression . identifier</span>
<span class="lineNum">    7775 </span>            :      postfix-expression -&gt; identifier
<span class="lineNum">    7776 </span><span class="lineCov">          2 :      postfix-expression ++</span>
<span class="lineNum">    7777 </span>            :      postfix-expression --
<span class="lineNum">    7778 </span><span class="lineCov">          2 :      ( type-name ) { initializer-list }</span>
<span class="lineNum">    7779 </span>            :      ( type-name ) { initializer-list , }
<span class="lineNum">    7780 </span>            : 
<span class="lineNum">    7781 </span>            :    argument-expression-list:
<span class="lineNum">    7782 </span>            :      argument-expression
<span class="lineNum">    7783 </span>            :      argument-expression-list , argument-expression
<span class="lineNum">    7784 </span>            : 
<span class="lineNum">    7785 </span>            :    primary-expression:
<span class="lineNum">    7786 </span>            :      identifier
<span class="lineNum">    7787 </span>            :      constant
<span class="lineNum">    7788 </span>            :      string-literal
<span class="lineNum">    7789 </span>            :      ( expression )
<span class="lineNum">    7790 </span>            :      generic-selection
<span class="lineNum">    7791 </span>            : 
<span class="lineNum">    7792 </span>            :    GNU extensions:
<span class="lineNum">    7793 </span>            : 
<span class="lineNum">    7794 </span>            :    primary-expression:
<span class="lineNum">    7795 </span>            :      __func__
<span class="lineNum">    7796 </span>            :        (treated as a keyword in GNU C)
<span class="lineNum">    7797 </span>            :      __FUNCTION__
<span class="lineNum">    7798 </span>            :      __PRETTY_FUNCTION__
<span class="lineNum">    7799 </span>            :      ( compound-statement )
<span class="lineNum">    7800 </span>            :      __builtin_va_arg ( assignment-expression , type-name )
<span class="lineNum">    7801 </span>            :      __builtin_offsetof ( type-name , offsetof-member-designator )
<span class="lineNum">    7802 </span>            :      __builtin_choose_expr ( assignment-expression ,
<span class="lineNum">    7803 </span>            :                              assignment-expression ,
<span class="lineNum">    7804 </span>            :                              assignment-expression )
<span class="lineNum">    7805 </span>            :      __builtin_types_compatible_p ( type-name , type-name )
<span class="lineNum">    7806 </span>            :      __builtin_tgmath ( expr-list )
<span class="lineNum">    7807 </span>            :      __builtin_complex ( assignment-expression , assignment-expression )
<span class="lineNum">    7808 </span>            :      __builtin_shuffle ( assignment-expression , assignment-expression )
<span class="lineNum">    7809 </span>            :      __builtin_shuffle ( assignment-expression ,
<span class="lineNum">    7810 </span>            :                          assignment-expression ,
<span class="lineNum">    7811 </span>            :                          assignment-expression, )
<span class="lineNum">    7812 </span>            : 
<span class="lineNum">    7813 </span>            :    offsetof-member-designator:
<span class="lineNum">    7814 </span>            :      identifier
<span class="lineNum">    7815 </span>            :      offsetof-member-designator . identifier
<span class="lineNum">    7816 </span>            :      offsetof-member-designator [ expression ]
<span class="lineNum">    7817 </span>            : 
<span class="lineNum">    7818 </span>            :    Objective-C:
<span class="lineNum">    7819 </span>            : 
<span class="lineNum">    7820 </span>            :    primary-expression:
<span class="lineNum">    7821 </span>            :      [ objc-receiver objc-message-args ]
<span class="lineNum">    7822 </span>            :      @selector ( objc-selector-arg )
<span class="lineNum">    7823 </span>            :      @protocol ( identifier )
<span class="lineNum">    7824 </span>            :      @encode ( type-name )
<span class="lineNum">    7825 </span>            :      objc-string-literal
<span class="lineNum">    7826 </span>            :      Classname . identifier
<span class="lineNum">    7827 </span>            : */
<a name="7828"><span class="lineNum">    7828 </span>            : </a>
<span class="lineNum">    7829 </span>            : static struct c_expr
<span class="lineNum">    7830 </span>            : c_parser_postfix_expression (c_parser *parser)
<span class="lineNum">    7831 </span>            : {
<span class="lineNum">    7832 </span>            :   struct c_expr expr, e1;
<span class="lineNum">    7833 </span>            :   struct c_type_name *t1, *t2;
<span class="lineNum">    7834 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    7835 </span>            :   source_range tok_range = c_parser_peek_token (parser)-&gt;get_range ();
<span class="lineNum">    7836 </span>            :   expr.original_code = ERROR_MARK;
<span class="lineNum">    7837 </span>            :   expr.original_type = NULL;
<span class="lineNum">    7838 </span>            :   switch (c_parser_peek_token (parser)-&gt;type)
<span class="lineNum">    7839 </span>            :     {
<span class="lineNum">    7840 </span>            :     case CPP_NUMBER:
<span class="lineNum">    7841 </span>            :       expr.value = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    7842 </span>            :       set_c_expr_source_range (&amp;expr, tok_range);
<span class="lineNum">    7843 </span>            :       loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    7844 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    7845 </span>            :       if (TREE_CODE (expr.value) == FIXED_CST
<span class="lineNum">    7846 </span>            :           &amp;&amp; !targetm.fixed_point_supported_p ())
<span class="lineNum">    7847 </span>            :         {
<span class="lineNum">    7848 </span>            :           error_at (loc, &quot;fixed-point types not supported for this target&quot;);
<span class="lineNum">    7849 </span>            :           expr.set_error ();
<span class="lineNum">    7850 </span>            :         }
<span class="lineNum">    7851 </span>            :       break;
<span class="lineNum">    7852 </span>            :     case CPP_CHAR:
<span class="lineNum">    7853 </span>            :     case CPP_CHAR16:
<span class="lineNum">    7854 </span><span class="lineCov">  112457028 :     case CPP_CHAR32:</span>
<span class="lineNum">    7855 </span>            :     case CPP_WCHAR:
<span class="lineNum">    7856 </span><span class="lineCov">  112457028 :       expr.value = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">    7857 </span><span class="lineCov">  112457028 :       /* For the purpose of warning when a pointer is compared with</span>
<span class="lineNum">    7858 </span><span class="lineCov">  112457028 :          a zero character constant.  */</span>
<span class="lineNum">    7859 </span><span class="lineCov">  112457028 :       expr.original_type = char_type_node;</span>
<span class="lineNum">    7860 </span><span class="lineCov">  112457028 :       set_c_expr_source_range (&amp;expr, tok_range);</span>
<span class="lineNum">    7861 </span><span class="lineCov">  112457028 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    7862 </span><span class="lineCov">  112457028 :       break;</span>
<span class="lineNum">    7863 </span>            :     case CPP_STRING:
<span class="lineNum">    7864 </span><span class="lineCov">   20011873 :     case CPP_STRING16:</span>
<span class="lineNum">    7865 </span><span class="lineCov">   20011873 :     case CPP_STRING32:</span>
<span class="lineNum">    7866 </span><span class="lineCov">   20011873 :     case CPP_WSTRING:</span>
<span class="lineNum">    7867 </span><span class="lineCov">   20011873 :     case CPP_UTF8STRING:</span>
<span class="lineNum">    7868 </span><span class="lineCov">   20011873 :       expr.value = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">    7869 </span><span class="lineCov">   20011873 :       set_c_expr_source_range (&amp;expr, tok_range);</span>
<span class="lineNum">    7870 </span><span class="lineCov">   20011873 :       expr.original_code = STRING_CST;</span>
<span class="lineNum">    7871 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    7872 </span><span class="lineCov">          5 :       break;</span>
<span class="lineNum">    7873 </span><span class="lineCov">          5 :     case CPP_OBJC_STRING:</span>
<span class="lineNum">    7874 </span>            :       gcc_assert (c_dialect_objc ());
<span class="lineNum">    7875 </span>            :       expr.value
<span class="lineNum">    7876 </span><span class="lineCov">      45443 :         = objc_build_string_object (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">    7877 </span><span class="lineCov">      45443 :       set_c_expr_source_range (&amp;expr, tok_range);</span>
<span class="lineNum">    7878 </span><span class="lineCov">      45443 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    7879 </span><span class="lineCov">      45443 :       break;</span>
<span class="lineNum">    7880 </span><span class="lineCov">      45443 :     case CPP_NAME:</span>
<span class="lineNum">    7881 </span>            :       switch (c_parser_peek_token (parser)-&gt;id_kind)
<span class="lineNum">    7882 </span>            :         {
<span class="lineNum">    7883 </span><span class="lineCov">      45443 :         case C_ID_ID:</span>
<span class="lineNum">    7884 </span><span class="lineCov">      45443 :           {</span>
<span class="lineNum">    7885 </span><span class="lineCov">      45443 :             tree id = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">    7886 </span><span class="lineCov">      45443 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    7887 </span><span class="lineCov">     838627 :             expr.value = build_external_ref (loc, id,</span>
<span class="lineNum">    7888 </span><span class="lineCov">     838627 :                                              (c_parser_peek_token (parser)-&gt;type</span>
<span class="lineNum">    7889 </span><span class="lineCov">     838627 :                                               == CPP_OPEN_PAREN),</span>
<span class="lineNum">    7890 </span><span class="lineCov">     838627 :                                              &amp;expr.original_type);</span>
<span class="lineNum">    7891 </span><span class="lineCov">     838627 :             set_c_expr_source_range (&amp;expr, tok_range);</span>
<span class="lineNum">    7892 </span><span class="lineCov">     838627 :             break;</span>
<span class="lineNum">    7893 </span><span class="lineCov">     838627 :           }</span>
<span class="lineNum">    7894 </span><span class="lineCov">     838627 :         case C_ID_CLASSNAME:</span>
<span class="lineNum">    7895 </span><span class="lineCov">     838627 :           {</span>
<span class="lineNum">    7896 </span><span class="lineCov">     838627 :             /* Here we parse the Objective-C 2.0 Class.name dot</span>
<span class="lineNum">    7897 </span><span class="lineNoCov">          0 :                syntax.  */</span>
<span class="lineNum">    7898 </span><span class="lineNoCov">          0 :             tree class_name = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">    7899 </span><span class="lineNoCov">          0 :             tree component;</span>
<span class="lineNum">    7900 </span><span class="lineNoCov">          0 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    7901 </span><span class="lineNoCov">          0 :             gcc_assert (c_dialect_objc ());</span>
<span class="lineNum">    7902 </span><span class="lineNoCov">          0 :             if (!c_parser_require (parser, CPP_DOT, &quot;expected %&lt;.%&gt;&quot;))</span>
<span class="lineNum">    7903 </span><span class="lineNoCov">          0 :               {</span>
<span class="lineNum">    7904 </span><span class="lineCov">   86488530 :                 expr.set_error ();</span>
<span class="lineNum">    7905 </span><span class="lineCov">   86488530 :                 break;</span>
<span class="lineNum">    7906 </span>            :               }
<span class="lineNum">    7907 </span><span class="lineCov">   86488529 :             if (c_parser_next_token_is_not (parser, CPP_NAME))</span>
<span class="lineNum">    7908 </span><span class="lineCov">   86488529 :               {</span>
<span class="lineNum">    7909 </span><span class="lineCov">   86488529 :                 c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">    7910 </span><span class="lineCov">   86488529 :                 expr.set_error ();</span>
<span class="lineNum">    7911 </span><span class="lineCov">  259465587 :                 break;</span>
<span class="lineNum">    7912 </span><span class="lineCov">   86488529 :               }</span>
<span class="lineNum">    7913 </span>            :             c_token *component_tok = c_parser_peek_token (parser);
<span class="lineNum">    7914 </span>            :             component = component_tok-&gt;value;
<span class="lineNum">    7915 </span><span class="lineCov">   86488529 :             location_t end_loc = component_tok-&gt;get_finish ();</span>
<span class="lineNum">    7916 </span><span class="lineCov">   86488529 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    7917 </span>            :             expr.value = objc_build_class_component_ref (class_name, 
<span class="lineNum">    7918 </span><span class="lineNoCov">          0 :                                                          component);</span>
<span class="lineNum">    7919 </span><span class="lineNoCov">          0 :             set_c_expr_source_range (&amp;expr, loc, end_loc);</span>
<span class="lineNum">    7920 </span>            :             break;
<span class="lineNum">    7921 </span>            :           }
<span class="lineNum">    7922 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    7923 </span><span class="lineNoCov">          0 :           c_parser_error (parser, &quot;expected expression&quot;);</span>
<span class="lineNum">    7924 </span><span class="lineNoCov">          0 :           expr.set_error ();</span>
<span class="lineNum">    7925 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7926 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    7927 </span>            :       break;
<span class="lineNum">    7928 </span><span class="lineNoCov">          0 :     case CPP_OPEN_PAREN:</span>
<span class="lineNum">    7929 </span>            :       /* A parenthesized expression, statement expression or compound
<span class="lineNum">    7930 </span>            :          literal.  */
<span class="lineNum">    7931 </span><span class="lineNoCov">          0 :       if (c_parser_peek_2nd_token (parser)-&gt;type == CPP_OPEN_BRACE)</span>
<span class="lineNum">    7932 </span>            :         {
<span class="lineNum">    7933 </span><span class="lineNoCov">          0 :           /* A statement expression.  */</span>
<span class="lineNum">    7934 </span><span class="lineNoCov">          0 :           tree stmt;</span>
<span class="lineNum">    7935 </span>            :           location_t brace_loc;
<span class="lineNum">    7936 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    7937 </span><span class="lineNoCov">          0 :           brace_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7938 </span><span class="lineNoCov">          0 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    7939 </span><span class="lineNoCov">          0 :           /* If we've not yet started the current function's statement list,</span>
<span class="lineNum">    7940 </span><span class="lineNoCov">          0 :              or we're in the parameter scope of an old-style function</span>
<span class="lineNum">    7941 </span><span class="lineNoCov">          0 :              declaration, statement expressions are not allowed.  */</span>
<span class="lineNum">    7942 </span>            :           if (!building_stmt_list_p () || old_style_parameter_scope ())
<span class="lineNum">    7943 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">    7944 </span><span class="lineNoCov">          0 :               error_at (loc, &quot;braced-group within expression allowed &quot;</span>
<span class="lineNum">    7945 </span>            :                         &quot;only inside a function&quot;);
<span class="lineNum">    7946 </span><span class="lineCov">          1 :               parser-&gt;error = true;</span>
<span class="lineNum">    7947 </span><span class="lineCov">          1 :               c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, NULL);</span>
<span class="lineNum">    7948 </span><span class="lineCov">          1 :               c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);</span>
<span class="lineNum">    7949 </span>            :               expr.set_error ();
<span class="lineNum">    7950 </span>            :               break;
<span class="lineNum">    7951 </span>            :             }
<span class="lineNum">    7952 </span><span class="lineCov">    4822008 :           stmt = c_begin_stmt_expr ();</span>
<span class="lineNum">    7953 </span>            :           c_parser_compound_statement_nostart (parser);
<span class="lineNum">    7954 </span>            :           location_t close_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    7955 </span><span class="lineCov">    4822008 :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,</span>
<span class="lineNum">    7956 </span>            :                                      &quot;expected %&lt;)%&gt;&quot;);
<span class="lineNum">    7957 </span>            :           pedwarn (loc, OPT_Wpedantic,
<span class="lineNum">    7958 </span><span class="lineCov">      29133 :                    &quot;ISO C forbids braced-groups within expressions&quot;);</span>
<span class="lineNum">    7959 </span><span class="lineCov">      29133 :           expr.value = c_finish_stmt_expr (brace_loc, stmt);</span>
<span class="lineNum">    7960 </span><span class="lineCov">      29133 :           set_c_expr_source_range (&amp;expr, loc, close_loc);</span>
<span class="lineNum">    7961 </span><span class="lineCov">      29133 :           mark_exp_read (expr.value);</span>
<span class="lineNum">    7962 </span><span class="lineCov">      29133 :         }</span>
<span class="lineNum">    7963 </span>            :       else
<span class="lineNum">    7964 </span>            :         {
<span class="lineNum">    7965 </span>            :           /* A parenthesized expression.  */
<span class="lineNum">    7966 </span><span class="lineCov">      29133 :           location_t loc_open_paren = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    7967 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    7968 </span><span class="lineCov">         24 :           expr = c_parser_expression (parser);</span>
<span class="lineNum">    7969 </span>            :           if (TREE_CODE (expr.value) == MODIFY_EXPR)
<span class="lineNum">    7970 </span><span class="lineCov">         24 :             TREE_NO_WARNING (expr.value) = 1;</span>
<span class="lineNum">    7971 </span><span class="lineCov">         24 :           if (expr.original_code != C_MAYBE_CONST_EXPR</span>
<span class="lineNum">    7972 </span><span class="lineCov">         24 :               &amp;&amp; expr.original_code != SIZEOF_EXPR)</span>
<span class="lineNum">    7973 </span><span class="lineCov">         24 :             expr.original_code = ERROR_MARK;</span>
<span class="lineNum">    7974 </span>            :           /* Don't change EXPR.ORIGINAL_TYPE.  */
<span class="lineNum">    7975 </span>            :           location_t loc_close_paren = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    7976 </span><span class="lineCov">      29109 :           set_c_expr_source_range (&amp;expr, loc_open_paren, loc_close_paren);</span>
<span class="lineNum">    7977 </span><span class="lineCov">      29109 :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,</span>
<span class="lineNum">    7978 </span><span class="lineCov">      29109 :                                      &quot;expected %&lt;)%&gt;&quot;, loc_open_paren);</span>
<span class="lineNum">    7979 </span><span class="lineCov">      29109 :         }</span>
<span class="lineNum">    7980 </span>            :       break;
<span class="lineNum">    7981 </span><span class="lineCov">      29109 :     case CPP_KEYWORD:</span>
<span class="lineNum">    7982 </span>            :       switch (c_parser_peek_token (parser)-&gt;keyword)
<span class="lineNum">    7983 </span><span class="lineCov">      29109 :         {</span>
<span class="lineNum">    7984 </span><span class="lineCov">      29109 :         case RID_FUNCTION_NAME:</span>
<span class="lineNum">    7985 </span><span class="lineCov">      29109 :           pedwarn (loc, OPT_Wpedantic,  &quot;ISO C does not support &quot;</span>
<span class="lineNum">    7986 </span>            :                    &quot;%&lt;__FUNCTION__%&gt; predefined identifier&quot;);
<span class="lineNum">    7987 </span>            :           expr.value = fname_decl (loc,
<span class="lineNum">    7988 </span>            :                                    c_parser_peek_token (parser)-&gt;keyword,
<span class="lineNum">    7989 </span>            :                                    c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">    7990 </span><span class="lineCov">    4792875 :           set_c_expr_source_range (&amp;expr, loc, loc);</span>
<span class="lineNum">    7991 </span><span class="lineCov">    4792875 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    7992 </span><span class="lineCov">    4792875 :           break;</span>
<span class="lineNum">    7993 </span><span class="lineCov">    4792875 :         case RID_PRETTY_FUNCTION_NAME:</span>
<span class="lineNum">    7994 </span><span class="lineCov">      25794 :           pedwarn (loc, OPT_Wpedantic,  &quot;ISO C does not support &quot;</span>
<span class="lineNum">    7995 </span><span class="lineCov">    4792875 :                    &quot;%&lt;__PRETTY_FUNCTION__%&gt; predefined identifier&quot;);</span>
<span class="lineNum">    7996 </span><span class="lineCov">    4792863 :           expr.value = fname_decl (loc,</span>
<span class="lineNum">    7997 </span><span class="lineCov">    4788822 :                                    c_parser_peek_token (parser)-&gt;keyword,</span>
<span class="lineNum">    7998 </span>            :                                    c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">    7999 </span><span class="lineCov">    4792875 :           set_c_expr_source_range (&amp;expr, loc, loc);</span>
<span class="lineNum">    8000 </span><span class="lineCov">    4792875 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    8001 </span><span class="lineCov">    4792875 :           break;</span>
<span class="lineNum">    8002 </span>            :         case RID_C99_FUNCTION_NAME:
<span class="lineNum">    8003 </span>            :           pedwarn_c90 (loc, OPT_Wpedantic,  &quot;ISO C90 does not support &quot;
<span class="lineNum">    8004 </span>            :                    &quot;%&lt;__func__%&gt; predefined identifier&quot;);
<span class="lineNum">    8005 </span><span class="lineCov">     250140 :           expr.value = fname_decl (loc,</span>
<span class="lineNum">    8006 </span><span class="lineCov">     250140 :                                    c_parser_peek_token (parser)-&gt;keyword,</span>
<span class="lineNum">    8007 </span>            :                                    c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">    8008 </span><span class="lineCov">        495 :           set_c_expr_source_range (&amp;expr, loc, loc);</span>
<span class="lineNum">    8009 </span><span class="lineCov">        495 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    8010 </span>            :           break;
<span class="lineNum">    8011 </span><span class="lineCov">       1980 :         case RID_VA_ARG:</span>
<span class="lineNum">    8012 </span><span class="lineCov">        495 :           {</span>
<span class="lineNum">    8013 </span><span class="lineCov">        495 :             location_t start_loc = loc;</span>
<span class="lineNum">    8014 </span><span class="lineCov">        495 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    8015 </span><span class="lineCov">        495 :             matching_parens parens;</span>
<span class="lineNum">    8016 </span><span class="lineCov">        495 :             if (!parens.require_open (parser))</span>
<span class="lineNum">    8017 </span><span class="lineCov">       1746 :               {</span>
<span class="lineNum">    8018 </span><span class="lineCov">       1746 :                 expr.set_error ();</span>
<span class="lineNum">    8019 </span>            :                 break;
<span class="lineNum">    8020 </span><span class="lineCov">       6984 :               }</span>
<span class="lineNum">    8021 </span><span class="lineCov">       1746 :             e1 = c_parser_expr_no_commas (parser, NULL);</span>
<span class="lineNum">    8022 </span><span class="lineCov">       1746 :             mark_exp_read (e1.value);</span>
<span class="lineNum">    8023 </span><span class="lineCov">       1746 :             e1.value = c_fully_fold (e1.value, false, NULL);</span>
<span class="lineNum">    8024 </span><span class="lineCov">       1746 :             if (!c_parser_require (parser, CPP_COMMA, &quot;expected %&lt;,%&gt;&quot;))</span>
<span class="lineNum">    8025 </span><span class="lineCov">       1746 :               {</span>
<span class="lineNum">    8026 </span><span class="lineCov">       2759 :                 c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);</span>
<span class="lineNum">    8027 </span><span class="lineCov">       2759 :                 expr.set_error ();</span>
<span class="lineNum">    8028 </span>            :                 break;
<span class="lineNum">    8029 </span><span class="lineCov">      11036 :               }</span>
<span class="lineNum">    8030 </span><span class="lineCov">       2759 :             loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    8031 </span><span class="lineCov">       2759 :             t1 = c_parser_type_name (parser);</span>
<span class="lineNum">    8032 </span><span class="lineCov">       2759 :             location_t end_loc = c_parser_peek_token (parser)-&gt;get_finish ();</span>
<span class="lineNum">    8033 </span><span class="lineCov">       2759 :             c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,</span>
<span class="lineNum">    8034 </span><span class="lineCov">       2759 :                                        &quot;expected %&lt;)%&gt;&quot;);</span>
<span class="lineNum">    8035 </span><span class="lineCov">      18822 :             if (t1 == NULL)</span>
<span class="lineNum">    8036 </span><span class="lineCov">      18822 :               {</span>
<span class="lineNum">    8037 </span><span class="lineCov">      18822 :                 expr.set_error ();</span>
<span class="lineNum">    8038 </span><span class="lineCov">      18822 :               }</span>
<span class="lineNum">    8039 </span><span class="lineCov">      37644 :             else</span>
<span class="lineNum">    8040 </span><span class="lineCov">      18822 :               {</span>
<span class="lineNum">    8041 </span>            :                 tree type_expr = NULL_TREE;
<span class="lineNum">    8042 </span><span class="lineNoCov">          0 :                 expr.value = c_build_va_arg (start_loc, e1.value, loc,</span>
<span class="lineNum">    8043 </span>            :                                              groktypename (t1, &amp;type_expr, NULL));
<span class="lineNum">    8044 </span>            :                 if (type_expr)
<span class="lineNum">    8045 </span><span class="lineCov">      18822 :                   {</span>
<span class="lineNum">    8046 </span><span class="lineCov">      18822 :                     expr.value = build2 (C_MAYBE_CONST_EXPR,</span>
<span class="lineNum">    8047 </span><span class="lineCov">      18822 :                                          TREE_TYPE (expr.value), type_expr,</span>
<span class="lineNum">    8048 </span><span class="lineCov">      18822 :                                          expr.value);</span>
<span class="lineNum">    8049 </span>            :                     C_MAYBE_CONST_EXPR_NON_CONST (expr.value) = true;
<span class="lineNum">    8050 </span><span class="lineNoCov">          0 :                   }</span>
<span class="lineNum">    8051 </span><span class="lineNoCov">          0 :                 set_c_expr_source_range (&amp;expr, start_loc, end_loc);</span>
<span class="lineNum">    8052 </span>            :               }
<span class="lineNum">    8053 </span>            :           }
<span class="lineNum">    8054 </span><span class="lineCov">      18822 :           break;</span>
<span class="lineNum">    8055 </span><span class="lineCov">      18822 :         case RID_OFFSETOF:</span>
<span class="lineNum">    8056 </span><span class="lineCov">      18822 :           {</span>
<span class="lineNum">    8057 </span><span class="lineCov">      18822 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    8058 </span>            :             matching_parens parens;
<span class="lineNum">    8059 </span><span class="lineCov">      18822 :             if (!parens.require_open (parser))</span>
<span class="lineNum">    8060 </span>            :               {
<span class="lineNum">    8061 </span><span class="lineNoCov">          0 :                 expr.set_error ();</span>
<span class="lineNum">    8062 </span>            :                 break;
<span class="lineNum">    8063 </span>            :               }
<span class="lineNum">    8064 </span>            :             t1 = c_parser_type_name (parser);
<span class="lineNum">    8065 </span><span class="lineCov">      18822 :             if (t1 == NULL)</span>
<span class="lineNum">    8066 </span><span class="lineCov">      18822 :               parser-&gt;error = true;</span>
<span class="lineNum">    8067 </span>            :             if (!c_parser_require (parser, CPP_COMMA, &quot;expected %&lt;,%&gt;&quot;))
<span class="lineNum">    8068 </span><span class="lineCov">      18822 :               gcc_assert (parser-&gt;error);</span>
<span class="lineNum">    8069 </span>            :             if (parser-&gt;error)
<span class="lineNum">    8070 </span><span class="lineCov">         72 :               {</span>
<span class="lineNum">    8071 </span><span class="lineCov">         24 :                 c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);</span>
<span class="lineNum">    8072 </span>            :                 expr.set_error ();
<span class="lineNum">    8073 </span><span class="lineCov">         24 :                 break;</span>
<span class="lineNum">    8074 </span>            :               }
<span class="lineNum">    8075 </span><span class="lineCov">      18822 :             tree type = groktypename (t1, NULL, NULL);</span>
<span class="lineNum">    8076 </span><span class="lineNoCov">          0 :             tree offsetof_ref;</span>
<span class="lineNum">    8077 </span>            :             if (type == error_mark_node)
<span class="lineNum">    8078 </span><span class="lineCov">      18822 :               offsetof_ref = error_mark_node;</span>
<span class="lineNum">    8079 </span><span class="lineCov">        859 :             else</span>
<span class="lineNum">    8080 </span><span class="lineCov">        859 :               {</span>
<span class="lineNum">    8081 </span><span class="lineCov">        859 :                 offsetof_ref = build1 (INDIRECT_REF, type, null_pointer_node);</span>
<span class="lineNum">    8082 </span><span class="lineCov">       1718 :                 SET_EXPR_LOCATION (offsetof_ref, loc);</span>
<span class="lineNum">    8083 </span><span class="lineCov">        859 :               }</span>
<span class="lineNum">    8084 </span>            :             /* Parse the second argument to __builtin_offsetof.  We
<span class="lineNum">    8085 </span><span class="lineNoCov">          0 :                must have one identifier, and beyond that we want to</span>
<span class="lineNum">    8086 </span><span class="lineCov">          1 :                accept sub structure and sub array references.  */</span>
<span class="lineNum">    8087 </span>            :             if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">    8088 </span><span class="lineCov">        859 :               {</span>
<span class="lineNum">    8089 </span><span class="lineCov">        859 :                 c_token *comp_tok = c_parser_peek_token (parser);</span>
<span class="lineNum">    8090 </span><span class="lineNoCov">          0 :                 offsetof_ref = build_component_ref</span>
<span class="lineNum">    8091 </span><span class="lineCov">        859 :                   (loc, offsetof_ref, comp_tok-&gt;value, comp_tok-&gt;location);</span>
<span class="lineNum">    8092 </span><span class="lineCov">          1 :                 c_parser_consume_token (parser);</span>
<span class="lineNum">    8093 </span><span class="lineCov">        859 :                 while (c_parser_next_token_is (parser, CPP_DOT)</span>
<span class="lineNum">    8094 </span>            :                        || c_parser_next_token_is (parser,
<span class="lineNum">    8095 </span><span class="lineCov">          1 :                                                   CPP_OPEN_SQUARE)</span>
<span class="lineNum">    8096 </span><span class="lineCov">          1 :                        || c_parser_next_token_is (parser,</span>
<span class="lineNum">    8097 </span>            :                                                   CPP_DEREF))
<span class="lineNum">    8098 </span>            :                   {
<span class="lineNum">    8099 </span><span class="lineCov">        858 :                     if (c_parser_next_token_is (parser, CPP_DEREF))</span>
<span class="lineNum">    8100 </span><span class="lineCov">        858 :                       {</span>
<span class="lineNum">    8101 </span><span class="lineCov">        858 :                         loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    8102 </span>            :                         offsetof_ref = build_array_ref (loc,
<span class="lineNum">    8103 </span>            :                                                         offsetof_ref,
<span class="lineNum">    8104 </span>            :                                                         integer_zero_node);
<span class="lineNum">    8105 </span><span class="lineCov">        857 :                         goto do_dot;</span>
<span class="lineNum">    8106 </span><span class="lineCov">        857 :                       }</span>
<span class="lineNum">    8107 </span>            :                     else if (c_parser_next_token_is (parser, CPP_DOT))
<span class="lineNum">    8108 </span>            :                       {
<span class="lineNum">    8109 </span>            :                       do_dot:
<span class="lineNum">    8110 </span>            :                         c_parser_consume_token (parser);
<span class="lineNum">    8111 </span><span class="lineCov">        858 :                         if (c_parser_next_token_is_not (parser,</span>
<span class="lineNum">    8112 </span>            :                                                         CPP_NAME))
<span class="lineNum">    8113 </span><span class="lineCov">        858 :                           {</span>
<span class="lineNum">    8114 </span><span class="lineCov">       1716 :                             c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">    8115 </span><span class="lineCov">        858 :                             break;</span>
<span class="lineNum">    8116 </span><span class="lineCov">        858 :                           }</span>
<span class="lineNum">    8117 </span><span class="lineCov">       1388 :                         c_token *comp_tok = c_parser_peek_token (parser);</span>
<span class="lineNum">    8118 </span><span class="lineCov">       1278 :                         offsetof_ref = build_component_ref</span>
<span class="lineNum">    8119 </span>            :                           (loc, offsetof_ref, comp_tok-&gt;value,
<span class="lineNum">    8120 </span><span class="lineCov">       2247 :                            comp_tok-&gt;location);</span>
<span class="lineNum">    8121 </span>            :                         c_parser_consume_token (parser);
<span class="lineNum">    8122 </span>            :                       }
<span class="lineNum">    8123 </span><span class="lineCov">        530 :                     else</span>
<span class="lineNum">    8124 </span>            :                       {
<span class="lineNum">    8125 </span><span class="lineCov">          1 :                         struct c_expr ce;</span>
<span class="lineNum">    8126 </span><span class="lineCov">          1 :                         tree idx;</span>
<span class="lineNum">    8127 </span>            :                         loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    8128 </span>            :                         c_parser_consume_token (parser);
<span class="lineNum">    8129 </span><span class="lineCov">          1 :                         ce = c_parser_expression (parser);</span>
<span class="lineNum">    8130 </span>            :                         ce = convert_lvalue_to_rvalue (loc, ce, false, false);
<span class="lineNum">    8131 </span><span class="lineCov">        529 :                         idx = ce.value;</span>
<span class="lineNum">    8132 </span>            :                         idx = c_fully_fold (idx, false, NULL);
<span class="lineNum">    8133 </span><span class="lineCov">        110 :                         c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,</span>
<span class="lineNum">    8134 </span><span class="lineCov">        111 :                                                    &quot;expected %&lt;]%&gt;&quot;);</span>
<span class="lineNum">    8135 </span><span class="lineCov">        111 :                         offsetof_ref = build_array_ref (loc, offsetof_ref, idx);</span>
<span class="lineNum">    8136 </span>            :                       }
<span class="lineNum">    8137 </span>            :                   }
<span class="lineNum">    8138 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">    8139 </span><span class="lineNoCov">          0 :             else</span>
<span class="lineNum">    8140 </span>            :               c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">    8141 </span><span class="lineCov">        111 :             location_t end_loc = c_parser_peek_token (parser)-&gt;get_finish ();</span>
<span class="lineNum">    8142 </span><span class="lineCov">        222 :             c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,</span>
<span class="lineNum">    8143 </span><span class="lineCov">        111 :                                        &quot;expected %&lt;)%&gt;&quot;);</span>
<span class="lineNum">    8144 </span>            :             expr.value = fold_offsetof (offsetof_ref);
<span class="lineNum">    8145 </span><span class="lineCov">        111 :             set_c_expr_source_range (&amp;expr, loc, end_loc);</span>
<span class="lineNum">    8146 </span>            :           }
<span class="lineNum">    8147 </span>            :           break;
<span class="lineNum">    8148 </span>            :         case RID_CHOOSE_EXPR:
<span class="lineNum">    8149 </span><span class="lineCov">        419 :           {</span>
<span class="lineNum">    8150 </span><span class="lineCov">        419 :             vec&lt;c_expr_t, va_gc&gt; *cexpr_list;</span>
<span class="lineNum">    8151 </span><span class="lineCov">        419 :             c_expr_t *e1_p, *e2_p, *e3_p;</span>
<span class="lineNum">    8152 </span><span class="lineCov">        419 :             tree c;</span>
<span class="lineNum">    8153 </span><span class="lineCov">        419 :             location_t close_paren_loc;</span>
<span class="lineNum">    8154 </span><span class="lineCov">        419 : </span>
<span class="lineNum">    8155 </span><span class="lineCov">        419 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    8156 </span><span class="lineCov">        419 :             if (!c_parser_get_builtin_args (parser,</span>
<span class="lineNum">    8157 </span><span class="lineCov">        419 :                                             &quot;__builtin_choose_expr&quot;,</span>
<span class="lineNum">    8158 </span>            :                                             &amp;cexpr_list, true,
<span class="lineNum">    8159 </span><span class="lineCov">        419 :                                             &amp;close_paren_loc))</span>
<span class="lineNum">    8160 </span>            :               {
<span class="lineNum">    8161 </span>            :                 expr.set_error ();
<span class="lineNum">    8162 </span>            :                 break;
<span class="lineNum">    8163 </span>            :               }
<span class="lineNum">    8164 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    8165 </span><span class="lineCov">        858 :             if (vec_safe_length (cexpr_list) != 3)</span>
<span class="lineNum">    8166 </span><span class="lineCov">        858 :               {</span>
<span class="lineNum">    8167 </span>            :                 error_at (loc, &quot;wrong number of arguments to &quot;
<span class="lineNum">    8168 </span><span class="lineCov">        858 :                                &quot;%&lt;__builtin_choose_expr%&gt;&quot;);</span>
<span class="lineNum">    8169 </span><span class="lineCov">        859 :                 expr.set_error ();</span>
<span class="lineNum">    8170 </span>            :                 break;
<span class="lineNum">    8171 </span><span class="lineCov">        858 :               }</span>
<span class="lineNum">    8172 </span><span class="lineCov">       1073 : </span>
<span class="lineNum">    8173 </span><span class="lineCov">       1073 :             e1_p = &amp;(*cexpr_list)[0];</span>
<span class="lineNum">    8174 </span><span class="lineCov">       1073 :             e2_p = &amp;(*cexpr_list)[1];</span>
<span class="lineNum">    8175 </span><span class="lineCov">       1073 :             e3_p = &amp;(*cexpr_list)[2];</span>
<span class="lineNum">    8176 </span><span class="lineCov">       1073 : </span>
<span class="lineNum">    8177 </span><span class="lineCov">       1073 :             c = e1_p-&gt;value;</span>
<span class="lineNum">    8178 </span>            :             mark_exp_read (e2_p-&gt;value);
<span class="lineNum">    8179 </span><span class="lineCov">       1073 :             mark_exp_read (e3_p-&gt;value);</span>
<span class="lineNum">    8180 </span><span class="lineCov">       1073 :             if (TREE_CODE (c) != INTEGER_CST</span>
<span class="lineNum">    8181 </span>            :                 || !INTEGRAL_TYPE_P (TREE_TYPE (c)))
<span class="lineNum">    8182 </span>            :               error_at (loc,
<span class="lineNum">    8183 </span>            :                         &quot;first argument to %&lt;__builtin_choose_expr%&gt; not&quot;
<span class="lineNum">    8184 </span>            :                         &quot; a constant&quot;);
<span class="lineNum">    8185 </span><span class="lineNoCov">          0 :             constant_expression_warning (c);</span>
<span class="lineNum">    8186 </span>            :             expr = integer_zerop (c) ? *e3_p : *e2_p;
<span class="lineNum">    8187 </span>            :             set_c_expr_source_range (&amp;expr, loc, close_paren_loc);
<span class="lineNum">    8188 </span>            :             break;
<span class="lineNum">    8189 </span><span class="lineCov">       1073 :           }</span>
<span class="lineNum">    8190 </span>            :         case RID_TYPES_COMPATIBLE_P:
<span class="lineNum">    8191 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">    8192 </span>            :             c_parser_consume_token (parser);
<span class="lineNum">    8193 </span><span class="lineNoCov">          0 :             matching_parens parens;</span>
<span class="lineNum">    8194 </span>            :             if (!parens.require_open (parser))
<span class="lineNum">    8195 </span>            :               {
<span class="lineNum">    8196 </span>            :                 expr.set_error ();
<span class="lineNum">    8197 </span><span class="lineCov">       1073 :                 break;</span>
<span class="lineNum">    8198 </span><span class="lineCov">       1073 :               }</span>
<span class="lineNum">    8199 </span><span class="lineCov">       1073 :             t1 = c_parser_type_name (parser);</span>
<span class="lineNum">    8200 </span>            :             if (t1 == NULL)
<span class="lineNum">    8201 </span><span class="lineCov">       1073 :               {</span>
<span class="lineNum">    8202 </span><span class="lineCov">       1073 :                 expr.set_error ();</span>
<span class="lineNum">    8203 </span><span class="lineCov">       1073 :                 break;</span>
<span class="lineNum">    8204 </span><span class="lineCov">       1073 :               }</span>
<span class="lineNum">    8205 </span><span class="lineCov">       1073 :             if (!c_parser_require (parser, CPP_COMMA, &quot;expected %&lt;,%&gt;&quot;))</span>
<span class="lineNum">    8206 </span><span class="lineCov">          7 :               {</span>
<span class="lineNum">    8207 </span>            :                 c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
<span class="lineNum">    8208 </span>            :                 expr.set_error ();
<span class="lineNum">    8209 </span><span class="lineCov">       1073 :                 break;</span>
<span class="lineNum">    8210 </span><span class="lineCov">       1073 :               }</span>
<span class="lineNum">    8211 </span><span class="lineCov">       1073 :             t2 = c_parser_type_name (parser);</span>
<span class="lineNum">    8212 </span><span class="lineCov">       1073 :             if (t2 == NULL)</span>
<span class="lineNum">    8213 </span>            :               {
<span class="lineNum">    8214 </span><span class="lineCov">        591 :                 expr.set_error ();</span>
<span class="lineNum">    8215 </span><span class="lineCov">        591 :                 break;</span>
<span class="lineNum">    8216 </span><span class="lineCov">        591 :               }</span>
<span class="lineNum">    8217 </span><span class="lineCov">       1182 :             location_t close_paren_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    8218 </span><span class="lineCov">        591 :             parens.skip_until_found_close (parser);</span>
<span class="lineNum">    8219 </span>            :             tree e1, e2;
<span class="lineNum">    8220 </span><span class="lineNoCov">          0 :             e1 = groktypename (t1, NULL, NULL);</span>
<span class="lineNum">    8221 </span><span class="lineCov">          2 :             e2 = groktypename (t2, NULL, NULL);</span>
<span class="lineNum">    8222 </span>            :             if (e1 == error_mark_node || e2 == error_mark_node)
<span class="lineNum">    8223 </span><span class="lineCov">        591 :               {</span>
<span class="lineNum">    8224 </span><span class="lineCov">        591 :                 expr.set_error ();</span>
<span class="lineNum">    8225 </span>            :                 break;
<span class="lineNum">    8226 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">    8227 </span>            : 
<span class="lineNum">    8228 </span>            :             e1 = TYPE_MAIN_VARIANT (e1);
<span class="lineNum">    8229 </span><span class="lineCov">        591 :             e2 = TYPE_MAIN_VARIANT (e2);</span>
<span class="lineNum">    8230 </span>            : 
<span class="lineNum">    8231 </span><span class="lineCov">          1 :             expr.value</span>
<span class="lineNum">    8232 </span><span class="lineCov">          1 :               = comptypes (e1, e2) ? integer_one_node : integer_zero_node;</span>
<span class="lineNum">    8233 </span>            :             set_c_expr_source_range (&amp;expr, loc, close_paren_loc);
<span class="lineNum">    8234 </span>            :           }
<span class="lineNum">    8235 </span><span class="lineCov">        590 :           break;</span>
<span class="lineNum">    8236 </span><span class="lineCov">        590 :         case RID_BUILTIN_TGMATH:</span>
<span class="lineNum">    8237 </span>            :           {
<span class="lineNum">    8238 </span><span class="lineNoCov">          0 :             vec&lt;c_expr_t, va_gc&gt; *cexpr_list;</span>
<span class="lineNum">    8239 </span>            :             location_t close_paren_loc;
<span class="lineNum">    8240 </span>            : 
<span class="lineNum">    8241 </span><span class="lineCov">        590 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    8242 </span><span class="lineCov">        590 :             if (!c_parser_get_builtin_args (parser,</span>
<span class="lineNum">    8243 </span><span class="lineCov">        590 :                                             &quot;__builtin_tgmath&quot;,</span>
<span class="lineNum">    8244 </span><span class="lineCov">        590 :                                             &amp;cexpr_list, false,</span>
<span class="lineNum">    8245 </span><span class="lineCov">        590 :                                             &amp;close_paren_loc))</span>
<span class="lineNum">    8246 </span><span class="lineCov">        590 :               {</span>
<span class="lineNum">    8247 </span>            :                 expr.set_error ();
<span class="lineNum">    8248 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    8249 </span>            :               }
<span class="lineNum">    8250 </span>            : 
<span class="lineNum">    8251 </span>            :             if (vec_safe_length (cexpr_list) &lt; 3)
<span class="lineNum">    8252 </span><span class="lineCov">        589 :               {</span>
<span class="lineNum">    8253 </span><span class="lineCov">        589 :                 error_at (loc, &quot;too few arguments to %&lt;__builtin_tgmath%&gt;&quot;);</span>
<span class="lineNum">    8254 </span>            :                 expr.set_error ();
<span class="lineNum">    8255 </span><span class="lineCov">        589 :                 break;</span>
<span class="lineNum">    8256 </span><span class="lineCov">        589 :               }</span>
<span class="lineNum">    8257 </span><span class="lineCov">        591 : </span>
<span class="lineNum">    8258 </span>            :             unsigned int i;
<span class="lineNum">    8259 </span><span class="lineCov">        589 :             c_expr_t *p;</span>
<span class="lineNum">    8260 </span><span class="lineCov">        340 :             FOR_EACH_VEC_ELT (*cexpr_list, i, p)</span>
<span class="lineNum">    8261 </span><span class="lineCov">        340 :               *p = convert_lvalue_to_rvalue (loc, *p, true, true);</span>
<span class="lineNum">    8262 </span><span class="lineCov">        340 :             unsigned int nargs = check_tgmath_function (&amp;(*cexpr_list)[0], 1);</span>
<span class="lineNum">    8263 </span><span class="lineCov">        340 :             if (nargs == 0)</span>
<span class="lineNum">    8264 </span>            :               {
<span class="lineNum">    8265 </span><span class="lineCov">        340 :                 expr.set_error ();</span>
<span class="lineNum">    8266 </span><span class="lineCov">        340 :                 break;</span>
<span class="lineNum">    8267 </span>            :               }
<span class="lineNum">    8268 </span>            :             if (vec_safe_length (cexpr_list) &lt; nargs)
<span class="lineNum">    8269 </span>            :               {
<span class="lineNum">    8270 </span>            :                 error_at (loc, &quot;too few arguments to %&lt;__builtin_tgmath%&gt;&quot;);
<span class="lineNum">    8271 </span><span class="lineNoCov">          0 :                 expr.set_error ();</span>
<span class="lineNum">    8272 </span><span class="lineCov">        311 :                 break;</span>
<span class="lineNum">    8273 </span>            :               }
<span class="lineNum">    8274 </span>            :             unsigned int num_functions = vec_safe_length (cexpr_list) - nargs;
<span class="lineNum">    8275 </span><span class="lineCov">        340 :             if (num_functions &lt; 2)</span>
<span class="lineNum">    8276 </span>            :               {
<span class="lineNum">    8277 </span><span class="lineCov">          3 :                 error_at (loc, &quot;too few arguments to %&lt;__builtin_tgmath%&gt;&quot;);</span>
<span class="lineNum">    8278 </span><span class="lineCov">          3 :                 expr.set_error ();</span>
<span class="lineNum">    8279 </span>            :                 break;
<span class="lineNum">    8280 </span>            :               }
<span class="lineNum">    8281 </span>            : 
<span class="lineNum">    8282 </span>            :             /* The first NUM_FUNCTIONS expressions are the function
<span class="lineNum">    8283 </span>            :                pointers.  The remaining NARGS expressions are the
<span class="lineNum">    8284 </span><span class="lineCov">       2443 :                arguments that are to be passed to one of those</span>
<span class="lineNum">    8285 </span><span class="lineCov">       2106 :                functions, chosen following &lt;tgmath.h&gt; rules.  */</span>
<span class="lineNum">    8286 </span><span class="lineCov">        337 :             for (unsigned int j = 1; j &lt; num_functions; j++)</span>
<span class="lineNum">    8287 </span><span class="lineCov">        337 :               {</span>
<span class="lineNum">    8288 </span>            :                 unsigned int this_nargs
<span class="lineNum">    8289 </span><span class="lineCov">          4 :                   = check_tgmath_function (&amp;(*cexpr_list)[j], j + 1);</span>
<span class="lineNum">    8290 </span>            :                 if (this_nargs == 0)
<span class="lineNum">    8291 </span>            :                   {
<span class="lineNum">    8292 </span><span class="lineCov">        666 :                     expr.set_error ();</span>
<span class="lineNum">    8293 </span>            :                     goto out;
<span class="lineNum">    8294 </span><span class="lineCov">          1 :                   }</span>
<span class="lineNum">    8295 </span><span class="lineCov">          1 :                 if (this_nargs != nargs)</span>
<span class="lineNum">    8296 </span>            :                   {
<span class="lineNum">    8297 </span>            :                     error_at ((*cexpr_list)[j].get_location (),
<span class="lineNum">    8298 </span><span class="lineCov">        332 :                               &quot;argument %u of %&lt;__builtin_tgmath%&gt; has &quot;</span>
<span class="lineNum">    8299 </span><span class="lineCov">        332 :                               &quot;wrong number of arguments&quot;, j + 1);</span>
<span class="lineNum">    8300 </span>            :                     expr.set_error ();
<span class="lineNum">    8301 </span><span class="lineCov">          1 :                     goto out;</span>
<span class="lineNum">    8302 </span><span class="lineCov">          1 :                   }</span>
<span class="lineNum">    8303 </span>            :               }
<span class="lineNum">    8304 </span>            : 
<span class="lineNum">    8305 </span>            :             /* The functions all have the same number of arguments.
<span class="lineNum">    8306 </span>            :                Determine whether arguments and return types vary in
<span class="lineNum">    8307 </span>            :                ways permitted for &lt;tgmath.h&gt; functions.  */
<span class="lineNum">    8308 </span>            :             /* The first entry in each of these vectors is for the
<span class="lineNum">    8309 </span>            :                return type, subsequent entries for parameter
<span class="lineNum">    8310 </span><span class="lineCov">       1648 :                types.  */</span>
<span class="lineNum">    8311 </span>            :             auto_vec&lt;enum tgmath_parm_kind&gt; parm_kind (nargs + 1);
<span class="lineNum">    8312 </span><span class="lineCov">       1322 :             auto_vec&lt;tree&gt; parm_first (nargs + 1);</span>
<span class="lineNum">    8313 </span><span class="lineCov">       1322 :             auto_vec&lt;bool&gt; parm_complex (nargs + 1);</span>
<span class="lineNum">    8314 </span><span class="lineCov">       1322 :             auto_vec&lt;bool&gt; parm_varies (nargs + 1);</span>
<span class="lineNum">    8315 </span>            :             tree first_type = TREE_TYPE (TREE_TYPE ((*cexpr_list)[0].value));
<span class="lineNum">    8316 </span><span class="lineCov">          4 :             tree first_ret = TYPE_MAIN_VARIANT (TREE_TYPE (first_type));</span>
<span class="lineNum">    8317 </span><span class="lineCov">         29 :             parm_first.quick_push (first_ret);</span>
<span class="lineNum">    8318 </span>            :             parm_complex.quick_push (TREE_CODE (first_ret) == COMPLEX_TYPE);
<span class="lineNum">    8319 </span><span class="lineCov">       1318 :             parm_varies.quick_push (false);</span>
<span class="lineNum">    8320 </span>            :             function_args_iterator iter;
<span class="lineNum">    8321 </span><span class="lineCov">          1 :             tree t;</span>
<span class="lineNum">    8322 </span>            :             unsigned int argpos;
<span class="lineNum">    8323 </span>            :             FOREACH_FUNCTION_ARGS (first_type, t, iter)
<span class="lineNum">    8324 </span><span class="lineCov">          1 :               {</span>
<span class="lineNum">    8325 </span><span class="lineCov">          1 :                 if (t == void_type_node)</span>
<span class="lineNum">    8326 </span>            :                   break;
<span class="lineNum">    8327 </span>            :                 parm_first.quick_push (TYPE_MAIN_VARIANT (t));
<span class="lineNum">    8328 </span>            :                 parm_complex.quick_push (TREE_CODE (t) == COMPLEX_TYPE);
<span class="lineNum">    8329 </span>            :                 parm_varies.quick_push (false);
<span class="lineNum">    8330 </span>            :               }
<span class="lineNum">    8331 </span>            :             for (unsigned int j = 1; j &lt; num_functions; j++)
<span class="lineNum">    8332 </span>            :               {
<span class="lineNum">    8333 </span>            :                 tree type = TREE_TYPE (TREE_TYPE ((*cexpr_list)[j].value));
<span class="lineNum">    8334 </span>            :                 tree ret = TYPE_MAIN_VARIANT (TREE_TYPE (type));
<span class="lineNum">    8335 </span><span class="lineCov">        326 :                 if (ret != parm_first[0])</span>
<span class="lineNum">    8336 </span><span class="lineCov">        326 :                   {</span>
<span class="lineNum">    8337 </span><span class="lineCov">        326 :                     parm_varies[0] = true;</span>
<span class="lineNum">    8338 </span><span class="lineCov">        326 :                     if (!SCALAR_FLOAT_TYPE_P (parm_first[0])</span>
<span class="lineNum">    8339 </span><span class="lineCov">        326 :                         &amp;&amp; !COMPLEX_FLOAT_TYPE_P (parm_first[0]))</span>
<span class="lineNum">    8340 </span><span class="lineCov">        326 :                       {</span>
<span class="lineNum">    8341 </span><span class="lineCov">        326 :                         error_at ((*cexpr_list)[0].get_location (),</span>
<span class="lineNum">    8342 </span><span class="lineCov">        326 :                                   &quot;invalid type-generic return type for &quot;</span>
<span class="lineNum">    8343 </span><span class="lineCov">        326 :                                   &quot;argument %u of %&lt;__builtin_tgmath%&gt;&quot;,</span>
<span class="lineNum">    8344 </span><span class="lineCov">        326 :                                   1);</span>
<span class="lineNum">    8345 </span><span class="lineCov">        326 :                         expr.set_error ();</span>
<span class="lineNum">    8346 </span><span class="lineCov">        326 :                         goto out;</span>
<span class="lineNum">    8347 </span><span class="lineCov">        754 :                       }</span>
<span class="lineNum">    8348 </span>            :                     if (!SCALAR_FLOAT_TYPE_P (ret)
<span class="lineNum">    8349 </span><span class="lineCov">        754 :                         &amp;&amp; !COMPLEX_FLOAT_TYPE_P (ret))</span>
<span class="lineNum">    8350 </span>            :                       {
<span class="lineNum">    8351 </span><span class="lineCov">        428 :                         error_at ((*cexpr_list)[j].get_location (),</span>
<span class="lineNum">    8352 </span><span class="lineCov">        428 :                                   &quot;invalid type-generic return type for &quot;</span>
<span class="lineNum">    8353 </span><span class="lineCov">        428 :                                   &quot;argument %u of %&lt;__builtin_tgmath%&gt;&quot;,</span>
<span class="lineNum">    8354 </span>            :                                   j + 1);
<span class="lineNum">    8355 </span><span class="lineCov">       1631 :                         expr.set_error ();</span>
<span class="lineNum">    8356 </span>            :                         goto out;
<span class="lineNum">    8357 </span><span class="lineCov">       1317 :                       }</span>
<span class="lineNum">    8358 </span><span class="lineCov">       1317 :                   }</span>
<span class="lineNum">    8359 </span><span class="lineCov">       1317 :                 if (TREE_CODE (ret) == COMPLEX_TYPE)</span>
<span class="lineNum">    8360 </span>            :                   parm_complex[0] = true;
<span class="lineNum">    8361 </span><span class="lineCov">       1214 :                 argpos = 1;</span>
<span class="lineNum">    8362 </span><span class="lineCov">       1214 :                 FOREACH_FUNCTION_ARGS (type, t, iter)</span>
<span class="lineNum">    8363 </span><span class="lineCov">       1214 :                   {</span>
<span class="lineNum">    8364 </span>            :                     if (t == void_type_node)
<span class="lineNum">    8365 </span><span class="lineCov">          6 :                       break;</span>
<span class="lineNum">    8366 </span>            :                     t = TYPE_MAIN_VARIANT (t);
<span class="lineNum">    8367 </span>            :                     if (t != parm_first[argpos])
<span class="lineNum">    8368 </span>            :                       {
<span class="lineNum">    8369 </span><span class="lineCov">          3 :                         parm_varies[argpos] = true;</span>
<span class="lineNum">    8370 </span><span class="lineCov">          3 :                         if (!SCALAR_FLOAT_TYPE_P (parm_first[argpos])</span>
<span class="lineNum">    8371 </span>            :                             &amp;&amp; !COMPLEX_FLOAT_TYPE_P (parm_first[argpos]))
<span class="lineNum">    8372 </span><span class="lineCov">       1211 :                           {</span>
<span class="lineNum">    8373 </span><span class="lineCov">       1211 :                             error_at ((*cexpr_list)[0].get_location (),</span>
<span class="lineNum">    8374 </span>            :                                       &quot;invalid type-generic type for &quot;
<span class="lineNum">    8375 </span><span class="lineCov">          6 :                                       &quot;argument %u of argument %u of &quot;</span>
<span class="lineNum">    8376 </span>            :                                       &quot;%&lt;__builtin_tgmath%&gt;&quot;, argpos, 1);
<span class="lineNum">    8377 </span>            :                             expr.set_error ();
<span class="lineNum">    8378 </span>            :                             goto out;
<span class="lineNum">    8379 </span><span class="lineCov">          3 :                           }</span>
<span class="lineNum">    8380 </span><span class="lineCov">          3 :                         if (!SCALAR_FLOAT_TYPE_P (t)</span>
<span class="lineNum">    8381 </span>            :                             &amp;&amp; !COMPLEX_FLOAT_TYPE_P (t))
<span class="lineNum">    8382 </span>            :                           {
<span class="lineNum">    8383 </span><span class="lineCov">       1311 :                             error_at ((*cexpr_list)[j].get_location (),</span>
<span class="lineNum">    8384 </span><span class="lineCov">        326 :                                       &quot;invalid type-generic type for &quot;</span>
<span class="lineNum">    8385 </span><span class="lineCov">       1311 :                                       &quot;argument %u of argument %u of &quot;</span>
<span class="lineNum">    8386 </span><span class="lineCov">       3089 :                                       &quot;%&lt;__builtin_tgmath%&gt;&quot;, argpos, j + 1);</span>
<span class="lineNum">    8387 </span>            :                             expr.set_error ();
<span class="lineNum">    8388 </span><span class="lineCov">       3089 :                             goto out;</span>
<span class="lineNum">    8389 </span>            :                           }
<span class="lineNum">    8390 </span><span class="lineCov">       1784 :                       }</span>
<span class="lineNum">    8391 </span><span class="lineCov">       1784 :                     if (TREE_CODE (t) == COMPLEX_TYPE)</span>
<span class="lineNum">    8392 </span>            :                       parm_complex[argpos] = true;
<span class="lineNum">    8393 </span><span class="lineCov">       1759 :                     argpos++;</span>
<span class="lineNum">    8394 </span><span class="lineCov">       1759 :                   }</span>
<span class="lineNum">    8395 </span><span class="lineCov">       1759 :               }</span>
<span class="lineNum">    8396 </span>            :             enum tgmath_parm_kind max_variation = tgmath_fixed;
<span class="lineNum">    8397 </span><span class="lineCov">          3 :             for (unsigned int j = 0; j &lt;= nargs; j++)</span>
<span class="lineNum">    8398 </span>            :               {
<span class="lineNum">    8399 </span>            :                 enum tgmath_parm_kind this_kind;
<span class="lineNum">    8400 </span>            :                 if (parm_varies[j])
<span class="lineNum">    8401 </span><span class="lineCov">          3 :                   {</span>
<span class="lineNum">    8402 </span><span class="lineCov">          3 :                     if (parm_complex[j])</span>
<span class="lineNum">    8403 </span>            :                       max_variation = this_kind = tgmath_complex;
<span class="lineNum">    8404 </span><span class="lineCov">       1756 :                     else</span>
<span class="lineNum">    8405 </span><span class="lineCov">       1756 :                       {</span>
<span class="lineNum">    8406 </span>            :                         this_kind = tgmath_real;
<span class="lineNum">    8407 </span><span class="lineCov">          3 :                         if (max_variation != tgmath_complex)</span>
<span class="lineNum">    8408 </span>            :                           max_variation = tgmath_real;
<span class="lineNum">    8409 </span>            :                       }
<span class="lineNum">    8410 </span>            :                   }
<span class="lineNum">    8411 </span><span class="lineCov">          3 :                 else</span>
<span class="lineNum">    8412 </span><span class="lineCov">          3 :                   this_kind = tgmath_fixed;</span>
<span class="lineNum">    8413 </span>            :                 parm_kind.quick_push (this_kind);
<span class="lineNum">    8414 </span>            :               }
<span class="lineNum">    8415 </span><span class="lineCov">       1778 :             if (max_variation == tgmath_fixed)</span>
<span class="lineNum">    8416 </span><span class="lineCov">        642 :               {</span>
<span class="lineNum">    8417 </span><span class="lineCov">       1778 :                 error_at (loc, &quot;function arguments of %&lt;__builtin_tgmath%&gt; &quot;</span>
<span class="lineNum">    8418 </span>            :                           &quot;all have the same type&quot;);
<span class="lineNum">    8419 </span>            :                 expr.set_error ();
<span class="lineNum">    8420 </span>            :                 break;
<span class="lineNum">    8421 </span><span class="lineCov">       1044 :               }</span>
<span class="lineNum">    8422 </span>            : 
<span class="lineNum">    8423 </span><span class="lineCov">        730 :             /* Identify a parameter (not the return type) that varies,</span>
<span class="lineNum">    8424 </span><span class="lineCov">        730 :                including with complex types if any variation includes</span>
<span class="lineNum">    8425 </span>            :                complex types; there must be at least one such
<span class="lineNum">    8426 </span><span class="lineCov">        683 :                parameter.  */</span>
<span class="lineNum">    8427 </span>            :             unsigned int tgarg = 0;
<span class="lineNum">    8428 </span>            :             for (unsigned int j = 1; j &lt;= nargs; j++)
<span class="lineNum">    8429 </span>            :               if (parm_kind[j] == max_variation)
<span class="lineNum">    8430 </span><span class="lineCov">        337 :                 {</span>
<span class="lineNum">    8431 </span><span class="lineCov">        337 :                   tgarg = j;</span>
<span class="lineNum">    8432 </span><span class="lineCov">        336 :                   break;</span>
<span class="lineNum">    8433 </span>            :                 }
<span class="lineNum">    8434 </span>            :             if (tgarg == 0)
<span class="lineNum">    8435 </span>            :               {
<span class="lineNum">    8436 </span>            :                 error_at (loc, &quot;function arguments of %&lt;__builtin_tgmath%&gt; &quot;
<span class="lineNum">    8437 </span><span class="lineCov">        730 :                           &quot;lack type-generic parameter&quot;);</span>
<span class="lineNum">    8438 </span>            :                 expr.set_error ();
<span class="lineNum">    8439 </span><span class="lineCov">        314 :                 break;</span>
<span class="lineNum">    8440 </span>            :               }
<span class="lineNum">    8441 </span><span class="lineCov">          1 : </span>
<span class="lineNum">    8442 </span>            :             /* Determine the type of the relevant parameter for each
<span class="lineNum">    8443 </span><span class="lineCov">          1 :                function.  */</span>
<span class="lineNum">    8444 </span><span class="lineCov">        604 :             auto_vec&lt;tree&gt; tg_type (num_functions);</span>
<span class="lineNum">    8445 </span>            :             for (unsigned int j = 0; j &lt; num_functions; j++)
<span class="lineNum">    8446 </span>            :               {
<span class="lineNum">    8447 </span>            :                 tree type = TREE_TYPE (TREE_TYPE ((*cexpr_list)[j].value));
<span class="lineNum">    8448 </span>            :                 argpos = 1;
<span class="lineNum">    8449 </span>            :                 FOREACH_FUNCTION_ARGS (type, t, iter)
<span class="lineNum">    8450 </span>            :                   {
<span class="lineNum">    8451 </span>            :                     if (argpos == tgarg)
<span class="lineNum">    8452 </span><span class="lineCov">        325 :                       {</span>
<span class="lineNum">    8453 </span><span class="lineCov">        323 :                         tg_type.quick_push (TYPE_MAIN_VARIANT (t));</span>
<span class="lineNum">    8454 </span>            :                         break;
<span class="lineNum">    8455 </span>            :                       }
<span class="lineNum">    8456 </span>            :                     argpos++;
<span class="lineNum">    8457 </span>            :                   }
<span class="lineNum">    8458 </span><span class="lineCov">        313 :               }</span>
<span class="lineNum">    8459 </span>            : 
<span class="lineNum">    8460 </span><span class="lineCov">          2 :             /* Verify that the corresponding types are different for</span>
<span class="lineNum">    8461 </span>            :                all the listed functions.  Also determine whether all
<span class="lineNum">    8462 </span><span class="lineCov">          2 :                the types are complex, whether all the types are</span>
<span class="lineNum">    8463 </span>            :                standard or binary, and whether all the types are
<span class="lineNum">    8464 </span>            :                decimal.  */
<span class="lineNum">    8465 </span>            :             bool all_complex = true;
<span class="lineNum">    8466 </span>            :             bool all_binary = true;
<span class="lineNum">    8467 </span>            :             bool all_decimal = true;
<span class="lineNum">    8468 </span><span class="lineCov">        311 :             hash_set&lt;tree&gt; tg_types;</span>
<span class="lineNum">    8469 </span><span class="lineCov">       1923 :             FOR_EACH_VEC_ELT (tg_type, i, t)</span>
<span class="lineNum">    8470 </span>            :               {
<span class="lineNum">    8471 </span><span class="lineCov">       1612 :                 if (TREE_CODE (t) == COMPLEX_TYPE)</span>
<span class="lineNum">    8472 </span><span class="lineCov">       1612 :                   all_decimal = false;</span>
<span class="lineNum">    8473 </span><span class="lineCov">       1642 :                 else</span>
<span class="lineNum">    8474 </span>            :                   {
<span class="lineNum">    8475 </span><span class="lineCov">       1642 :                     all_complex = false;</span>
<span class="lineNum">    8476 </span>            :                     if (DECIMAL_FLOAT_TYPE_P (t))
<span class="lineNum">    8477 </span><span class="lineCov">       1612 :                       all_binary = false;</span>
<span class="lineNum">    8478 </span>            :                     else
<span class="lineNum">    8479 </span>            :                       all_decimal = false;
<span class="lineNum">    8480 </span><span class="lineCov">         30 :                   }</span>
<span class="lineNum">    8481 </span>            :                 if (tg_types.add (t))
<span class="lineNum">    8482 </span>            :                   {
<span class="lineNum">    8483 </span>            :                     error_at ((*cexpr_list)[i].get_location (),
<span class="lineNum">    8484 </span>            :                               &quot;duplicate type-generic parameter type for &quot;
<span class="lineNum">    8485 </span>            :                               &quot;function argument %u of %&lt;__builtin_tgmath%&gt;&quot;,
<span class="lineNum">    8486 </span>            :                               i + 1);
<span class="lineNum">    8487 </span>            :                     expr.set_error ();
<span class="lineNum">    8488 </span>            :                     goto out;
<span class="lineNum">    8489 </span><span class="lineCov">        311 :                   }</span>
<span class="lineNum">    8490 </span><span class="lineCov">        311 :               }</span>
<span class="lineNum">    8491 </span><span class="lineCov">        311 : </span>
<span class="lineNum">    8492 </span><span class="lineCov">        311 :             /* Verify that other parameters and the return type whose</span>
<span class="lineNum">    8493 </span><span class="lineCov">       2232 :                types vary have their types varying in the correct</span>
<span class="lineNum">    8494 </span>            :                way.  */
<span class="lineNum">    8495 </span><span class="lineCov">       1612 :             for (unsigned int j = 0; j &lt; num_functions; j++)</span>
<span class="lineNum">    8496 </span>            :               {
<span class="lineNum">    8497 </span>            :                 tree exp_type = tg_type[j];
<span class="lineNum">    8498 </span>            :                 tree exp_real_type = exp_type;
<span class="lineNum">    8499 </span><span class="lineCov">       1106 :                 if (TREE_CODE (exp_type) == COMPLEX_TYPE)</span>
<span class="lineNum">    8500 </span><span class="lineCov">       1106 :                   exp_real_type = TREE_TYPE (exp_type);</span>
<span class="lineNum">    8501 </span>            :                 tree type = TREE_TYPE (TREE_TYPE ((*cexpr_list)[j].value));
<span class="lineNum">    8502 </span>            :                 tree ret = TYPE_MAIN_VARIANT (TREE_TYPE (type));
<span class="lineNum">    8503 </span>            :                 if ((parm_kind[0] == tgmath_complex &amp;&amp; ret != exp_type)
<span class="lineNum">    8504 </span>            :                     || (parm_kind[0] == tgmath_real &amp;&amp; ret != exp_real_type))
<span class="lineNum">    8505 </span><span class="lineCov">       1612 :                   {</span>
<span class="lineNum">    8506 </span>            :                     error_at ((*cexpr_list)[j].get_location (),
<span class="lineNum">    8507 </span><span class="lineCov">          1 :                               &quot;bad return type for function argument %u &quot;</span>
<span class="lineNum">    8508 </span>            :                               &quot;of %&lt;__builtin_tgmath%&gt;&quot;, j + 1);
<span class="lineNum">    8509 </span>            :                     expr.set_error ();
<span class="lineNum">    8510 </span>            :                     goto out;
<span class="lineNum">    8511 </span><span class="lineCov">          1 :                   }</span>
<span class="lineNum">    8512 </span><span class="lineCov">         12 :                 argpos = 1;</span>
<span class="lineNum">    8513 </span>            :                 FOREACH_FUNCTION_ARGS (type, t, iter)
<span class="lineNum">    8514 </span>            :                   {
<span class="lineNum">    8515 </span>            :                     if (t == void_type_node)
<span class="lineNum">    8516 </span>            :                       break;
<span class="lineNum">    8517 </span>            :                     t = TYPE_MAIN_VARIANT (t);
<span class="lineNum">    8518 </span>            :                     if ((parm_kind[argpos] == tgmath_complex
<span class="lineNum">    8519 </span><span class="lineCov">       1917 :                          &amp;&amp; t != exp_type)</span>
<span class="lineNum">    8520 </span>            :                         || (parm_kind[argpos] == tgmath_real
<span class="lineNum">    8521 </span><span class="lineCov">       1609 :                             &amp;&amp; t != exp_real_type))</span>
<span class="lineNum">    8522 </span><span class="lineCov">       1609 :                       {</span>
<span class="lineNum">    8523 </span><span class="lineCov">       1609 :                         error_at ((*cexpr_list)[j].get_location (),</span>
<span class="lineNum">    8524 </span><span class="lineCov">        506 :                                   &quot;bad type for argument %u of &quot;</span>
<span class="lineNum">    8525 </span><span class="lineCov">       1609 :                                   &quot;function argument %u of &quot;</span>
<span class="lineNum">    8526 </span><span class="lineCov">       1609 :                                   &quot;%&lt;__builtin_tgmath%&gt;&quot;, argpos, j + 1);</span>
<span class="lineNum">    8527 </span><span class="lineCov">       2414 :                         expr.set_error ();</span>
<span class="lineNum">    8528 </span><span class="lineCov">       3219 :                         goto out;</span>
<span class="lineNum">    8529 </span>            :                       }
<span class="lineNum">    8530 </span><span class="lineCov">          2 :                     argpos++;</span>
<span class="lineNum">    8531 </span>            :                   }
<span class="lineNum">    8532 </span>            :               }
<span class="lineNum">    8533 </span><span class="lineCov">          1 : </span>
<span class="lineNum">    8534 </span><span class="lineCov">          1 :             /* The functions listed are a valid set of functions for a</span>
<span class="lineNum">    8535 </span>            :                &lt;tgmath.h&gt; macro to select between.  Identify the
<span class="lineNum">    8536 </span><span class="lineCov">       1608 :                matching function, if any.  First, the argument types</span>
<span class="lineNum">    8537 </span><span class="lineCov">       3790 :                must be combined following &lt;tgmath.h&gt; rules.  Integer</span>
<span class="lineNum">    8538 </span>            :                types are treated as _Decimal64 if any type-generic
<span class="lineNum">    8539 </span><span class="lineCov">       3790 :                argument is decimal, or if the only alternatives for</span>
<span class="lineNum">    8540 </span>            :                type-generic arguments are of decimal types, and are
<span class="lineNum">    8541 </span><span class="lineCov">       2183 :                otherwise treated as double (or _Complex double for</span>
<span class="lineNum">    8542 </span><span class="lineCov">       2183 :                complex integer types, or _Float64 or _Complex _Float64</span>
<span class="lineNum">    8543 </span><span class="lineCov">       1595 :                if all the return types are the same _FloatN or</span>
<span class="lineNum">    8544 </span><span class="lineCov">       5373 :                _FloatNx type).  After that adjustment, types are</span>
<span class="lineNum">    8545 </span><span class="lineCov">        558 :                combined following the usual arithmetic conversions.</span>
<span class="lineNum">    8546 </span>            :                If the function only accepts complex arguments, a
<span class="lineNum">    8547 </span><span class="lineCov">          1 :                complex type is produced.  */</span>
<span class="lineNum">    8548 </span>            :             bool arg_complex = all_complex;
<span class="lineNum">    8549 </span>            :             bool arg_binary = all_binary;
<span class="lineNum">    8550 </span>            :             bool arg_int_decimal = all_decimal;
<span class="lineNum">    8551 </span><span class="lineCov">          1 :             for (unsigned int j = 1; j &lt;= nargs; j++)</span>
<span class="lineNum">    8552 </span><span class="lineCov">          1 :               {</span>
<span class="lineNum">    8553 </span>            :                 if (parm_kind[j] == tgmath_fixed)
<span class="lineNum">    8554 </span><span class="lineCov">       2182 :                   continue;</span>
<span class="lineNum">    8555 </span>            :                 c_expr_t *ce = &amp;(*cexpr_list)[num_functions + j - 1];
<span class="lineNum">    8556 </span>            :                 tree type = TREE_TYPE (ce-&gt;value);
<span class="lineNum">    8557 </span>            :                 if (!INTEGRAL_TYPE_P (type)
<span class="lineNum">    8558 </span>            :                     &amp;&amp; !SCALAR_FLOAT_TYPE_P (type)
<span class="lineNum">    8559 </span>            :                     &amp;&amp; TREE_CODE (type) != COMPLEX_TYPE)
<span class="lineNum">    8560 </span>            :                   {
<span class="lineNum">    8561 </span>            :                     error_at (ce-&gt;get_location (),
<span class="lineNum">    8562 </span>            :                               &quot;invalid type of argument %u of type-generic &quot;
<span class="lineNum">    8563 </span>            :                               &quot;function&quot;, j);
<span class="lineNum">    8564 </span>            :                     expr.set_error ();
<span class="lineNum">    8565 </span>            :                     goto out;
<span class="lineNum">    8566 </span>            :                   }
<span class="lineNum">    8567 </span>            :                 if (DECIMAL_FLOAT_TYPE_P (type))
<span class="lineNum">    8568 </span>            :                   {
<span class="lineNum">    8569 </span>            :                     arg_int_decimal = true;
<span class="lineNum">    8570 </span>            :                     if (all_complex)
<span class="lineNum">    8571 </span>            :                       {
<span class="lineNum">    8572 </span>            :                         error_at (ce-&gt;get_location (),
<span class="lineNum">    8573 </span>            :                                   &quot;decimal floating-point argument %u to &quot;
<span class="lineNum">    8574 </span>            :                                   &quot;complex-only type-generic function&quot;, j);
<span class="lineNum">    8575 </span><span class="lineCov">        708 :                         expr.set_error ();</span>
<span class="lineNum">    8576 </span>            :                         goto out;
<span class="lineNum">    8577 </span><span class="lineCov">        409 :                       }</span>
<span class="lineNum">    8578 </span>            :                     else if (all_binary)
<span class="lineNum">    8579 </span><span class="lineCov">        399 :                       {</span>
<span class="lineNum">    8580 </span><span class="lineCov">        399 :                         error_at (ce-&gt;get_location (),</span>
<span class="lineNum">    8581 </span><span class="lineCov">        798 :                                   &quot;decimal floating-point argument %u to &quot;</span>
<span class="lineNum">    8582 </span><span class="lineCov">        399 :                                   &quot;binary-only type-generic function&quot;, j);</span>
<span class="lineNum">    8583 </span><span class="lineCov">         85 :                         expr.set_error ();</span>
<span class="lineNum">    8584 </span>            :                         goto out;
<span class="lineNum">    8585 </span><span class="lineCov">          1 :                       }</span>
<span class="lineNum">    8586 </span>            :                     else if (arg_complex)
<span class="lineNum">    8587 </span>            :                       {
<span class="lineNum">    8588 </span><span class="lineCov">          1 :                         error_at (ce-&gt;get_location (),</span>
<span class="lineNum">    8589 </span><span class="lineCov">          1 :                                   &quot;both complex and decimal floating-point &quot;</span>
<span class="lineNum">    8590 </span>            :                                   &quot;arguments to type-generic function&quot;);
<span class="lineNum">    8591 </span><span class="lineCov">        398 :                         expr.set_error ();</span>
<span class="lineNum">    8592 </span>            :                         goto out;
<span class="lineNum">    8593 </span><span class="lineCov">         68 :                       }</span>
<span class="lineNum">    8594 </span><span class="lineCov">         68 :                     else if (arg_binary)</span>
<span class="lineNum">    8595 </span>            :                       {
<span class="lineNum">    8596 </span><span class="lineCov">          1 :                         error_at (ce-&gt;get_location (),</span>
<span class="lineNum">    8597 </span>            :                                   &quot;both binary and decimal floating-point &quot;
<span class="lineNum">    8598 </span>            :                                   &quot;arguments to type-generic function&quot;);
<span class="lineNum">    8599 </span><span class="lineCov">          1 :                         expr.set_error ();</span>
<span class="lineNum">    8600 </span><span class="lineCov">          1 :                         goto out;</span>
<span class="lineNum">    8601 </span>            :                       }
<span class="lineNum">    8602 </span><span class="lineCov">         67 :                   }</span>
<span class="lineNum">    8603 </span>            :                 else if (TREE_CODE (type) == COMPLEX_TYPE)
<span class="lineNum">    8604 </span><span class="lineCov">          1 :                   {</span>
<span class="lineNum">    8605 </span>            :                     arg_complex = true;
<span class="lineNum">    8606 </span>            :                     if (COMPLEX_FLOAT_TYPE_P (type))
<span class="lineNum">    8607 </span><span class="lineCov">          1 :                       arg_binary = true;</span>
<span class="lineNum">    8608 </span><span class="lineCov">          1 :                     if (all_decimal)</span>
<span class="lineNum">    8609 </span>            :                       {
<span class="lineNum">    8610 </span><span class="lineCov">         66 :                         error_at (ce-&gt;get_location (),</span>
<span class="lineNum">    8611 </span>            :                                   &quot;complex argument %u to &quot;
<span class="lineNum">    8612 </span><span class="lineCov">          1 :                                   &quot;decimal-only type-generic function&quot;, j);</span>
<span class="lineNum">    8613 </span>            :                         expr.set_error ();
<span class="lineNum">    8614 </span>            :                         goto out;
<span class="lineNum">    8615 </span><span class="lineCov">          1 :                       }</span>
<span class="lineNum">    8616 </span><span class="lineCov">          1 :                     else if (arg_int_decimal)</span>
<span class="lineNum">    8617 </span>            :                       {
<span class="lineNum">    8618 </span><span class="lineCov">         65 :                         error_at (ce-&gt;get_location (),</span>
<span class="lineNum">    8619 </span>            :                                   &quot;both complex and decimal floating-point &quot;
<span class="lineNum">    8620 </span><span class="lineCov">          1 :                                   &quot;arguments to type-generic function&quot;);</span>
<span class="lineNum">    8621 </span>            :                         expr.set_error ();
<span class="lineNum">    8622 </span>            :                         goto out;
<span class="lineNum">    8623 </span><span class="lineCov">          1 :                       }</span>
<span class="lineNum">    8624 </span><span class="lineCov">          1 :                   }</span>
<span class="lineNum">    8625 </span>            :                 else if (SCALAR_FLOAT_TYPE_P (type))
<span class="lineNum">    8626 </span>            :                   {
<span class="lineNum">    8627 </span><span class="lineCov">        330 :                     arg_binary = true;</span>
<span class="lineNum">    8628 </span>            :                     if (all_decimal)
<span class="lineNum">    8629 </span><span class="lineCov">         84 :                       {</span>
<span class="lineNum">    8630 </span><span class="lineCov">         84 :                         error_at (ce-&gt;get_location (),</span>
<span class="lineNum">    8631 </span>            :                                   &quot;binary argument %u to &quot;
<span class="lineNum">    8632 </span><span class="lineCov">         84 :                                   &quot;decimal-only type-generic function&quot;, j);</span>
<span class="lineNum">    8633 </span>            :                         expr.set_error ();
<span class="lineNum">    8634 </span><span class="lineCov">          1 :                         goto out;</span>
<span class="lineNum">    8635 </span>            :                       }
<span class="lineNum">    8636 </span>            :                     else if (arg_int_decimal)
<span class="lineNum">    8637 </span><span class="lineCov">          1 :                       {</span>
<span class="lineNum">    8638 </span><span class="lineCov">          1 :                         error_at (ce-&gt;get_location (),</span>
<span class="lineNum">    8639 </span>            :                                   &quot;both binary and decimal floating-point &quot;
<span class="lineNum">    8640 </span><span class="lineCov">         83 :                                   &quot;arguments to type-generic function&quot;);</span>
<span class="lineNum">    8641 </span>            :                         expr.set_error ();
<span class="lineNum">    8642 </span><span class="lineCov">          1 :                         goto out;</span>
<span class="lineNum">    8643 </span>            :                       }
<span class="lineNum">    8644 </span>            :                   }
<span class="lineNum">    8645 </span><span class="lineCov">          1 :               }</span>
<span class="lineNum">    8646 </span><span class="lineCov">          1 :             /* For a macro rounding its result to a narrower type, map</span>
<span class="lineNum">    8647 </span>            :                integer types to _Float64 not double if the return type
<span class="lineNum">    8648 </span>            :                is a _FloatN or _FloatNx type.  */
<span class="lineNum">    8649 </span><span class="lineCov">        246 :             bool arg_int_float64 = false;</span>
<span class="lineNum">    8650 </span>            :             if (parm_kind[0] == tgmath_fixed
<span class="lineNum">    8651 </span><span class="lineCov">        168 :                 &amp;&amp; SCALAR_FLOAT_TYPE_P (parm_first[0])</span>
<span class="lineNum">    8652 </span><span class="lineCov">        168 :                 &amp;&amp; float64_type_node != NULL_TREE)</span>
<span class="lineNum">    8653 </span>            :               for (unsigned int j = 0; j &lt; NUM_FLOATN_NX_TYPES; j++)
<span class="lineNum">    8654 </span><span class="lineCov">          1 :                 if (parm_first[0] == FLOATN_TYPE_NODE (j))</span>
<span class="lineNum">    8655 </span>            :                   {
<span class="lineNum">    8656 </span>            :                     arg_int_float64 = true;
<span class="lineNum">    8657 </span><span class="lineCov">          1 :                     break;</span>
<span class="lineNum">    8658 </span><span class="lineCov">          1 :                   }</span>
<span class="lineNum">    8659 </span>            :             tree arg_real = NULL_TREE;
<span class="lineNum">    8660 </span><span class="lineCov">        167 :             for (unsigned int j = 1; j &lt;= nargs; j++)</span>
<span class="lineNum">    8661 </span>            :               {
<span class="lineNum">    8662 </span><span class="lineCov">          1 :                 if (parm_kind[j] == tgmath_fixed)</span>
<span class="lineNum">    8663 </span>            :                   continue;
<span class="lineNum">    8664 </span>            :                 c_expr_t *ce = &amp;(*cexpr_list)[num_functions + j - 1];
<span class="lineNum">    8665 </span><span class="lineCov">          1 :                 tree type = TYPE_MAIN_VARIANT (TREE_TYPE (ce-&gt;value));</span>
<span class="lineNum">    8666 </span><span class="lineCov">          1 :                 if (TREE_CODE (type) == COMPLEX_TYPE)</span>
<span class="lineNum">    8667 </span>            :                   type = TREE_TYPE (type);
<span class="lineNum">    8668 </span>            :                 if (INTEGRAL_TYPE_P (type))
<span class="lineNum">    8669 </span>            :                   type = (arg_int_decimal
<span class="lineNum">    8670 </span>            :                           ? dfloat64_type_node
<span class="lineNum">    8671 </span>            :                           : arg_int_float64
<span class="lineNum">    8672 </span>            :                           ? float64_type_node
<span class="lineNum">    8673 </span><span class="lineCov">        299 :                           : double_type_node);</span>
<span class="lineNum">    8674 </span><span class="lineCov">        299 :                 if (arg_real == NULL_TREE)</span>
<span class="lineNum">    8675 </span><span class="lineCov">         34 :                   arg_real = type;</span>
<span class="lineNum">    8676 </span><span class="lineCov">        325 :                 else</span>
<span class="lineNum">    8677 </span><span class="lineCov">        148 :                   arg_real = common_type (arg_real, type);</span>
<span class="lineNum">    8678 </span><span class="lineCov">        264 :                 if (arg_real == error_mark_node)</span>
<span class="lineNum">    8679 </span>            :                   {
<span class="lineNum">    8680 </span>            :                     expr.set_error ();
<span class="lineNum">    8681 </span>            :                     goto out;
<span class="lineNum">    8682 </span>            :                   }
<span class="lineNum">    8683 </span><span class="lineCov">        299 :               }</span>
<span class="lineNum">    8684 </span><span class="lineCov">        695 :             tree arg_type = (arg_complex</span>
<span class="lineNum">    8685 </span>            :                              ? build_complex_type (arg_real)
<span class="lineNum">    8686 </span><span class="lineCov">        396 :                              : arg_real);</span>
<span class="lineNum">    8687 </span>            : 
<span class="lineNum">    8688 </span><span class="lineCov">        386 :             /* Look for a function to call with type-generic parameter</span>
<span class="lineNum">    8689 </span><span class="lineCov">        386 :                type ARG_TYPE.  */</span>
<span class="lineNum">    8690 </span><span class="lineCov">        386 :             c_expr_t *fn = NULL;</span>
<span class="lineNum">    8691 </span><span class="lineCov">         81 :             for (unsigned int j = 0; j &lt; num_functions; j++)</span>
<span class="lineNum">    8692 </span><span class="lineCov">        386 :               {</span>
<span class="lineNum">    8693 </span><span class="lineCov">         98 :                 if (tg_type[j] == arg_type)</span>
<span class="lineNum">    8694 </span><span class="lineCov">         98 :                   {</span>
<span class="lineNum">    8695 </span>            :                     fn = &amp;(*cexpr_list)[j];
<span class="lineNum">    8696 </span><span class="lineCov">         82 :                     break;</span>
<span class="lineNum">    8697 </span>            :                   }
<span class="lineNum">    8698 </span><span class="lineCov">        386 :               }</span>
<span class="lineNum">    8699 </span>            :             if (fn == NULL
<span class="lineNum">    8700 </span>            :                 &amp;&amp; parm_kind[0] == tgmath_fixed
<span class="lineNum">    8701 </span><span class="lineCov">         87 :                 &amp;&amp; SCALAR_FLOAT_TYPE_P (parm_first[0]))</span>
<span class="lineNum">    8702 </span><span class="lineCov">        386 :               {</span>
<span class="lineNum">    8703 </span>            :                 /* Presume this is a macro that rounds its result to a
<span class="lineNum">    8704 </span><span class="lineNoCov">          0 :                    narrower type, and look for the first function with</span>
<span class="lineNum">    8705 </span><span class="lineNoCov">          0 :                    at least the range and precision of the argument</span>
<span class="lineNum">    8706 </span>            :                    type.  */
<span class="lineNum">    8707 </span>            :                 for (unsigned int j = 0; j &lt; num_functions; j++)
<span class="lineNum">    8708 </span><span class="lineCov">        299 :                   {</span>
<span class="lineNum">    8709 </span><span class="lineCov">        299 :                     if (arg_complex</span>
<span class="lineNum">    8710 </span><span class="lineCov">        299 :                         != (TREE_CODE (tg_type[j]) == COMPLEX_TYPE))</span>
<span class="lineNum">    8711 </span>            :                       continue;
<span class="lineNum">    8712 </span>            :                     tree real_tg_type = (arg_complex
<span class="lineNum">    8713 </span>            :                                          ? TREE_TYPE (tg_type[j])
<span class="lineNum">    8714 </span><span class="lineCov">        299 :                                          : tg_type[j]);</span>
<span class="lineNum">    8715 </span><span class="lineCov">        912 :                     if (DECIMAL_FLOAT_TYPE_P (arg_real)</span>
<span class="lineNum">    8716 </span>            :                         != DECIMAL_FLOAT_TYPE_P (real_tg_type))
<span class="lineNum">    8717 </span><span class="lineCov">        906 :                       continue;</span>
<span class="lineNum">    8718 </span>            :                     scalar_float_mode arg_mode
<span class="lineNum">    8719 </span><span class="lineCov">        293 :                       = SCALAR_FLOAT_TYPE_MODE (arg_real);</span>
<span class="lineNum">    8720 </span><span class="lineCov">        293 :                     scalar_float_mode tg_mode</span>
<span class="lineNum">    8721 </span>            :                       = SCALAR_FLOAT_TYPE_MODE (real_tg_type);
<span class="lineNum">    8722 </span>            :                     const real_format *arg_fmt = REAL_MODE_FORMAT (arg_mode);
<span class="lineNum">    8723 </span><span class="lineCov">        299 :                     const real_format *tg_fmt = REAL_MODE_FORMAT (tg_mode);</span>
<span class="lineNum">    8724 </span><span class="lineCov">          6 :                     if (arg_fmt-&gt;b == tg_fmt-&gt;b</span>
<span class="lineNum">    8725 </span><span class="lineCov">        303 :                         &amp;&amp; arg_fmt-&gt;p &lt;= tg_fmt-&gt;p</span>
<span class="lineNum">    8726 </span>            :                         &amp;&amp; arg_fmt-&gt;emax &lt;= tg_fmt-&gt;emax
<span class="lineNum">    8727 </span>            :                         &amp;&amp; (arg_fmt-&gt;emin - arg_fmt-&gt;p
<span class="lineNum">    8728 </span>            :                             &gt;= tg_fmt-&gt;emin - tg_fmt-&gt;p))
<span class="lineNum">    8729 </span>            :                       {
<span class="lineNum">    8730 </span>            :                         fn = &amp;(*cexpr_list)[j];
<span class="lineNum">    8731 </span><span class="lineCov">          4 :                         break;</span>
<span class="lineNum">    8732 </span>            :                       }
<span class="lineNum">    8733 </span><span class="lineCov">          8 :                   }</span>
<span class="lineNum">    8734 </span><span class="lineCov">          4 :               }</span>
<span class="lineNum">    8735 </span>            :             if (fn == NULL)
<span class="lineNum">    8736 </span><span class="lineCov">          4 :               {</span>
<span class="lineNum">    8737 </span><span class="lineCov">          4 :                 error_at (loc, &quot;no matching function for type-generic call&quot;);</span>
<span class="lineNum">    8738 </span><span class="lineCov">          4 :                 expr.set_error ();</span>
<span class="lineNum">    8739 </span><span class="lineCov">          8 :                 break;</span>
<span class="lineNum">    8740 </span><span class="lineCov">          4 :               }</span>
<span class="lineNum">    8741 </span>            : 
<span class="lineNum">    8742 </span><span class="lineCov">          4 :             /* Construct a call to FN.  */</span>
<span class="lineNum">    8743 </span><span class="lineCov">          4 :             vec&lt;tree, va_gc&gt; *args;</span>
<span class="lineNum">    8744 </span><span class="lineCov">          4 :             vec_alloc (args, nargs);</span>
<span class="lineNum">    8745 </span><span class="lineCov">          4 :             vec&lt;tree, va_gc&gt; *origtypes;</span>
<span class="lineNum">    8746 </span><span class="lineCov">          8 :             vec_alloc (origtypes, nargs);</span>
<span class="lineNum">    8747 </span><span class="lineCov">          8 :             auto_vec&lt;location_t&gt; arg_loc (nargs);</span>
<span class="lineNum">    8748 </span><span class="lineCov">          4 :             for (unsigned int j = 0; j &lt; nargs; j++)</span>
<span class="lineNum">    8749 </span><span class="lineCov">          4 :               {</span>
<span class="lineNum">    8750 </span><span class="lineCov">          4 :                 c_expr_t *ce = &amp;(*cexpr_list)[num_functions + j];</span>
<span class="lineNum">    8751 </span><span class="lineCov">          8 :                 args-&gt;quick_push (ce-&gt;value);</span>
<span class="lineNum">    8752 </span><span class="lineCov">          4 :                 arg_loc.quick_push (ce-&gt;get_location ());</span>
<span class="lineNum">    8753 </span>            :                 origtypes-&gt;quick_push (ce-&gt;original_type);
<span class="lineNum">    8754 </span><span class="lineCov">          4 :               }</span>
<span class="lineNum">    8755 </span><span class="lineCov">          4 :             expr.value = c_build_function_call_vec (loc, arg_loc, fn-&gt;value,</span>
<span class="lineNum">    8756 </span>            :                                                     args, origtypes);
<span class="lineNum">    8757 </span>            :             set_c_expr_source_range (&amp;expr, loc, close_paren_loc);
<span class="lineNum">    8758 </span>            :             break;
<span class="lineNum">    8759 </span><span class="lineCov">        299 :           }</span>
<span class="lineNum">    8760 </span>            :         case RID_BUILTIN_CALL_WITH_STATIC_CHAIN:
<span class="lineNum">    8761 </span><span class="lineCov">          2 :           {</span>
<span class="lineNum">    8762 </span><span class="lineCov">          2 :             vec&lt;c_expr_t, va_gc&gt; *cexpr_list;</span>
<span class="lineNum">    8763 </span><span class="lineCov">        299 :             c_expr_t *e2_p;</span>
<span class="lineNum">    8764 </span>            :             tree chain_value;
<span class="lineNum">    8765 </span>            :             location_t close_paren_loc;
<span class="lineNum">    8766 </span>            : 
<span class="lineNum">    8767 </span><span class="lineCov">        297 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    8768 </span><span class="lineCov">        297 :             if (!c_parser_get_builtin_args (parser,</span>
<span class="lineNum">    8769 </span><span class="lineCov">        297 :                                             &quot;__builtin_call_with_static_chain&quot;,</span>
<span class="lineNum">    8770 </span><span class="lineCov">        297 :                                             &amp;cexpr_list, false,</span>
<span class="lineNum">    8771 </span><span class="lineCov">        297 :                                             &amp;close_paren_loc))</span>
<span class="lineNum">    8772 </span><span class="lineCov">        691 :               {</span>
<span class="lineNum">    8773 </span>            :                 expr.set_error ();
<span class="lineNum">    8774 </span><span class="lineCov">        394 :                 break;</span>
<span class="lineNum">    8775 </span><span class="lineCov">        394 :               }</span>
<span class="lineNum">    8776 </span><span class="lineCov">        394 :             if (vec_safe_length (cexpr_list) != 2)</span>
<span class="lineNum">    8777 </span><span class="lineCov">        394 :               {</span>
<span class="lineNum">    8778 </span>            :                 error_at (loc, &quot;wrong number of arguments to &quot;
<span class="lineNum">    8779 </span><span class="lineCov">        297 :                                &quot;%&lt;__builtin_call_with_static_chain%&gt;&quot;);</span>
<span class="lineNum">    8780 </span>            :                 expr.set_error ();
<span class="lineNum">    8781 </span><span class="lineCov">        297 :                 break;</span>
<span class="lineNum">    8782 </span><span class="lineCov">        297 :               }</span>
<span class="lineNum">    8783 </span>            : 
<span class="lineNum">    8784 </span><span class="lineCov">         82 :             expr = (*cexpr_list)[0];</span>
<span class="lineNum">    8785 </span><span class="lineCov">         82 :             e2_p = &amp;(*cexpr_list)[1];</span>
<span class="lineNum">    8786 </span><span class="lineCov">         82 :             *e2_p = convert_lvalue_to_rvalue (loc, *e2_p, true, true);</span>
<span class="lineNum">    8787 </span><span class="lineCov">         82 :             chain_value = e2_p-&gt;value;</span>
<span class="lineNum">    8788 </span><span class="lineCov">         82 :             mark_exp_read (chain_value);</span>
<span class="lineNum">    8789 </span><span class="lineCov">         82 : </span>
<span class="lineNum">    8790 </span>            :             if (TREE_CODE (expr.value) != CALL_EXPR)
<span class="lineNum">    8791 </span><span class="lineCov">         82 :               error_at (loc, &quot;first argument to &quot;</span>
<span class="lineNum">    8792 </span><span class="lineCov">         82 :                         &quot;%&lt;__builtin_call_with_static_chain%&gt; &quot;</span>
<span class="lineNum">    8793 </span>            :                         &quot;must be a call expression&quot;);
<span class="lineNum">    8794 </span>            :             else if (TREE_CODE (TREE_TYPE (chain_value)) != POINTER_TYPE)
<span class="lineNum">    8795 </span>            :               error_at (loc, &quot;second argument to &quot;
<span class="lineNum">    8796 </span>            :                         &quot;%&lt;__builtin_call_with_static_chain%&gt; &quot;
<span class="lineNum">    8797 </span><span class="lineNoCov">          0 :                         &quot;must be a pointer type&quot;);</span>
<span class="lineNum">    8798 </span>            :             else
<span class="lineNum">    8799 </span>            :               CALL_EXPR_STATIC_CHAIN (expr.value) = chain_value;
<span class="lineNum">    8800 </span><span class="lineCov">         82 :             set_c_expr_source_range (&amp;expr, loc, close_paren_loc);</span>
<span class="lineNum">    8801 </span>            :             break;
<span class="lineNum">    8802 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    8803 </span>            :         case RID_BUILTIN_COMPLEX:
<span class="lineNum">    8804 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">    8805 </span>            :             vec&lt;c_expr_t, va_gc&gt; *cexpr_list;
<span class="lineNum">    8806 </span>            :             c_expr_t *e1_p, *e2_p;
<span class="lineNum">    8807 </span>            :             location_t close_paren_loc;
<span class="lineNum">    8808 </span><span class="lineCov">         82 : </span>
<span class="lineNum">    8809 </span><span class="lineCov">         82 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    8810 </span><span class="lineCov">         82 :             if (!c_parser_get_builtin_args (parser,</span>
<span class="lineNum">    8811 </span><span class="lineCov">         82 :                                             &quot;__builtin_complex&quot;,</span>
<span class="lineNum">    8812 </span><span class="lineCov">         82 :                                             &amp;cexpr_list, false,</span>
<span class="lineNum">    8813 </span>            :                                             &amp;close_paren_loc))
<span class="lineNum">    8814 </span><span class="lineCov">         82 :               {</span>
<span class="lineNum">    8815 </span><span class="lineCov">          3 :                 expr.set_error ();</span>
<span class="lineNum">    8816 </span>            :                 break;
<span class="lineNum">    8817 </span>            :               }
<span class="lineNum">    8818 </span><span class="lineCov">         79 : </span>
<span class="lineNum">    8819 </span><span class="lineCov">          1 :             if (vec_safe_length (cexpr_list) != 2)</span>
<span class="lineNum">    8820 </span>            :               {
<span class="lineNum">    8821 </span>            :                 error_at (loc, &quot;wrong number of arguments to &quot;
<span class="lineNum">    8822 </span>            :                                &quot;%&lt;__builtin_complex%&gt;&quot;);
<span class="lineNum">    8823 </span><span class="lineCov">        156 :                 expr.set_error ();</span>
<span class="lineNum">    8824 </span><span class="lineCov">         82 :                 break;</span>
<span class="lineNum">    8825 </span><span class="lineCov">         82 :               }</span>
<span class="lineNum">    8826 </span>            : 
<span class="lineNum">    8827 </span><span class="lineCov">      11877 :             e1_p = &amp;(*cexpr_list)[0];</span>
<span class="lineNum">    8828 </span><span class="lineCov">      11877 :             e2_p = &amp;(*cexpr_list)[1];</span>
<span class="lineNum">    8829 </span><span class="lineCov">      11877 : </span>
<span class="lineNum">    8830 </span><span class="lineCov">      11877 :             *e1_p = convert_lvalue_to_rvalue (loc, *e1_p, true, true);</span>
<span class="lineNum">    8831 </span><span class="lineCov">      11877 :             if (TREE_CODE (e1_p-&gt;value) == EXCESS_PRECISION_EXPR)</span>
<span class="lineNum">    8832 </span>            :               e1_p-&gt;value = convert (TREE_TYPE (e1_p-&gt;value),
<span class="lineNum">    8833 </span><span class="lineCov">      11877 :                                      TREE_OPERAND (e1_p-&gt;value, 0));</span>
<span class="lineNum">    8834 </span><span class="lineCov">      11877 :             *e2_p = convert_lvalue_to_rvalue (loc, *e2_p, true, true);</span>
<span class="lineNum">    8835 </span>            :             if (TREE_CODE (e2_p-&gt;value) == EXCESS_PRECISION_EXPR)
<span class="lineNum">    8836 </span>            :               e2_p-&gt;value = convert (TREE_TYPE (e2_p-&gt;value),
<span class="lineNum">    8837 </span>            :                                      TREE_OPERAND (e2_p-&gt;value, 0));
<span class="lineNum">    8838 </span>            :             if (!SCALAR_FLOAT_TYPE_P (TREE_TYPE (e1_p-&gt;value))
<span class="lineNum">    8839 </span><span class="lineCov">          1 :                 || DECIMAL_FLOAT_TYPE_P (TREE_TYPE (e1_p-&gt;value))</span>
<span class="lineNum">    8840 </span>            :                 || !SCALAR_FLOAT_TYPE_P (TREE_TYPE (e2_p-&gt;value))
<span class="lineNum">    8841 </span>            :                 || DECIMAL_FLOAT_TYPE_P (TREE_TYPE (e2_p-&gt;value)))
<span class="lineNum">    8842 </span>            :               {
<span class="lineNum">    8843 </span><span class="lineCov">      11876 :                 error_at (loc, &quot;%&lt;__builtin_complex%&gt; operand &quot;</span>
<span class="lineNum">    8844 </span>            :                           &quot;not of real binary floating-point type&quot;);
<span class="lineNum">    8845 </span><span class="lineCov">          2 :                 expr.set_error ();</span>
<span class="lineNum">    8846 </span>            :                 break;
<span class="lineNum">    8847 </span><span class="lineCov">          2 :               }</span>
<span class="lineNum">    8848 </span>            :             if (TYPE_MAIN_VARIANT (TREE_TYPE (e1_p-&gt;value))
<span class="lineNum">    8849 </span>            :                 != TYPE_MAIN_VARIANT (TREE_TYPE (e2_p-&gt;value)))
<span class="lineNum">    8850 </span>            :               {
<span class="lineNum">    8851 </span><span class="lineCov">      11874 :                 error_at (loc,</span>
<span class="lineNum">    8852 </span><span class="lineCov">      11874 :                           &quot;%&lt;__builtin_complex%&gt; operands of different types&quot;);</span>
<span class="lineNum">    8853 </span>            :                 expr.set_error ();
<span class="lineNum">    8854 </span><span class="lineCov">      11874 :                 break;</span>
<span class="lineNum">    8855 </span><span class="lineCov">      11874 :               }</span>
<span class="lineNum">    8856 </span><span class="lineNoCov">          0 :             pedwarn_c90 (loc, OPT_Wpedantic,</span>
<span class="lineNum">    8857 </span><span class="lineNoCov">          0 :                          &quot;ISO C90 does not support complex types&quot;);</span>
<span class="lineNum">    8858 </span><span class="lineCov">      11874 :             expr.value = build2_loc (loc, COMPLEX_EXPR,</span>
<span class="lineNum">    8859 </span><span class="lineCov">      11874 :                                      build_complex_type</span>
<span class="lineNum">    8860 </span><span class="lineNoCov">          0 :                                      (TYPE_MAIN_VARIANT</span>
<span class="lineNum">    8861 </span><span class="lineNoCov">          0 :                                       (TREE_TYPE (e1_p-&gt;value))),</span>
<span class="lineNum">    8862 </span><span class="lineCov">      11874 :                                      e1_p-&gt;value, e2_p-&gt;value);</span>
<span class="lineNum">    8863 </span><span class="lineCov">      35619 :             set_c_expr_source_range (&amp;expr, loc, close_paren_loc);</span>
<span class="lineNum">    8864 </span><span class="lineCov">      11872 :             break;</span>
<span class="lineNum">    8865 </span><span class="lineCov">      47487 :           }</span>
<span class="lineNum">    8866 </span>            :         case RID_BUILTIN_SHUFFLE:
<span class="lineNum">    8867 </span><span class="lineCov">          3 :           {</span>
<span class="lineNum">    8868 </span>            :             vec&lt;c_expr_t, va_gc&gt; *cexpr_list;
<span class="lineNum">    8869 </span><span class="lineCov">          3 :             unsigned int i;</span>
<span class="lineNum">    8870 </span>            :             c_expr_t *p;
<span class="lineNum">    8871 </span>            :             location_t close_paren_loc;
<span class="lineNum">    8872 </span><span class="lineCov">      11871 : </span>
<span class="lineNum">    8873 </span><span class="lineCov">      11871 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    8874 </span>            :             if (!c_parser_get_builtin_args (parser,
<span class="lineNum">    8875 </span><span class="lineCov">          1 :                                             &quot;__builtin_shuffle&quot;,</span>
<span class="lineNum">    8876 </span>            :                                             &amp;cexpr_list, false,
<span class="lineNum">    8877 </span><span class="lineCov">          1 :                                             &amp;close_paren_loc))</span>
<span class="lineNum">    8878 </span>            :               {
<span class="lineNum">    8879 </span>            :                 expr.set_error ();
<span class="lineNum">    8880 </span><span class="lineCov">      11870 :                 break;</span>
<span class="lineNum">    8881 </span>            :               }
<span class="lineNum">    8882 </span><span class="lineCov">      11870 : </span>
<span class="lineNum">    8883 </span>            :             FOR_EACH_VEC_SAFE_ELT (cexpr_list, i, p)
<span class="lineNum">    8884 </span><span class="lineCov">      11870 :               *p = convert_lvalue_to_rvalue (loc, *p, true, true);</span>
<span class="lineNum">    8885 </span>            : 
<span class="lineNum">    8886 </span>            :             if (vec_safe_length (cexpr_list) == 2)
<span class="lineNum">    8887 </span><span class="lineCov">      11870 :               expr.value =</span>
<span class="lineNum">    8888 </span><span class="lineCov">      11870 :                 c_build_vec_perm_expr</span>
<span class="lineNum">    8889 </span>            :                   (loc, (*cexpr_list)[0].value,
<span class="lineNum">    8890 </span><span class="lineCov">     211343 :                    NULL_TREE, (*cexpr_list)[1].value);</span>
<span class="lineNum">    8891 </span><span class="lineCov">     211343 : </span>
<span class="lineNum">    8892 </span><span class="lineCov">     211343 :             else if (vec_safe_length (cexpr_list) == 3)</span>
<span class="lineNum">    8893 </span><span class="lineCov">     211343 :               expr.value =</span>
<span class="lineNum">    8894 </span><span class="lineCov">     211343 :                 c_build_vec_perm_expr</span>
<span class="lineNum">    8895 </span><span class="lineCov">     211343 :                   (loc, (*cexpr_list)[0].value,</span>
<span class="lineNum">    8896 </span>            :                    (*cexpr_list)[1].value,
<span class="lineNum">    8897 </span><span class="lineCov">     211343 :                    (*cexpr_list)[2].value);</span>
<span class="lineNum">    8898 </span><span class="lineCov">     211343 :             else</span>
<span class="lineNum">    8899 </span>            :               {
<span class="lineNum">    8900 </span>            :                 error_at (loc, &quot;wrong number of arguments to &quot;
<span class="lineNum">    8901 </span>            :                                &quot;%&lt;__builtin_shuffle%&gt;&quot;);
<span class="lineNum">    8902 </span>            :                 expr.set_error ();
<span class="lineNum">    8903 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">    8904 </span>            :             set_c_expr_source_range (&amp;expr, loc, close_paren_loc);
<span class="lineNum">    8905 </span>            :             break;
<span class="lineNum">    8906 </span>            :           }
<span class="lineNum">    8907 </span><span class="lineCov">     659582 :         case RID_AT_SELECTOR:</span>
<span class="lineNum">    8908 </span><span class="lineCov">     448239 :           {</span>
<span class="lineNum">    8909 </span>            :             gcc_assert (c_dialect_objc ());
<span class="lineNum">    8910 </span><span class="lineCov">     211343 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    8911 </span><span class="lineCov">     185790 :             matching_parens parens;</span>
<span class="lineNum">    8912 </span>            :             if (!parens.require_open (parser))
<span class="lineNum">    8913 </span><span class="lineCov">     185790 :               {</span>
<span class="lineNum">    8914 </span><span class="lineCov">     185790 :                 expr.set_error ();</span>
<span class="lineNum">    8915 </span>            :                 break;
<span class="lineNum">    8916 </span><span class="lineCov">      25553 :               }</span>
<span class="lineNum">    8917 </span><span class="lineCov">      25553 :             tree sel = c_parser_objc_selector_arg (parser);</span>
<span class="lineNum">    8918 </span>            :             location_t close_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    8919 </span><span class="lineCov">      51106 :             parens.skip_until_found_close (parser);</span>
<span class="lineNum">    8920 </span><span class="lineCov">      25553 :             expr.value = objc_build_selector_expr (loc, sel);</span>
<span class="lineNum">    8921 </span><span class="lineCov">      25553 :             set_c_expr_source_range (&amp;expr, loc, close_loc);</span>
<span class="lineNum">    8922 </span>            :           }
<span class="lineNum">    8923 </span>            :           break;
<span class="lineNum">    8924 </span><span class="lineNoCov">          0 :         case RID_AT_PROTOCOL:</span>
<span class="lineNum">    8925 </span>            :           {
<span class="lineNum">    8926 </span><span class="lineNoCov">          0 :             gcc_assert (c_dialect_objc ());</span>
<span class="lineNum">    8927 </span>            :             c_parser_consume_token (parser);
<span class="lineNum">    8928 </span><span class="lineCov">     211343 :             matching_parens parens;</span>
<span class="lineNum">    8929 </span><span class="lineCov">     211343 :             if (!parens.require_open (parser))</span>
<span class="lineNum">    8930 </span>            :               {
<span class="lineNum">    8931 </span><span class="lineNoCov">          0 :                 expr.set_error ();</span>
<span class="lineNum">    8932 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    8933 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">    8934 </span><span class="lineNoCov">          0 :             if (c_parser_next_token_is_not (parser, CPP_NAME))</span>
<span class="lineNum">    8935 </span><span class="lineNoCov">          0 :               {</span>
<span class="lineNum">    8936 </span><span class="lineNoCov">          0 :                 c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">    8937 </span>            :                 c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
<span class="lineNum">    8938 </span><span class="lineNoCov">          0 :                 expr.set_error ();</span>
<span class="lineNum">    8939 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    8940 </span>            :               }
<span class="lineNum">    8941 </span><span class="lineNoCov">          0 :             tree id = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">    8942 </span><span class="lineNoCov">          0 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    8943 </span><span class="lineNoCov">          0 :             location_t close_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    8944 </span><span class="lineNoCov">          0 :             parens.skip_until_found_close (parser);</span>
<span class="lineNum">    8945 </span><span class="lineNoCov">          0 :             expr.value = objc_build_protocol_expr (id);</span>
<span class="lineNum">    8946 </span>            :             set_c_expr_source_range (&amp;expr, loc, close_loc);
<span class="lineNum">    8947 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    8948 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    8949 </span><span class="lineNoCov">          0 :         case RID_AT_ENCODE:</span>
<span class="lineNum">    8950 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">    8951 </span><span class="lineNoCov">          0 :             /* Extension to support C-structures in the archiver.  */</span>
<span class="lineNum">    8952 </span><span class="lineNoCov">          0 :             gcc_assert (c_dialect_objc ());</span>
<span class="lineNum">    8953 </span><span class="lineNoCov">          0 :             c_parser_consume_token (parser);</span>
<span class="lineNum">    8954 </span>            :             matching_parens parens;
<span class="lineNum">    8955 </span><span class="lineNoCov">          0 :             if (!parens.require_open (parser))</span>
<span class="lineNum">    8956 </span>            :               {
<span class="lineNum">    8957 </span>            :                 expr.set_error ();
<span class="lineNum">    8958 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    8959 </span>            :               }
<span class="lineNum">    8960 </span><span class="lineNoCov">          0 :             t1 = c_parser_type_name (parser);</span>
<span class="lineNum">    8961 </span><span class="lineNoCov">          0 :             if (t1 == NULL)</span>
<span class="lineNum">    8962 </span><span class="lineNoCov">          0 :               {</span>
<span class="lineNum">    8963 </span>            :                 expr.set_error ();
<span class="lineNum">    8964 </span>            :                 c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);
<span class="lineNum">    8965 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    8966 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">    8967 </span><span class="lineNoCov">          0 :             location_t close_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    8968 </span><span class="lineNoCov">          0 :             parens.skip_until_found_close (parser);</span>
<span class="lineNum">    8969 </span><span class="lineNoCov">          0 :             tree type = groktypename (t1, NULL, NULL);</span>
<span class="lineNum">    8970 </span><span class="lineNoCov">          0 :             expr.value = objc_build_encode_expr (type);</span>
<span class="lineNum">    8971 </span>            :             set_c_expr_source_range (&amp;expr, loc, close_loc);
<span class="lineNum">    8972 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">    8973 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    8974 </span><span class="lineNoCov">          0 :         case RID_GENERIC:</span>
<span class="lineNum">    8975 </span>            :           expr = c_parser_generic_selection (parser);
<span class="lineNum">    8976 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    8977 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    8978 </span><span class="lineNoCov">          0 :           c_parser_error (parser, &quot;expected expression&quot;);</span>
<span class="lineNum">    8979 </span><span class="lineNoCov">          0 :           expr.set_error ();</span>
<span class="lineNum">    8980 </span>            :           break;
<span class="lineNum">    8981 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    8982 </span>            :       break;
<span class="lineNum">    8983 </span>            :     case CPP_OPEN_SQUARE:
<span class="lineNum">    8984 </span><span class="lineNoCov">          0 :       if (c_dialect_objc ())</span>
<span class="lineNum">    8985 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    8986 </span>            :           tree receiver, args;
<span class="lineNum">    8987 </span><span class="lineNoCov">          0 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    8988 </span><span class="lineNoCov">          0 :           receiver = c_parser_objc_receiver (parser);</span>
<span class="lineNum">    8989 </span><span class="lineNoCov">          0 :           args = c_parser_objc_message_args (parser);</span>
<span class="lineNum">    8990 </span>            :           location_t close_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    8991 </span><span class="lineNoCov">          0 :           c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,</span>
<span class="lineNum">    8992 </span><span class="lineNoCov">          0 :                                      &quot;expected %&lt;]%&gt;&quot;);</span>
<span class="lineNum">    8993 </span><span class="lineNoCov">          0 :           expr.value = objc_build_message_expr (receiver, args);</span>
<span class="lineNum">    8994 </span><span class="lineNoCov">          0 :           set_c_expr_source_range (&amp;expr, loc, close_loc);</span>
<span class="lineNum">    8995 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    8996 </span>            :         }
<span class="lineNum">    8997 </span><span class="lineNoCov">          0 :       /* Else fall through to report error.  */</span>
<span class="lineNum">    8998 </span><span class="lineCov">        126 :       /* FALLTHRU */</span>
<span class="lineNum">    8999 </span><span class="lineCov">        126 :     default:</span>
<span class="lineNum">    9000 </span><span class="lineCov">        126 :       c_parser_error (parser, &quot;expected expression&quot;);</span>
<span class="lineNum">    9001 </span><span class="lineCov">         27 :       expr.set_error ();</span>
<span class="lineNum">    9002 </span><span class="lineCov">         27 :       break;</span>
<span class="lineNum">    9003 </span><span class="lineCov">         27 :     }</span>
<span class="lineNum">    9004 </span>            :  out:
<span class="lineNum">    9005 </span>            :   return c_parser_postfix_expression_after_primary
<span class="lineNum">    9006 </span>            :     (parser, EXPR_LOC_OR_LOC (expr.value, loc), expr);
<span class="lineNum">    9007 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    9008 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9009 </span>            : /* Parse a postfix expression after a parenthesized type name: the
<span class="lineNum">    9010 </span><span class="lineNoCov">          0 :    brace-enclosed initializer of a compound literal, possibly followed</span>
<span class="lineNum">    9011 </span><span class="lineNoCov">          0 :    by some postfix operators.  This is separate because it is not</span>
<span class="lineNum">    9012 </span><span class="lineNoCov">          0 :    possible to tell until after the type name whether a cast</span>
<span class="lineNum">    9013 </span><span class="lineNoCov">          0 :    expression has a cast or a compound literal, or whether the operand</span>
<span class="lineNum">    9014 </span><span class="lineNoCov">          0 :    of sizeof is a parenthesized type name or starts with a compound</span>
<span class="lineNum">    9015 </span><span class="lineNoCov">          0 :    literal.  TYPE_LOC is the location where TYPE_NAME starts--the</span>
<span class="lineNum">    9016 </span>            :    location of the first token after the parentheses around the type
<span class="lineNum">    9017 </span><span class="lineNoCov">          0 :    name.  */</span>
<a name="9018"><span class="lineNum">    9018 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">    9019 </span><span class="lineNoCov">          0 : static struct c_expr</span>
<span class="lineNum">    9020 </span><span class="lineNoCov">          0 : c_parser_postfix_expression_after_paren_type (c_parser *parser,</span>
<span class="lineNum">    9021 </span>            :                                               struct c_type_name *type_name,
<span class="lineNum">    9022 </span>            :                                               location_t type_loc)
<span class="lineNum">    9023 </span><span class="lineCov">        407 : {</span>
<span class="lineNum">    9024 </span><span class="lineCov">        407 :   tree type;</span>
<span class="lineNum">    9025 </span><span class="lineCov">        407 :   struct c_expr init;</span>
<span class="lineNum">    9026 </span>            :   bool non_const;
<span class="lineNum">    9027 </span>            :   struct c_expr expr;
<span class="lineNum">    9028 </span><span class="lineCov">  112457028 :   location_t start_loc;</span>
<span class="lineNum">    9029 </span><span class="lineCov">  112457028 :   tree type_expr = NULL_TREE;</span>
<span class="lineNum">    9030 </span><span class="lineCov">  112457028 :   bool type_expr_const = true;</span>
<span class="lineNum">    9031 </span>            :   check_compound_literal_type (type_loc, type_name);
<span class="lineNum">    9032 </span>            :   rich_location richloc (line_table, type_loc);
<span class="lineNum">    9033 </span>            :   start_init (NULL_TREE, NULL, 0, &amp;richloc);
<span class="lineNum">    9034 </span>            :   type = groktypename (type_name, &amp;type_expr, &amp;type_expr_const);
<span class="lineNum">    9035 </span>            :   start_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    9036 </span>            :   if (type != error_mark_node &amp;&amp; C_TYPE_VARIABLE_SIZE (type))
<span class="lineNum">    9037 </span>            :     {
<span class="lineNum">    9038 </span>            :       error_at (type_loc, &quot;compound literal has variable size&quot;);
<span class="lineNum">    9039 </span>            :       type = error_mark_node;
<span class="lineNum">    9040 </span>            :     }
<span class="lineNum">    9041 </span>            :   init = c_parser_braced_init (parser, type, false, NULL);
<span class="lineNum">    9042 </span>            :   finish_init ();
<span class="lineNum">    9043 </span>            :   maybe_warn_string_init (type_loc, type, init);
<span class="lineNum">    9044 </span><span class="lineCov">     435285 : </span>
<span class="lineNum">    9045 </span>            :   if (type != error_mark_node
<span class="lineNum">    9046 </span>            :       &amp;&amp; !ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (type))
<span class="lineNum">    9047 </span>            :       &amp;&amp; current_function_decl)
<span class="lineNum">    9048 </span><span class="lineCov">     435285 :     {</span>
<span class="lineNum">    9049 </span><span class="lineCov">     435285 :       error (&quot;compound literal qualified by address-space qualifier&quot;);</span>
<span class="lineNum">    9050 </span><span class="lineCov">     435285 :       type = error_mark_node;</span>
<span class="lineNum">    9051 </span><span class="lineCov">     435285 :     }</span>
<span class="lineNum">    9052 </span><span class="lineCov">     435285 : </span>
<span class="lineNum">    9053 </span><span class="lineCov">     435285 :   pedwarn_c90 (start_loc, OPT_Wpedantic, &quot;ISO C90 forbids compound literals&quot;);</span>
<span class="lineNum">    9054 </span><span class="lineCov">     435285 :   non_const = ((init.value &amp;&amp; TREE_CODE (init.value) == CONSTRUCTOR)</span>
<span class="lineNum">    9055 </span><span class="lineCov">     435285 :                ? CONSTRUCTOR_NON_CONST (init.value)</span>
<span class="lineNum">    9056 </span><span class="lineCov">     870570 :                : init.original_code == C_MAYBE_CONST_EXPR);</span>
<span class="lineNum">    9057 </span><span class="lineCov">     435285 :   non_const |= !type_expr_const;</span>
<span class="lineNum">    9058 </span><span class="lineCov">     435285 :   unsigned int alignas_align = 0;</span>
<span class="lineNum">    9059 </span><span class="lineCov">     435285 :   if (type != error_mark_node</span>
<span class="lineNum">    9060 </span><span class="lineCov">     435285 :       &amp;&amp; type_name-&gt;specs-&gt;align_log != -1)</span>
<span class="lineNum">    9061 </span>            :     {
<span class="lineNum">    9062 </span><span class="lineCov">          8 :       alignas_align = 1U &lt;&lt; type_name-&gt;specs-&gt;align_log;</span>
<span class="lineNum">    9063 </span><span class="lineCov">          8 :       if (alignas_align &lt; min_align_of_type (type))</span>
<span class="lineNum">    9064 </span>            :         {
<span class="lineNum">    9065 </span><span class="lineCov">     435285 :           error_at (type_name-&gt;specs-&gt;locations[cdw_alignas],</span>
<span class="lineNum">    9066 </span><span class="lineCov">     435285 :                     &quot;%&lt;_Alignas%&gt; specifiers cannot reduce &quot;</span>
<span class="lineNum">    9067 </span><span class="lineCov">     435285 :                     &quot;alignment of compound literal&quot;);</span>
<span class="lineNum">    9068 </span>            :           alignas_align = 0;
<span class="lineNum">    9069 </span><span class="lineCov">     435285 :         }</span>
<span class="lineNum">    9070 </span><span class="lineCov">     435275 :     }</span>
<span class="lineNum">    9071 </span><span class="lineCov">     435285 :   expr.value = build_compound_literal (start_loc, type, init.value, non_const,</span>
<span class="lineNum">    9072 </span>            :                                        alignas_align);
<span class="lineNum">    9073 </span><span class="lineNoCov">          0 :   set_c_expr_source_range (&amp;expr, init.src_range);</span>
<span class="lineNum">    9074 </span><span class="lineNoCov">          0 :   expr.original_code = ERROR_MARK;</span>
<span class="lineNum">    9075 </span>            :   expr.original_type = NULL;
<span class="lineNum">    9076 </span>            :   if (type != error_mark_node
<span class="lineNum">    9077 </span><span class="lineCov">     435285 :       &amp;&amp; expr.value != error_mark_node</span>
<span class="lineNum">    9078 </span><span class="lineCov">     435285 :       &amp;&amp; type_expr)</span>
<span class="lineNum">    9079 </span><span class="lineCov">     870326 :     {</span>
<span class="lineNum">    9080 </span><span class="lineCov">     870570 :       if (TREE_CODE (expr.value) == C_MAYBE_CONST_EXPR)</span>
<span class="lineNum">    9081 </span><span class="lineCov">     435285 :         {</span>
<span class="lineNum">    9082 </span><span class="lineCov">     435285 :           gcc_assert (C_MAYBE_CONST_EXPR_PRE (expr.value) == NULL_TREE);</span>
<span class="lineNum">    9083 </span><span class="lineCov">     435285 :           C_MAYBE_CONST_EXPR_PRE (expr.value) = type_expr;</span>
<span class="lineNum">    9084 </span><span class="lineCov">     435275 :         }</span>
<span class="lineNum">    9085 </span>            :       else
<span class="lineNum">    9086 </span><span class="lineCov">          4 :         {</span>
<span class="lineNum">    9087 </span><span class="lineCov">          4 :           gcc_assert (!non_const);</span>
<span class="lineNum">    9088 </span>            :           expr.value = build2 (C_MAYBE_CONST_EXPR, type,
<span class="lineNum">    9089 </span><span class="lineCov">          1 :                                type_expr, expr.value);</span>
<span class="lineNum">    9090 </span>            :         }
<span class="lineNum">    9091 </span>            :     }
<span class="lineNum">    9092 </span><span class="lineCov">          1 :   return c_parser_postfix_expression_after_primary (parser, start_loc, expr);</span>
<span class="lineNum">    9093 </span>            : }
<span class="lineNum">    9094 </span>            : 
<span class="lineNum">    9095 </span><span class="lineCov">     435285 : /* Callback function for sizeof_pointer_memaccess_warning to compare</span>
<span class="lineNum">    9096 </span>            :    types.  */
<a name="9097"><span class="lineNum">    9097 </span><span class="lineCov">     435285 : </span></a>
<span class="lineNum">    9098 </span><span class="lineCov">     435285 : static bool</span>
<span class="lineNum">    9099 </span><span class="lineCov">     435285 : sizeof_ptr_memacc_comptypes (tree type1, tree type2)</span>
<span class="lineNum">    9100 </span><span class="lineCov">     435285 : {</span>
<span class="lineNum">    9101 </span><span class="lineCov">     435275 :   return comptypes (type1, type2) == 1;</span>
<span class="lineNum">    9102 </span><span class="lineCov">     435224 : }</span>
<span class="lineNum">    9103 </span>            : 
<span class="lineNum">    9104 </span><span class="lineCov">         18 : /* Warn for patterns where abs-like function appears to be used incorrectly,</span>
<span class="lineNum">    9105 </span>            :    gracely ignore any non-abs-like function.  The warning location should be
<span class="lineNum">    9106 </span><span class="lineCov">         22 :    LOC.  FNDECL is the declaration of called function, it must be a</span>
<span class="lineNum">    9107 </span><span class="lineCov">         22 :    BUILT_IN_NORMAL function.  ARG is the first and only argument of the</span>
<span class="lineNum">    9108 </span>            :    call.  */
<a name="9109"><span class="lineNum">    9109 </span>            : </a>
<span class="lineNum">    9110 </span>            : static void
<span class="lineNum">    9111 </span><span class="lineCov">          7 : warn_for_abs (location_t loc, tree fndecl, tree arg)</span>
<span class="lineNum">    9112 </span><span class="lineCov">          7 : {</span>
<span class="lineNum">    9113 </span>            :   tree atype = TREE_TYPE (arg);
<span class="lineNum">    9114 </span>            : 
<span class="lineNum">    9115 </span>            :   /* Casts from pointers (and thus arrays and fndecls) will generate
<span class="lineNum">    9116 </span><span class="lineCov">     435285 :      -Wint-conversion warnings.  Most other wrong types hopefully lead to type</span>
<span class="lineNum">    9117 </span>            :      mismatch errors.  TODO: Think about what to do with FIXED_POINT_TYPE_P
<span class="lineNum">    9118 </span>            :      types and possibly other exotic types.  */
<span class="lineNum">    9119 </span>            :   if (!INTEGRAL_TYPE_P (atype)
<span class="lineNum">    9120 </span>            :       &amp;&amp; !SCALAR_FLOAT_TYPE_P (atype)
<span class="lineNum">    9121 </span>            :       &amp;&amp; TREE_CODE (atype) != COMPLEX_TYPE)
<span class="lineNum">    9122 </span>            :     return;
<span class="lineNum">    9123 </span><span class="lineCov">       3439 : </span>
<span class="lineNum">    9124 </span>            :   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);
<span class="lineNum">    9125 </span><span class="lineCov">       3439 : </span>
<span class="lineNum">    9126 </span>            :   switch (fcode)
<span class="lineNum">    9127 </span>            :     {
<span class="lineNum">    9128 </span>            :     case BUILT_IN_ABS:
<span class="lineNum">    9129 </span>            :     case BUILT_IN_LABS:
<span class="lineNum">    9130 </span>            :     case BUILT_IN_LLABS:
<span class="lineNum">    9131 </span>            :     case BUILT_IN_IMAXABS:
<span class="lineNum">    9132 </span>            :       if (!INTEGRAL_TYPE_P (atype))
<span class="lineNum">    9133 </span>            :         {
<span class="lineNum">    9134 </span>            :           if (SCALAR_FLOAT_TYPE_P (atype))
<span class="lineNum">    9135 </span><span class="lineCov">      17932 :             warning_at (loc, OPT_Wabsolute_value,</span>
<span class="lineNum">    9136 </span>            :                         &quot;using integer absolute value function %qD when &quot;
<span class="lineNum">    9137 </span><span class="lineCov">      17932 :                         &quot;argument is of floating point type %qT&quot;,</span>
<span class="lineNum">    9138 </span>            :                         fndecl, atype);
<span class="lineNum">    9139 </span>            :           else if (TREE_CODE (atype) == COMPLEX_TYPE)
<span class="lineNum">    9140 </span>            :             warning_at (loc, OPT_Wabsolute_value,
<span class="lineNum">    9141 </span>            :                         &quot;using integer absolute value function %qD when &quot;
<span class="lineNum">    9142 </span>            :                         &quot;argument is of complex type %qT&quot;, fndecl, atype);
<span class="lineNum">    9143 </span><span class="lineCov">      35864 :           else</span>
<span class="lineNum">    9144 </span><span class="lineCov">      17932 :             gcc_unreachable ();</span>
<span class="lineNum">    9145 </span><span class="lineCov">       3149 :           return;</span>
<span class="lineNum">    9146 </span>            :         }
<span class="lineNum">    9147 </span>            :       if (TYPE_UNSIGNED (atype))
<span class="lineNum">    9148 </span><span class="lineCov">      16001 :         warning_at (loc, OPT_Wabsolute_value,</span>
<span class="lineNum">    9149 </span>            :                     &quot;taking the absolute value of unsigned type %qT &quot;
<span class="lineNum">    9150 </span><span class="lineCov">      16001 :                     &quot;has no effect&quot;, atype);</span>
<span class="lineNum">    9151 </span>            :       break;
<span class="lineNum">    9152 </span><span class="lineCov">         22 : </span>
<span class="lineNum">    9153 </span><span class="lineCov">         22 :     CASE_FLT_FN (BUILT_IN_FABS):</span>
<span class="lineNum">    9154 </span><span class="lineCov">         22 :     CASE_FLT_FN_FLOATN_NX (BUILT_IN_FABS):</span>
<span class="lineNum">    9155 </span><span class="lineCov">         22 :       if (!SCALAR_FLOAT_TYPE_P (atype)</span>
<span class="lineNum">    9156 </span><span class="lineCov">         22 :           || DECIMAL_FLOAT_MODE_P (TYPE_MODE (atype)))</span>
<span class="lineNum">    9157 </span>            :         {
<span class="lineNum">    9158 </span><span class="lineCov">          4 :           if (INTEGRAL_TYPE_P (atype))</span>
<span class="lineNum">    9159 </span><span class="lineCov">          3 :             warning_at (loc, OPT_Wabsolute_value,</span>
<span class="lineNum">    9160 </span>            :                         &quot;using floating point absolute value function %qD &quot;
<span class="lineNum">    9161 </span>            :                         &quot;when argument is of integer type %qT&quot;, fndecl, atype);
<span class="lineNum">    9162 </span>            :           else if (DECIMAL_FLOAT_TYPE_P (atype))
<span class="lineNum">    9163 </span><span class="lineCov">          1 :             warning_at (loc, OPT_Wabsolute_value,</span>
<span class="lineNum">    9164 </span><span class="lineCov">          1 :                         &quot;using floating point absolute value function %qD &quot;</span>
<span class="lineNum">    9165 </span>            :                         &quot;when argument is of decimal floating point type %qT&quot;,
<span class="lineNum">    9166 </span>            :                         fndecl, atype);
<span class="lineNum">    9167 </span>            :           else if (TREE_CODE (atype) == COMPLEX_TYPE)
<span class="lineNum">    9168 </span><span class="lineNoCov">          0 :             warning_at (loc, OPT_Wabsolute_value,</span>
<span class="lineNum">    9169 </span><span class="lineCov">          4 :                         &quot;using floating point absolute value function %qD when &quot;</span>
<span class="lineNum">    9170 </span>            :                         &quot;argument is of complex type %qT&quot;, fndecl, atype);
<span class="lineNum">    9171 </span><span class="lineCov">         18 :           else</span>
<span class="lineNum">    9172 </span><span class="lineCov">          4 :             gcc_unreachable ();</span>
<span class="lineNum">    9173 </span>            :           return;
<span class="lineNum">    9174 </span>            :         }
<span class="lineNum">    9175 </span>            :       break;
<span class="lineNum">    9176 </span>            : 
<span class="lineNum">    9177 </span><span class="lineCov">       4150 :     CASE_FLT_FN (BUILT_IN_CABS):</span>
<span class="lineNum">    9178 </span><span class="lineCov">       4150 :       if (TREE_CODE (atype) != COMPLEX_TYPE)</span>
<span class="lineNum">    9179 </span><span class="lineCov">       4150 :         {</span>
<span class="lineNum">    9180 </span><span class="lineCov">       4150 :           if (INTEGRAL_TYPE_P (atype))</span>
<span class="lineNum">    9181 </span>            :             warning_at (loc, OPT_Wabsolute_value,
<span class="lineNum">    9182 </span><span class="lineCov">          4 :                         &quot;using complex absolute value function %qD when &quot;</span>
<span class="lineNum">    9183 </span><span class="lineCov">          2 :                         &quot;argument is of integer type %qT&quot;, fndecl, atype);</span>
<span class="lineNum">    9184 </span>            :           else if (SCALAR_FLOAT_TYPE_P (atype))
<span class="lineNum">    9185 </span>            :             warning_at (loc, OPT_Wabsolute_value,
<span class="lineNum">    9186 </span><span class="lineCov">          2 :                         &quot;using complex absolute value function %qD when &quot;</span>
<span class="lineNum">    9187 </span><span class="lineCov">          1 :                         &quot;argument is of floating point type %qT&quot;,</span>
<span class="lineNum">    9188 </span>            :                         fndecl, atype);
<span class="lineNum">    9189 </span>            :           else
<span class="lineNum">    9190 </span>            :             gcc_unreachable ();
<span class="lineNum">    9191 </span><span class="lineCov">          1 : </span>
<span class="lineNum">    9192 </span><span class="lineCov">          1 :           return;</span>
<span class="lineNum">    9193 </span>            :         }
<span class="lineNum">    9194 </span>            :       break;
<span class="lineNum">    9195 </span>            : 
<span class="lineNum">    9196 </span><span class="lineNoCov">          0 :     case BUILT_IN_FABSD32:</span>
<span class="lineNum">    9197 </span><span class="lineCov">          4 :     case BUILT_IN_FABSD64:</span>
<span class="lineNum">    9198 </span>            :     case BUILT_IN_FABSD128:
<span class="lineNum">    9199 </span>            :       if (!DECIMAL_FLOAT_TYPE_P (atype))
<span class="lineNum">    9200 </span>            :         {
<span class="lineNum">    9201 </span><span class="lineCov">          7 :           if (INTEGRAL_TYPE_P (atype))</span>
<span class="lineNum">    9202 </span><span class="lineCov">          7 :             warning_at (loc, OPT_Wabsolute_value,</span>
<span class="lineNum">    9203 </span>            :                         &quot;using decimal floating point absolute value &quot;
<span class="lineNum">    9204 </span><span class="lineCov">          4 :                         &quot;function %qD when argument is of integer type %qT&quot;,</span>
<span class="lineNum">    9205 </span><span class="lineCov">          2 :                         fndecl, atype);</span>
<span class="lineNum">    9206 </span>            :           else if (SCALAR_FLOAT_TYPE_P (atype))
<span class="lineNum">    9207 </span>            :             warning_at (loc, OPT_Wabsolute_value,
<span class="lineNum">    9208 </span><span class="lineCov">          2 :                         &quot;using decimal floating point absolute value &quot;</span>
<span class="lineNum">    9209 </span><span class="lineCov">          2 :                         &quot;function %qD when argument is of floating point &quot;</span>
<span class="lineNum">    9210 </span>            :                         &quot;type %qT&quot;, fndecl, atype);
<span class="lineNum">    9211 </span>            :           else if (TREE_CODE (atype) == COMPLEX_TYPE)
<span class="lineNum">    9212 </span>            :             warning_at (loc, OPT_Wabsolute_value,
<span class="lineNum">    9213 </span>            :                         &quot;using decimal floating point absolute value &quot;
<span class="lineNum">    9214 </span><span class="lineNoCov">          0 :                         &quot;function %qD when argument is of complex type %qT&quot;,</span>
<span class="lineNum">    9215 </span>            :                         fndecl, atype);
<span class="lineNum">    9216 </span><span class="lineCov">          4 :           else</span>
<span class="lineNum">    9217 </span>            :             gcc_unreachable ();
<span class="lineNum">    9218 </span>            :           return;
<span class="lineNum">    9219 </span>            :         }
<span class="lineNum">    9220 </span><span class="lineCov">          6 :       break;</span>
<span class="lineNum">    9221 </span><span class="lineCov">          6 : </span>
<span class="lineNum">    9222 </span><span class="lineCov">          6 :     default:</span>
<span class="lineNum">    9223 </span><span class="lineCov">          6 :       return;</span>
<span class="lineNum">    9224 </span>            :     }
<span class="lineNum">    9225 </span><span class="lineCov">          4 : </span>
<span class="lineNum">    9226 </span><span class="lineCov">          1 :   tree ftype = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));</span>
<span class="lineNum">    9227 </span>            :   if (TREE_CODE (atype) == COMPLEX_TYPE)
<span class="lineNum">    9228 </span>            :     {
<span class="lineNum">    9229 </span>            :       gcc_assert (TREE_CODE (ftype) == COMPLEX_TYPE);
<span class="lineNum">    9230 </span><span class="lineCov">          3 :       atype = TREE_TYPE (atype);</span>
<span class="lineNum">    9231 </span><span class="lineCov">          2 :       ftype = TREE_TYPE (ftype);</span>
<span class="lineNum">    9232 </span>            :     }
<span class="lineNum">    9233 </span>            : 
<span class="lineNum">    9234 </span>            :   if (TYPE_PRECISION (ftype) &lt; TYPE_PRECISION (atype))
<span class="lineNum">    9235 </span><span class="lineCov">          1 :     warning_at (loc, OPT_Wabsolute_value,</span>
<span class="lineNum">    9236 </span><span class="lineCov">          1 :                 &quot;absolute value function %qD given an argument of type %qT &quot;</span>
<span class="lineNum">    9237 </span>            :                 &quot;but has parameter of type %qT which may cause truncation &quot;
<span class="lineNum">    9238 </span>            :                 &quot;of value&quot;, fndecl, atype, ftype);
<span class="lineNum">    9239 </span>            : }
<span class="lineNum">    9240 </span>            : 
<span class="lineNum">    9241 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9242 </span><span class="lineCov">          4 : /* Parse a postfix expression after the initial primary or compound</span>
<span class="lineNum">    9243 </span>            :    literal; that is, parse a series of postfix operators.
<span class="lineNum">    9244 </span>            : 
<span class="lineNum">    9245 </span>            :    EXPR_LOC is the location of the primary expression.  */
<a name="9246"><span class="lineNum">    9246 </span>            : </a>
<span class="lineNum">    9247 </span>            : static struct c_expr
<span class="lineNum">    9248 </span>            : c_parser_postfix_expression_after_primary (c_parser *parser,
<span class="lineNum">    9249 </span>            :                                            location_t expr_loc,
<span class="lineNum">    9250 </span><span class="lineCov">       4169 :                                            struct c_expr expr)</span>
<span class="lineNum">    9251 </span><span class="lineCov">       4169 : {</span>
<span class="lineNum">    9252 </span>            :   struct c_expr orig_expr;
<span class="lineNum">    9253 </span><span class="lineCov">          3 :   tree ident, idx;</span>
<span class="lineNum">    9254 </span><span class="lineCov">          3 :   location_t sizeof_arg_loc[3], comp_loc;</span>
<span class="lineNum">    9255 </span><span class="lineCov">          3 :   tree sizeof_arg[3];</span>
<span class="lineNum">    9256 </span>            :   unsigned int literal_zero_mask;
<span class="lineNum">    9257 </span>            :   unsigned int i;
<span class="lineNum">    9258 </span><span class="lineCov">       4169 :   vec&lt;tree, va_gc&gt; *exprlist;</span>
<span class="lineNum">    9259 </span><span class="lineCov">          8 :   vec&lt;tree, va_gc&gt; *origtypes = NULL;</span>
<span class="lineNum">    9260 </span>            :   vec&lt;location_t&gt; arg_loc = vNULL;
<span class="lineNum">    9261 </span>            :   location_t start;
<span class="lineNum">    9262 </span>            :   location_t finish;
<span class="lineNum">    9263 </span>            : 
<span class="lineNum">    9264 </span>            :   while (true)
<span class="lineNum">    9265 </span>            :     {
<span class="lineNum">    9266 </span>            :       location_t op_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    9267 </span>            :       switch (c_parser_peek_token (parser)-&gt;type)
<span class="lineNum">    9268 </span>            :         {
<span class="lineNum">    9269 </span>            :         case CPP_OPEN_SQUARE:
<span class="lineNum">    9270 </span>            :           /* Array reference.  */
<span class="lineNum">    9271 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    9272 </span><span class="lineCov">  112892313 :           idx = c_parser_expression (parser).value;</span>
<span class="lineNum">    9273 </span>            :           c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,
<span class="lineNum">    9274 </span>            :                                      &quot;expected %&lt;]%&gt;&quot;);
<span class="lineNum">    9275 </span>            :           start = expr.get_start ();
<span class="lineNum">    9276 </span><span class="lineCov">  112892313 :           finish = parser-&gt;tokens_buf[0].location;</span>
<span class="lineNum">    9277 </span><span class="lineCov">  112892313 :           expr.value = build_array_ref (op_loc, expr.value, idx);</span>
<span class="lineNum">    9278 </span><span class="lineCov">  112892313 :           set_c_expr_source_range (&amp;expr, start, finish);</span>
<span class="lineNum">    9279 </span><span class="lineCov">  112892313 :           expr.original_code = ERROR_MARK;</span>
<span class="lineNum">    9280 </span><span class="lineCov">  112892313 :           expr.original_type = NULL;</span>
<span class="lineNum">    9281 </span><span class="lineCov">  112892313 :           break;</span>
<span class="lineNum">    9282 </span><span class="lineCov">  112892313 :         case CPP_OPEN_PAREN:</span>
<span class="lineNum">    9283 </span><span class="lineCov">  112892313 :           /* Function call.  */</span>
<span class="lineNum">    9284 </span><span class="lineCov">  112892313 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    9285 </span><span class="lineCov">  141195461 :           for (i = 0; i &lt; 3; i++)</span>
<span class="lineNum">    9286 </span><span class="lineCov">  141195461 :             {</span>
<span class="lineNum">    9287 </span>            :               sizeof_arg[i] = NULL_TREE;
<span class="lineNum">    9288 </span><span class="lineCov">  141195461 :               sizeof_arg_loc[i] = UNKNOWN_LOCATION;</span>
<span class="lineNum">    9289 </span>            :             }
<span class="lineNum">    9290 </span><span class="lineCov">  141195461 :           literal_zero_mask = 0;</span>
<span class="lineNum">    9291 </span><span class="lineCov">  141195461 :           if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))</span>
<span class="lineNum">    9292 </span>            :             exprlist = NULL;
<span class="lineNum">    9293 </span><span class="lineCov">    2065082 :           else</span>
<span class="lineNum">    9294 </span>            :             exprlist = c_parser_expr_list (parser, true, false, &amp;origtypes,
<span class="lineNum">    9295 </span><span class="lineCov">    2065082 :                                            sizeof_arg_loc, sizeof_arg,</span>
<span class="lineNum">    9296 </span><span class="lineCov">    2065082 :                                            &amp;arg_loc, &amp;literal_zero_mask);</span>
<span class="lineNum">    9297 </span><span class="lineCov">    2065082 :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,</span>
<span class="lineNum">    9298 </span>            :                                      &quot;expected %&lt;)%&gt;&quot;);
<span class="lineNum">    9299 </span><span class="lineCov">    2065082 :           orig_expr = expr;</span>
<span class="lineNum">    9300 </span><span class="lineCov">    2065082 :           mark_exp_read (expr.value);</span>
<span class="lineNum">    9301 </span><span class="lineCov">    2065082 :           if (warn_sizeof_pointer_memaccess)</span>
<span class="lineNum">    9302 </span><span class="lineCov">    2065082 :             sizeof_pointer_memaccess_warning (sizeof_arg_loc,</span>
<span class="lineNum">    9303 </span><span class="lineCov">    2065082 :                                               expr.value, exprlist,</span>
<span class="lineNum">    9304 </span><span class="lineCov">    2065082 :                                               sizeof_arg,</span>
<span class="lineNum">    9305 </span><span class="lineCov">    2065082 :                                               sizeof_ptr_memacc_comptypes);</span>
<span class="lineNum">    9306 </span><span class="lineCov">   24210591 :           if (TREE_CODE (expr.value) == FUNCTION_DECL)</span>
<span class="lineNum">    9307 </span>            :             {
<span class="lineNum">    9308 </span><span class="lineCov">   24210591 :               if (fndecl_built_in_p (expr.value, BUILT_IN_MEMSET)</span>
<span class="lineNum">    9309 </span><span class="lineCov">   96842364 :                   &amp;&amp; vec_safe_length (exprlist) == 3)</span>
<span class="lineNum">    9310 </span>            :                 {
<span class="lineNum">    9311 </span><span class="lineCov">   72631773 :                   tree arg0 = (*exprlist)[0];</span>
<span class="lineNum">    9312 </span><span class="lineCov">   72631773 :                   tree arg2 = (*exprlist)[2];</span>
<span class="lineNum">    9313 </span>            :                   warn_for_memset (expr_loc, arg0, arg2, literal_zero_mask);
<span class="lineNum">    9314 </span><span class="lineCov">   24210591 :                 }</span>
<span class="lineNum">    9315 </span><span class="lineCov">   24210591 :               if (warn_absolute_value</span>
<span class="lineNum">    9316 </span>            :                   &amp;&amp; fndecl_built_in_p (expr.value, BUILT_IN_NORMAL)
<span class="lineNum">    9317 </span>            :                   &amp;&amp; vec_safe_length (exprlist) == 1)
<span class="lineNum">    9318 </span><span class="lineCov">   18674250 :                 warn_for_abs (expr_loc, expr.value, (*exprlist)[0]);</span>
<span class="lineNum">    9319 </span>            :             }
<span class="lineNum">    9320 </span>            : 
<span class="lineNum">    9321 </span><span class="lineCov">   24210591 :           start = expr.get_start ();</span>
<span class="lineNum">    9322 </span>            :           finish = parser-&gt;tokens_buf[0].get_finish ();
<span class="lineNum">    9323 </span><span class="lineCov">   24210591 :           expr.value</span>
<span class="lineNum">    9324 </span><span class="lineCov">   24210591 :             = c_build_function_call_vec (expr_loc, arg_loc, expr.value,</span>
<span class="lineNum">    9325 </span><span class="lineCov">   24210591 :                                          exprlist, origtypes);</span>
<span class="lineNum">    9326 </span><span class="lineCov">     784943 :           set_c_expr_source_range (&amp;expr, start, finish);</span>
<span class="lineNum">    9327 </span>            : 
<span class="lineNum">    9328 </span>            :           expr.original_code = ERROR_MARK;
<span class="lineNum">    9329 </span>            :           if (TREE_CODE (expr.value) == INTEGER_CST
<span class="lineNum">    9330 </span><span class="lineCov">   24210591 :               &amp;&amp; TREE_CODE (orig_expr.value) == FUNCTION_DECL</span>
<span class="lineNum">    9331 </span>            :               &amp;&amp; fndecl_built_in_p (orig_expr.value, BUILT_IN_CONSTANT_P))
<span class="lineNum">    9332 </span><span class="lineCov">   24142301 :             expr.original_code = C_MAYBE_CONST_EXPR;</span>
<span class="lineNum">    9333 </span><span class="lineCov">   24142301 :           expr.original_type = NULL;</span>
<span class="lineNum">    9334 </span>            :           if (exprlist)
<span class="lineNum">    9335 </span><span class="lineCov">      24451 :             {</span>
<span class="lineNum">    9336 </span><span class="lineCov">      24451 :               release_tree_vector (exprlist);</span>
<span class="lineNum">    9337 </span><span class="lineCov">      24451 :               release_tree_vector (origtypes);</span>
<span class="lineNum">    9338 </span>            :             }
<span class="lineNum">    9339 </span><span class="lineCov">   24142301 :           arg_loc.release ();</span>
<span class="lineNum">    9340 </span><span class="lineCov">     581446 :           break;</span>
<span class="lineNum">    9341 </span><span class="lineCov">   24219492 :         case CPP_DOT:</span>
<span class="lineNum">    9342 </span><span class="lineCov">      17932 :           /* Structure element reference.  */</span>
<span class="lineNum">    9343 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    9344 </span>            :           expr = default_function_array_conversion (expr_loc, expr);
<span class="lineNum">    9345 </span><span class="lineCov">   24210591 :           if (c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">    9346 </span><span class="lineCov">   24210591 :             {</span>
<span class="lineNum">    9347 </span><span class="lineCov">   24210591 :               c_token *comp_tok = c_parser_peek_token (parser);</span>
<span class="lineNum">    9348 </span><span class="lineCov">   24210591 :               ident = comp_tok-&gt;value;</span>
<span class="lineNum">    9349 </span>            :               comp_loc = comp_tok-&gt;location;
<span class="lineNum">    9350 </span><span class="lineCov">   24210591 :             }</span>
<span class="lineNum">    9351 </span>            :           else
<span class="lineNum">    9352 </span><span class="lineCov">   24210591 :             {</span>
<span class="lineNum">    9353 </span><span class="lineCov">   24210591 :               c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">    9354 </span><span class="lineCov">      10225 :               expr.set_error ();</span>
<span class="lineNum">    9355 </span><span class="lineCov">   24220816 :               expr.original_code = ERROR_MARK;</span>
<span class="lineNum">    9356 </span><span class="lineCov">        804 :               expr.original_type = NULL;</span>
<span class="lineNum">    9357 </span><span class="lineCov">   24210591 :               return expr;</span>
<span class="lineNum">    9358 </span><span class="lineCov">   24210591 :             }</span>
<span class="lineNum">    9359 </span>            :           start = expr.get_start ();
<span class="lineNum">    9360 </span><span class="lineCov">   18674250 :           finish = c_parser_peek_token (parser)-&gt;get_finish ();</span>
<span class="lineNum">    9361 </span><span class="lineCov">   18674250 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    9362 </span>            :           expr.value = build_component_ref (op_loc, expr.value, ident,
<span class="lineNum">    9363 </span><span class="lineCov">   24210591 :                                             comp_loc);</span>
<span class="lineNum">    9364 </span>            :           set_c_expr_source_range (&amp;expr, start, finish);
<span class="lineNum">    9365 </span><span class="lineCov">    1261259 :           expr.original_code = ERROR_MARK;</span>
<span class="lineNum">    9366 </span>            :           if (TREE_CODE (expr.value) != COMPONENT_REF)
<span class="lineNum">    9367 </span><span class="lineCov">    1261259 :             expr.original_type = NULL;</span>
<span class="lineNum">    9368 </span><span class="lineCov">    1261259 :           else</span>
<span class="lineNum">    9369 </span><span class="lineCov">    1261259 :             {</span>
<span class="lineNum">    9370 </span>            :               /* Remember the original type of a bitfield.  */
<span class="lineNum">    9371 </span><span class="lineCov">    1261259 :               tree field = TREE_OPERAND (expr.value, 1);</span>
<span class="lineNum">    9372 </span><span class="lineCov">    1261259 :               if (TREE_CODE (field) != FIELD_DECL)</span>
<span class="lineNum">    9373 </span><span class="lineCov">    1261259 :                 expr.original_type = NULL;</span>
<span class="lineNum">    9374 </span>            :               else
<span class="lineNum">    9375 </span>            :                 expr.original_type = DECL_BIT_FIELD_TYPE (field);
<span class="lineNum">    9376 </span>            :             }
<span class="lineNum">    9377 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    9378 </span><span class="lineNoCov">          0 :         case CPP_DEREF:</span>
<span class="lineNum">    9379 </span><span class="lineNoCov">          0 :           /* Structure element reference.  */</span>
<span class="lineNum">    9380 </span><span class="lineNoCov">          0 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    9381 </span><span class="lineNoCov">          0 :           expr = convert_lvalue_to_rvalue (expr_loc, expr, true, false);</span>
<span class="lineNum">    9382 </span>            :           if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">    9383 </span><span class="lineCov">    1261259 :             {</span>
<span class="lineNum">    9384 </span><span class="lineCov">    1261259 :               c_token *comp_tok = c_parser_peek_token (parser);</span>
<span class="lineNum">    9385 </span><span class="lineCov">    1261259 :               ident = comp_tok-&gt;value;</span>
<span class="lineNum">    9386 </span><span class="lineCov">    1261259 :               comp_loc = comp_tok-&gt;location;</span>
<span class="lineNum">    9387 </span>            :             }
<span class="lineNum">    9388 </span><span class="lineCov">    1261259 :           else</span>
<span class="lineNum">    9389 </span><span class="lineCov">    1261259 :             {</span>
<span class="lineNum">    9390 </span><span class="lineCov">    1261259 :               c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">    9391 </span><span class="lineCov">         21 :               expr.set_error ();</span>
<span class="lineNum">    9392 </span>            :               expr.original_code = ERROR_MARK;
<span class="lineNum">    9393 </span>            :               expr.original_type = NULL;
<span class="lineNum">    9394 </span>            :               return expr;
<span class="lineNum">    9395 </span><span class="lineCov">    1261238 :             }</span>
<span class="lineNum">    9396 </span><span class="lineCov">    1261238 :           start = expr.get_start ();</span>
<span class="lineNum">    9397 </span><span class="lineNoCov">          0 :           finish = c_parser_peek_token (parser)-&gt;get_finish ();</span>
<span class="lineNum">    9398 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    9399 </span><span class="lineCov">    2522476 :           expr.value = build_component_ref (op_loc,</span>
<span class="lineNum">    9400 </span>            :                                             build_indirect_ref (op_loc,
<span class="lineNum">    9401 </span>            :                                                                 expr.value,
<span class="lineNum">    9402 </span><span class="lineCov">     361725 :                                                                 RO_ARROW),</span>
<span class="lineNum">    9403 </span>            :                                             ident, comp_loc);
<span class="lineNum">    9404 </span><span class="lineCov">     361725 :           set_c_expr_source_range (&amp;expr, start, finish);</span>
<span class="lineNum">    9405 </span><span class="lineCov">     361725 :           expr.original_code = ERROR_MARK;</span>
<span class="lineNum">    9406 </span><span class="lineCov">     361725 :           if (TREE_CODE (expr.value) != COMPONENT_REF)</span>
<span class="lineNum">    9407 </span>            :             expr.original_type = NULL;
<span class="lineNum">    9408 </span><span class="lineCov">     361693 :           else</span>
<span class="lineNum">    9409 </span><span class="lineCov">     361693 :             {</span>
<span class="lineNum">    9410 </span><span class="lineCov">     361693 :               /* Remember the original type of a bitfield.  */</span>
<span class="lineNum">    9411 </span>            :               tree field = TREE_OPERAND (expr.value, 1);
<span class="lineNum">    9412 </span>            :               if (TREE_CODE (field) != FIELD_DECL)
<span class="lineNum">    9413 </span>            :                 expr.original_type = NULL;
<span class="lineNum">    9414 </span><span class="lineCov">         32 :               else</span>
<span class="lineNum">    9415 </span><span class="lineCov">         32 :                 expr.original_type = DECL_BIT_FIELD_TYPE (field);</span>
<span class="lineNum">    9416 </span><span class="lineCov">         32 :             }</span>
<span class="lineNum">    9417 </span><span class="lineCov">         32 :           break;</span>
<span class="lineNum">    9418 </span><span class="lineCov">         32 :         case CPP_PLUS_PLUS:</span>
<span class="lineNum">    9419 </span>            :           /* Postincrement.  */
<span class="lineNum">    9420 </span><span class="lineCov">     361693 :           start = expr.get_start ();</span>
<span class="lineNum">    9421 </span><span class="lineCov">     361693 :           finish = c_parser_peek_token (parser)-&gt;get_finish ();</span>
<span class="lineNum">    9422 </span><span class="lineCov">     361693 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    9423 </span><span class="lineCov">     361693 :           expr = default_function_array_read_conversion (expr_loc, expr);</span>
<span class="lineNum">    9424 </span>            :           expr.value = build_unary_op (op_loc, POSTINCREMENT_EXPR,
<span class="lineNum">    9425 </span>            :                                        expr.value, false);
<span class="lineNum">    9426 </span>            :           set_c_expr_source_range (&amp;expr, start, finish);
<span class="lineNum">    9427 </span>            :           expr.original_code = ERROR_MARK;
<span class="lineNum">    9428 </span><span class="lineCov">     361693 :           expr.original_type = NULL;</span>
<span class="lineNum">    9429 </span><span class="lineCov">     361693 :           break;</span>
<span class="lineNum">    9430 </span><span class="lineCov">     361693 :         case CPP_MINUS_MINUS:</span>
<span class="lineNum">    9431 </span><span class="lineCov">        105 :           /* Postdecrement.  */</span>
<span class="lineNum">    9432 </span>            :           start = expr.get_start ();
<span class="lineNum">    9433 </span>            :           finish = c_parser_peek_token (parser)-&gt;get_finish ();
<span class="lineNum">    9434 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    9435 </span><span class="lineCov">     361588 :           expr = default_function_array_read_conversion (expr_loc, expr);</span>
<span class="lineNum">    9436 </span><span class="lineCov">     361588 :           expr.value = build_unary_op (op_loc, POSTDECREMENT_EXPR,</span>
<span class="lineNum">    9437 </span><span class="lineNoCov">          0 :                                        expr.value, false);</span>
<span class="lineNum">    9438 </span>            :           set_c_expr_source_range (&amp;expr, start, finish);
<span class="lineNum">    9439 </span><span class="lineCov">     723176 :           expr.original_code = ERROR_MARK;</span>
<span class="lineNum">    9440 </span>            :           expr.original_type = NULL;
<span class="lineNum">    9441 </span>            :           break;
<span class="lineNum">    9442 </span><span class="lineCov">     390141 :         default:</span>
<span class="lineNum">    9443 </span>            :           return expr;
<span class="lineNum">    9444 </span><span class="lineCov">     390141 :         }</span>
<span class="lineNum">    9445 </span><span class="lineCov">     390141 :     }</span>
<span class="lineNum">    9446 </span><span class="lineCov">     390141 : }</span>
<span class="lineNum">    9447 </span><span class="lineCov">     390141 : </span>
<span class="lineNum">    9448 </span><span class="lineCov">     390141 : /* Parse an expression (C90 6.3.17, C99 6.5.17, C11 6.5.17).</span>
<span class="lineNum">    9449 </span>            : 
<span class="lineNum">    9450 </span><span class="lineCov">     390141 :    expression:</span>
<span class="lineNum">    9451 </span><span class="lineCov">     390141 :      assignment-expression</span>
<span class="lineNum">    9452 </span><span class="lineCov">     390141 :      expression , assignment-expression</span>
<span class="lineNum">    9453 </span><span class="lineCov">     390141 : */</span>
<a name="9454"><span class="lineNum">    9454 </span><span class="lineCov">      14382 : </span></a>
<span class="lineNum">    9455 </span>            : static struct c_expr
<span class="lineNum">    9456 </span><span class="lineCov">      14382 : c_parser_expression (c_parser *parser)</span>
<span class="lineNum">    9457 </span><span class="lineCov">      14382 : {</span>
<span class="lineNum">    9458 </span><span class="lineCov">      14382 :   location_t tloc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    9459 </span><span class="lineCov">      14382 :   struct c_expr expr;</span>
<span class="lineNum">    9460 </span><span class="lineCov">      14382 :   expr = c_parser_expr_no_commas (parser, NULL);</span>
<span class="lineNum">    9461 </span>            :   if (c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">    9462 </span><span class="lineCov">      14382 :     expr = convert_lvalue_to_rvalue (tloc, expr, true, false);</span>
<span class="lineNum">    9463 </span><span class="lineCov">      14382 :   while (c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">    9464 </span><span class="lineCov">      14382 :     {</span>
<span class="lineNum">    9465 </span><span class="lineCov">      14382 :       struct c_expr next;</span>
<span class="lineNum">    9466 </span><span class="lineCov">  112892281 :       tree lhsval;</span>
<span class="lineNum">    9467 </span><span class="lineCov">  112892281 :       location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    9468 </span>            :       location_t expr_loc;
<span class="lineNum">    9469 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    9470 </span>            :       expr_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">    9471 </span>            :       lhsval = expr.value;
<span class="lineNum">    9472 </span>            :       while (TREE_CODE (lhsval) == COMPOUND_EXPR)
<span class="lineNum">    9473 </span>            :         lhsval = TREE_OPERAND (lhsval, 1);
<span class="lineNum">    9474 </span>            :       if (DECL_P (lhsval) || handled_component_p (lhsval))
<span class="lineNum">    9475 </span>            :         mark_exp_read (lhsval);
<span class="lineNum">    9476 </span>            :       next = c_parser_expr_no_commas (parser, NULL);
<span class="lineNum">    9477 </span>            :       next = convert_lvalue_to_rvalue (expr_loc, next, true, false);
<span class="lineNum">    9478 </span>            :       expr.value = build_compound_expr (loc, expr.value, next.value);
<span class="lineNum">    9479 </span>            :       expr.original_code = COMPOUND_EXPR;
<span class="lineNum">    9480 </span><span class="lineCov">   30655276 :       expr.original_type = next.original_type;</span>
<span class="lineNum">    9481 </span>            :     }
<span class="lineNum">    9482 </span><span class="lineCov">   30655276 :   return expr;</span>
<span class="lineNum">    9483 </span><span class="lineCov">   30655276 : }</span>
<span class="lineNum">    9484 </span><span class="lineCov">   30655276 : </span>
<span class="lineNum">    9485 </span><span class="lineCov">   30655276 : /* Parse an expression and convert functions or arrays to pointers and</span>
<span class="lineNum">    9486 </span><span class="lineCov">      37202 :    lvalues to rvalues.  */</span>
<a name="9487"><span class="lineNum">    9487 </span><span class="lineCov">   30704351 : </span></a>
<span class="lineNum">    9488 </span>            : static struct c_expr
<span class="lineNum">    9489 </span><span class="lineCov">      49075 : c_parser_expression_conv (c_parser *parser)</span>
<span class="lineNum">    9490 </span><span class="lineCov">      49075 : {</span>
<span class="lineNum">    9491 </span><span class="lineCov">      49075 :   struct c_expr expr;</span>
<span class="lineNum">    9492 </span><span class="lineCov">      49075 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">    9493 </span><span class="lineCov">      49075 :   expr = c_parser_expression (parser);</span>
<span class="lineNum">    9494 </span><span class="lineCov">      49075 :   expr = convert_lvalue_to_rvalue (loc, expr, true, false);</span>
<span class="lineNum">    9495 </span><span class="lineCov">      49075 :   return expr;</span>
<span class="lineNum">    9496 </span><span class="lineCov">      61706 : }</span>
<span class="lineNum">    9497 </span><span class="lineCov">      12631 : </span>
<span class="lineNum">    9498 </span><span class="lineCov">      49075 : /* Helper function of c_parser_expr_list.  Check if IDXth (0 based)</span>
<span class="lineNum">    9499 </span><span class="lineCov">         68 :    argument is a literal zero alone and if so, set it in literal_zero_mask.  */</span>
<a name="9500"><span class="lineNum">    9500 </span><span class="lineCov">      49075 : </span></a>
<span class="lineNum">    9501 </span><span class="lineCov">      49075 : static inline void</span>
<span class="lineNum">    9502 </span><span class="lineCov">      49075 : c_parser_check_literal_zero (c_parser *parser, unsigned *literal_zero_mask,</span>
<span class="lineNum">    9503 </span><span class="lineCov">      49075 :                              unsigned int idx)</span>
<span class="lineNum">    9504 </span><span class="lineCov">      49075 : {</span>
<span class="lineNum">    9505 </span>            :   if (idx &gt;= HOST_BITS_PER_INT)
<span class="lineNum">    9506 </span><span class="lineCov">   30655276 :     return;</span>
<span class="lineNum">    9507 </span>            : 
<span class="lineNum">    9508 </span>            :   c_token *tok = c_parser_peek_token (parser);
<span class="lineNum">    9509 </span>            :   switch (tok-&gt;type)
<span class="lineNum">    9510 </span>            :     {
<span class="lineNum">    9511 </span>            :     case CPP_NUMBER:
<span class="lineNum">    9512 </span>            :     case CPP_CHAR:
<span class="lineNum">    9513 </span><span class="lineCov">   22096094 :     case CPP_WCHAR:</span>
<span class="lineNum">    9514 </span>            :     case CPP_CHAR16:
<span class="lineNum">    9515 </span><span class="lineCov">   22096094 :     case CPP_CHAR32:</span>
<span class="lineNum">    9516 </span><span class="lineCov">   22096094 :       /* If a parameter is literal zero alone, remember it</span>
<span class="lineNum">    9517 </span><span class="lineCov">   22096094 :          for -Wmemset-transposed-args warning.  */</span>
<span class="lineNum">    9518 </span><span class="lineCov">   22096094 :       if (integer_zerop (tok-&gt;value)</span>
<span class="lineNum">    9519 </span><span class="lineCov">   22096094 :           &amp;&amp; !TREE_OVERFLOW (tok-&gt;value)</span>
<span class="lineNum">    9520 </span>            :           &amp;&amp; (c_parser_peek_2nd_token (parser)-&gt;type == CPP_COMMA
<span class="lineNum">    9521 </span>            :               || c_parser_peek_2nd_token (parser)-&gt;type == CPP_CLOSE_PAREN))
<span class="lineNum">    9522 </span>            :         *literal_zero_mask |= 1U &lt;&lt; idx;
<span class="lineNum">    9523 </span>            :     default:
<span class="lineNum">    9524 </span>            :       break;
<span class="lineNum">    9525 </span>            :     }
<span class="lineNum">    9526 </span><span class="lineCov">   61152940 : }</span>
<span class="lineNum">    9527 </span>            : 
<span class="lineNum">    9528 </span>            : /* Parse a non-empty list of expressions.  If CONVERT_P, convert
<span class="lineNum">    9529 </span><span class="lineCov">   61152940 :    functions and arrays to pointers and lvalues to rvalues.  If</span>
<span class="lineNum">    9530 </span>            :    FOLD_P, fold the expressions.  If LOCATIONS is non-NULL, save the
<span class="lineNum">    9531 </span>            :    locations of function arguments into this vector.
<span class="lineNum">    9532 </span><span class="lineCov">   61130997 : </span>
<span class="lineNum">    9533 </span><span class="lineCov">   61130997 :    nonempty-expr-list:</span>
<span class="lineNum">    9534 </span>            :      assignment-expression
<span class="lineNum">    9535 </span><span class="lineCov">    3102465 :      nonempty-expr-list , assignment-expression</span>
<span class="lineNum">    9536 </span><span class="lineCov">    3102465 : */</span>
<a name="9537"><span class="lineNum">    9537 </span><span class="lineCov">    3102465 : </span></a>
<span class="lineNum">    9538 </span><span class="lineCov">    3102465 : static vec&lt;tree, va_gc&gt; *</span>
<span class="lineNum">    9539 </span><span class="lineCov">    3102465 : c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,</span>
<span class="lineNum">    9540 </span>            :                     vec&lt;tree, va_gc&gt; **p_orig_types,
<span class="lineNum">    9541 </span>            :                     location_t *sizeof_arg_loc, tree *sizeof_arg,
<span class="lineNum">    9542 </span><span class="lineCov">    3102465 :                     vec&lt;location_t&gt; *locations,</span>
<span class="lineNum">    9543 </span><span class="lineCov">     579066 :                     unsigned int *literal_zero_mask)</span>
<span class="lineNum">    9544 </span><span class="lineCov">    3681531 : {</span>
<span class="lineNum">    9545 </span><span class="lineCov">     414937 :   vec&lt;tree, va_gc&gt; *ret;</span>
<span class="lineNum">    9546 </span><span class="lineCov">     578403 :   vec&lt;tree, va_gc&gt; *orig_types;</span>
<span class="lineNum">    9547 </span>            :   struct c_expr expr;
<span class="lineNum">    9548 </span>            :   unsigned int idx = 0;
<span class="lineNum">    9549 </span>            : 
<span class="lineNum">    9550 </span>            :   ret = make_tree_vector ();
<span class="lineNum">    9551 </span>            :   if (p_orig_types == NULL)
<span class="lineNum">    9552 </span>            :     orig_types = NULL;
<span class="lineNum">    9553 </span>            :   else
<span class="lineNum">    9554 </span>            :     orig_types = make_tree_vector ();
<span class="lineNum">    9555 </span>            : 
<span class="lineNum">    9556 </span>            :   if (literal_zero_mask)
<span class="lineNum">    9557 </span>            :     c_parser_check_literal_zero (parser, literal_zero_mask, 0);
<span class="lineNum">    9558 </span>            :   expr = c_parser_expr_no_commas (parser, NULL);
<span class="lineNum">    9559 </span>            :   if (convert_p)
<span class="lineNum">    9560 </span>            :     expr = convert_lvalue_to_rvalue (expr.get_location (), expr, true, true);
<span class="lineNum">    9561 </span>            :   if (fold_p)
<span class="lineNum">    9562 </span>            :     expr.value = c_fully_fold (expr.value, false, NULL);
<span class="lineNum">    9563 </span><span class="lineCov">   20947320 :   ret-&gt;quick_push (expr.value);</span>
<span class="lineNum">    9564 </span>            :   if (orig_types)
<span class="lineNum">    9565 </span>            :     orig_types-&gt;quick_push (expr.original_type);
<span class="lineNum">    9566 </span>            :   if (locations)
<span class="lineNum">    9567 </span>            :     locations-&gt;safe_push (expr.get_location ());
<span class="lineNum">    9568 </span>            :   if (sizeof_arg != NULL
<span class="lineNum">    9569 </span><span class="lineCov">   20947320 :       &amp;&amp; expr.original_code == SIZEOF_EXPR)</span>
<span class="lineNum">    9570 </span><span class="lineCov">   20947320 :     {</span>
<span class="lineNum">    9571 </span><span class="lineCov">   20947320 :       sizeof_arg[0] = c_last_sizeof_arg;</span>
<span class="lineNum">    9572 </span><span class="lineCov">   20947320 :       sizeof_arg_loc[0] = c_last_sizeof_loc;</span>
<span class="lineNum">    9573 </span>            :     }
<span class="lineNum">    9574 </span><span class="lineCov">   20947320 :   while (c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">    9575 </span><span class="lineCov">   20947320 :     {</span>
<span class="lineNum">    9576 </span><span class="lineCov">    2273070 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    9577 </span>            :       if (literal_zero_mask)
<span class="lineNum">    9578 </span><span class="lineCov">   18674250 :         c_parser_check_literal_zero (parser, literal_zero_mask, idx + 1);</span>
<span class="lineNum">    9579 </span>            :       expr = c_parser_expr_no_commas (parser, NULL);
<span class="lineNum">    9580 </span><span class="lineCov">   20947320 :       if (convert_p)</span>
<span class="lineNum">    9581 </span><span class="lineCov">   18674250 :         expr = convert_lvalue_to_rvalue (expr.get_location (), expr, true,</span>
<span class="lineNum">    9582 </span><span class="lineCov">   20947320 :                                          true);</span>
<span class="lineNum">    9583 </span><span class="lineCov">   20947320 :       if (fold_p)</span>
<span class="lineNum">    9584 </span><span class="lineCov">   18674250 :         expr.value = c_fully_fold (expr.value, false, NULL);</span>
<span class="lineNum">    9585 </span><span class="lineCov">   20947320 :       vec_safe_push (ret, expr.value);</span>
<span class="lineNum">    9586 </span><span class="lineCov">    2273070 :       if (orig_types)</span>
<span class="lineNum">    9587 </span><span class="lineCov">   20947320 :         vec_safe_push (orig_types, expr.original_type);</span>
<span class="lineNum">    9588 </span><span class="lineCov">   20947320 :       if (locations)</span>
<span class="lineNum">    9589 </span><span class="lineCov">   18674250 :         locations-&gt;safe_push (expr.get_location ());</span>
<span class="lineNum">    9590 </span><span class="lineCov">   20947320 :       if (++idx &lt; 3</span>
<span class="lineNum">    9591 </span><span class="lineCov">   18674250 :           &amp;&amp; sizeof_arg != NULL</span>
<span class="lineNum">    9592 </span><span class="lineCov">   20947320 :           &amp;&amp; expr.original_code == SIZEOF_EXPR)</span>
<span class="lineNum">    9593 </span><span class="lineCov">   18674250 :         {</span>
<span class="lineNum">    9594 </span>            :           sizeof_arg[idx] = c_last_sizeof_arg;
<span class="lineNum">    9595 </span><span class="lineCov">       1462 :           sizeof_arg_loc[idx] = c_last_sizeof_loc;</span>
<span class="lineNum">    9596 </span><span class="lineCov">       1462 :         }</span>
<span class="lineNum">    9597 </span>            :     }
<span class="lineNum">    9598 </span><span class="lineCov">   64069317 :   if (orig_types)</span>
<span class="lineNum">    9599 </span>            :     *p_orig_types = orig_types;
<span class="lineNum">    9600 </span><span class="lineCov">   43121997 :   return ret;</span>
<span class="lineNum">    9601 </span><span class="lineCov">   43121997 : }</span>
<span class="lineNum">    9602 </span><span class="lineCov">   42478690 : </span>
<span class="lineNum">    9603 </span><span class="lineCov">   43121997 : /* Parse Objective-C-specific constructs.  */</span>
<span class="lineNum">    9604 </span><span class="lineCov">   43121997 : </span>
<span class="lineNum">    9605 </span><span class="lineCov">   42478690 : /* Parse an objc-class-definition.</span>
<span class="lineNum">    9606 </span><span class="lineCov">   42478690 : </span>
<span class="lineNum">    9607 </span><span class="lineCov">   43121997 :    objc-class-definition:</span>
<span class="lineNum">    9608 </span><span class="lineCov">     643307 :      @interface identifier objc-superclass[opt] objc-protocol-refs[opt]</span>
<span class="lineNum">    9609 </span><span class="lineCov">   43121997 :        objc-class-instance-variables[opt] objc-methodprotolist @end</span>
<span class="lineNum">    9610 </span><span class="lineCov">   43121997 :      @implementation identifier objc-superclass[opt]</span>
<span class="lineNum">    9611 </span><span class="lineCov">   42478690 :        objc-class-instance-variables[opt]</span>
<span class="lineNum">    9612 </span><span class="lineCov">   43121997 :      @interface identifier ( identifier ) objc-protocol-refs[opt]</span>
<span class="lineNum">    9613 </span><span class="lineCov">   42478690 :        objc-methodprotolist @end</span>
<span class="lineNum">    9614 </span><span class="lineCov">   43121997 :      @interface identifier ( ) objc-protocol-refs[opt]</span>
<span class="lineNum">    9615 </span><span class="lineCov">   31185956 :        objc-methodprotolist @end</span>
<span class="lineNum">    9616 </span><span class="lineCov">   73664681 :      @implementation identifier ( identifier )</span>
<span class="lineNum">    9617 </span>            : 
<span class="lineNum">    9618 </span><span class="lineCov">      51442 :    objc-superclass:</span>
<span class="lineNum">    9619 </span><span class="lineCov">      51442 :      : identifier</span>
<span class="lineNum">    9620 </span>            : 
<span class="lineNum">    9621 </span>            :    &quot;@interface identifier (&quot; must start &quot;@interface identifier (
<span class="lineNum">    9622 </span><span class="lineCov">   20947320 :    identifier ) ...&quot;: objc-methodprotolist in the first production may</span>
<span class="lineNum">    9623 </span><span class="lineCov">   18674250 :    not start with a parenthesized identifier as a declarator of a data</span>
<span class="lineNum">    9624 </span><span class="lineCov">   20947320 :    definition with no declaration specifiers if the objc-superclass,</span>
<span class="lineNum">    9625 </span>            :    objc-protocol-refs and objc-class-instance-variables are omitted.  */
<a name="9626"><span class="lineNum">    9626 </span>            : </a>
<span class="lineNum">    9627 </span>            : static void
<span class="lineNum">    9628 </span>            : c_parser_objc_class_definition (c_parser *parser, tree attributes)
<span class="lineNum">    9629 </span>            : {
<span class="lineNum">    9630 </span>            :   bool iface_p;
<span class="lineNum">    9631 </span>            :   tree id1;
<span class="lineNum">    9632 </span>            :   tree superclass;
<span class="lineNum">    9633 </span>            :   if (c_parser_next_token_is_keyword (parser, RID_AT_INTERFACE))
<span class="lineNum">    9634 </span>            :     iface_p = true;
<span class="lineNum">    9635 </span>            :   else if (c_parser_next_token_is_keyword (parser, RID_AT_IMPLEMENTATION))
<span class="lineNum">    9636 </span>            :     iface_p = false;
<span class="lineNum">    9637 </span>            :   else
<span class="lineNum">    9638 </span>            :     gcc_unreachable ();
<span class="lineNum">    9639 </span>            : 
<span class="lineNum">    9640 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    9641 </span>            :   if (c_parser_next_token_is_not (parser, CPP_NAME))
<span class="lineNum">    9642 </span>            :     {
<span class="lineNum">    9643 </span>            :       c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">    9644 </span>            :       return;
<span class="lineNum">    9645 </span>            :     }
<span class="lineNum">    9646 </span>            :   id1 = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    9647 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    9648 </span>            :   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))
<span class="lineNum">    9649 </span>            :     {
<span class="lineNum">    9650 </span>            :       /* We have a category or class extension.  */
<span class="lineNum">    9651 </span>            :       tree id2;
<span class="lineNum">    9652 </span><span class="lineNoCov">          0 :       tree proto = NULL_TREE;</span>
<span class="lineNum">    9653 </span>            :       matching_parens parens;
<span class="lineNum">    9654 </span><span class="lineNoCov">          0 :       parens.consume_open (parser);</span>
<span class="lineNum">    9655 </span><span class="lineNoCov">          0 :       if (c_parser_next_token_is_not (parser, CPP_NAME))</span>
<span class="lineNum">    9656 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    9657 </span><span class="lineNoCov">          0 :           if (iface_p &amp;&amp; c_parser_next_token_is (parser, CPP_CLOSE_PAREN))</span>
<span class="lineNum">    9658 </span>            :             {
<span class="lineNum">    9659 </span><span class="lineNoCov">          0 :               /* We have a class extension.  */</span>
<span class="lineNum">    9660 </span>            :               id2 = NULL_TREE;
<span class="lineNum">    9661 </span>            :             }
<span class="lineNum">    9662 </span><span class="lineNoCov">          0 :           else</span>
<span class="lineNum">    9663 </span>            :             {
<span class="lineNum">    9664 </span><span class="lineNoCov">          0 :               c_parser_error (parser, &quot;expected identifier or %&lt;)%&gt;&quot;);</span>
<span class="lineNum">    9665 </span><span class="lineNoCov">          0 :               c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);</span>
<span class="lineNum">    9666 </span>            :               return;
<span class="lineNum">    9667 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    9668 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    9669 </span>            :       else
<span class="lineNum">    9670 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    9671 </span><span class="lineNoCov">          0 :           id2 = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">    9672 </span><span class="lineNoCov">          0 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    9673 </span>            :         }
<span class="lineNum">    9674 </span>            :       parens.skip_until_found_close (parser);
<span class="lineNum">    9675 </span><span class="lineNoCov">          0 :       if (!iface_p)</span>
<span class="lineNum">    9676 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    9677 </span><span class="lineNoCov">          0 :           objc_start_category_implementation (id1, id2);</span>
<span class="lineNum">    9678 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">    9679 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    9680 </span>            :       if (c_parser_next_token_is (parser, CPP_LESS))
<span class="lineNum">    9681 </span><span class="lineNoCov">          0 :         proto = c_parser_objc_protocol_refs (parser);</span>
<span class="lineNum">    9682 </span>            :       objc_start_category_interface (id1, id2, proto, attributes);
<span class="lineNum">    9683 </span>            :       c_parser_objc_methodprotolist (parser);
<span class="lineNum">    9684 </span>            :       c_parser_require_keyword (parser, RID_AT_END, &quot;expected %&lt;@end%&gt;&quot;);
<span class="lineNum">    9685 </span>            :       objc_finish_interface ();
<span class="lineNum">    9686 </span>            :       return;
<span class="lineNum">    9687 </span>            :     }
<span class="lineNum">    9688 </span><span class="lineNoCov">          0 :   if (c_parser_next_token_is (parser, CPP_COLON))</span>
<span class="lineNum">    9689 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    9690 </span><span class="lineNoCov">          0 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    9691 </span>            :       if (c_parser_next_token_is_not (parser, CPP_NAME))
<span class="lineNum">    9692 </span>            :         {
<span class="lineNum">    9693 </span>            :           c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">    9694 </span>            :           return;
<span class="lineNum">    9695 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    9696 </span><span class="lineNoCov">          0 :       superclass = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">    9697 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    9698 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    9699 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">    9700 </span>            :     superclass = NULL_TREE;
<span class="lineNum">    9701 </span><span class="lineNoCov">          0 :   if (iface_p)</span>
<span class="lineNum">    9702 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    9703 </span>            :       tree proto = NULL_TREE;
<span class="lineNum">    9704 </span><span class="lineNoCov">          0 :       if (c_parser_next_token_is (parser, CPP_LESS))</span>
<span class="lineNum">    9705 </span><span class="lineNoCov">          0 :         proto = c_parser_objc_protocol_refs (parser);</span>
<span class="lineNum">    9706 </span><span class="lineNoCov">          0 :       objc_start_class_interface (id1, superclass, proto, attributes);</span>
<span class="lineNum">    9707 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    9708 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">    9709 </span><span class="lineNoCov">          0 :     objc_start_class_implementation (id1, superclass);</span>
<span class="lineNum">    9710 </span><span class="lineNoCov">          0 :   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))</span>
<span class="lineNum">    9711 </span>            :     c_parser_objc_class_instance_variables (parser);
<span class="lineNum">    9712 </span><span class="lineNoCov">          0 :   if (iface_p)</span>
<span class="lineNum">    9713 </span>            :     {
<span class="lineNum">    9714 </span><span class="lineNoCov">          0 :       objc_continue_interface ();</span>
<span class="lineNum">    9715 </span><span class="lineNoCov">          0 :       c_parser_objc_methodprotolist (parser);</span>
<span class="lineNum">    9716 </span>            :       c_parser_require_keyword (parser, RID_AT_END, &quot;expected %&lt;@end%&gt;&quot;);
<span class="lineNum">    9717 </span><span class="lineNoCov">          0 :       objc_finish_interface ();</span>
<span class="lineNum">    9718 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    9719 </span>            :   else
<span class="lineNum">    9720 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    9721 </span><span class="lineNoCov">          0 :       objc_continue_implementation ();</span>
<span class="lineNum">    9722 </span>            :       return;
<span class="lineNum">    9723 </span>            :     }
<span class="lineNum">    9724 </span>            : }
<span class="lineNum">    9725 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9726 </span>            : /* Parse objc-class-instance-variables.
<span class="lineNum">    9727 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9728 </span><span class="lineNoCov">          0 :    objc-class-instance-variables:</span>
<span class="lineNum">    9729 </span><span class="lineNoCov">          0 :      { objc-instance-variable-decl-list[opt] }</span>
<span class="lineNum">    9730 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9731 </span>            :    objc-instance-variable-decl-list:
<span class="lineNum">    9732 </span>            :      objc-visibility-spec
<span class="lineNum">    9733 </span><span class="lineNoCov">          0 :      objc-instance-variable-decl ;</span>
<span class="lineNum">    9734 </span><span class="lineNoCov">          0 :      ;</span>
<span class="lineNum">    9735 </span><span class="lineNoCov">          0 :      objc-instance-variable-decl-list objc-visibility-spec</span>
<span class="lineNum">    9736 </span><span class="lineNoCov">          0 :      objc-instance-variable-decl-list objc-instance-variable-decl ;</span>
<span class="lineNum">    9737 </span>            :      objc-instance-variable-decl-list ;
<span class="lineNum">    9738 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9739 </span><span class="lineNoCov">          0 :    objc-visibility-spec:</span>
<span class="lineNum">    9740 </span><span class="lineNoCov">          0 :      @private</span>
<span class="lineNum">    9741 </span><span class="lineNoCov">          0 :      @protected</span>
<span class="lineNum">    9742 </span>            :      @public
<span class="lineNum">    9743 </span>            : 
<span class="lineNum">    9744 </span>            :    objc-instance-variable-decl:
<span class="lineNum">    9745 </span><span class="lineNoCov">          0 :      struct-declaration</span>
<span class="lineNum">    9746 </span><span class="lineNoCov">          0 : */</span>
<a name="9747"><span class="lineNum">    9747 </span>            : </a>
<span class="lineNum">    9748 </span>            : static void
<span class="lineNum">    9749 </span>            : c_parser_objc_class_instance_variables (c_parser *parser)
<span class="lineNum">    9750 </span>            : {
<span class="lineNum">    9751 </span>            :   gcc_assert (c_parser_next_token_is (parser, CPP_OPEN_BRACE));
<span class="lineNum">    9752 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    9753 </span>            :   while (c_parser_next_token_is_not (parser, CPP_EOF))
<span class="lineNum">    9754 </span>            :     {
<span class="lineNum">    9755 </span>            :       tree decls;
<span class="lineNum">    9756 </span>            :       /* Parse any stray semicolon.  */
<span class="lineNum">    9757 </span>            :       if (c_parser_next_token_is (parser, CPP_SEMICOLON))
<span class="lineNum">    9758 </span>            :         {
<span class="lineNum">    9759 </span>            :           pedwarn (c_parser_peek_token (parser)-&gt;location, OPT_Wpedantic,
<span class="lineNum">    9760 </span>            :                    &quot;extra semicolon&quot;);
<span class="lineNum">    9761 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    9762 </span>            :           continue;
<span class="lineNum">    9763 </span>            :         }
<span class="lineNum">    9764 </span>            :       /* Stop if at the end of the instance variables.  */
<span class="lineNum">    9765 </span>            :       if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))
<span class="lineNum">    9766 </span>            :         {
<span class="lineNum">    9767 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    9768 </span>            :           break;
<span class="lineNum">    9769 </span>            :         }
<span class="lineNum">    9770 </span>            :       /* Parse any objc-visibility-spec.  */
<span class="lineNum">    9771 </span>            :       if (c_parser_next_token_is_keyword (parser, RID_AT_PRIVATE))
<span class="lineNum">    9772 </span>            :         {
<span class="lineNum">    9773 </span><span class="lineNoCov">          0 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    9774 </span>            :           objc_set_visibility (OBJC_IVAR_VIS_PRIVATE);
<span class="lineNum">    9775 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">    9776 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    9777 </span><span class="lineNoCov">          0 :       else if (c_parser_next_token_is_keyword (parser, RID_AT_PROTECTED))</span>
<span class="lineNum">    9778 </span>            :         {
<span class="lineNum">    9779 </span><span class="lineNoCov">          0 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    9780 </span>            :           objc_set_visibility (OBJC_IVAR_VIS_PROTECTED);
<span class="lineNum">    9781 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">    9782 </span>            :         }
<span class="lineNum">    9783 </span><span class="lineNoCov">          0 :       else if (c_parser_next_token_is_keyword (parser, RID_AT_PUBLIC))</span>
<span class="lineNum">    9784 </span>            :         {
<span class="lineNum">    9785 </span><span class="lineNoCov">          0 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    9786 </span><span class="lineNoCov">          0 :           objc_set_visibility (OBJC_IVAR_VIS_PUBLIC);</span>
<span class="lineNum">    9787 </span>            :           continue;
<span class="lineNum">    9788 </span>            :         }
<span class="lineNum">    9789 </span><span class="lineNoCov">          0 :       else if (c_parser_next_token_is_keyword (parser, RID_AT_PACKAGE))</span>
<span class="lineNum">    9790 </span>            :         {
<span class="lineNum">    9791 </span><span class="lineNoCov">          0 :           c_parser_consume_token (parser);</span>
<span class="lineNum">    9792 </span><span class="lineNoCov">          0 :           objc_set_visibility (OBJC_IVAR_VIS_PACKAGE);</span>
<span class="lineNum">    9793 </span>            :           continue;
<span class="lineNum">    9794 </span>            :         }
<span class="lineNum">    9795 </span><span class="lineNoCov">          0 :       else if (c_parser_next_token_is (parser, CPP_PRAGMA))</span>
<span class="lineNum">    9796 </span>            :         {
<span class="lineNum">    9797 </span><span class="lineNoCov">          0 :           c_parser_pragma (parser, pragma_external, NULL);</span>
<span class="lineNum">    9798 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">    9799 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    9800 </span>            : 
<span class="lineNum">    9801 </span><span class="lineNoCov">          0 :       /* Parse some comma-separated declarations.  */</span>
<span class="lineNum">    9802 </span>            :       decls = c_parser_struct_declaration (parser);
<span class="lineNum">    9803 </span><span class="lineNoCov">          0 :       if (decls == NULL)</span>
<span class="lineNum">    9804 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    9805 </span><span class="lineNoCov">          0 :           /* There is a syntax error.  We want to skip the offending</span>
<span class="lineNum">    9806 </span>            :              tokens up to the next ';' (included) or '}'
<span class="lineNum">    9807 </span><span class="lineNoCov">          0 :              (excluded).  */</span>
<span class="lineNum">    9808 </span>            :           
<span class="lineNum">    9809 </span><span class="lineNoCov">          0 :           /* First, skip manually a ')' or ']'.  This is because they</span>
<span class="lineNum">    9810 </span><span class="lineNoCov">          0 :              reduce the nesting level, so c_parser_skip_until_found()</span>
<span class="lineNum">    9811 </span><span class="lineNoCov">          0 :              wouldn't be able to skip past them.  */</span>
<span class="lineNum">    9812 </span>            :           c_token *token = c_parser_peek_token (parser);
<span class="lineNum">    9813 </span><span class="lineNoCov">          0 :           if (token-&gt;type == CPP_CLOSE_PAREN || token-&gt;type == CPP_CLOSE_SQUARE)</span>
<span class="lineNum">    9814 </span>            :             c_parser_consume_token (parser);
<span class="lineNum">    9815 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9816 </span><span class="lineNoCov">          0 :           /* Then, do the standard skipping.  */</span>
<span class="lineNum">    9817 </span><span class="lineNoCov">          0 :           c_parser_skip_until_found (parser, CPP_SEMICOLON, NULL);</span>
<span class="lineNum">    9818 </span>            : 
<span class="lineNum">    9819 </span><span class="lineNoCov">          0 :           /* We hopefully recovered.  Start normal parsing again.  */</span>
<span class="lineNum">    9820 </span>            :           parser-&gt;error = false;
<span class="lineNum">    9821 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">    9822 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    9823 </span>            :       else
<span class="lineNum">    9824 </span>            :         {
<span class="lineNum">    9825 </span>            :           /* Comma-separated instance variables are chained together
<span class="lineNum">    9826 </span><span class="lineNoCov">          0 :              in reverse order; add them one by one.  */</span>
<span class="lineNum">    9827 </span><span class="lineNoCov">          0 :           tree ivar = nreverse (decls);</span>
<span class="lineNum">    9828 </span>            :           for (; ivar; ivar = DECL_CHAIN (ivar))
<span class="lineNum">    9829 </span>            :             objc_add_instance_variable (copy_node (ivar));
<span class="lineNum">    9830 </span>            :         }
<span class="lineNum">    9831 </span>            :       c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);
<span class="lineNum">    9832 </span>            :     }
<span class="lineNum">    9833 </span>            : }
<span class="lineNum">    9834 </span>            : 
<span class="lineNum">    9835 </span>            : /* Parse an objc-class-declaration.
<span class="lineNum">    9836 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9837 </span><span class="lineNoCov">          0 :    objc-class-declaration:</span>
<span class="lineNum">    9838 </span><span class="lineNoCov">          0 :      @class identifier-list ;</span>
<span class="lineNum">    9839 </span>            : */
<a name="9840"><span class="lineNum">    9840 </span>            : </a>
<span class="lineNum">    9841 </span><span class="lineNoCov">          0 : static void</span>
<span class="lineNum">    9842 </span>            : c_parser_objc_class_declaration (c_parser *parser)
<span class="lineNum">    9843 </span>            : {
<span class="lineNum">    9844 </span><span class="lineNoCov">          0 :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_AT_CLASS));</span>
<span class="lineNum">    9845 </span><span class="lineNoCov">          0 :   c_parser_consume_token (parser);</span>
<span class="lineNum">    9846 </span>            :   /* Any identifiers, including those declared as type names, are OK
<span class="lineNum">    9847 </span>            :      here.  */
<span class="lineNum">    9848 </span>            :   while (true)
<span class="lineNum">    9849 </span>            :     {
<span class="lineNum">    9850 </span>            :       tree id;
<span class="lineNum">    9851 </span><span class="lineNoCov">          0 :       if (c_parser_next_token_is_not (parser, CPP_NAME))</span>
<span class="lineNum">    9852 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    9853 </span><span class="lineNoCov">          0 :           c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">    9854 </span>            :           c_parser_skip_until_found (parser, CPP_SEMICOLON, NULL);
<span class="lineNum">    9855 </span><span class="lineNoCov">          0 :           parser-&gt;error = false;</span>
<span class="lineNum">    9856 </span>            :           return;
<span class="lineNum">    9857 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    9858 </span>            :       id = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    9859 </span>            :       objc_declare_class (id);
<span class="lineNum">    9860 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    9861 </span>            :       if (c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">    9862 </span>            :         c_parser_consume_token (parser);
<span class="lineNum">    9863 </span>            :       else
<span class="lineNum">    9864 </span>            :         break;
<span class="lineNum">    9865 </span>            :     }
<span class="lineNum">    9866 </span><span class="lineNoCov">          0 :   c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);</span>
<span class="lineNum">    9867 </span>            : }
<span class="lineNum">    9868 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9869 </span><span class="lineNoCov">          0 : /* Parse an objc-alias-declaration.</span>
<span class="lineNum">    9870 </span>            : 
<span class="lineNum">    9871 </span>            :    objc-alias-declaration:
<span class="lineNum">    9872 </span><span class="lineNoCov">          0 :      @compatibility_alias identifier identifier ;</span>
<span class="lineNum">    9873 </span>            : */
<a name="9874"><span class="lineNum">    9874 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">    9875 </span><span class="lineNoCov">          0 : static void</span>
<span class="lineNum">    9876 </span>            : c_parser_objc_alias_declaration (c_parser *parser)
<span class="lineNum">    9877 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    9878 </span><span class="lineNoCov">          0 :   tree id1, id2;</span>
<span class="lineNum">    9879 </span><span class="lineNoCov">          0 :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_AT_ALIAS));</span>
<span class="lineNum">    9880 </span><span class="lineNoCov">          0 :   c_parser_consume_token (parser);</span>
<span class="lineNum">    9881 </span>            :   if (c_parser_next_token_is_not (parser, CPP_NAME))
<span class="lineNum">    9882 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    9883 </span><span class="lineNoCov">          0 :       c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">    9884 </span><span class="lineNoCov">          0 :       c_parser_skip_until_found (parser, CPP_SEMICOLON, NULL);</span>
<span class="lineNum">    9885 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    9886 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    9887 </span>            :   id1 = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    9888 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    9889 </span><span class="lineNoCov">          0 :   if (c_parser_next_token_is_not (parser, CPP_NAME))</span>
<span class="lineNum">    9890 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    9891 </span>            :       c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">    9892 </span>            :       c_parser_skip_until_found (parser, CPP_SEMICOLON, NULL);
<span class="lineNum">    9893 </span>            :       return;
<span class="lineNum">    9894 </span>            :     }
<span class="lineNum">    9895 </span>            :   id2 = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    9896 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">    9897 </span>            :   c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);
<span class="lineNum">    9898 </span>            :   objc_declare_alias (id1, id2);
<span class="lineNum">    9899 </span>            : }
<span class="lineNum">    9900 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9901 </span>            : /* Parse an objc-protocol-definition.
<span class="lineNum">    9902 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9903 </span><span class="lineNoCov">          0 :    objc-protocol-definition:</span>
<span class="lineNum">    9904 </span><span class="lineNoCov">          0 :      @protocol identifier objc-protocol-refs[opt] objc-methodprotolist @end</span>
<span class="lineNum">    9905 </span><span class="lineNoCov">          0 :      @protocol identifier-list ;</span>
<span class="lineNum">    9906 </span>            : 
<span class="lineNum">    9907 </span><span class="lineNoCov">          0 :    &quot;@protocol identifier ;&quot; should be resolved as &quot;@protocol</span>
<span class="lineNum">    9908 </span><span class="lineNoCov">          0 :    identifier-list ;&quot;: objc-methodprotolist may not start with a</span>
<span class="lineNum">    9909 </span><span class="lineNoCov">          0 :    semicolon in the first alternative if objc-protocol-refs are</span>
<span class="lineNum">    9910 </span>            :    omitted.  */
<a name="9911"><span class="lineNum">    9911 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">    9912 </span><span class="lineNoCov">          0 : static void</span>
<span class="lineNum">    9913 </span><span class="lineNoCov">          0 : c_parser_objc_protocol_definition (c_parser *parser, tree attributes)</span>
<span class="lineNum">    9914 </span>            : {
<span class="lineNum">    9915 </span><span class="lineNoCov">          0 :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_AT_PROTOCOL));</span>
<span class="lineNum">    9916 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9917 </span><span class="lineNoCov">          0 :   c_parser_consume_token (parser);</span>
<span class="lineNum">    9918 </span>            :   if (c_parser_next_token_is_not (parser, CPP_NAME))
<span class="lineNum">    9919 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    9920 </span><span class="lineNoCov">          0 :       c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">    9921 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    9922 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    9923 </span>            :   if (c_parser_peek_2nd_token (parser)-&gt;type == CPP_COMMA
<span class="lineNum">    9924 </span>            :       || c_parser_peek_2nd_token (parser)-&gt;type == CPP_SEMICOLON)
<span class="lineNum">    9925 </span>            :     {
<span class="lineNum">    9926 </span>            :       /* Any identifiers, including those declared as type names, are
<span class="lineNum">    9927 </span>            :          OK here.  */
<span class="lineNum">    9928 </span>            :       while (true)
<span class="lineNum">    9929 </span>            :         {
<span class="lineNum">    9930 </span>            :           tree id;
<span class="lineNum">    9931 </span>            :           if (c_parser_next_token_is_not (parser, CPP_NAME))
<span class="lineNum">    9932 </span>            :             {
<span class="lineNum">    9933 </span>            :               c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">    9934 </span>            :               break;
<span class="lineNum">    9935 </span>            :             }
<span class="lineNum">    9936 </span>            :           id = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">    9937 </span><span class="lineNoCov">          0 :           objc_declare_protocol (id, attributes);</span>
<span class="lineNum">    9938 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">    9939 </span><span class="lineNoCov">          0 :           if (c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">    9940 </span>            :             c_parser_consume_token (parser);
<span class="lineNum">    9941 </span><span class="lineNoCov">          0 :           else</span>
<span class="lineNum">    9942 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    9943 </span>            :         }
<span class="lineNum">    9944 </span><span class="lineNoCov">          0 :       c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);</span>
<span class="lineNum">    9945 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    9946 </span>            :   else
<span class="lineNum">    9947 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    9948 </span><span class="lineNoCov">          0 :       tree id = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">    9949 </span>            :       tree proto = NULL_TREE;
<span class="lineNum">    9950 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">    9951 </span>            :       if (c_parser_next_token_is (parser, CPP_LESS))
<span class="lineNum">    9952 </span><span class="lineNoCov">          0 :         proto = c_parser_objc_protocol_refs (parser);</span>
<span class="lineNum">    9953 </span>            :       parser-&gt;objc_pq_context = true;
<span class="lineNum">    9954 </span><span class="lineNoCov">          0 :       objc_start_protocol (id, proto, attributes);</span>
<span class="lineNum">    9955 </span><span class="lineNoCov">          0 :       c_parser_objc_methodprotolist (parser);</span>
<span class="lineNum">    9956 </span>            :       c_parser_require_keyword (parser, RID_AT_END, &quot;expected %&lt;@end%&gt;&quot;);
<span class="lineNum">    9957 </span><span class="lineNoCov">          0 :       parser-&gt;objc_pq_context = false;</span>
<span class="lineNum">    9958 </span><span class="lineNoCov">          0 :       objc_finish_interface ();</span>
<span class="lineNum">    9959 </span>            :     }
<span class="lineNum">    9960 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    9961 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9962 </span><span class="lineNoCov">          0 : /* Parse an objc-method-type.</span>
<span class="lineNum">    9963 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9964 </span><span class="lineNoCov">          0 :    objc-method-type:</span>
<span class="lineNum">    9965 </span>            :      +
<span class="lineNum">    9966 </span>            :      -
<span class="lineNum">    9967 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9968 </span><span class="lineNoCov">          0 :    Return true if it is a class method (+) and false if it is</span>
<span class="lineNum">    9969 </span>            :    an instance method (-).
<a name="9970"><span class="lineNum">    9970 </span>            : */</a>
<span class="lineNum">    9971 </span>            : static inline bool
<span class="lineNum">    9972 </span><span class="lineNoCov">          0 : c_parser_objc_method_type (c_parser *parser)</span>
<span class="lineNum">    9973 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    9974 </span><span class="lineNoCov">          0 :   switch (c_parser_peek_token (parser)-&gt;type)</span>
<span class="lineNum">    9975 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    9976 </span><span class="lineNoCov">          0 :     case CPP_PLUS:</span>
<span class="lineNum">    9977 </span><span class="lineNoCov">          0 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    9978 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    9979 </span><span class="lineNoCov">          0 :     case CPP_MINUS:</span>
<span class="lineNum">    9980 </span><span class="lineNoCov">          0 :       c_parser_consume_token (parser);</span>
<span class="lineNum">    9981 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    9982 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    9983 </span>            :       gcc_unreachable ();
<span class="lineNum">    9984 </span>            :     }
<span class="lineNum">    9985 </span>            : }
<span class="lineNum">    9986 </span>            : 
<span class="lineNum">    9987 </span>            : /* Parse an objc-method-definition.
<span class="lineNum">    9988 </span>            : 
<span class="lineNum">    9989 </span>            :    objc-method-definition:
<span class="lineNum">    9990 </span>            :      objc-method-type objc-method-decl ;[opt] compound-statement
<span class="lineNum">    9991 </span>            : */
<a name="9992"><span class="lineNum">    9992 </span>            : </a>
<span class="lineNum">    9993 </span>            : static void
<span class="lineNum">    9994 </span>            : c_parser_objc_method_definition (c_parser *parser)
<span class="lineNum">    9995 </span>            : {
<span class="lineNum">    9996 </span><span class="lineNoCov">          0 :   bool is_class_method = c_parser_objc_method_type (parser);</span>
<span class="lineNum">    9997 </span>            :   tree decl, attributes = NULL_TREE, expr = NULL_TREE;
<span class="lineNum">    9998 </span><span class="lineNoCov">          0 :   parser-&gt;objc_pq_context = true;</span>
<span class="lineNum">    9999 </span>            :   decl = c_parser_objc_method_decl (parser, is_class_method, &amp;attributes,
<span class="lineNum">   10000 </span><span class="lineNoCov">          0 :                                     &amp;expr);</span>
<span class="lineNum">   10001 </span><span class="lineNoCov">          0 :   if (decl == error_mark_node)</span>
<span class="lineNum">   10002 </span><span class="lineNoCov">          0 :     return;  /* Bail here. */</span>
<span class="lineNum">   10003 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10004 </span><span class="lineNoCov">          0 :   if (c_parser_next_token_is (parser, CPP_SEMICOLON))</span>
<span class="lineNum">   10005 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   10006 </span><span class="lineNoCov">          0 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   10007 </span><span class="lineNoCov">          0 :       pedwarn (c_parser_peek_token (parser)-&gt;location, OPT_Wpedantic,</span>
<span class="lineNum">   10008 </span>            :                &quot;extra semicolon in method definition specified&quot;);
<span class="lineNum">   10009 </span>            :     }
<span class="lineNum">   10010 </span>            : 
<span class="lineNum">   10011 </span>            :   if (!c_parser_next_token_is (parser, CPP_OPEN_BRACE))
<span class="lineNum">   10012 </span>            :     {
<span class="lineNum">   10013 </span>            :       c_parser_error (parser, &quot;expected %&lt;{%&gt;&quot;);
<span class="lineNum">   10014 </span>            :       return;
<span class="lineNum">   10015 </span>            :     }
<span class="lineNum">   10016 </span>            : 
<span class="lineNum">   10017 </span>            :   parser-&gt;objc_pq_context = false;
<span class="lineNum">   10018 </span><span class="lineNoCov">          0 :   if (objc_start_method_definition (is_class_method, decl, attributes, expr))</span>
<span class="lineNum">   10019 </span>            :     {
<span class="lineNum">   10020 </span><span class="lineNoCov">          0 :       add_stmt (c_parser_compound_statement (parser));</span>
<span class="lineNum">   10021 </span><span class="lineNoCov">          0 :       objc_finish_method_definition (current_function_decl);</span>
<span class="lineNum">   10022 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   10023 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">   10024 </span>            :     {
<span class="lineNum">   10025 </span><span class="lineNoCov">          0 :       /* This code is executed when we find a method definition</span>
<span class="lineNum">   10026 </span><span class="lineNoCov">          0 :          outside of an @implementation context (or invalid for other</span>
<span class="lineNum">   10027 </span>            :          reasons).  Parse the method (to keep going) but do not emit
<span class="lineNum">   10028 </span><span class="lineNoCov">          0 :          any code.</span>
<span class="lineNum">   10029 </span>            :       */
<span class="lineNum">   10030 </span><span class="lineNoCov">          0 :       c_parser_compound_statement (parser);</span>
<span class="lineNum">   10031 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   10032 </span>            : }
<span class="lineNum">   10033 </span>            : 
<span class="lineNum">   10034 </span>            : /* Parse an objc-methodprotolist.
<span class="lineNum">   10035 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10036 </span>            :    objc-methodprotolist:
<span class="lineNum">   10037 </span><span class="lineNoCov">          0 :      empty</span>
<span class="lineNum">   10038 </span><span class="lineNoCov">          0 :      objc-methodprotolist objc-methodproto</span>
<span class="lineNum">   10039 </span>            :      objc-methodprotolist declaration
<span class="lineNum">   10040 </span>            :      objc-methodprotolist ;
<span class="lineNum">   10041 </span><span class="lineNoCov">          0 :      @optional</span>
<span class="lineNum">   10042 </span><span class="lineNoCov">          0 :      @required</span>
<span class="lineNum">   10043 </span>            : 
<span class="lineNum">   10044 </span><span class="lineNoCov">          0 :    The declaration is a data definition, which may be missing</span>
<span class="lineNum">   10045 </span><span class="lineNoCov">          0 :    declaration specifiers under the same rules and diagnostics as</span>
<span class="lineNum">   10046 </span>            :    other data definitions outside functions, and the stray semicolon
<span class="lineNum">   10047 </span>            :    is diagnosed the same way as a stray semicolon outside a
<span class="lineNum">   10048 </span>            :    function.  */
<a name="10049"><span class="lineNum">   10049 </span>            : </a>
<span class="lineNum">   10050 </span>            : static void
<span class="lineNum">   10051 </span>            : c_parser_objc_methodprotolist (c_parser *parser)
<span class="lineNum">   10052 </span>            : {
<span class="lineNum">   10053 </span>            :   while (true)
<span class="lineNum">   10054 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   10055 </span>            :       /* The list is terminated by @end.  */
<span class="lineNum">   10056 </span>            :       switch (c_parser_peek_token (parser)-&gt;type)
<span class="lineNum">   10057 </span>            :         {
<span class="lineNum">   10058 </span>            :         case CPP_SEMICOLON:
<span class="lineNum">   10059 </span>            :           pedwarn (c_parser_peek_token (parser)-&gt;location, OPT_Wpedantic,
<span class="lineNum">   10060 </span>            :                    &quot;ISO C does not allow extra %&lt;;%&gt; outside of a function&quot;);
<span class="lineNum">   10061 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   10062 </span>            :           break;
<span class="lineNum">   10063 </span>            :         case CPP_PLUS:
<span class="lineNum">   10064 </span>            :         case CPP_MINUS:
<span class="lineNum">   10065 </span>            :           c_parser_objc_methodproto (parser);
<span class="lineNum">   10066 </span>            :           break;
<span class="lineNum">   10067 </span>            :         case CPP_PRAGMA:
<span class="lineNum">   10068 </span>            :           c_parser_pragma (parser, pragma_external, NULL);
<span class="lineNum">   10069 </span>            :           break;
<span class="lineNum">   10070 </span>            :         case CPP_EOF:
<span class="lineNum">   10071 </span>            :           return;
<span class="lineNum">   10072 </span>            :         default:
<span class="lineNum">   10073 </span>            :           if (c_parser_next_token_is_keyword (parser, RID_AT_END))
<span class="lineNum">   10074 </span>            :             return;
<span class="lineNum">   10075 </span><span class="lineNoCov">          0 :           else if (c_parser_next_token_is_keyword (parser, RID_AT_PROPERTY))</span>
<span class="lineNum">   10076 </span>            :             c_parser_objc_at_property_declaration (parser);
<span class="lineNum">   10077 </span><span class="lineNoCov">          0 :           else if (c_parser_next_token_is_keyword (parser, RID_AT_OPTIONAL))</span>
<span class="lineNum">   10078 </span>            :             {
<span class="lineNum">   10079 </span>            :               objc_set_method_opt (true);
<span class="lineNum">   10080 </span><span class="lineNoCov">          0 :               c_parser_consume_token (parser);</span>
<span class="lineNum">   10081 </span>            :             }
<span class="lineNum">   10082 </span><span class="lineNoCov">          0 :           else if (c_parser_next_token_is_keyword (parser, RID_AT_REQUIRED))</span>
<span class="lineNum">   10083 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">   10084 </span>            :               objc_set_method_opt (false);
<span class="lineNum">   10085 </span><span class="lineNoCov">          0 :               c_parser_consume_token (parser);</span>
<span class="lineNum">   10086 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">   10087 </span><span class="lineNoCov">          0 :           else</span>
<span class="lineNum">   10088 </span><span class="lineNoCov">          0 :             c_parser_declaration_or_fndef (parser, false, false, true,</span>
<span class="lineNum">   10089 </span><span class="lineNoCov">          0 :                                            false, true, NULL, vNULL);</span>
<span class="lineNum">   10090 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   10091 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   10092 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   10093 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   10094 </span>            : 
<span class="lineNum">   10095 </span>            : /* Parse an objc-methodproto.
<span class="lineNum">   10096 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10097 </span><span class="lineNoCov">          0 :    objc-methodproto:</span>
<span class="lineNum">   10098 </span>            :      objc-method-type objc-method-decl ;
<span class="lineNum">   10099 </span><span class="lineNoCov">          0 : */</span>
<a name="10100"><span class="lineNum">   10100 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   10101 </span><span class="lineNoCov">          0 : static void</span>
<span class="lineNum">   10102 </span>            : c_parser_objc_methodproto (c_parser *parser)
<span class="lineNum">   10103 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   10104 </span><span class="lineNoCov">          0 :   bool is_class_method = c_parser_objc_method_type (parser);</span>
<span class="lineNum">   10105 </span>            :   tree decl, attributes = NULL_TREE;
<span class="lineNum">   10106 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10107 </span>            :   /* Remember protocol qualifiers in prototypes.  */
<span class="lineNum">   10108 </span><span class="lineNoCov">          0 :   parser-&gt;objc_pq_context = true;</span>
<span class="lineNum">   10109 </span><span class="lineNoCov">          0 :   decl = c_parser_objc_method_decl (parser, is_class_method, &amp;attributes,</span>
<span class="lineNum">   10110 </span>            :                                     NULL);
<span class="lineNum">   10111 </span>            :   /* Forget protocol qualifiers now.  */
<span class="lineNum">   10112 </span><span class="lineNoCov">          0 :   parser-&gt;objc_pq_context = false;</span>
<span class="lineNum">   10113 </span>            : 
<span class="lineNum">   10114 </span>            :   /* Do not allow the presence of attributes to hide an erroneous 
<span class="lineNum">   10115 </span>            :      method implementation in the interface section.  */
<span class="lineNum">   10116 </span>            :   if (!c_parser_next_token_is (parser, CPP_SEMICOLON))
<span class="lineNum">   10117 </span>            :     {
<span class="lineNum">   10118 </span>            :       c_parser_error (parser, &quot;expected %&lt;;%&gt;&quot;);
<span class="lineNum">   10119 </span>            :       return;
<span class="lineNum">   10120 </span>            :     }
<span class="lineNum">   10121 </span>            :   
<span class="lineNum">   10122 </span>            :   if (decl != error_mark_node)
<span class="lineNum">   10123 </span>            :     objc_add_method_declaration (is_class_method, decl, attributes);
<span class="lineNum">   10124 </span>            : 
<span class="lineNum">   10125 </span>            :   c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);
<span class="lineNum">   10126 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   10127 </span>            : 
<span class="lineNum">   10128 </span><span class="lineNoCov">          0 : /* If we are at a position that method attributes may be present, check that </span>
<span class="lineNum">   10129 </span><span class="lineNoCov">          0 :    there are not any parsed already (a syntax error) and then collect any </span>
<span class="lineNum">   10130 </span>            :    specified at the current location.  Finally, if new attributes were present,
<span class="lineNum">   10131 </span>            :    check that the next token is legal ( ';' for decls and '{' for defs).  */
<a name="10132"><span class="lineNum">   10132 </span><span class="lineNoCov">          0 :    </span></a>
<span class="lineNum">   10133 </span><span class="lineNoCov">          0 : static bool </span>
<span class="lineNum">   10134 </span>            : c_parser_objc_maybe_method_attributes (c_parser* parser, tree* attributes)
<span class="lineNum">   10135 </span>            : {
<span class="lineNum">   10136 </span><span class="lineNoCov">          0 :   bool bad = false;</span>
<span class="lineNum">   10137 </span>            :   if (*attributes)
<span class="lineNum">   10138 </span>            :     {
<span class="lineNum">   10139 </span>            :       c_parser_error (parser, 
<span class="lineNum">   10140 </span><span class="lineNoCov">          0 :                     &quot;method attributes must be specified at the end only&quot;);</span>
<span class="lineNum">   10141 </span>            :       *attributes = NULL_TREE;
<span class="lineNum">   10142 </span><span class="lineNoCov">          0 :       bad = true;</span>
<span class="lineNum">   10143 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   10144 </span>            : 
<span class="lineNum">   10145 </span>            :   if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))
<span class="lineNum">   10146 </span><span class="lineNoCov">          0 :     *attributes = c_parser_attributes (parser);</span>
<span class="lineNum">   10147 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10148 </span>            :   /* If there were no attributes here, just report any earlier error.  */
<span class="lineNum">   10149 </span><span class="lineNoCov">          0 :   if (*attributes == NULL_TREE || bad)</span>
<span class="lineNum">   10150 </span>            :     return bad;
<span class="lineNum">   10151 </span>            : 
<span class="lineNum">   10152 </span>            :   /* If the attributes are followed by a ; or {, then just report any earlier
<span class="lineNum">   10153 </span>            :      error.  */
<span class="lineNum">   10154 </span>            :   if (c_parser_next_token_is (parser, CPP_SEMICOLON)
<span class="lineNum">   10155 </span>            :       || c_parser_next_token_is (parser, CPP_OPEN_BRACE))
<span class="lineNum">   10156 </span>            :     return bad;
<span class="lineNum">   10157 </span>            : 
<span class="lineNum">   10158 </span><span class="lineNoCov">          0 :   /* We've got attributes, but not at the end.  */</span>
<span class="lineNum">   10159 </span>            :   c_parser_error (parser, 
<span class="lineNum">   10160 </span><span class="lineNoCov">          0 :                   &quot;expected %&lt;;%&gt; or %&lt;{%&gt; after method attribute definition&quot;);</span>
<span class="lineNum">   10161 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">   10162 </span>            : }
<span class="lineNum">   10163 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10164 </span>            : /* Parse an objc-method-decl.
<span class="lineNum">   10165 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10166 </span><span class="lineNoCov">          0 :    objc-method-decl:</span>
<span class="lineNum">   10167 </span>            :      ( objc-type-name ) objc-selector
<span class="lineNum">   10168 </span>            :      objc-selector
<span class="lineNum">   10169 </span><span class="lineNoCov">          0 :      ( objc-type-name ) objc-keyword-selector objc-optparmlist</span>
<span class="lineNum">   10170 </span><span class="lineNoCov">          0 :      objc-keyword-selector objc-optparmlist</span>
<span class="lineNum">   10171 </span>            :      attributes
<span class="lineNum">   10172 </span>            : 
<span class="lineNum">   10173 </span><span class="lineNoCov">          0 :    objc-keyword-selector:</span>
<span class="lineNum">   10174 </span>            :      objc-keyword-decl
<span class="lineNum">   10175 </span>            :      objc-keyword-selector objc-keyword-decl
<span class="lineNum">   10176 </span>            : 
<span class="lineNum">   10177 </span>            :    objc-keyword-decl:
<span class="lineNum">   10178 </span><span class="lineNoCov">          0 :      objc-selector : ( objc-type-name ) identifier</span>
<span class="lineNum">   10179 </span><span class="lineNoCov">          0 :      objc-selector : identifier</span>
<span class="lineNum">   10180 </span><span class="lineNoCov">          0 :      : ( objc-type-name ) identifier</span>
<span class="lineNum">   10181 </span>            :      : identifier
<span class="lineNum">   10182 </span>            : 
<span class="lineNum">   10183 </span><span class="lineNoCov">          0 :    objc-optparmlist:</span>
<span class="lineNum">   10184 </span>            :      objc-optparms objc-optellipsis
<span class="lineNum">   10185 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10186 </span>            :    objc-optparms:
<span class="lineNum">   10187 </span>            :      empty
<span class="lineNum">   10188 </span>            :      objc-opt-parms , parameter-declaration
<span class="lineNum">   10189 </span>            : 
<span class="lineNum">   10190 </span>            :    objc-optellipsis:
<span class="lineNum">   10191 </span>            :      empty
<span class="lineNum">   10192 </span>            :      , ...
<span class="lineNum">   10193 </span>            : */
<a name="10194"><span class="lineNum">   10194 </span>            : </a>
<span class="lineNum">   10195 </span>            : static tree
<span class="lineNum">   10196 </span>            : c_parser_objc_method_decl (c_parser *parser, bool is_class_method,
<span class="lineNum">   10197 </span>            :                            tree *attributes, tree *expr)
<span class="lineNum">   10198 </span>            : {
<span class="lineNum">   10199 </span>            :   tree type = NULL_TREE;
<span class="lineNum">   10200 </span>            :   tree sel;
<span class="lineNum">   10201 </span>            :   tree parms = NULL_TREE;
<span class="lineNum">   10202 </span>            :   bool ellipsis = false;
<span class="lineNum">   10203 </span>            :   bool attr_err = false;
<span class="lineNum">   10204 </span>            : 
<span class="lineNum">   10205 </span>            :   *attributes = NULL_TREE;
<span class="lineNum">   10206 </span>            :   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))
<span class="lineNum">   10207 </span>            :     {
<span class="lineNum">   10208 </span>            :       matching_parens parens;
<span class="lineNum">   10209 </span>            :       parens.consume_open (parser);
<span class="lineNum">   10210 </span>            :       type = c_parser_objc_type_name (parser);
<span class="lineNum">   10211 </span>            :       parens.skip_until_found_close (parser);
<span class="lineNum">   10212 </span>            :     }
<span class="lineNum">   10213 </span>            :   sel = c_parser_objc_selector (parser);
<span class="lineNum">   10214 </span>            :   /* If there is no selector, or a colon follows, we have an
<span class="lineNum">   10215 </span>            :      objc-keyword-selector.  If there is a selector, and a colon does
<span class="lineNum">   10216 </span>            :      not follow, that selector ends the objc-method-decl.  */
<span class="lineNum">   10217 </span>            :   if (!sel || c_parser_next_token_is (parser, CPP_COLON))
<span class="lineNum">   10218 </span>            :     {
<span class="lineNum">   10219 </span>            :       tree tsel = sel;
<span class="lineNum">   10220 </span><span class="lineNoCov">          0 :       tree list = NULL_TREE;</span>
<span class="lineNum">   10221 </span>            :       while (true)
<span class="lineNum">   10222 </span>            :         {
<span class="lineNum">   10223 </span><span class="lineNoCov">          0 :           tree atype = NULL_TREE, id, keyworddecl;</span>
<span class="lineNum">   10224 </span><span class="lineNoCov">          0 :           tree param_attr = NULL_TREE;</span>
<span class="lineNum">   10225 </span><span class="lineNoCov">          0 :           if (!c_parser_require (parser, CPP_COLON, &quot;expected %&lt;:%&gt;&quot;))</span>
<span class="lineNum">   10226 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   10227 </span><span class="lineNoCov">          0 :           if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))</span>
<span class="lineNum">   10228 </span>            :             {
<span class="lineNum">   10229 </span><span class="lineNoCov">          0 :               c_parser_consume_token (parser);</span>
<span class="lineNum">   10230 </span><span class="lineNoCov">          0 :               atype = c_parser_objc_type_name (parser);</span>
<span class="lineNum">   10231 </span>            :               c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,
<span class="lineNum">   10232 </span><span class="lineNoCov">          0 :                                          &quot;expected %&lt;)%&gt;&quot;);</span>
<span class="lineNum">   10233 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">   10234 </span><span class="lineNoCov">          0 :           /* New ObjC allows attributes on method parameters.  */</span>
<span class="lineNum">   10235 </span><span class="lineNoCov">          0 :           if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))</span>
<span class="lineNum">   10236 </span>            :             param_attr = c_parser_attributes (parser);
<span class="lineNum">   10237 </span><span class="lineNoCov">          0 :           if (c_parser_next_token_is_not (parser, CPP_NAME))</span>
<span class="lineNum">   10238 </span>            :             {
<span class="lineNum">   10239 </span>            :               c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">   10240 </span>            :               return error_mark_node;
<span class="lineNum">   10241 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">   10242 </span>            :           id = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">   10243 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   10244 </span>            :           keyworddecl = objc_build_keyword_decl (tsel, atype, id, param_attr);
<span class="lineNum">   10245 </span><span class="lineNoCov">          0 :           list = chainon (list, keyworddecl);</span>
<span class="lineNum">   10246 </span>            :           tsel = c_parser_objc_selector (parser);
<span class="lineNum">   10247 </span><span class="lineNoCov">          0 :           if (!tsel &amp;&amp; c_parser_next_token_is_not (parser, CPP_COLON))</span>
<span class="lineNum">   10248 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   10249 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   10250 </span>            : 
<span class="lineNum">   10251 </span><span class="lineNoCov">          0 :       attr_err |= c_parser_objc_maybe_method_attributes (parser, attributes) ;</span>
<span class="lineNum">   10252 </span>            : 
<span class="lineNum">   10253 </span><span class="lineNoCov">          0 :       /* Parse the optional parameter list.  Optional Objective-C</span>
<span class="lineNum">   10254 </span><span class="lineNoCov">          0 :          method parameters follow the C syntax, and may include '...'</span>
<span class="lineNum">   10255 </span><span class="lineNoCov">          0 :          to denote a variable number of arguments.  */</span>
<span class="lineNum">   10256 </span>            :       parms = make_node (TREE_LIST);
<span class="lineNum">   10257 </span>            :       while (c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">   10258 </span>            :         {
<span class="lineNum">   10259 </span><span class="lineNoCov">          0 :           struct c_parm *parm;</span>
<span class="lineNum">   10260 </span><span class="lineNoCov">          0 :           c_parser_consume_token (parser);</span>
<span class="lineNum">   10261 </span><span class="lineNoCov">          0 :           if (c_parser_next_token_is (parser, CPP_ELLIPSIS))</span>
<span class="lineNum">   10262 </span>            :             {
<span class="lineNum">   10263 </span><span class="lineNoCov">          0 :               ellipsis = true;</span>
<span class="lineNum">   10264 </span><span class="lineNoCov">          0 :               c_parser_consume_token (parser);</span>
<span class="lineNum">   10265 </span>            :               attr_err |= c_parser_objc_maybe_method_attributes 
<span class="lineNum">   10266 </span><span class="lineNoCov">          0 :                                                 (parser, attributes) ;</span>
<span class="lineNum">   10267 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">   10268 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">   10269 </span><span class="lineNoCov">          0 :           parm = c_parser_parameter_declaration (parser, NULL_TREE);</span>
<span class="lineNum">   10270 </span><span class="lineNoCov">          0 :           if (parm == NULL)</span>
<span class="lineNum">   10271 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   10272 </span>            :           parms = chainon (parms,
<span class="lineNum">   10273 </span>            :                            build_tree_list (NULL_TREE, grokparm (parm, expr)));
<span class="lineNum">   10274 </span>            :         }
<span class="lineNum">   10275 </span><span class="lineNoCov">          0 :       sel = list;</span>
<span class="lineNum">   10276 </span>            :     }
<span class="lineNum">   10277 </span>            :   else
<span class="lineNum">   10278 </span>            :     attr_err |= c_parser_objc_maybe_method_attributes (parser, attributes) ;
<span class="lineNum">   10279 </span>            : 
<span class="lineNum">   10280 </span><span class="lineNoCov">          0 :   if (sel == NULL)</span>
<span class="lineNum">   10281 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   10282 </span>            :       c_parser_error (parser, &quot;objective-c method declaration is expected&quot;);
<span class="lineNum">   10283 </span><span class="lineNoCov">          0 :       return error_mark_node;</span>
<span class="lineNum">   10284 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   10285 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10286 </span>            :   if (attr_err)
<span class="lineNum">   10287 </span><span class="lineNoCov">          0 :     return error_mark_node;</span>
<span class="lineNum">   10288 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10289 </span><span class="lineNoCov">          0 :   return objc_build_method_signature (is_class_method, type, sel, parms, ellipsis);</span>
<span class="lineNum">   10290 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   10291 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10292 </span>            : /* Parse an objc-type-name.
<span class="lineNum">   10293 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10294 </span><span class="lineNoCov">          0 :    objc-type-name:</span>
<span class="lineNum">   10295 </span>            :      objc-type-qualifiers[opt] type-name
<span class="lineNum">   10296 </span><span class="lineNoCov">          0 :      objc-type-qualifiers[opt]</span>
<span class="lineNum">   10297 </span>            : 
<span class="lineNum">   10298 </span>            :    objc-type-qualifiers:
<span class="lineNum">   10299 </span>            :      objc-type-qualifier
<span class="lineNum">   10300 </span>            :      objc-type-qualifiers objc-type-qualifier
<span class="lineNum">   10301 </span>            : 
<span class="lineNum">   10302 </span><span class="lineNoCov">          0 :    objc-type-qualifier: one of</span>
<span class="lineNum">   10303 </span>            :      in out inout bycopy byref oneway
<span class="lineNum">   10304 </span><span class="lineNoCov">          0 : */</span>
<a name="10305"><span class="lineNum">   10305 </span>            : </a>
<span class="lineNum">   10306 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   10307 </span><span class="lineNoCov">          0 : c_parser_objc_type_name (c_parser *parser)</span>
<span class="lineNum">   10308 </span>            : {
<span class="lineNum">   10309 </span>            :   tree quals = NULL_TREE;
<span class="lineNum">   10310 </span><span class="lineNoCov">          0 :   struct c_type_name *type_name = NULL;</span>
<span class="lineNum">   10311 </span><span class="lineNoCov">          0 :   tree type = NULL_TREE;</span>
<span class="lineNum">   10312 </span>            :   while (true)
<span class="lineNum">   10313 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   10314 </span>            :       c_token *token = c_parser_peek_token (parser);
<span class="lineNum">   10315 </span>            :       if (token-&gt;type == CPP_KEYWORD
<span class="lineNum">   10316 </span>            :           &amp;&amp; (token-&gt;keyword == RID_IN
<span class="lineNum">   10317 </span>            :               || token-&gt;keyword == RID_OUT
<span class="lineNum">   10318 </span>            :               || token-&gt;keyword == RID_INOUT
<span class="lineNum">   10319 </span>            :               || token-&gt;keyword == RID_BYCOPY
<span class="lineNum">   10320 </span>            :               || token-&gt;keyword == RID_BYREF
<span class="lineNum">   10321 </span>            :               || token-&gt;keyword == RID_ONEWAY))
<span class="lineNum">   10322 </span>            :         {
<span class="lineNum">   10323 </span>            :           quals = chainon (build_tree_list (NULL_TREE, token-&gt;value), quals);
<span class="lineNum">   10324 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   10325 </span>            :         }
<span class="lineNum">   10326 </span>            :       else
<span class="lineNum">   10327 </span>            :         break;
<span class="lineNum">   10328 </span>            :     }
<span class="lineNum">   10329 </span>            :   if (c_parser_next_tokens_start_typename (parser, cla_prefer_type))
<span class="lineNum">   10330 </span>            :     type_name = c_parser_type_name (parser);
<span class="lineNum">   10331 </span><span class="lineNoCov">          0 :   if (type_name)</span>
<span class="lineNum">   10332 </span>            :     type = groktypename (type_name, NULL, NULL);
<span class="lineNum">   10333 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10334 </span><span class="lineNoCov">          0 :   /* If the type is unknown, and error has already been produced and</span>
<span class="lineNum">   10335 </span><span class="lineNoCov">          0 :      we need to recover from the error.  In that case, use NULL_TREE</span>
<span class="lineNum">   10336 </span><span class="lineNoCov">          0 :      for the type, as if no type had been specified; this will use the</span>
<span class="lineNum">   10337 </span>            :      default type ('id') which is good for error recovery.  */
<span class="lineNum">   10338 </span><span class="lineNoCov">          0 :   if (type == error_mark_node)</span>
<span class="lineNum">   10339 </span><span class="lineNoCov">          0 :     type = NULL_TREE;</span>
<span class="lineNum">   10340 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10341 </span>            :   return build_tree_list (quals, type);
<span class="lineNum">   10342 </span>            : }
<span class="lineNum">   10343 </span>            : 
<span class="lineNum">   10344 </span>            : /* Parse objc-protocol-refs.
<span class="lineNum">   10345 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10346 </span>            :    objc-protocol-refs:
<span class="lineNum">   10347 </span><span class="lineNoCov">          0 :      &lt; identifier-list &gt;</span>
<span class="lineNum">   10348 </span><span class="lineNoCov">          0 : */</span>
<a name="10349"><span class="lineNum">   10349 </span>            : </a>
<span class="lineNum">   10350 </span>            : static tree
<span class="lineNum">   10351 </span>            : c_parser_objc_protocol_refs (c_parser *parser)
<span class="lineNum">   10352 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   10353 </span><span class="lineNoCov">          0 :   tree list = NULL_TREE;</span>
<span class="lineNum">   10354 </span><span class="lineNoCov">          0 :   gcc_assert (c_parser_next_token_is (parser, CPP_LESS));</span>
<span class="lineNum">   10355 </span><span class="lineNoCov">          0 :   c_parser_consume_token (parser);</span>
<span class="lineNum">   10356 </span><span class="lineNoCov">          0 :   /* Any identifiers, including those declared as type names, are OK</span>
<span class="lineNum">   10357 </span>            :      here.  */
<span class="lineNum">   10358 </span>            :   while (true)
<span class="lineNum">   10359 </span>            :     {
<span class="lineNum">   10360 </span>            :       tree id;
<span class="lineNum">   10361 </span>            :       if (c_parser_next_token_is_not (parser, CPP_NAME))
<span class="lineNum">   10362 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   10363 </span><span class="lineNoCov">          0 :           c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">   10364 </span>            :           break;
<span class="lineNum">   10365 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   10366 </span>            :       id = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">   10367 </span>            :       list = chainon (list, build_tree_list (NULL_TREE, id));
<span class="lineNum">   10368 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   10369 </span>            :       if (c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">   10370 </span>            :         c_parser_consume_token (parser);
<span class="lineNum">   10371 </span>            :       else
<span class="lineNum">   10372 </span>            :         break;
<span class="lineNum">   10373 </span>            :     }
<span class="lineNum">   10374 </span>            :   c_parser_require (parser, CPP_GREATER, &quot;expected %&lt;&gt;%&gt;&quot;);
<span class="lineNum">   10375 </span><span class="lineNoCov">          0 :   return list;</span>
<span class="lineNum">   10376 </span>            : }
<span class="lineNum">   10377 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10378 </span><span class="lineNoCov">          0 : /* Parse an objc-try-catch-finally-statement.</span>
<span class="lineNum">   10379 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10380 </span>            :    objc-try-catch-finally-statement:
<span class="lineNum">   10381 </span>            :      @try compound-statement objc-catch-list[opt]
<span class="lineNum">   10382 </span><span class="lineNoCov">          0 :      @try compound-statement objc-catch-list[opt] @finally compound-statement</span>
<span class="lineNum">   10383 </span>            : 
<span class="lineNum">   10384 </span><span class="lineNoCov">          0 :    objc-catch-list:</span>
<span class="lineNum">   10385 </span><span class="lineNoCov">          0 :      @catch ( objc-catch-parameter-declaration ) compound-statement</span>
<span class="lineNum">   10386 </span>            :      objc-catch-list @catch ( objc-catch-parameter-declaration ) compound-statement
<span class="lineNum">   10387 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10388 </span><span class="lineNoCov">          0 :    objc-catch-parameter-declaration:</span>
<span class="lineNum">   10389 </span>            :      parameter-declaration
<span class="lineNum">   10390 </span><span class="lineNoCov">          0 :      '...'</span>
<span class="lineNum">   10391 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10392 </span><span class="lineNoCov">          0 :    where '...' is to be interpreted literally, that is, it means CPP_ELLIPSIS.</span>
<span class="lineNum">   10393 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10394 </span><span class="lineNoCov">          0 :    PS: This function is identical to cp_parser_objc_try_catch_finally_statement</span>
<span class="lineNum">   10395 </span>            :    for C++.  Keep them in sync.  */   
<a name="10396"><span class="lineNum">   10396 </span>            : </a>
<span class="lineNum">   10397 </span><span class="lineNoCov">          0 : static void</span>
<span class="lineNum">   10398 </span><span class="lineNoCov">          0 : c_parser_objc_try_catch_finally_statement (c_parser *parser)</span>
<span class="lineNum">   10399 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   10400 </span>            :   location_t location;
<span class="lineNum">   10401 </span>            :   tree stmt;
<span class="lineNum">   10402 </span>            : 
<span class="lineNum">   10403 </span>            :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_AT_TRY));
<span class="lineNum">   10404 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">   10405 </span>            :   location = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   10406 </span>            :   objc_maybe_warn_exceptions (location);
<span class="lineNum">   10407 </span>            :   stmt = c_parser_compound_statement (parser);
<span class="lineNum">   10408 </span>            :   objc_begin_try_stmt (location, stmt);
<span class="lineNum">   10409 </span>            : 
<span class="lineNum">   10410 </span>            :   while (c_parser_next_token_is_keyword (parser, RID_AT_CATCH))
<span class="lineNum">   10411 </span>            :     {
<span class="lineNum">   10412 </span>            :       struct c_parm *parm;
<span class="lineNum">   10413 </span>            :       tree parameter_declaration = error_mark_node;
<span class="lineNum">   10414 </span>            :       bool seen_open_paren = false;
<span class="lineNum">   10415 </span>            : 
<span class="lineNum">   10416 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   10417 </span>            :       matching_parens parens;
<span class="lineNum">   10418 </span>            :       if (!parens.require_open (parser))
<span class="lineNum">   10419 </span>            :         seen_open_paren = true;
<span class="lineNum">   10420 </span>            :       if (c_parser_next_token_is (parser, CPP_ELLIPSIS))
<span class="lineNum">   10421 </span>            :         {
<span class="lineNum">   10422 </span><span class="lineNoCov">          0 :           /* We have &quot;@catch (...)&quot; (where the '...' are literally</span>
<span class="lineNum">   10423 </span>            :              what is in the code).  Skip the '...'.
<span class="lineNum">   10424 </span><span class="lineNoCov">          0 :              parameter_declaration is set to NULL_TREE, and</span>
<span class="lineNum">   10425 </span><span class="lineNoCov">          0 :              objc_being_catch_clauses() knows that that means</span>
<span class="lineNum">   10426 </span>            :              '...'.  */
<span class="lineNum">   10427 </span><span class="lineNoCov">          0 :           c_parser_consume_token (parser);</span>
<span class="lineNum">   10428 </span><span class="lineNoCov">          0 :           parameter_declaration = NULL_TREE;</span>
<span class="lineNum">   10429 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   10430 </span><span class="lineNoCov">          0 :       else</span>
<span class="lineNum">   10431 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   10432 </span><span class="lineNoCov">          0 :           /* We have &quot;@catch (NSException *exception)&quot; or something</span>
<span class="lineNum">   10433 </span>            :              like that.  Parse the parameter declaration.  */
<span class="lineNum">   10434 </span><span class="lineNoCov">          0 :           parm = c_parser_parameter_declaration (parser, NULL_TREE);</span>
<span class="lineNum">   10435 </span>            :           if (parm == NULL)
<span class="lineNum">   10436 </span><span class="lineNoCov">          0 :             parameter_declaration = error_mark_node;</span>
<span class="lineNum">   10437 </span><span class="lineNoCov">          0 :           else</span>
<span class="lineNum">   10438 </span><span class="lineNoCov">          0 :             parameter_declaration = grokparm (parm, NULL);</span>
<span class="lineNum">   10439 </span>            :         }
<span class="lineNum">   10440 </span><span class="lineNoCov">          0 :       if (seen_open_paren)</span>
<span class="lineNum">   10441 </span><span class="lineNoCov">          0 :         parens.require_close (parser);</span>
<span class="lineNum">   10442 </span><span class="lineNoCov">          0 :       else</span>
<span class="lineNum">   10443 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   10444 </span><span class="lineNoCov">          0 :           /* If there was no open parenthesis, we are recovering from</span>
<span class="lineNum">   10445 </span>            :              an error, and we are trying to figure out what mistake
<span class="lineNum">   10446 </span>            :              the user has made.  */
<span class="lineNum">   10447 </span>            : 
<span class="lineNum">   10448 </span>            :           /* If there is an immediate closing parenthesis, the user
<span class="lineNum">   10449 </span>            :              probably forgot the opening one (ie, they typed &quot;@catch
<span class="lineNum">   10450 </span>            :              NSException *e)&quot;.  Parse the closing parenthesis and keep
<span class="lineNum">   10451 </span><span class="lineNoCov">          0 :              going.  */</span>
<span class="lineNum">   10452 </span><span class="lineNoCov">          0 :           if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))</span>
<span class="lineNum">   10453 </span>            :             c_parser_consume_token (parser);
<span class="lineNum">   10454 </span>            :           
<span class="lineNum">   10455 </span>            :           /* If these is no immediate closing parenthesis, the user
<span class="lineNum">   10456 </span>            :              probably doesn't know that parenthesis are required at
<span class="lineNum">   10457 </span>            :              all (ie, they typed &quot;@catch NSException *e&quot;).  So, just
<span class="lineNum">   10458 </span><span class="lineNoCov">          0 :              forget about the closing parenthesis and keep going.  */</span>
<span class="lineNum">   10459 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   10460 </span><span class="lineNoCov">          0 :       objc_begin_catch_clause (parameter_declaration);</span>
<span class="lineNum">   10461 </span>            :       if (c_parser_require (parser, CPP_OPEN_BRACE, &quot;expected %&lt;{%&gt;&quot;))
<span class="lineNum">   10462 </span><span class="lineNoCov">          0 :         c_parser_compound_statement_nostart (parser);</span>
<span class="lineNum">   10463 </span>            :       objc_finish_catch_clause ();
<span class="lineNum">   10464 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   10465 </span><span class="lineNoCov">          0 :   if (c_parser_next_token_is_keyword (parser, RID_AT_FINALLY))</span>
<span class="lineNum">   10466 </span>            :     {
<span class="lineNum">   10467 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   10468 </span>            :       location = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   10469 </span>            :       stmt = c_parser_compound_statement (parser);
<span class="lineNum">   10470 </span>            :       objc_build_finally_clause (location, stmt);
<span class="lineNum">   10471 </span>            :     }
<span class="lineNum">   10472 </span>            :   objc_finish_try_stmt ();
<span class="lineNum">   10473 </span>            : }
<span class="lineNum">   10474 </span>            : 
<span class="lineNum">   10475 </span>            : /* Parse an objc-synchronized-statement.
<span class="lineNum">   10476 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10477 </span><span class="lineNoCov">          0 :    objc-synchronized-statement:</span>
<span class="lineNum">   10478 </span>            :      @synchronized ( expression ) compound-statement
<span class="lineNum">   10479 </span>            : */
<a name="10480"><span class="lineNum">   10480 </span>            : </a>
<span class="lineNum">   10481 </span>            : static void
<span class="lineNum">   10482 </span>            : c_parser_objc_synchronized_statement (c_parser *parser)
<span class="lineNum">   10483 </span>            : {
<span class="lineNum">   10484 </span><span class="lineNoCov">          0 :   location_t loc;</span>
<span class="lineNum">   10485 </span><span class="lineNoCov">          0 :   tree expr, stmt;</span>
<span class="lineNum">   10486 </span><span class="lineNoCov">          0 :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_AT_SYNCHRONIZED));</span>
<span class="lineNum">   10487 </span><span class="lineNoCov">          0 :   c_parser_consume_token (parser);</span>
<span class="lineNum">   10488 </span>            :   loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   10489 </span><span class="lineNoCov">          0 :   objc_maybe_warn_exceptions (loc);</span>
<span class="lineNum">   10490 </span>            :   matching_parens parens;
<span class="lineNum">   10491 </span><span class="lineNoCov">          0 :   if (parens.require_open (parser))</span>
<span class="lineNum">   10492 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   10493 </span><span class="lineNoCov">          0 :       struct c_expr ce = c_parser_expression (parser);</span>
<span class="lineNum">   10494 </span><span class="lineNoCov">          0 :       ce = convert_lvalue_to_rvalue (loc, ce, false, false);</span>
<span class="lineNum">   10495 </span>            :       expr = ce.value;
<span class="lineNum">   10496 </span><span class="lineNoCov">          0 :       expr = c_fully_fold (expr, false, NULL);</span>
<span class="lineNum">   10497 </span><span class="lineNoCov">          0 :       parens.skip_until_found_close (parser);</span>
<span class="lineNum">   10498 </span>            :     }
<span class="lineNum">   10499 </span>            :   else
<span class="lineNum">   10500 </span>            :     expr = error_mark_node;
<span class="lineNum">   10501 </span>            :   stmt = c_parser_compound_statement (parser);
<span class="lineNum">   10502 </span>            :   objc_build_synchronized (loc, expr, stmt);
<span class="lineNum">   10503 </span>            : }
<span class="lineNum">   10504 </span>            : 
<span class="lineNum">   10505 </span>            : /* Parse an objc-selector; return NULL_TREE without an error if the
<span class="lineNum">   10506 </span><span class="lineNoCov">          0 :    next token is not an objc-selector.</span>
<span class="lineNum">   10507 </span>            : 
<span class="lineNum">   10508 </span><span class="lineNoCov">          0 :    objc-selector:</span>
<span class="lineNum">   10509 </span><span class="lineNoCov">          0 :      identifier</span>
<span class="lineNum">   10510 </span><span class="lineNoCov">          0 :      one of</span>
<span class="lineNum">   10511 </span><span class="lineNoCov">          0 :        enum struct union if else while do for switch case default</span>
<span class="lineNum">   10512 </span><span class="lineNoCov">          0 :        break continue return goto asm sizeof typeof __alignof</span>
<span class="lineNum">   10513 </span><span class="lineNoCov">          0 :        unsigned long const short volatile signed restrict _Complex</span>
<span class="lineNum">   10514 </span><span class="lineNoCov">          0 :        in out inout bycopy byref oneway int char float double void _Bool</span>
<span class="lineNum">   10515 </span><span class="lineNoCov">          0 :        _Atomic</span>
<span class="lineNum">   10516 </span>            : 
<span class="lineNum">   10517 </span><span class="lineNoCov">          0 :    ??? Why this selection of keywords but not, for example, storage</span>
<span class="lineNum">   10518 </span><span class="lineNoCov">          0 :    class specifiers?  */</span>
<a name="10519"><span class="lineNum">   10519 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   10520 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   10521 </span><span class="lineNoCov">          0 : c_parser_objc_selector (c_parser *parser)</span>
<span class="lineNum">   10522 </span>            : {
<span class="lineNum">   10523 </span>            :   c_token *token = c_parser_peek_token (parser);
<span class="lineNum">   10524 </span><span class="lineNoCov">          0 :   tree value = token-&gt;value;</span>
<span class="lineNum">   10525 </span><span class="lineNoCov">          0 :   if (token-&gt;type == CPP_NAME)</span>
<span class="lineNum">   10526 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   10527 </span><span class="lineNoCov">          0 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   10528 </span>            :       return value;
<span class="lineNum">   10529 </span>            :     }
<span class="lineNum">   10530 </span>            :   if (token-&gt;type != CPP_KEYWORD)
<span class="lineNum">   10531 </span>            :     return NULL_TREE;
<span class="lineNum">   10532 </span>            :   switch (token-&gt;keyword)
<span class="lineNum">   10533 </span>            :     {
<span class="lineNum">   10534 </span>            :     case RID_ENUM:
<span class="lineNum">   10535 </span>            :     case RID_STRUCT:
<span class="lineNum">   10536 </span>            :     case RID_UNION:
<span class="lineNum">   10537 </span>            :     case RID_IF:
<span class="lineNum">   10538 </span>            :     case RID_ELSE:
<span class="lineNum">   10539 </span>            :     case RID_WHILE:
<span class="lineNum">   10540 </span>            :     case RID_DO:
<span class="lineNum">   10541 </span>            :     case RID_FOR:
<span class="lineNum">   10542 </span>            :     case RID_SWITCH:
<span class="lineNum">   10543 </span>            :     case RID_CASE:
<span class="lineNum">   10544 </span>            :     case RID_DEFAULT:
<span class="lineNum">   10545 </span><span class="lineNoCov">          0 :     case RID_BREAK:</span>
<span class="lineNum">   10546 </span>            :     case RID_CONTINUE:
<span class="lineNum">   10547 </span><span class="lineNoCov">          0 :     case RID_RETURN:</span>
<span class="lineNum">   10548 </span><span class="lineNoCov">          0 :     case RID_GOTO:</span>
<span class="lineNum">   10549 </span><span class="lineNoCov">          0 :     case RID_ASM:</span>
<span class="lineNum">   10550 </span>            :     case RID_SIZEOF:
<span class="lineNum">   10551 </span><span class="lineNoCov">          0 :     case RID_TYPEOF:</span>
<span class="lineNum">   10552 </span><span class="lineNoCov">          0 :     case RID_ALIGNOF:</span>
<span class="lineNum">   10553 </span>            :     case RID_UNSIGNED:
<span class="lineNum">   10554 </span><span class="lineNoCov">          0 :     case RID_LONG:</span>
<span class="lineNum">   10555 </span>            :     case RID_CONST:
<span class="lineNum">   10556 </span><span class="lineNoCov">          0 :     case RID_SHORT:</span>
<span class="lineNum">   10557 </span>            :     case RID_VOLATILE:
<span class="lineNum">   10558 </span><span class="lineNoCov">          0 :     case RID_SIGNED:</span>
<span class="lineNum">   10559 </span><span class="lineNoCov">          0 :     case RID_RESTRICT:</span>
<span class="lineNum">   10560 </span><span class="lineNoCov">          0 :     case RID_COMPLEX:</span>
<span class="lineNum">   10561 </span><span class="lineNoCov">          0 :     case RID_IN:</span>
<span class="lineNum">   10562 </span><span class="lineNoCov">          0 :     case RID_OUT:</span>
<span class="lineNum">   10563 </span><span class="lineNoCov">          0 :     case RID_INOUT:</span>
<span class="lineNum">   10564 </span><span class="lineNoCov">          0 :     case RID_BYCOPY:</span>
<span class="lineNum">   10565 </span><span class="lineNoCov">          0 :     case RID_BYREF:</span>
<span class="lineNum">   10566 </span><span class="lineNoCov">          0 :     case RID_ONEWAY:</span>
<span class="lineNum">   10567 </span><span class="lineNoCov">          0 :     case RID_INT:</span>
<span class="lineNum">   10568 </span><span class="lineNoCov">          0 :     case RID_CHAR:</span>
<span class="lineNum">   10569 </span><span class="lineNoCov">          0 :     case RID_FLOAT:</span>
<span class="lineNum">   10570 </span><span class="lineNoCov">          0 :     case RID_DOUBLE:</span>
<span class="lineNum">   10571 </span><span class="lineNoCov">          0 :     CASE_RID_FLOATN_NX:</span>
<span class="lineNum">   10572 </span><span class="lineNoCov">          0 :     case RID_VOID:</span>
<span class="lineNum">   10573 </span><span class="lineNoCov">          0 :     case RID_BOOL:</span>
<span class="lineNum">   10574 </span><span class="lineNoCov">          0 :     case RID_ATOMIC:</span>
<span class="lineNum">   10575 </span><span class="lineNoCov">          0 :     case RID_AUTO_TYPE:</span>
<span class="lineNum">   10576 </span><span class="lineNoCov">          0 :     case RID_INT_N_0:</span>
<span class="lineNum">   10577 </span><span class="lineNoCov">          0 :     case RID_INT_N_1:</span>
<span class="lineNum">   10578 </span><span class="lineNoCov">          0 :     case RID_INT_N_2:</span>
<span class="lineNum">   10579 </span><span class="lineNoCov">          0 :     case RID_INT_N_3:</span>
<span class="lineNum">   10580 </span><span class="lineNoCov">          0 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   10581 </span><span class="lineNoCov">          0 :       return value;</span>
<span class="lineNum">   10582 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   10583 </span><span class="lineNoCov">          0 :       return NULL_TREE;</span>
<span class="lineNum">   10584 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   10585 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   10586 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10587 </span><span class="lineNoCov">          0 : /* Parse an objc-selector-arg.</span>
<span class="lineNum">   10588 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10589 </span><span class="lineNoCov">          0 :    objc-selector-arg:</span>
<span class="lineNum">   10590 </span><span class="lineNoCov">          0 :      objc-selector</span>
<span class="lineNum">   10591 </span><span class="lineNoCov">          0 :      objc-keywordname-list</span>
<span class="lineNum">   10592 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10593 </span><span class="lineNoCov">          0 :    objc-keywordname-list:</span>
<span class="lineNum">   10594 </span><span class="lineNoCov">          0 :      objc-keywordname</span>
<span class="lineNum">   10595 </span><span class="lineNoCov">          0 :      objc-keywordname-list objc-keywordname</span>
<span class="lineNum">   10596 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10597 </span><span class="lineNoCov">          0 :    objc-keywordname:</span>
<span class="lineNum">   10598 </span><span class="lineNoCov">          0 :      objc-selector :</span>
<span class="lineNum">   10599 </span><span class="lineNoCov">          0 :      :</span>
<span class="lineNum">   10600 </span><span class="lineNoCov">          0 : */</span>
<a name="10601"><span class="lineNum">   10601 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   10602 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   10603 </span><span class="lineNoCov">          0 : c_parser_objc_selector_arg (c_parser *parser)</span>
<span class="lineNum">   10604 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   10605 </span><span class="lineNoCov">          0 :   tree sel = c_parser_objc_selector (parser);</span>
<span class="lineNum">   10606 </span>            :   tree list = NULL_TREE;
<span class="lineNum">   10607 </span>            :   if (sel &amp;&amp; c_parser_next_token_is_not (parser, CPP_COLON))
<span class="lineNum">   10608 </span>            :     return sel;
<span class="lineNum">   10609 </span>            :   while (true)
<span class="lineNum">   10610 </span>            :     {
<span class="lineNum">   10611 </span>            :       if (!c_parser_require (parser, CPP_COLON, &quot;expected %&lt;:%&gt;&quot;))
<span class="lineNum">   10612 </span>            :         return list;
<span class="lineNum">   10613 </span>            :       list = chainon (list, build_tree_list (sel, NULL_TREE));
<span class="lineNum">   10614 </span>            :       sel = c_parser_objc_selector (parser);
<span class="lineNum">   10615 </span>            :       if (!sel &amp;&amp; c_parser_next_token_is_not (parser, CPP_COLON))
<span class="lineNum">   10616 </span>            :         break;
<span class="lineNum">   10617 </span>            :     }
<span class="lineNum">   10618 </span>            :   return list;
<span class="lineNum">   10619 </span>            : }
<span class="lineNum">   10620 </span>            : 
<span class="lineNum">   10621 </span>            : /* Parse an objc-receiver.
<span class="lineNum">   10622 </span>            : 
<span class="lineNum">   10623 </span>            :    objc-receiver:
<span class="lineNum">   10624 </span>            :      expression
<span class="lineNum">   10625 </span>            :      class-name
<span class="lineNum">   10626 </span>            :      type-name
<span class="lineNum">   10627 </span><span class="lineNoCov">          0 : */</span>
<a name="10628"><span class="lineNum">   10628 </span>            : </a>
<span class="lineNum">   10629 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   10630 </span><span class="lineNoCov">          0 : c_parser_objc_receiver (c_parser *parser)</span>
<span class="lineNum">   10631 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   10632 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   10633 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10634 </span>            :   if (c_parser_peek_token (parser)-&gt;type == CPP_NAME
<span class="lineNum">   10635 </span><span class="lineNoCov">          0 :       &amp;&amp; (c_parser_peek_token (parser)-&gt;id_kind == C_ID_TYPENAME</span>
<span class="lineNum">   10636 </span><span class="lineNoCov">          0 :           || c_parser_peek_token (parser)-&gt;id_kind == C_ID_CLASSNAME))</span>
<span class="lineNum">   10637 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   10638 </span><span class="lineNoCov">          0 :       tree id = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">   10639 </span><span class="lineNoCov">          0 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   10640 </span>            :       return objc_get_class_reference (id);
<span class="lineNum">   10641 </span>            :     }
<span class="lineNum">   10642 </span>            :   struct c_expr ce = c_parser_expression (parser);
<span class="lineNum">   10643 </span>            :   ce = convert_lvalue_to_rvalue (loc, ce, false, false);
<span class="lineNum">   10644 </span>            :   return c_fully_fold (ce.value, false, NULL);
<span class="lineNum">   10645 </span>            : }
<span class="lineNum">   10646 </span>            : 
<span class="lineNum">   10647 </span>            : /* Parse objc-message-args.
<span class="lineNum">   10648 </span>            : 
<span class="lineNum">   10649 </span>            :    objc-message-args:
<span class="lineNum">   10650 </span>            :      objc-selector
<span class="lineNum">   10651 </span>            :      objc-keywordarg-list
<span class="lineNum">   10652 </span>            : 
<span class="lineNum">   10653 </span>            :    objc-keywordarg-list:
<span class="lineNum">   10654 </span><span class="lineNoCov">          0 :      objc-keywordarg</span>
<span class="lineNum">   10655 </span>            :      objc-keywordarg-list objc-keywordarg
<span class="lineNum">   10656 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10657 </span>            :    objc-keywordarg:
<span class="lineNum">   10658 </span><span class="lineNoCov">          0 :      objc-selector : objc-keywordexpr</span>
<span class="lineNum">   10659 </span><span class="lineNoCov">          0 :      : objc-keywordexpr</span>
<span class="lineNum">   10660 </span><span class="lineNoCov">          0 : */</span>
<a name="10661"><span class="lineNum">   10661 </span>            : </a>
<span class="lineNum">   10662 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   10663 </span><span class="lineNoCov">          0 : c_parser_objc_message_args (c_parser *parser)</span>
<span class="lineNum">   10664 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   10665 </span>            :   tree sel = c_parser_objc_selector (parser);
<span class="lineNum">   10666 </span><span class="lineNoCov">          0 :   tree list = NULL_TREE;</span>
<span class="lineNum">   10667 </span><span class="lineNoCov">          0 :   if (sel &amp;&amp; c_parser_next_token_is_not (parser, CPP_COLON))</span>
<span class="lineNum">   10668 </span><span class="lineNoCov">          0 :     return sel;</span>
<span class="lineNum">   10669 </span>            :   while (true)
<span class="lineNum">   10670 </span>            :     {
<span class="lineNum">   10671 </span>            :       tree keywordexpr;
<span class="lineNum">   10672 </span>            :       if (!c_parser_require (parser, CPP_COLON, &quot;expected %&lt;:%&gt;&quot;))
<span class="lineNum">   10673 </span>            :         return error_mark_node;
<span class="lineNum">   10674 </span>            :       keywordexpr = c_parser_objc_keywordexpr (parser);
<span class="lineNum">   10675 </span>            :       list = chainon (list, build_tree_list (sel, keywordexpr));
<span class="lineNum">   10676 </span>            :       sel = c_parser_objc_selector (parser);
<span class="lineNum">   10677 </span>            :       if (!sel &amp;&amp; c_parser_next_token_is_not (parser, CPP_COLON))
<span class="lineNum">   10678 </span>            :         break;
<span class="lineNum">   10679 </span>            :     }
<span class="lineNum">   10680 </span>            :   return list;
<span class="lineNum">   10681 </span>            : }
<span class="lineNum">   10682 </span>            : 
<span class="lineNum">   10683 </span>            : /* Parse an objc-keywordexpr.
<span class="lineNum">   10684 </span>            : 
<span class="lineNum">   10685 </span>            :    objc-keywordexpr:
<span class="lineNum">   10686 </span>            :      nonempty-expr-list
<span class="lineNum">   10687 </span><span class="lineNoCov">          0 : */</span>
<a name="10688"><span class="lineNum">   10688 </span>            : </a>
<span class="lineNum">   10689 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   10690 </span><span class="lineNoCov">          0 : c_parser_objc_keywordexpr (c_parser *parser)</span>
<span class="lineNum">   10691 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   10692 </span>            :   tree ret;
<span class="lineNum">   10693 </span><span class="lineNoCov">          0 :   vec&lt;tree, va_gc&gt; *expr_list = c_parser_expr_list (parser, true, true,</span>
<span class="lineNum">   10694 </span>            :                                                 NULL, NULL, NULL, NULL);
<span class="lineNum">   10695 </span><span class="lineNoCov">          0 :   if (vec_safe_length (expr_list) == 1)</span>
<span class="lineNum">   10696 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   10697 </span><span class="lineNoCov">          0 :       /* Just return the expression, remove a level of</span>
<span class="lineNum">   10698 </span><span class="lineNoCov">          0 :          indirection.  */</span>
<span class="lineNum">   10699 </span><span class="lineNoCov">          0 :       ret = (*expr_list)[0];</span>
<span class="lineNum">   10700 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   10701 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">   10702 </span>            :     {
<span class="lineNum">   10703 </span>            :       /* We have a comma expression, we will collapse later.  */
<span class="lineNum">   10704 </span>            :       ret = build_tree_list_vec (expr_list);
<span class="lineNum">   10705 </span>            :     }
<span class="lineNum">   10706 </span>            :   release_tree_vector (expr_list);
<span class="lineNum">   10707 </span>            :   return ret;
<span class="lineNum">   10708 </span>            : }
<span class="lineNum">   10709 </span>            : 
<span class="lineNum">   10710 </span>            : /* A check, needed in several places, that ObjC interface, implementation or
<a name="10711"><span class="lineNum">   10711 </span>            :    method definitions are not prefixed by incorrect items.  */</a>
<span class="lineNum">   10712 </span>            : static bool
<span class="lineNum">   10713 </span>            : c_parser_objc_diagnose_bad_element_prefix (c_parser *parser, 
<span class="lineNum">   10714 </span><span class="lineNoCov">          0 :                                            struct c_declspecs *specs)</span>
<span class="lineNum">   10715 </span>            : {
<span class="lineNum">   10716 </span><span class="lineNoCov">          0 :   if (!specs-&gt;declspecs_seen_p || specs-&gt;non_sc_seen_p</span>
<span class="lineNum">   10717 </span><span class="lineNoCov">          0 :       || specs-&gt;typespec_kind != ctsk_none)</span>
<span class="lineNum">   10718 </span>            :     {
<span class="lineNum">   10719 </span><span class="lineNoCov">          0 :       c_parser_error (parser, </span>
<span class="lineNum">   10720 </span>            :                       &quot;no type or storage class may be specified here,&quot;);
<span class="lineNum">   10721 </span>            :       c_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   10722 </span>            :       return true;
<span class="lineNum">   10723 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   10724 </span>            :   return false;
<span class="lineNum">   10725 </span>            : }
<span class="lineNum">   10726 </span>            : 
<span class="lineNum">   10727 </span>            : /* Parse an Objective-C @property declaration.  The syntax is:
<span class="lineNum">   10728 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10729 </span>            :    objc-property-declaration:
<span class="lineNum">   10730 </span><span class="lineNoCov">          0 :      '@property' objc-property-attributes[opt] struct-declaration ;</span>
<span class="lineNum">   10731 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10732 </span>            :    objc-property-attributes:
<span class="lineNum">   10733 </span>            :     '(' objc-property-attribute-list ')'
<span class="lineNum">   10734 </span>            : 
<span class="lineNum">   10735 </span>            :    objc-property-attribute-list:
<span class="lineNum">   10736 </span>            :      objc-property-attribute
<span class="lineNum">   10737 </span><span class="lineNoCov">          0 :      objc-property-attribute-list, objc-property-attribute</span>
<span class="lineNum">   10738 </span>            : 
<span class="lineNum">   10739 </span>            :    objc-property-attribute
<span class="lineNum">   10740 </span><span class="lineNoCov">          0 :      'getter' = identifier</span>
<span class="lineNum">   10741 </span><span class="lineNoCov">          0 :      'setter' = identifier</span>
<span class="lineNum">   10742 </span>            :      'readonly'
<span class="lineNum">   10743 </span><span class="lineNoCov">          0 :      'readwrite'</span>
<span class="lineNum">   10744 </span>            :      'assign'
<span class="lineNum">   10745 </span><span class="lineNoCov">          0 :      'retain'</span>
<span class="lineNum">   10746 </span><span class="lineNoCov">          0 :      'copy'</span>
<span class="lineNum">   10747 </span>            :      'nonatomic'
<span class="lineNum">   10748 </span>            : 
<span class="lineNum">   10749 </span>            :   For example:
<span class="lineNum">   10750 </span>            :     @property NSString *name;
<span class="lineNum">   10751 </span>            :     @property (readonly) id object;
<span class="lineNum">   10752 </span>            :     @property (retain, nonatomic, getter=getTheName) id name;
<span class="lineNum">   10753 </span>            :     @property int a, b, c;
<span class="lineNum">   10754 </span>            : 
<span class="lineNum">   10755 </span>            :   PS: This function is identical to cp_parser_objc_at_propery_declaration
<a name="10756"><span class="lineNum">   10756 </span>            :   for C++.  Keep them in sync.  */</a>
<span class="lineNum">   10757 </span>            : static void
<span class="lineNum">   10758 </span>            : c_parser_objc_at_property_declaration (c_parser *parser)
<span class="lineNum">   10759 </span>            : {
<span class="lineNum">   10760 </span>            :   /* The following variables hold the attributes of the properties as
<span class="lineNum">   10761 </span>            :      parsed.  They are 'false' or 'NULL_TREE' if the attribute was not
<span class="lineNum">   10762 </span>            :      seen.  When we see an attribute, we set them to 'true' (if they
<span class="lineNum">   10763 </span>            :      are boolean properties) or to the identifier (if they have an
<span class="lineNum">   10764 </span>            :      argument, ie, for getter and setter).  Note that here we only
<span class="lineNum">   10765 </span>            :      parse the list of attributes, check the syntax and accumulate the
<span class="lineNum">   10766 </span>            :      attributes that we find.  objc_add_property_declaration() will
<span class="lineNum">   10767 </span>            :      then process the information.  */
<span class="lineNum">   10768 </span>            :   bool property_assign = false;
<span class="lineNum">   10769 </span>            :   bool property_copy = false;
<span class="lineNum">   10770 </span>            :   tree property_getter_ident = NULL_TREE;
<span class="lineNum">   10771 </span>            :   bool property_nonatomic = false;
<span class="lineNum">   10772 </span>            :   bool property_readonly = false;
<span class="lineNum">   10773 </span>            :   bool property_readwrite = false;
<span class="lineNum">   10774 </span>            :   bool property_retain = false;
<span class="lineNum">   10775 </span>            :   tree property_setter_ident = NULL_TREE;
<span class="lineNum">   10776 </span>            : 
<span class="lineNum">   10777 </span>            :   /* 'properties' is the list of properties that we read.  Usually a
<span class="lineNum">   10778 </span>            :      single one, but maybe more (eg, in &quot;@property int a, b, c;&quot; there
<span class="lineNum">   10779 </span>            :      are three).  */
<span class="lineNum">   10780 </span>            :   tree properties;
<span class="lineNum">   10781 </span>            :   location_t loc;
<span class="lineNum">   10782 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10783 </span>            :   loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   10784 </span>            :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_AT_PROPERTY));
<span class="lineNum">   10785 </span>            : 
<span class="lineNum">   10786 </span>            :   c_parser_consume_token (parser);  /* Eat '@property'.  */
<span class="lineNum">   10787 </span>            : 
<span class="lineNum">   10788 </span>            :   /* Parse the optional attribute list...  */
<span class="lineNum">   10789 </span>            :   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))
<span class="lineNum">   10790 </span>            :     {
<span class="lineNum">   10791 </span>            :       matching_parens parens;
<span class="lineNum">   10792 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10793 </span><span class="lineNoCov">          0 :       /* Eat the '(' */</span>
<span class="lineNum">   10794 </span><span class="lineNoCov">          0 :       parens.consume_open (parser);</span>
<span class="lineNum">   10795 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10796 </span><span class="lineNoCov">          0 :       /* Property attribute keywords are valid now.  */</span>
<span class="lineNum">   10797 </span><span class="lineNoCov">          0 :       parser-&gt;objc_property_attr_context = true;</span>
<span class="lineNum">   10798 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10799 </span><span class="lineNoCov">          0 :       while (true)</span>
<span class="lineNum">   10800 </span>            :         {
<span class="lineNum">   10801 </span>            :           bool syntax_error = false;
<span class="lineNum">   10802 </span>            :           c_token *token = c_parser_peek_token (parser);
<span class="lineNum">   10803 </span>            :           enum rid keyword;
<span class="lineNum">   10804 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10805 </span><span class="lineNoCov">          0 :           if (token-&gt;type != CPP_KEYWORD)</span>
<span class="lineNum">   10806 </span>            :             {
<span class="lineNum">   10807 </span><span class="lineNoCov">          0 :               if (token-&gt;type == CPP_CLOSE_PAREN)</span>
<span class="lineNum">   10808 </span><span class="lineNoCov">          0 :                 c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">   10809 </span>            :               else
<span class="lineNum">   10810 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">   10811 </span>            :                   c_parser_consume_token (parser);
<span class="lineNum">   10812 </span>            :                   c_parser_error (parser, &quot;unknown property attribute&quot;);
<span class="lineNum">   10813 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">   10814 </span>            :               break;
<span class="lineNum">   10815 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">   10816 </span>            :           keyword = token-&gt;keyword;
<span class="lineNum">   10817 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   10818 </span><span class="lineNoCov">          0 :           switch (keyword)</span>
<span class="lineNum">   10819 </span>            :             {
<span class="lineNum">   10820 </span>            :             case RID_ASSIGN:    property_assign = true;    break;
<span class="lineNum">   10821 </span><span class="lineNoCov">          0 :             case RID_COPY:      property_copy = true;      break;</span>
<span class="lineNum">   10822 </span>            :             case RID_NONATOMIC: property_nonatomic = true; break;
<span class="lineNum">   10823 </span><span class="lineNoCov">          0 :             case RID_READONLY:  property_readonly = true;  break;</span>
<span class="lineNum">   10824 </span>            :             case RID_READWRITE: property_readwrite = true; break;
<span class="lineNum">   10825 </span><span class="lineNoCov">          0 :             case RID_RETAIN:    property_retain = true;    break;</span>
<span class="lineNum">   10826 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10827 </span><span class="lineNoCov">          0 :             case RID_GETTER:</span>
<span class="lineNum">   10828 </span>            :             case RID_SETTER:
<span class="lineNum">   10829 </span><span class="lineNoCov">          0 :               if (c_parser_next_token_is_not (parser, CPP_EQ))</span>
<span class="lineNum">   10830 </span>            :                 {
<span class="lineNum">   10831 </span><span class="lineNoCov">          0 :                   if (keyword == RID_GETTER)</span>
<span class="lineNum">   10832 </span><span class="lineNoCov">          0 :                     c_parser_error (parser,</span>
<span class="lineNum">   10833 </span>            :                                     &quot;missing %&lt;=%&gt; (after %&lt;getter%&gt; attribute)&quot;);
<span class="lineNum">   10834 </span>            :                   else
<span class="lineNum">   10835 </span><span class="lineNoCov">          0 :                     c_parser_error (parser,</span>
<span class="lineNum">   10836 </span><span class="lineNoCov">          0 :                                     &quot;missing %&lt;=%&gt; (after %&lt;setter%&gt; attribute)&quot;);</span>
<span class="lineNum">   10837 </span>            :                   syntax_error = true;
<span class="lineNum">   10838 </span>            :                   break;
<span class="lineNum">   10839 </span>            :                 }
<span class="lineNum">   10840 </span><span class="lineNoCov">          0 :               c_parser_consume_token (parser); /* eat the = */</span>
<span class="lineNum">   10841 </span><span class="lineNoCov">          0 :               if (c_parser_next_token_is_not (parser, CPP_NAME))</span>
<span class="lineNum">   10842 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">   10843 </span>            :                   c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">   10844 </span>            :                   syntax_error = true;
<span class="lineNum">   10845 </span><span class="lineNoCov">          0 :                   break;</span>
<span class="lineNum">   10846 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">   10847 </span><span class="lineNoCov">          0 :               if (keyword == RID_SETTER)</span>
<span class="lineNum">   10848 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">   10849 </span><span class="lineNoCov">          0 :                   if (property_setter_ident != NULL_TREE)</span>
<span class="lineNum">   10850 </span>            :                     c_parser_error (parser, &quot;the %&lt;setter%&gt; attribute may only be specified once&quot;);
<span class="lineNum">   10851 </span><span class="lineNoCov">          0 :                   else</span>
<span class="lineNum">   10852 </span><span class="lineNoCov">          0 :                     property_setter_ident = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">   10853 </span><span class="lineNoCov">          0 :                   c_parser_consume_token (parser);</span>
<span class="lineNum">   10854 </span>            :                   if (c_parser_next_token_is_not (parser, CPP_COLON))
<span class="lineNum">   10855 </span><span class="lineNoCov">          0 :                     c_parser_error (parser, &quot;setter name must terminate with %&lt;:%&gt;&quot;);</span>
<span class="lineNum">   10856 </span><span class="lineNoCov">          0 :                   else</span>
<span class="lineNum">   10857 </span>            :                     c_parser_consume_token (parser);
<span class="lineNum">   10858 </span>            :                 }
<span class="lineNum">   10859 </span><span class="lineNoCov">          0 :               else</span>
<span class="lineNum">   10860 </span>            :                 {
<span class="lineNum">   10861 </span>            :                   if (property_getter_ident != NULL_TREE)
<span class="lineNum">   10862 </span>            :                     c_parser_error (parser, &quot;the %&lt;getter%&gt; attribute may only be specified once&quot;);
<span class="lineNum">   10863 </span>            :                   else
<span class="lineNum">   10864 </span><span class="lineNoCov">          0 :                     property_getter_ident = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">   10865 </span><span class="lineNoCov">          0 :                   c_parser_consume_token (parser);</span>
<span class="lineNum">   10866 </span>            :                 }
<span class="lineNum">   10867 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">   10868 </span><span class="lineNoCov">          0 :             default:</span>
<span class="lineNum">   10869 </span><span class="lineNoCov">          0 :               c_parser_error (parser, &quot;unknown property attribute&quot;);</span>
<span class="lineNum">   10870 </span>            :               syntax_error = true;
<span class="lineNum">   10871 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">   10872 </span>            :             }
<span class="lineNum">   10873 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10874 </span><span class="lineNoCov">          0 :           if (syntax_error)</span>
<span class="lineNum">   10875 </span>            :             break;
<span class="lineNum">   10876 </span><span class="lineNoCov">          0 :           </span>
<span class="lineNum">   10877 </span><span class="lineNoCov">          0 :           if (c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">   10878 </span><span class="lineNoCov">          0 :             c_parser_consume_token (parser);</span>
<span class="lineNum">   10879 </span><span class="lineNoCov">          0 :           else</span>
<span class="lineNum">   10880 </span>            :             break;
<span class="lineNum">   10881 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   10882 </span>            :       parser-&gt;objc_property_attr_context = false;
<span class="lineNum">   10883 </span>            :       parens.skip_until_found_close (parser);
<span class="lineNum">   10884 </span>            :     }
<span class="lineNum">   10885 </span><span class="lineNoCov">          0 :   /* ... and the property declaration(s).  */</span>
<span class="lineNum">   10886 </span><span class="lineNoCov">          0 :   properties = c_parser_struct_declaration (parser);</span>
<span class="lineNum">   10887 </span>            : 
<span class="lineNum">   10888 </span><span class="lineNoCov">          0 :   if (properties == error_mark_node)</span>
<span class="lineNum">   10889 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   10890 </span>            :       c_parser_skip_until_found (parser, CPP_SEMICOLON, NULL);
<span class="lineNum">   10891 </span>            :       parser-&gt;error = false;
<span class="lineNum">   10892 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">   10893 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   10894 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10895 </span><span class="lineNoCov">          0 :   if (properties == NULL_TREE)</span>
<span class="lineNum">   10896 </span>            :     c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">   10897 </span>            :   else
<span class="lineNum">   10898 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   10899 </span>            :       /* Comma-separated properties are chained together in
<span class="lineNum">   10900 </span>            :          reverse order; add them one by one.  */
<span class="lineNum">   10901 </span><span class="lineNoCov">          0 :       properties = nreverse (properties);</span>
<span class="lineNum">   10902 </span><span class="lineNoCov">          0 :       </span>
<span class="lineNum">   10903 </span>            :       for (; properties; properties = TREE_CHAIN (properties))
<span class="lineNum">   10904 </span>            :         objc_add_property_declaration (loc, copy_node (properties),
<span class="lineNum">   10905 </span><span class="lineNoCov">          0 :                                        property_readonly, property_readwrite,</span>
<span class="lineNum">   10906 </span><span class="lineNoCov">          0 :                                        property_assign, property_retain,</span>
<span class="lineNum">   10907 </span><span class="lineNoCov">          0 :                                        property_copy, property_nonatomic,</span>
<span class="lineNum">   10908 </span>            :                                        property_getter_ident, property_setter_ident);
<span class="lineNum">   10909 </span>            :     }
<span class="lineNum">   10910 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10911 </span>            :   c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);
<span class="lineNum">   10912 </span><span class="lineNoCov">          0 :   parser-&gt;error = false;</span>
<span class="lineNum">   10913 </span>            : }
<span class="lineNum">   10914 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10915 </span><span class="lineNoCov">          0 : /* Parse an Objective-C @synthesize declaration.  The syntax is:</span>
<span class="lineNum">   10916 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10917 </span>            :    objc-synthesize-declaration:
<span class="lineNum">   10918 </span>            :      @synthesize objc-synthesize-identifier-list ;
<span class="lineNum">   10919 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10920 </span><span class="lineNoCov">          0 :    objc-synthesize-identifier-list:</span>
<span class="lineNum">   10921 </span>            :      objc-synthesize-identifier
<span class="lineNum">   10922 </span>            :      objc-synthesize-identifier-list, objc-synthesize-identifier
<span class="lineNum">   10923 </span>            : 
<span class="lineNum">   10924 </span>            :    objc-synthesize-identifier
<span class="lineNum">   10925 </span><span class="lineNoCov">          0 :      identifier</span>
<span class="lineNum">   10926 </span>            :      identifier = identifier
<span class="lineNum">   10927 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10928 </span><span class="lineNoCov">          0 :   For example:</span>
<span class="lineNum">   10929 </span>            :     @synthesize MyProperty;
<span class="lineNum">   10930 </span>            :     @synthesize OneProperty, AnotherProperty=MyIvar, YetAnotherProperty;
<span class="lineNum">   10931 </span>            : 
<span class="lineNum">   10932 </span>            :   PS: This function is identical to cp_parser_objc_at_synthesize_declaration
<span class="lineNum">   10933 </span>            :   for C++.  Keep them in sync.
<a name="10934"><span class="lineNum">   10934 </span>            : */</a>
<span class="lineNum">   10935 </span><span class="lineNoCov">          0 : static void</span>
<span class="lineNum">   10936 </span><span class="lineNoCov">          0 : c_parser_objc_at_synthesize_declaration (c_parser *parser)</span>
<span class="lineNum">   10937 </span>            : {
<span class="lineNum">   10938 </span>            :   tree list = NULL_TREE;
<span class="lineNum">   10939 </span>            :   location_t loc;
<span class="lineNum">   10940 </span>            :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_AT_SYNTHESIZE));
<span class="lineNum">   10941 </span>            :   loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   10942 </span>            : 
<span class="lineNum">   10943 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">   10944 </span>            :   while (true)
<span class="lineNum">   10945 </span>            :     {
<span class="lineNum">   10946 </span>            :       tree property, ivar;
<span class="lineNum">   10947 </span>            :       if (c_parser_next_token_is_not (parser, CPP_NAME))
<span class="lineNum">   10948 </span>            :         {
<span class="lineNum">   10949 </span>            :           c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">   10950 </span>            :           c_parser_skip_until_found (parser, CPP_SEMICOLON, NULL);
<span class="lineNum">   10951 </span>            :           /* Once we find the semicolon, we can resume normal parsing.
<span class="lineNum">   10952 </span>            :              We have to reset parser-&gt;error manually because
<span class="lineNum">   10953 </span>            :              c_parser_skip_until_found() won't reset it for us if the
<span class="lineNum">   10954 </span>            :              next token is precisely a semicolon.  */
<span class="lineNum">   10955 </span>            :           parser-&gt;error = false;
<span class="lineNum">   10956 </span>            :           return;
<span class="lineNum">   10957 </span>            :         }
<span class="lineNum">   10958 </span>            :       property = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">   10959 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   10960 </span><span class="lineNoCov">          0 :       if (c_parser_next_token_is (parser, CPP_EQ))</span>
<span class="lineNum">   10961 </span>            :         {
<span class="lineNum">   10962 </span><span class="lineNoCov">          0 :           c_parser_consume_token (parser);</span>
<span class="lineNum">   10963 </span><span class="lineNoCov">          0 :           if (c_parser_next_token_is_not (parser, CPP_NAME))</span>
<span class="lineNum">   10964 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">   10965 </span><span class="lineNoCov">          0 :               c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">   10966 </span>            :               c_parser_skip_until_found (parser, CPP_SEMICOLON, NULL);
<span class="lineNum">   10967 </span><span class="lineNoCov">          0 :               parser-&gt;error = false;</span>
<span class="lineNum">   10968 </span><span class="lineNoCov">          0 :               return;</span>
<span class="lineNum">   10969 </span>            :             }
<span class="lineNum">   10970 </span><span class="lineNoCov">          0 :           ivar = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">   10971 </span><span class="lineNoCov">          0 :           c_parser_consume_token (parser);</span>
<span class="lineNum">   10972 </span>            :         }
<span class="lineNum">   10973 </span><span class="lineNoCov">          0 :       else</span>
<span class="lineNum">   10974 </span><span class="lineNoCov">          0 :         ivar = NULL_TREE;</span>
<span class="lineNum">   10975 </span>            :       list = chainon (list, build_tree_list (ivar, property));
<span class="lineNum">   10976 </span>            :       if (c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">   10977 </span>            :         c_parser_consume_token (parser);
<span class="lineNum">   10978 </span>            :       else
<span class="lineNum">   10979 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   10980 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   10981 </span>            :   c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);
<span class="lineNum">   10982 </span><span class="lineNoCov">          0 :   objc_add_synthesize_declaration (loc, list);</span>
<span class="lineNum">   10983 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   10984 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10985 </span>            : /* Parse an Objective-C @dynamic declaration.  The syntax is:
<span class="lineNum">   10986 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10987 </span><span class="lineNoCov">          0 :    objc-dynamic-declaration:</span>
<span class="lineNum">   10988 </span>            :      @dynamic identifier-list ;
<span class="lineNum">   10989 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10990 </span><span class="lineNoCov">          0 :    For example:</span>
<span class="lineNum">   10991 </span><span class="lineNoCov">          0 :      @dynamic MyProperty;</span>
<span class="lineNum">   10992 </span><span class="lineNoCov">          0 :      @dynamic MyProperty, AnotherProperty;</span>
<span class="lineNum">   10993 </span>            : 
<span class="lineNum">   10994 </span><span class="lineNoCov">          0 :   PS: This function is identical to cp_parser_objc_at_dynamic_declaration</span>
<span class="lineNum">   10995 </span><span class="lineNoCov">          0 :   for C++.  Keep them in sync.</span>
<a name="10996"><span class="lineNum">   10996 </span>            : */</a>
<span class="lineNum">   10997 </span>            : static void
<span class="lineNum">   10998 </span>            : c_parser_objc_at_dynamic_declaration (c_parser *parser)
<span class="lineNum">   10999 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   11000 </span><span class="lineNoCov">          0 :   tree list = NULL_TREE;</span>
<span class="lineNum">   11001 </span><span class="lineNoCov">          0 :   location_t loc;</span>
<span class="lineNum">   11002 </span>            :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_AT_DYNAMIC));
<span class="lineNum">   11003 </span>            :   loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   11004 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   11005 </span><span class="lineNoCov">          0 :   c_parser_consume_token (parser);</span>
<span class="lineNum">   11006 </span><span class="lineNoCov">          0 :   while (true)</span>
<span class="lineNum">   11007 </span>            :     {
<span class="lineNum">   11008 </span>            :       tree property;
<span class="lineNum">   11009 </span>            :       if (c_parser_next_token_is_not (parser, CPP_NAME))
<span class="lineNum">   11010 </span>            :         {
<span class="lineNum">   11011 </span>            :           c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">   11012 </span>            :           c_parser_skip_until_found (parser, CPP_SEMICOLON, NULL);
<span class="lineNum">   11013 </span>            :           parser-&gt;error = false;
<span class="lineNum">   11014 </span>            :           return;
<span class="lineNum">   11015 </span>            :         }
<span class="lineNum">   11016 </span>            :       property = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">   11017 </span>            :       list = chainon (list, build_tree_list (NULL_TREE, property));
<span class="lineNum">   11018 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   11019 </span>            :       if (c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">   11020 </span>            :         c_parser_consume_token (parser);
<span class="lineNum">   11021 </span>            :       else
<span class="lineNum">   11022 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   11023 </span>            :     }
<span class="lineNum">   11024 </span><span class="lineNoCov">          0 :   c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);</span>
<span class="lineNum">   11025 </span><span class="lineNoCov">          0 :   objc_add_dynamic_declaration (loc, list);</span>
<span class="lineNum">   11026 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   11027 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   11028 </span>            : 
<span class="lineNum">   11029 </span><span class="lineNoCov">          0 : /* Parse a pragma GCC ivdep.  */</span>
<a name="11030"><span class="lineNum">   11030 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   11031 </span>            : static bool
<span class="lineNum">   11032 </span><span class="lineNoCov">          0 : c_parse_pragma_ivdep (c_parser *parser)</span>
<span class="lineNum">   11033 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   11034 </span>            :   c_parser_consume_pragma (parser);
<span class="lineNum">   11035 </span><span class="lineNoCov">          0 :   c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   11036 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">   11037 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   11038 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   11039 </span>            : /* Parse a pragma GCC unroll.  */
<a name="11040"><span class="lineNum">   11040 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   11041 </span><span class="lineNoCov">          0 : static unsigned short</span>
<span class="lineNum">   11042 </span><span class="lineNoCov">          0 : c_parser_pragma_unroll (c_parser *parser)</span>
<span class="lineNum">   11043 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   11044 </span><span class="lineNoCov">          0 :   unsigned short unroll;</span>
<span class="lineNum">   11045 </span>            :   c_parser_consume_pragma (parser);
<span class="lineNum">   11046 </span>            :   location_t location = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   11047 </span><span class="lineNoCov">          0 :   tree expr = c_parser_expr_no_commas (parser, NULL).value;</span>
<span class="lineNum">   11048 </span><span class="lineNoCov">          0 :   mark_exp_read (expr);</span>
<span class="lineNum">   11049 </span><span class="lineNoCov">          0 :   expr = c_fully_fold (expr, false, NULL);</span>
<span class="lineNum">   11050 </span>            :   HOST_WIDE_INT lunroll = 0;
<span class="lineNum">   11051 </span>            :   if (!INTEGRAL_TYPE_P (TREE_TYPE (expr))
<span class="lineNum">   11052 </span>            :       || TREE_CODE (expr) != INTEGER_CST
<span class="lineNum">   11053 </span>            :       || (lunroll = tree_to_shwi (expr)) &lt; 0
<span class="lineNum">   11054 </span>            :       || lunroll &gt;= USHRT_MAX)
<span class="lineNum">   11055 </span>            :     {
<span class="lineNum">   11056 </span><span class="lineNoCov">          0 :       error_at (location, &quot;%&lt;#pragma GCC unroll%&gt; requires an&quot;</span>
<span class="lineNum">   11057 </span>            :                 &quot; assignment-expression that evaluates to a non-negative&quot;
<span class="lineNum">   11058 </span><span class="lineNoCov">          0 :                 &quot; integral constant less than %u&quot;, USHRT_MAX);</span>
<span class="lineNum">   11059 </span><span class="lineCov">         23 :       unroll = 0;</span>
<span class="lineNum">   11060 </span><span class="lineCov">         24 :     }</span>
<span class="lineNum">   11061 </span>            :   else
<span class="lineNum">   11062 </span>            :     {
<span class="lineNum">   11063 </span>            :       unroll = (unsigned short)lunroll;
<span class="lineNum">   11064 </span>            :       if (unroll == 0)
<span class="lineNum">   11065 </span>            :         unroll = 1;
<span class="lineNum">   11066 </span><span class="lineCov">         25 :     }</span>
<span class="lineNum">   11067 </span>            : 
<span class="lineNum">   11068 </span><span class="lineCov">         25 :   c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   11069 </span><span class="lineCov">         25 :   return unroll;</span>
<span class="lineNum">   11070 </span><span class="lineCov">         25 : }</span>
<span class="lineNum">   11071 </span><span class="lineCov">         25 : </span>
<span class="lineNum">   11072 </span><span class="lineCov">         25 : /* Handle pragmas.  Some OpenMP pragmas are associated with, and therefore</span>
<span class="lineNum">   11073 </span><span class="lineCov">         25 :    should be considered, statements.  ALLOW_STMT is true if we're within</span>
<span class="lineNum">   11074 </span><span class="lineCov">         25 :    the context of a function and such pragmas are to be allowed.  Returns</span>
<span class="lineNum">   11075 </span><span class="lineCov">         75 :    true if we actually parsed such a pragma.  */</span>
<a name="11076"><span class="lineNum">   11076 </span><span class="lineCov">         24 : </span></a>
<span class="lineNum">   11077 </span><span class="lineCov">         23 : static bool</span>
<span class="lineNum">   11078 </span><span class="lineCov">         47 : c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)</span>
<span class="lineNum">   11079 </span>            : {
<span class="lineNum">   11080 </span><span class="lineCov">          4 :   unsigned int id;</span>
<span class="lineNum">   11081 </span>            :   const char *construct = NULL;
<span class="lineNum">   11082 </span>            : 
<span class="lineNum">   11083 </span><span class="lineCov">          4 :   id = c_parser_peek_token (parser)-&gt;pragma_kind;</span>
<span class="lineNum">   11084 </span>            :   gcc_assert (id != PRAGMA_NONE);
<span class="lineNum">   11085 </span>            : 
<span class="lineNum">   11086 </span>            :   switch (id)
<span class="lineNum">   11087 </span><span class="lineCov">         21 :     {</span>
<span class="lineNum">   11088 </span><span class="lineCov">         21 :     case PRAGMA_OACC_DECLARE:</span>
<span class="lineNum">   11089 </span><span class="lineCov">          2 :       c_parser_oacc_declare (parser);</span>
<span class="lineNum">   11090 </span>            :       return false;
<span class="lineNum">   11091 </span>            : 
<span class="lineNum">   11092 </span><span class="lineCov">         25 :     case PRAGMA_OACC_ENTER_DATA:</span>
<span class="lineNum">   11093 </span><span class="lineCov">         25 :       if (context != pragma_compound)</span>
<span class="lineNum">   11094 </span>            :         {
<span class="lineNum">   11095 </span>            :           construct = &quot;acc enter data&quot;;
<span class="lineNum">   11096 </span>            :         in_compound:
<span class="lineNum">   11097 </span>            :           if (context == pragma_stmt)
<span class="lineNum">   11098 </span>            :             {
<span class="lineNum">   11099 </span>            :               error_at (c_parser_peek_token (parser)-&gt;location,
<span class="lineNum">   11100 </span>            :                         &quot;%&lt;#pragma %s%&gt; may only be used in compound &quot;
<span class="lineNum">   11101 </span>            :                         &quot;statements&quot;, construct);
<span class="lineNum">   11102 </span><span class="lineCov">     597556 :               c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);</span>
<span class="lineNum">   11103 </span>            :               return false;
<span class="lineNum">   11104 </span><span class="lineCov">     597556 :             }</span>
<span class="lineNum">   11105 </span><span class="lineCov">     597556 :           goto bad_stmt;</span>
<span class="lineNum">   11106 </span>            :         }
<span class="lineNum">   11107 </span><span class="lineCov">     597556 :       c_parser_oacc_enter_exit_data (parser, true);</span>
<span class="lineNum">   11108 </span><span class="lineCov">     597556 :       return false;</span>
<span class="lineNum">   11109 </span>            : 
<span class="lineNum">   11110 </span><span class="lineCov">     597556 :     case PRAGMA_OACC_EXIT_DATA:</span>
<span class="lineNum">   11111 </span>            :       if (context != pragma_compound)
<span class="lineNum">   11112 </span><span class="lineCov">         72 :         {</span>
<span class="lineNum">   11113 </span><span class="lineCov">         72 :           construct = &quot;acc exit data&quot;;</span>
<span class="lineNum">   11114 </span><span class="lineCov">         72 :           goto in_compound;</span>
<span class="lineNum">   11115 </span>            :         }
<span class="lineNum">   11116 </span><span class="lineCov">         69 :       c_parser_oacc_enter_exit_data (parser, false);</span>
<span class="lineNum">   11117 </span><span class="lineCov">         69 :       return false;</span>
<span class="lineNum">   11118 </span>            : 
<span class="lineNum">   11119 </span>            :     case PRAGMA_OACC_ROUTINE:
<span class="lineNum">   11120 </span><span class="lineCov">         61 :       if (context != pragma_external)</span>
<span class="lineNum">   11121 </span><span class="lineCov">         61 :         {</span>
<span class="lineNum">   11122 </span>            :           error_at (c_parser_peek_token (parser)-&gt;location,
<span class="lineNum">   11123 </span><span class="lineCov">         58 :                     &quot;%&lt;#pragma acc routine%&gt; must be at file scope&quot;);</span>
<span class="lineNum">   11124 </span>            :           c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);
<span class="lineNum">   11125 </span>            :           return false;
<span class="lineNum">   11126 </span><span class="lineCov">         58 :         }</span>
<span class="lineNum">   11127 </span><span class="lineCov">         58 :       c_parser_oacc_routine (parser, context);</span>
<span class="lineNum">   11128 </span>            :       return false;
<span class="lineNum">   11129 </span>            : 
<span class="lineNum">   11130 </span>            :     case PRAGMA_OACC_UPDATE:
<span class="lineNum">   11131 </span><span class="lineCov">         66 :       if (context != pragma_compound)</span>
<span class="lineNum">   11132 </span><span class="lineCov">         66 :         {</span>
<span class="lineNum">   11133 </span>            :           construct = &quot;acc update&quot;;
<span class="lineNum">   11134 </span><span class="lineCov">         60 :           goto in_compound;</span>
<span class="lineNum">   11135 </span><span class="lineCov">         60 :         }</span>
<span class="lineNum">   11136 </span>            :       c_parser_oacc_update (parser);
<span class="lineNum">   11137 </span>            :       return false;
<span class="lineNum">   11138 </span>            : 
<span class="lineNum">   11139 </span>            :     case PRAGMA_OMP_BARRIER:
<span class="lineNum">   11140 </span><span class="lineCov">         57 :       if (context != pragma_compound)</span>
<span class="lineNum">   11141 </span><span class="lineCov">         57 :         {</span>
<span class="lineNum">   11142 </span>            :           construct = &quot;omp barrier&quot;;
<span class="lineNum">   11143 </span><span class="lineCov">        122 :           goto in_compound;</span>
<span class="lineNum">   11144 </span><span class="lineCov">        122 :         }</span>
<span class="lineNum">   11145 </span>            :       c_parser_omp_barrier (parser);
<span class="lineNum">   11146 </span><span class="lineCov">          5 :       return false;</span>
<span class="lineNum">   11147 </span>            : 
<span class="lineNum">   11148 </span><span class="lineCov">          5 :     case PRAGMA_OMP_FLUSH:</span>
<span class="lineNum">   11149 </span><span class="lineCov">          5 :       if (context != pragma_compound)</span>
<span class="lineNum">   11150 </span>            :         {
<span class="lineNum">   11151 </span><span class="lineCov">        117 :           construct = &quot;omp flush&quot;;</span>
<span class="lineNum">   11152 </span><span class="lineCov">        117 :           goto in_compound;</span>
<span class="lineNum">   11153 </span>            :         }
<span class="lineNum">   11154 </span><span class="lineCov">         66 :       c_parser_omp_flush (parser);</span>
<span class="lineNum">   11155 </span><span class="lineCov">         66 :       return false;</span>
<span class="lineNum">   11156 </span>            : 
<span class="lineNum">   11157 </span>            :     case PRAGMA_OMP_TASKWAIT:
<span class="lineNum">   11158 </span>            :       if (context != pragma_compound)
<span class="lineNum">   11159 </span>            :         {
<span class="lineNum">   11160 </span><span class="lineCov">         58 :           construct = &quot;omp taskwait&quot;;</span>
<span class="lineNum">   11161 </span><span class="lineCov">         58 :           goto in_compound;</span>
<span class="lineNum">   11162 </span>            :         }
<span class="lineNum">   11163 </span><span class="lineCov">        264 :       c_parser_omp_taskwait (parser);</span>
<span class="lineNum">   11164 </span><span class="lineCov">        264 :       return false;</span>
<span class="lineNum">   11165 </span>            : 
<span class="lineNum">   11166 </span>            :     case PRAGMA_OMP_TASKYIELD:
<span class="lineNum">   11167 </span>            :       if (context != pragma_compound)
<span class="lineNum">   11168 </span>            :         {
<span class="lineNum">   11169 </span><span class="lineCov">        253 :           construct = &quot;omp taskyield&quot;;</span>
<span class="lineNum">   11170 </span><span class="lineCov">        253 :           goto in_compound;</span>
<span class="lineNum">   11171 </span>            :         }
<span class="lineNum">   11172 </span><span class="lineCov">         23 :       c_parser_omp_taskyield (parser);</span>
<span class="lineNum">   11173 </span><span class="lineCov">         23 :       return false;</span>
<span class="lineNum">   11174 </span>            : 
<span class="lineNum">   11175 </span>            :     case PRAGMA_OMP_CANCEL:
<span class="lineNum">   11176 </span>            :       if (context != pragma_compound)
<span class="lineNum">   11177 </span>            :         {
<span class="lineNum">   11178 </span><span class="lineCov">         14 :           construct = &quot;omp cancel&quot;;</span>
<span class="lineNum">   11179 </span><span class="lineCov">         14 :           goto in_compound;</span>
<span class="lineNum">   11180 </span>            :         }
<span class="lineNum">   11181 </span><span class="lineCov">         40 :       c_parser_omp_cancel (parser);</span>
<span class="lineNum">   11182 </span><span class="lineCov">         40 :       return false;</span>
<span class="lineNum">   11183 </span>            : 
<span class="lineNum">   11184 </span>            :     case PRAGMA_OMP_CANCELLATION_POINT:
<span class="lineNum">   11185 </span>            :       c_parser_omp_cancellation_point (parser, context);
<span class="lineNum">   11186 </span>            :       return false;
<span class="lineNum">   11187 </span><span class="lineCov">         32 : </span>
<span class="lineNum">   11188 </span><span class="lineCov">         32 :     case PRAGMA_OMP_THREADPRIVATE:</span>
<span class="lineNum">   11189 </span>            :       c_parser_omp_threadprivate (parser);
<span class="lineNum">   11190 </span><span class="lineCov">          9 :       return false;</span>
<span class="lineNum">   11191 </span><span class="lineCov">          9 : </span>
<span class="lineNum">   11192 </span>            :     case PRAGMA_OMP_TARGET:
<span class="lineNum">   11193 </span>            :       return c_parser_omp_target (parser, context, if_p);
<span class="lineNum">   11194 </span>            : 
<span class="lineNum">   11195 </span>            :     case PRAGMA_OMP_END_DECLARE_TARGET:
<span class="lineNum">   11196 </span><span class="lineCov">          1 :       c_parser_omp_end_declare_target (parser);</span>
<span class="lineNum">   11197 </span><span class="lineCov">          1 :       return false;</span>
<span class="lineNum">   11198 </span>            : 
<span class="lineNum">   11199 </span><span class="lineCov">        165 :     case PRAGMA_OMP_SECTION:</span>
<span class="lineNum">   11200 </span><span class="lineCov">        165 :       error_at (c_parser_peek_token (parser)-&gt;location,</span>
<span class="lineNum">   11201 </span>            :                 &quot;%&lt;#pragma omp section%&gt; may only be used in &quot;
<span class="lineNum">   11202 </span>            :                 &quot;%&lt;#pragma omp sections%&gt; construct&quot;);
<span class="lineNum">   11203 </span>            :       c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);
<span class="lineNum">   11204 </span>            :       return false;
<span class="lineNum">   11205 </span><span class="lineCov">        157 : </span>
<span class="lineNum">   11206 </span><span class="lineCov">        157 :     case PRAGMA_OMP_DECLARE:</span>
<span class="lineNum">   11207 </span>            :       c_parser_omp_declare (parser, context);
<span class="lineNum">   11208 </span><span class="lineCov">        145 :       return false;</span>
<span class="lineNum">   11209 </span><span class="lineCov">        145 : </span>
<span class="lineNum">   11210 </span><span class="lineCov">        145 :     case PRAGMA_OMP_ORDERED:</span>
<span class="lineNum">   11211 </span>            :       return c_parser_omp_ordered (parser, context, if_p);
<span class="lineNum">   11212 </span><span class="lineCov">         40 : </span>
<span class="lineNum">   11213 </span><span class="lineCov">         40 :     case PRAGMA_IVDEP:</span>
<span class="lineNum">   11214 </span><span class="lineCov">         40 :       {</span>
<span class="lineNum">   11215 </span>            :         const bool ivdep = c_parse_pragma_ivdep (parser);
<span class="lineNum">   11216 </span><span class="lineCov">       2617 :         unsigned short unroll;</span>
<span class="lineNum">   11217 </span><span class="lineCov">       2617 :         if (c_parser_peek_token (parser)-&gt;pragma_kind == PRAGMA_UNROLL)</span>
<span class="lineNum">   11218 </span>            :           unroll = c_parser_pragma_unroll (parser);
<span class="lineNum">   11219 </span><span class="lineCov">         34 :         else</span>
<span class="lineNum">   11220 </span><span class="lineCov">         34 :           unroll = 0;</span>
<span class="lineNum">   11221 </span><span class="lineCov">         34 :         if (!c_parser_next_token_is_keyword (parser, RID_FOR)</span>
<span class="lineNum">   11222 </span>            :             &amp;&amp; !c_parser_next_token_is_keyword (parser, RID_WHILE)
<span class="lineNum">   11223 </span><span class="lineCov">          3 :             &amp;&amp; !c_parser_next_token_is_keyword (parser, RID_DO))</span>
<span class="lineNum">   11224 </span><span class="lineCov">          3 :           {</span>
<span class="lineNum">   11225 </span>            :             c_parser_error (parser, &quot;for, while or do statement expected&quot;);
<span class="lineNum">   11226 </span>            :             return false;
<span class="lineNum">   11227 </span><span class="lineCov">          3 :           }</span>
<span class="lineNum">   11228 </span><span class="lineCov">          3 :         if (c_parser_next_token_is_keyword (parser, RID_FOR))</span>
<span class="lineNum">   11229 </span>            :           c_parser_for_statement (parser, ivdep, unroll, if_p);
<span class="lineNum">   11230 </span><span class="lineCov">        358 :         else if (c_parser_next_token_is_keyword (parser, RID_WHILE))</span>
<span class="lineNum">   11231 </span><span class="lineCov">        358 :           c_parser_while_statement (parser, ivdep, unroll, if_p);</span>
<span class="lineNum">   11232 </span><span class="lineCov">        358 :         else</span>
<span class="lineNum">   11233 </span>            :           c_parser_do_statement (parser, ivdep, unroll);
<span class="lineNum">   11234 </span><span class="lineCov">        250 :       }</span>
<span class="lineNum">   11235 </span><span class="lineCov">        250 :       return false;</span>
<span class="lineNum">   11236 </span>            : 
<span class="lineNum">   11237 </span><span class="lineCov">         23 :     case PRAGMA_UNROLL:</span>
<span class="lineNum">   11238 </span><span class="lineCov">         23 :       {</span>
<span class="lineNum">   11239 </span><span class="lineCov">         23 :         unsigned short unroll = c_parser_pragma_unroll (parser);</span>
<span class="lineNum">   11240 </span><span class="lineCov">         23 :         bool ivdep;</span>
<span class="lineNum">   11241 </span><span class="lineCov">         23 :         if (c_parser_peek_token (parser)-&gt;pragma_kind == PRAGMA_IVDEP)</span>
<span class="lineNum">   11242 </span><span class="lineCov">          1 :           ivdep = c_parse_pragma_ivdep (parser);</span>
<span class="lineNum">   11243 </span>            :         else
<span class="lineNum">   11244 </span>            :           ivdep = false;
<span class="lineNum">   11245 </span><span class="lineCov">         23 :         if (!c_parser_next_token_is_keyword (parser, RID_FOR)</span>
<span class="lineNum">   11246 </span><span class="lineCov">          5 :             &amp;&amp; !c_parser_next_token_is_keyword (parser, RID_WHILE)</span>
<span class="lineNum">   11247 </span><span class="lineCov">         25 :             &amp;&amp; !c_parser_next_token_is_keyword (parser, RID_DO))</span>
<span class="lineNum">   11248 </span>            :           {
<span class="lineNum">   11249 </span><span class="lineNoCov">          0 :             c_parser_error (parser, &quot;for, while or do statement expected&quot;);</span>
<span class="lineNum">   11250 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">   11251 </span>            :           }
<span class="lineNum">   11252 </span><span class="lineCov">         23 :         if (c_parser_next_token_is_keyword (parser, RID_FOR))</span>
<span class="lineNum">   11253 </span><span class="lineCov">         18 :           c_parser_for_statement (parser, ivdep, unroll, if_p);</span>
<span class="lineNum">   11254 </span><span class="lineCov">          5 :         else if (c_parser_next_token_is_keyword (parser, RID_WHILE))</span>
<span class="lineNum">   11255 </span><span class="lineCov">          3 :           c_parser_while_statement (parser, ivdep, unroll, if_p);</span>
<span class="lineNum">   11256 </span>            :         else
<span class="lineNum">   11257 </span><span class="lineCov">          2 :           c_parser_do_statement (parser, ivdep, unroll);</span>
<span class="lineNum">   11258 </span>            :       }
<span class="lineNum">   11259 </span>            :       return false;
<span class="lineNum">   11260 </span>            : 
<span class="lineNum">   11261 </span><span class="lineCov">         24 :     case PRAGMA_GCC_PCH_PREPROCESS:</span>
<span class="lineNum">   11262 </span><span class="lineCov">         24 :       c_parser_error (parser, &quot;%&lt;#pragma GCC pch_preprocess%&gt; must be first&quot;);</span>
<span class="lineNum">   11263 </span><span class="lineCov">         24 :       c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);</span>
<span class="lineNum">   11264 </span><span class="lineCov">         24 :       return false;</span>
<span class="lineNum">   11265 </span><span class="lineCov">         24 : </span>
<span class="lineNum">   11266 </span><span class="lineCov">          1 :     case PRAGMA_OACC_WAIT:</span>
<span class="lineNum">   11267 </span>            :       if (context != pragma_compound)
<span class="lineNum">   11268 </span>            :         {
<span class="lineNum">   11269 </span><span class="lineCov">         24 :           construct = &quot;acc wait&quot;;</span>
<span class="lineNum">   11270 </span><span class="lineCov">          3 :           goto in_compound;</span>
<span class="lineNum">   11271 </span><span class="lineCov">         27 :         }</span>
<span class="lineNum">   11272 </span>            :         /* FALL THROUGH.  */
<span class="lineNum">   11273 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   11274 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   11275 </span>            :       if (id &lt; PRAGMA_FIRST_EXTERNAL)
<span class="lineNum">   11276 </span><span class="lineCov">         24 :         {</span>
<span class="lineNum">   11277 </span><span class="lineCov">         21 :           if (context != pragma_stmt &amp;&amp; context != pragma_compound)</span>
<span class="lineNum">   11278 </span><span class="lineCov">          3 :             {</span>
<span class="lineNum">   11279 </span><span class="lineNoCov">          0 :             bad_stmt:</span>
<span class="lineNum">   11280 </span>            :               c_parser_error (parser, &quot;expected declaration specifiers&quot;);
<span class="lineNum">   11281 </span><span class="lineCov">          3 :               c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);</span>
<span class="lineNum">   11282 </span>            :               return false;
<span class="lineNum">   11283 </span>            :             }
<span class="lineNum">   11284 </span>            :           c_parser_omp_construct (parser, if_p);
<span class="lineNum">   11285 </span><span class="lineCov">          1 :           return true;</span>
<span class="lineNum">   11286 </span><span class="lineCov">          1 :         }</span>
<span class="lineNum">   11287 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">   11288 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">   11289 </span>            : 
<span class="lineNum">   11290 </span><span class="lineCov">         64 :   c_parser_consume_pragma (parser);</span>
<span class="lineNum">   11291 </span><span class="lineCov">         64 :   c_invoke_pragma_handler (id);</span>
<span class="lineNum">   11292 </span>            : 
<span class="lineNum">   11293 </span>            :   /* Skip to EOL, but suppress any error message.  Those will have been
<span class="lineNum">   11294 </span>            :      generated by the handler routine through calling error, as opposed
<span class="lineNum">   11295 </span>            :      to calling c_parser_error.  */
<span class="lineNum">   11296 </span>            :   parser-&gt;error = true;
<span class="lineNum">   11297 </span>            :   c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   11298 </span><span class="lineCov">     593168 : </span>
<span class="lineNum">   11299 </span><span class="lineCov">     593168 :   return false;</span>
<span class="lineNum">   11300 </span>            : }
<span class="lineNum">   11301 </span><span class="lineCov">       7869 : </span>
<span class="lineNum">   11302 </span>            : /* The interface the pragma parsers have to the lexer.  */
<a name="11303"><span class="lineNum">   11303 </span><span class="lineCov">          1 : </span></a>
<span class="lineNum">   11304 </span><span class="lineCov">          4 : enum cpp_ttype</span>
<span class="lineNum">   11305 </span><span class="lineCov">          4 : pragma_lex (tree *value, location_t *loc)</span>
<span class="lineNum">   11306 </span><span class="lineCov">          4 : {</span>
<span class="lineNum">   11307 </span>            :   c_token *tok = c_parser_peek_token (the_parser);
<span class="lineNum">   11308 </span><span class="lineCov">       7868 :   enum cpp_ttype ret = tok-&gt;type;</span>
<span class="lineNum">   11309 </span><span class="lineCov">       7868 : </span>
<span class="lineNum">   11310 </span>            :   *value = tok-&gt;value;
<span class="lineNum">   11311 </span><span class="lineCov">     585299 :   if (loc)</span>
<span class="lineNum">   11312 </span>            :     *loc = tok-&gt;location;
<span class="lineNum">   11313 </span>            : 
<span class="lineNum">   11314 </span><span class="lineCov">     585299 :   if (ret == CPP_PRAGMA_EOL || ret == CPP_EOF)</span>
<span class="lineNum">   11315 </span><span class="lineCov">     585299 :     ret = CPP_EOF;</span>
<span class="lineNum">   11316 </span>            :   else
<span class="lineNum">   11317 </span>            :     {
<span class="lineNum">   11318 </span>            :       if (ret == CPP_KEYWORD)
<span class="lineNum">   11319 </span>            :         ret = CPP_NAME;
<span class="lineNum">   11320 </span><span class="lineCov">     585299 :       c_parser_consume_token (the_parser);</span>
<span class="lineNum">   11321 </span><span class="lineCov">     585299 :     }</span>
<span class="lineNum">   11322 </span>            : 
<span class="lineNum">   11323 </span><span class="lineCov">     585299 :   return ret;</span>
<span class="lineNum">   11324 </span>            : }
<a name="11325"><span class="lineNum">   11325 </span>            : </a>
<span class="lineNum">   11326 </span>            : static void
<span class="lineNum">   11327 </span>            : c_parser_pragma_pch_preprocess (c_parser *parser)
<span class="lineNum">   11328 </span>            : {
<span class="lineNum">   11329 </span><span class="lineCov">    1173381 :   tree name = NULL;</span>
<span class="lineNum">   11330 </span>            : 
<span class="lineNum">   11331 </span><span class="lineCov">    1173381 :   c_parser_consume_pragma (parser);</span>
<span class="lineNum">   11332 </span><span class="lineCov">    1173381 :   if (c_parser_next_token_is (parser, CPP_STRING))</span>
<span class="lineNum">   11333 </span>            :     {
<span class="lineNum">   11334 </span><span class="lineCov">    1173381 :       name = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">   11335 </span><span class="lineCov">    1173381 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   11336 </span><span class="lineCov">        441 :     }</span>
<span class="lineNum">   11337 </span>            :   else
<span class="lineNum">   11338 </span><span class="lineCov">    1173381 :     c_parser_error (parser, &quot;expected string literal&quot;);</span>
<span class="lineNum">   11339 </span>            :   c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   11340 </span>            : 
<span class="lineNum">   11341 </span>            :   if (name)
<span class="lineNum">   11342 </span><span class="lineCov">     588380 :     c_common_pch_pragma (parse_in, TREE_STRING_POINTER (name));</span>
<span class="lineNum">   11343 </span><span class="lineCov">        328 : }</span>
<span class="lineNum">   11344 </span><span class="lineCov">     588380 : </span>
<span class="lineNum">   11345 </span>            : /* OpenACC and OpenMP parsing routines.  */
<span class="lineNum">   11346 </span>            : 
<span class="lineNum">   11347 </span><span class="lineCov">    1173381 : /* Returns name of the next clause.</span>
<span class="lineNum">   11348 </span>            :    If the clause is not recognized PRAGMA_OMP_CLAUSE_NONE is returned and
<span class="lineNum">   11349 </span>            :    the token is not consumed.  Otherwise appropriate pragma_omp_clause is
<span class="lineNum">   11350 </span>            :    returned and the token is consumed.  */
<a name="11351"><span class="lineNum">   11351 </span><span class="lineCov">          6 : </span></a>
<span class="lineNum">   11352 </span>            : static pragma_omp_clause
<span class="lineNum">   11353 </span><span class="lineCov">          6 : c_parser_omp_clause_name (c_parser *parser)</span>
<span class="lineNum">   11354 </span>            : {
<span class="lineNum">   11355 </span><span class="lineCov">          6 :   pragma_omp_clause result = PRAGMA_OMP_CLAUSE_NONE;</span>
<span class="lineNum">   11356 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   11357 </span>            :   if (c_parser_next_token_is_keyword (parser, RID_AUTO))
<span class="lineNum">   11358 </span><span class="lineCov">          6 :     result = PRAGMA_OACC_CLAUSE_AUTO;</span>
<span class="lineNum">   11359 </span><span class="lineCov">          6 :   else if (c_parser_next_token_is_keyword (parser, RID_IF))</span>
<span class="lineNum">   11360 </span>            :     result = PRAGMA_OMP_CLAUSE_IF;
<span class="lineNum">   11361 </span>            :   else if (c_parser_next_token_is_keyword (parser, RID_DEFAULT))
<span class="lineNum">   11362 </span><span class="lineNoCov">          0 :     result = PRAGMA_OMP_CLAUSE_DEFAULT;</span>
<span class="lineNum">   11363 </span><span class="lineCov">          6 :   else if (c_parser_next_token_is_keyword (parser, RID_FOR))</span>
<span class="lineNum">   11364 </span>            :     result = PRAGMA_OMP_CLAUSE_FOR;
<span class="lineNum">   11365 </span><span class="lineCov">          6 :   else if (c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">   11366 </span><span class="lineCov">          6 :     {</span>
<span class="lineNum">   11367 </span><span class="lineCov">          6 :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">   11368 </span>            : 
<span class="lineNum">   11369 </span>            :       switch (p[0])
<span class="lineNum">   11370 </span>            :         {
<span class="lineNum">   11371 </span>            :         case 'a':
<span class="lineNum">   11372 </span>            :           if (!strcmp (&quot;aligned&quot;, p))
<span class="lineNum">   11373 </span>            :             result = PRAGMA_OMP_CLAUSE_ALIGNED;
<span class="lineNum">   11374 </span>            :           else if (!strcmp (&quot;async&quot;, p))
<span class="lineNum">   11375 </span>            :             result = PRAGMA_OACC_CLAUSE_ASYNC;
<span class="lineNum">   11376 </span>            :           break;
<span class="lineNum">   11377 </span><span class="lineCov">      13057 :         case 'c':</span>
<span class="lineNum">   11378 </span>            :           if (!strcmp (&quot;collapse&quot;, p))
<span class="lineNum">   11379 </span><span class="lineCov">      13057 :             result = PRAGMA_OMP_CLAUSE_COLLAPSE;</span>
<span class="lineNum">   11380 </span>            :           else if (!strcmp (&quot;copy&quot;, p))
<span class="lineNum">   11381 </span><span class="lineCov">      13057 :             result = PRAGMA_OACC_CLAUSE_COPY;</span>
<span class="lineNum">   11382 </span>            :           else if (!strcmp (&quot;copyin&quot;, p))
<span class="lineNum">   11383 </span><span class="lineCov">      12954 :             result = PRAGMA_OMP_CLAUSE_COPYIN;</span>
<span class="lineNum">   11384 </span>            :           else if (!strcmp (&quot;copyout&quot;, p))
<span class="lineNum">   11385 </span><span class="lineCov">      12657 :             result = PRAGMA_OACC_CLAUSE_COPYOUT;</span>
<span class="lineNum">   11386 </span>            :           else if (!strcmp (&quot;copyprivate&quot;, p))
<span class="lineNum">   11387 </span><span class="lineCov">      12502 :             result = PRAGMA_OMP_CLAUSE_COPYPRIVATE;</span>
<span class="lineNum">   11388 </span>            :           else if (!strcmp (&quot;create&quot;, p))
<span class="lineNum">   11389 </span><span class="lineCov">      12429 :             result = PRAGMA_OACC_CLAUSE_CREATE;</span>
<span class="lineNum">   11390 </span>            :           break;
<span class="lineNum">   11391 </span><span class="lineCov">      12385 :         case 'd':</span>
<span class="lineNum">   11392 </span>            :           if (!strcmp (&quot;defaultmap&quot;, p))
<span class="lineNum">   11393 </span><span class="lineCov">      12385 :             result = PRAGMA_OMP_CLAUSE_DEFAULTMAP;</span>
<span class="lineNum">   11394 </span>            :           else if (!strcmp (&quot;delete&quot;, p))
<span class="lineNum">   11395 </span><span class="lineCov">        250 :             result = PRAGMA_OACC_CLAUSE_DELETE;</span>
<span class="lineNum">   11396 </span><span class="lineCov">        250 :           else if (!strcmp (&quot;depend&quot;, p))</span>
<span class="lineNum">   11397 </span>            :             result = PRAGMA_OMP_CLAUSE_DEPEND;
<span class="lineNum">   11398 </span><span class="lineCov">        166 :           else if (!strcmp (&quot;device&quot;, p))</span>
<span class="lineNum">   11399 </span><span class="lineCov">        165 :             result = PRAGMA_OMP_CLAUSE_DEVICE;</span>
<span class="lineNum">   11400 </span>            :           else if (!strcmp (&quot;deviceptr&quot;, p))
<span class="lineNum">   11401 </span><span class="lineCov">       2046 :             result = PRAGMA_OACC_CLAUSE_DEVICEPTR;</span>
<span class="lineNum">   11402 </span><span class="lineCov">       2046 :           else if (!strcmp (&quot;device_resident&quot;, p))</span>
<span class="lineNum">   11403 </span>            :             result = PRAGMA_OACC_CLAUSE_DEVICE_RESIDENT;
<span class="lineNum">   11404 </span><span class="lineCov">       1013 :           else if (!strcmp (&quot;dist_schedule&quot;, p))</span>
<span class="lineNum">   11405 </span>            :             result = PRAGMA_OMP_CLAUSE_DIST_SCHEDULE;
<span class="lineNum">   11406 </span><span class="lineCov">        449 :           break;</span>
<span class="lineNum">   11407 </span>            :         case 'f':
<span class="lineNum">   11408 </span><span class="lineCov">        227 :           if (!strcmp (&quot;final&quot;, p))</span>
<span class="lineNum">   11409 </span>            :             result = PRAGMA_OMP_CLAUSE_FINAL;
<span class="lineNum">   11410 </span><span class="lineCov">         74 :           else if (!strcmp (&quot;finalize&quot;, p))</span>
<span class="lineNum">   11411 </span>            :             result = PRAGMA_OACC_CLAUSE_FINALIZE;
<span class="lineNum">   11412 </span><span class="lineCov">         55 :           else if (!strcmp (&quot;firstprivate&quot;, p))</span>
<span class="lineNum">   11413 </span><span class="lineCov">         55 :             result = PRAGMA_OMP_CLAUSE_FIRSTPRIVATE;</span>
<span class="lineNum">   11414 </span>            :           else if (!strcmp (&quot;from&quot;, p))
<span class="lineNum">   11415 </span><span class="lineCov">       1182 :             result = PRAGMA_OMP_CLAUSE_FROM;</span>
<span class="lineNum">   11416 </span><span class="lineCov">       1182 :           break;</span>
<span class="lineNum">   11417 </span>            :         case 'g':
<span class="lineNum">   11418 </span><span class="lineCov">       1168 :           if (!strcmp (&quot;gang&quot;, p))</span>
<span class="lineNum">   11419 </span>            :             result = PRAGMA_OACC_CLAUSE_GANG;
<span class="lineNum">   11420 </span><span class="lineCov">       1140 :           else if (!strcmp (&quot;grainsize&quot;, p))</span>
<span class="lineNum">   11421 </span>            :             result = PRAGMA_OMP_CLAUSE_GRAINSIZE;
<span class="lineNum">   11422 </span><span class="lineCov">        726 :           break;</span>
<span class="lineNum">   11423 </span>            :         case 'h':
<span class="lineNum">   11424 </span><span class="lineCov">        642 :           if (!strcmp (&quot;hint&quot;, p))</span>
<span class="lineNum">   11425 </span>            :             result = PRAGMA_OMP_CLAUSE_HINT;
<span class="lineNum">   11426 </span><span class="lineCov">        594 :           else if (!strcmp (&quot;host&quot;, p))</span>
<span class="lineNum">   11427 </span>            :             result = PRAGMA_OACC_CLAUSE_HOST;
<span class="lineNum">   11428 </span><span class="lineCov">        587 :           break;</span>
<span class="lineNum">   11429 </span><span class="lineCov">        586 :         case 'i':</span>
<span class="lineNum">   11430 </span>            :           if (!strcmp (&quot;if_present&quot;, p))
<span class="lineNum">   11431 </span><span class="lineCov">       1146 :             result = PRAGMA_OACC_CLAUSE_IF_PRESENT;</span>
<span class="lineNum">   11432 </span><span class="lineCov">       1146 :           else if (!strcmp (&quot;inbranch&quot;, p))</span>
<span class="lineNum">   11433 </span>            :             result = PRAGMA_OMP_CLAUSE_INBRANCH;
<span class="lineNum">   11434 </span><span class="lineCov">       1141 :           else if (!strcmp (&quot;independent&quot;, p))</span>
<span class="lineNum">   11435 </span>            :             result = PRAGMA_OACC_CLAUSE_INDEPENDENT;
<span class="lineNum">   11436 </span><span class="lineCov">       1139 :           else if (!strcmp (&quot;is_device_ptr&quot;, p))</span>
<span class="lineNum">   11437 </span>            :             result = PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR;
<span class="lineNum">   11438 </span><span class="lineCov">        912 :           break;</span>
<span class="lineNum">   11439 </span><span class="lineCov">        912 :         case 'l':</span>
<span class="lineNum">   11440 </span>            :           if (!strcmp (&quot;lastprivate&quot;, p))
<span class="lineNum">   11441 </span><span class="lineCov">        410 :             result = PRAGMA_OMP_CLAUSE_LASTPRIVATE;</span>
<span class="lineNum">   11442 </span><span class="lineCov">        410 :           else if (!strcmp (&quot;linear&quot;, p))</span>
<span class="lineNum">   11443 </span>            :             result = PRAGMA_OMP_CLAUSE_LINEAR;
<span class="lineNum">   11444 </span><span class="lineCov">          3 :           else if (!strcmp (&quot;link&quot;, p))</span>
<span class="lineNum">   11445 </span><span class="lineCov">          3 :             result = PRAGMA_OMP_CLAUSE_LINK;</span>
<span class="lineNum">   11446 </span>            :           break;
<span class="lineNum">   11447 </span><span class="lineCov">         32 :         case 'm':</span>
<span class="lineNum">   11448 </span><span class="lineCov">         32 :           if (!strcmp (&quot;map&quot;, p))</span>
<span class="lineNum">   11449 </span>            :             result = PRAGMA_OMP_CLAUSE_MAP;
<span class="lineNum">   11450 </span><span class="lineCov">         32 :           else if (!strcmp (&quot;mergeable&quot;, p))</span>
<span class="lineNum">   11451 </span><span class="lineCov">         32 :             result = PRAGMA_OMP_CLAUSE_MERGEABLE;</span>
<span class="lineNum">   11452 </span>            :           break;
<span class="lineNum">   11453 </span><span class="lineCov">         56 :         case 'n':</span>
<span class="lineNum">   11454 </span><span class="lineCov">         56 :           if (!strcmp (&quot;nogroup&quot;, p))</span>
<span class="lineNum">   11455 </span>            :             result = PRAGMA_OMP_CLAUSE_NOGROUP;
<span class="lineNum">   11456 </span><span class="lineCov">         44 :           else if (!strcmp (&quot;notinbranch&quot;, p))</span>
<span class="lineNum">   11457 </span>            :             result = PRAGMA_OMP_CLAUSE_NOTINBRANCH;
<span class="lineNum">   11458 </span><span class="lineCov">         39 :           else if (!strcmp (&quot;nowait&quot;, p))</span>
<span class="lineNum">   11459 </span>            :             result = PRAGMA_OMP_CLAUSE_NOWAIT;
<span class="lineNum">   11460 </span><span class="lineCov">         14 :           else if (!strcmp (&quot;num_gangs&quot;, p))</span>
<span class="lineNum">   11461 </span><span class="lineCov">         14 :             result = PRAGMA_OACC_CLAUSE_NUM_GANGS;</span>
<span class="lineNum">   11462 </span>            :           else if (!strcmp (&quot;num_tasks&quot;, p))
<span class="lineNum">   11463 </span><span class="lineCov">        411 :             result = PRAGMA_OMP_CLAUSE_NUM_TASKS;</span>
<span class="lineNum">   11464 </span><span class="lineCov">        411 :           else if (!strcmp (&quot;num_teams&quot;, p))</span>
<span class="lineNum">   11465 </span>            :             result = PRAGMA_OMP_CLAUSE_NUM_TEAMS;
<span class="lineNum">   11466 </span><span class="lineCov">        265 :           else if (!strcmp (&quot;num_threads&quot;, p))</span>
<span class="lineNum">   11467 </span>            :             result = PRAGMA_OMP_CLAUSE_NUM_THREADS;
<span class="lineNum">   11468 </span><span class="lineCov">         21 :           else if (!strcmp (&quot;num_workers&quot;, p))</span>
<span class="lineNum">   11469 </span><span class="lineCov">         21 :             result = PRAGMA_OACC_CLAUSE_NUM_WORKERS;</span>
<span class="lineNum">   11470 </span>            :           break;
<span class="lineNum">   11471 </span><span class="lineCov">        612 :         case 'o':</span>
<span class="lineNum">   11472 </span><span class="lineCov">        612 :           if (!strcmp (&quot;ordered&quot;, p))</span>
<span class="lineNum">   11473 </span>            :             result = PRAGMA_OMP_CLAUSE_ORDERED;
<span class="lineNum">   11474 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">   11475 </span><span class="lineCov">          1 :         case 'p':</span>
<span class="lineNum">   11476 </span>            :           if (!strcmp (&quot;parallel&quot;, p))
<span class="lineNum">   11477 </span><span class="lineCov">       1047 :             result = PRAGMA_OMP_CLAUSE_PARALLEL;</span>
<span class="lineNum">   11478 </span><span class="lineCov">       1047 :           else if (!strcmp (&quot;present&quot;, p))</span>
<span class="lineNum">   11479 </span>            :             result = PRAGMA_OACC_CLAUSE_PRESENT;
<span class="lineNum">   11480 </span><span class="lineCov">       1043 :           /* As of OpenACC 2.5, these are now aliases of the non-present_or</span>
<span class="lineNum">   11481 </span>            :              clauses.  */
<span class="lineNum">   11482 </span><span class="lineCov">        957 :           else if (!strcmp (&quot;present_or_copy&quot;, p)</span>
<span class="lineNum">   11483 </span>            :                    || !strcmp (&quot;pcopy&quot;, p))
<span class="lineNum">   11484 </span><span class="lineCov">        774 :             result = PRAGMA_OACC_CLAUSE_COPY;</span>
<span class="lineNum">   11485 </span>            :           else if (!strcmp (&quot;present_or_copyin&quot;, p)
<span class="lineNum">   11486 </span><span class="lineCov">        491 :                    || !strcmp (&quot;pcopyin&quot;, p))</span>
<span class="lineNum">   11487 </span>            :             result = PRAGMA_OACC_CLAUSE_COPYIN;
<span class="lineNum">   11488 </span><span class="lineCov">        488 :           else if (!strcmp (&quot;present_or_copyout&quot;, p)</span>
<span class="lineNum">   11489 </span>            :                    || !strcmp (&quot;pcopyout&quot;, p))
<span class="lineNum">   11490 </span><span class="lineCov">        422 :             result = PRAGMA_OACC_CLAUSE_COPYOUT;</span>
<span class="lineNum">   11491 </span>            :           else if (!strcmp (&quot;present_or_create&quot;, p)
<span class="lineNum">   11492 </span><span class="lineCov">        195 :                    || !strcmp (&quot;pcreate&quot;, p))</span>
<span class="lineNum">   11493 </span><span class="lineCov">        195 :             result = PRAGMA_OACC_CLAUSE_CREATE;</span>
<span class="lineNum">   11494 </span>            :           else if (!strcmp (&quot;priority&quot;, p))
<span class="lineNum">   11495 </span><span class="lineCov">        118 :             result = PRAGMA_OMP_CLAUSE_PRIORITY;</span>
<span class="lineNum">   11496 </span><span class="lineCov">        118 :           else if (!strcmp (&quot;private&quot;, p))</span>
<span class="lineNum">   11497 </span><span class="lineCov">        117 :             result = PRAGMA_OMP_CLAUSE_PRIVATE;</span>
<span class="lineNum">   11498 </span>            :           else if (!strcmp (&quot;proc_bind&quot;, p))
<span class="lineNum">   11499 </span><span class="lineCov">        588 :             result = PRAGMA_OMP_CLAUSE_PROC_BIND;</span>
<span class="lineNum">   11500 </span><span class="lineCov">        588 :           break;</span>
<span class="lineNum">   11501 </span>            :         case 'r':
<span class="lineNum">   11502 </span><span class="lineCov">        516 :           if (!strcmp (&quot;reduction&quot;, p))</span>
<span class="lineNum">   11503 </span>            :             result = PRAGMA_OMP_CLAUSE_REDUCTION;
<span class="lineNum">   11504 </span>            :           break;
<span class="lineNum">   11505 </span>            :         case 's':
<span class="lineNum">   11506 </span><span class="lineCov">        420 :           if (!strcmp (&quot;safelen&quot;, p))</span>
<span class="lineNum">   11507 </span><span class="lineCov">        411 :             result = PRAGMA_OMP_CLAUSE_SAFELEN;</span>
<span class="lineNum">   11508 </span>            :           else if (!strcmp (&quot;schedule&quot;, p))
<span class="lineNum">   11509 </span><span class="lineCov">        403 :             result = PRAGMA_OMP_CLAUSE_SCHEDULE;</span>
<span class="lineNum">   11510 </span><span class="lineCov">        393 :           else if (!strcmp (&quot;sections&quot;, p))</span>
<span class="lineNum">   11511 </span>            :             result = PRAGMA_OMP_CLAUSE_SECTIONS;
<span class="lineNum">   11512 </span><span class="lineCov">        385 :           else if (!strcmp (&quot;self&quot;, p)) /* &quot;self&quot; is a synonym for &quot;host&quot;.  */</span>
<span class="lineNum">   11513 </span><span class="lineCov">        336 :             result = PRAGMA_OACC_CLAUSE_HOST;</span>
<span class="lineNum">   11514 </span>            :           else if (!strcmp (&quot;seq&quot;, p))
<span class="lineNum">   11515 </span><span class="lineCov">        324 :             result = PRAGMA_OACC_CLAUSE_SEQ;</span>
<span class="lineNum">   11516 </span><span class="lineCov">        316 :           else if (!strcmp (&quot;shared&quot;, p))</span>
<span class="lineNum">   11517 </span>            :             result = PRAGMA_OMP_CLAUSE_SHARED;
<span class="lineNum">   11518 </span><span class="lineCov">        312 :           else if (!strcmp (&quot;simd&quot;, p))</span>
<span class="lineNum">   11519 </span>            :             result = PRAGMA_OMP_CLAUSE_SIMD;
<span class="lineNum">   11520 </span><span class="lineCov">        304 :           else if (!strcmp (&quot;simdlen&quot;, p))</span>
<span class="lineNum">   11521 </span>            :             result = PRAGMA_OMP_CLAUSE_SIMDLEN;
<span class="lineNum">   11522 </span><span class="lineCov">         52 :           break;</span>
<span class="lineNum">   11523 </span><span class="lineCov">         52 :         case 't':</span>
<span class="lineNum">   11524 </span>            :           if (!strcmp (&quot;taskgroup&quot;, p))
<span class="lineNum">   11525 </span><span class="lineCov">        804 :             result = PRAGMA_OMP_CLAUSE_TASKGROUP;</span>
<span class="lineNum">   11526 </span><span class="lineCov">        804 :           else if (!strcmp (&quot;thread_limit&quot;, p))</span>
<span class="lineNum">   11527 </span><span class="lineCov">        804 :             result = PRAGMA_OMP_CLAUSE_THREAD_LIMIT;</span>
<span class="lineNum">   11528 </span>            :           else if (!strcmp (&quot;threads&quot;, p))
<span class="lineNum">   11529 </span><span class="lineCov">       2268 :             result = PRAGMA_OMP_CLAUSE_THREADS;</span>
<span class="lineNum">   11530 </span><span class="lineCov">       2268 :           else if (!strcmp (&quot;tile&quot;, p))</span>
<span class="lineNum">   11531 </span>            :             result = PRAGMA_OACC_CLAUSE_TILE;
<span class="lineNum">   11532 </span><span class="lineCov">       2183 :           else if (!strcmp (&quot;to&quot;, p))</span>
<span class="lineNum">   11533 </span>            :             result = PRAGMA_OMP_CLAUSE_TO;
<span class="lineNum">   11534 </span><span class="lineCov">        619 :           break;</span>
<span class="lineNum">   11535 </span>            :         case 'u':
<span class="lineNum">   11536 </span><span class="lineCov">        551 :           if (!strcmp (&quot;uniform&quot;, p))</span>
<span class="lineNum">   11537 </span>            :             result = PRAGMA_OMP_CLAUSE_UNIFORM;
<span class="lineNum">   11538 </span><span class="lineCov">        541 :           else if (!strcmp (&quot;untied&quot;, p))</span>
<span class="lineNum">   11539 </span>            :             result = PRAGMA_OMP_CLAUSE_UNTIED;
<span class="lineNum">   11540 </span><span class="lineCov">        441 :           else if (!strcmp (&quot;use_device&quot;, p))</span>
<span class="lineNum">   11541 </span>            :             result = PRAGMA_OACC_CLAUSE_USE_DEVICE;
<span class="lineNum">   11542 </span><span class="lineCov">        111 :           else if (!strcmp (&quot;use_device_ptr&quot;, p))</span>
<span class="lineNum">   11543 </span>            :             result = PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR;
<span class="lineNum">   11544 </span><span class="lineCov">         71 :           break;</span>
<span class="lineNum">   11545 </span><span class="lineCov">         71 :         case 'v':</span>
<span class="lineNum">   11546 </span>            :           if (!strcmp (&quot;vector&quot;, p))
<span class="lineNum">   11547 </span><span class="lineCov">        474 :             result = PRAGMA_OACC_CLAUSE_VECTOR;</span>
<span class="lineNum">   11548 </span><span class="lineCov">        474 :           else if (!strcmp (&quot;vector_length&quot;, p))</span>
<span class="lineNum">   11549 </span>            :             result = PRAGMA_OACC_CLAUSE_VECTOR_LENGTH;
<span class="lineNum">   11550 </span><span class="lineCov">        398 :           break;</span>
<span class="lineNum">   11551 </span>            :         case 'w':
<span class="lineNum">   11552 </span><span class="lineCov">        329 :           if (!strcmp (&quot;wait&quot;, p))</span>
<span class="lineNum">   11553 </span>            :             result = PRAGMA_OACC_CLAUSE_WAIT;
<span class="lineNum">   11554 </span><span class="lineCov">        296 :           else if (!strcmp (&quot;worker&quot;, p))</span>
<span class="lineNum">   11555 </span>            :             result = PRAGMA_OACC_CLAUSE_WORKER;
<span class="lineNum">   11556 </span><span class="lineCov">        179 :           break;</span>
<span class="lineNum">   11557 </span><span class="lineCov">        178 :         }</span>
<span class="lineNum">   11558 </span>            :     }
<span class="lineNum">   11559 </span><span class="lineCov">         70 : </span>
<span class="lineNum">   11560 </span><span class="lineCov">         70 :   if (result != PRAGMA_OMP_CLAUSE_NONE)</span>
<span class="lineNum">   11561 </span>            :     c_parser_consume_token (parser);
<span class="lineNum">   11562 </span><span class="lineCov">         17 : </span>
<span class="lineNum">   11563 </span>            :   return result;
<span class="lineNum">   11564 </span><span class="lineCov">         14 : }</span>
<span class="lineNum">   11565 </span>            : 
<span class="lineNum">   11566 </span><span class="lineCov">          3 : /* Validate that a clause of the given type does not already exist.  */</span>
<a name="11567"><span class="lineNum">   11567 </span><span class="lineCov">          3 : </span></a>
<span class="lineNum">   11568 </span>            : static void
<span class="lineNum">   11569 </span><span class="lineCov">        531 : check_no_duplicate_clause (tree clauses, enum omp_clause_code code,</span>
<span class="lineNum">   11570 </span><span class="lineCov">        531 :                            const char *name)</span>
<span class="lineNum">   11571 </span>            : {
<span class="lineNum">   11572 </span><span class="lineCov">        206 :   tree c;</span>
<span class="lineNum">   11573 </span><span class="lineCov">        206 : </span>
<span class="lineNum">   11574 </span>            :   for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))
<span class="lineNum">   11575 </span><span class="lineCov">        337 :     if (OMP_CLAUSE_CODE (c) == code)</span>
<span class="lineNum">   11576 </span><span class="lineCov">        337 :       {</span>
<span class="lineNum">   11577 </span>            :         location_t loc = OMP_CLAUSE_LOCATION (c);
<span class="lineNum">   11578 </span><span class="lineCov">        277 :         error_at (loc, &quot;too many %qs clauses&quot;, name);</span>
<span class="lineNum">   11579 </span><span class="lineCov">        277 :         break;</span>
<span class="lineNum">   11580 </span>            :       }
<span class="lineNum">   11581 </span>            : }
<span class="lineNum">   11582 </span>            : 
<span class="lineNum">   11583 </span>            : /* OpenACC 2.0
<span class="lineNum">   11584 </span><span class="lineCov">      13057 :    Parse wait clause or wait directive parameters.  */</span>
<a name="11585"><span class="lineNum">   11585 </span><span class="lineCov">      13006 : </span></a>
<span class="lineNum">   11586 </span>            : static tree
<span class="lineNum">   11587 </span><span class="lineCov">      13057 : c_parser_oacc_wait_list (c_parser *parser, location_t clause_loc, tree list)</span>
<span class="lineNum">   11588 </span>            : {
<span class="lineNum">   11589 </span>            :   vec&lt;tree, va_gc&gt; *args;
<span class="lineNum">   11590 </span>            :   tree t, args_tree;
<span class="lineNum">   11591 </span>            : 
<span class="lineNum">   11592 </span>            :   matching_parens parens;
<span class="lineNum">   11593 </span><span class="lineCov">       7679 :   if (!parens.require_open (parser))</span>
<span class="lineNum">   11594 </span>            :     return list;
<span class="lineNum">   11595 </span>            : 
<span class="lineNum">   11596 </span><span class="lineCov">       7679 :   args = c_parser_expr_list (parser, false, true, NULL, NULL, NULL, NULL);</span>
<span class="lineNum">   11597 </span>            : 
<span class="lineNum">   11598 </span><span class="lineCov">      22483 :   if (args-&gt;length () == 0)</span>
<span class="lineNum">   11599 </span><span class="lineCov">       7417 :     {</span>
<span class="lineNum">   11600 </span>            :       c_parser_error (parser, &quot;expected integer expression before ')'&quot;);
<span class="lineNum">   11601 </span><span class="lineCov">         15 :       release_tree_vector (args);</span>
<span class="lineNum">   11602 </span><span class="lineCov">         15 :       return list;</span>
<span class="lineNum">   11603 </span><span class="lineCov">         15 :     }</span>
<span class="lineNum">   11604 </span>            : 
<span class="lineNum">   11605 </span><span class="lineCov">       7679 :   args_tree = build_tree_list_vec (args);</span>
<span class="lineNum">   11606 </span>            : 
<span class="lineNum">   11607 </span>            :   for (t = args_tree; t; t = TREE_CHAIN (t))
<span class="lineNum">   11608 </span>            :     {
<span class="lineNum">   11609 </span>            :       tree targ = TREE_VALUE (t);
<span class="lineNum">   11610 </span>            : 
<span class="lineNum">   11611 </span><span class="lineCov">         85 :       if (targ != error_mark_node)</span>
<span class="lineNum">   11612 </span>            :         {
<span class="lineNum">   11613 </span><span class="lineCov">         85 :           if (!INTEGRAL_TYPE_P (TREE_TYPE (targ)))</span>
<span class="lineNum">   11614 </span><span class="lineCov">         85 :             {</span>
<span class="lineNum">   11615 </span>            :               c_parser_error (parser, &quot;expression must be integral&quot;);
<span class="lineNum">   11616 </span><span class="lineCov">        170 :               targ = error_mark_node;</span>
<span class="lineNum">   11617 </span><span class="lineCov">         85 :             }</span>
<span class="lineNum">   11618 </span>            :           else
<span class="lineNum">   11619 </span>            :             {
<span class="lineNum">   11620 </span><span class="lineCov">         85 :               tree c = build_omp_clause (clause_loc, OMP_CLAUSE_WAIT);</span>
<span class="lineNum">   11621 </span>            : 
<span class="lineNum">   11622 </span><span class="lineCov">         85 :               OMP_CLAUSE_DECL (c) = targ;</span>
<span class="lineNum">   11623 </span>            :               OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   11624 </span><span class="lineNoCov">          0 :               list = c;</span>
<span class="lineNum">   11625 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">   11626 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   11627 </span>            :     }
<span class="lineNum">   11628 </span>            : 
<span class="lineNum">   11629 </span><span class="lineCov">         85 :   release_tree_vector (args);</span>
<span class="lineNum">   11630 </span>            :   parens.require_close (parser);
<span class="lineNum">   11631 </span><span class="lineCov">        212 :   return list;</span>
<span class="lineNum">   11632 </span>            : }
<span class="lineNum">   11633 </span><span class="lineCov">        127 : </span>
<span class="lineNum">   11634 </span>            : /* OpenACC 2.0, OpenMP 2.5:
<span class="lineNum">   11635 </span><span class="lineCov">        127 :    variable-list:</span>
<span class="lineNum">   11636 </span>            :      identifier
<span class="lineNum">   11637 </span><span class="lineCov">        114 :      variable-list , identifier</span>
<span class="lineNum">   11638 </span>            : 
<span class="lineNum">   11639 </span><span class="lineCov">          6 :    If KIND is nonzero, create the appropriate node and install the</span>
<span class="lineNum">   11640 </span><span class="lineCov">          6 :    decl in OMP_CLAUSE_DECL and add the node to the head of the list.</span>
<span class="lineNum">   11641 </span>            :    If KIND is nonzero, CLAUSE_LOC is the location of the clause.
<span class="lineNum">   11642 </span>            : 
<span class="lineNum">   11643 </span>            :    If KIND is zero, create a TREE_LIST with the decl in TREE_PURPOSE;
<span class="lineNum">   11644 </span><span class="lineCov">        108 :    return the list created.  */</span>
<a name="11645"><span class="lineNum">   11645 </span>            : </a>
<span class="lineNum">   11646 </span><span class="lineCov">        108 : static tree</span>
<span class="lineNum">   11647 </span><span class="lineCov">        108 : c_parser_omp_variable_list (c_parser *parser,</span>
<span class="lineNum">   11648 </span><span class="lineCov">        108 :                             location_t clause_loc,</span>
<span class="lineNum">   11649 </span>            :                             enum omp_clause_code kind, tree list)
<span class="lineNum">   11650 </span>            : {
<span class="lineNum">   11651 </span>            :   if (c_parser_next_token_is_not (parser, CPP_NAME)
<span class="lineNum">   11652 </span>            :       || c_parser_peek_token (parser)-&gt;id_kind != C_ID_ID)
<span class="lineNum">   11653 </span><span class="lineCov">         85 :     c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">   11654 </span><span class="lineCov">        170 : </span>
<span class="lineNum">   11655 </span><span class="lineCov">         85 :   while (c_parser_next_token_is (parser, CPP_NAME)</span>
<span class="lineNum">   11656 </span>            :          &amp;&amp; c_parser_peek_token (parser)-&gt;id_kind == C_ID_ID)
<span class="lineNum">   11657 </span>            :     {
<span class="lineNum">   11658 </span>            :       tree t = lookup_name (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   11659 </span>            : 
<span class="lineNum">   11660 </span>            :       if (t == NULL_TREE)
<span class="lineNum">   11661 </span>            :         {
<span class="lineNum">   11662 </span>            :           undeclared_variable (c_parser_peek_token (parser)-&gt;location,
<span class="lineNum">   11663 </span>            :                                c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   11664 </span>            :           t = error_mark_node;
<span class="lineNum">   11665 </span>            :         }
<span class="lineNum">   11666 </span>            : 
<span class="lineNum">   11667 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   11668 </span>            : 
<span class="lineNum">   11669 </span>            :       if (t == error_mark_node)
<span class="lineNum">   11670 </span>            :         ;
<span class="lineNum">   11671 </span><span class="lineCov">       5668 :       else if (kind != 0)</span>
<span class="lineNum">   11672 </span>            :         {
<span class="lineNum">   11673 </span>            :           switch (kind)
<span class="lineNum">   11674 </span>            :             {
<span class="lineNum">   11675 </span><span class="lineCov">       5668 :             case OMP_CLAUSE__CACHE_:</span>
<span class="lineNum">   11676 </span><span class="lineCov">       5668 :               /* The OpenACC cache directive explicitly only allows &quot;array</span>
<span class="lineNum">   11677 </span><span class="lineCov">          7 :                  elements or subarrays&quot;.  */</span>
<span class="lineNum">   11678 </span>            :               if (c_parser_peek_token (parser)-&gt;type != CPP_OPEN_SQUARE)
<span class="lineNum">   11679 </span><span class="lineCov">       6973 :                 {</span>
<span class="lineNum">   11680 </span><span class="lineCov">       6973 :                   c_parser_error (parser, &quot;expected %&lt;[%&gt;&quot;);</span>
<span class="lineNum">   11681 </span>            :                   t = error_mark_node;
<span class="lineNum">   11682 </span><span class="lineCov">       6965 :                   break;</span>
<span class="lineNum">   11683 </span>            :                 }
<span class="lineNum">   11684 </span><span class="lineCov">       6965 :               /* FALLTHROUGH  */</span>
<span class="lineNum">   11685 </span>            :             case OMP_CLAUSE_MAP:
<span class="lineNum">   11686 </span><span class="lineCov">          7 :             case OMP_CLAUSE_FROM:</span>
<span class="lineNum">   11687 </span><span class="lineCov">          7 :             case OMP_CLAUSE_TO:</span>
<span class="lineNum">   11688 </span><span class="lineCov">          7 :               while (c_parser_next_token_is (parser, CPP_DOT))</span>
<span class="lineNum">   11689 </span>            :                 {
<span class="lineNum">   11690 </span>            :                   location_t op_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   11691 </span><span class="lineCov">       6965 :                   c_parser_consume_token (parser);</span>
<span class="lineNum">   11692 </span>            :                   if (!c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   11693 </span><span class="lineCov">       6965 :                     {</span>
<span class="lineNum">   11694 </span>            :                       c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">   11695 </span><span class="lineCov">       6957 :                       t = error_mark_node;</span>
<span class="lineNum">   11696 </span>            :                       break;
<span class="lineNum">   11697 </span><span class="lineCov">       6849 :                     }</span>
<span class="lineNum">   11698 </span>            : 
<span class="lineNum">   11699 </span><span class="lineCov">         70 :                   c_token *comp_tok = c_parser_peek_token (parser);</span>
<span class="lineNum">   11700 </span>            :                   tree ident = comp_tok-&gt;value;
<span class="lineNum">   11701 </span>            :                   location_t comp_loc = comp_tok-&gt;location;
<span class="lineNum">   11702 </span><span class="lineCov">         70 :                   c_parser_consume_token (parser);</span>
<span class="lineNum">   11703 </span>            :                   t = build_component_ref (op_loc, t, ident, comp_loc);
<span class="lineNum">   11704 </span><span class="lineCov">          1 :                 }</span>
<span class="lineNum">   11705 </span><span class="lineCov">          1 :               /* FALLTHROUGH  */</span>
<span class="lineNum">   11706 </span><span class="lineCov">          1 :             case OMP_CLAUSE_DEPEND:</span>
<span class="lineNum">   11707 </span>            :             case OMP_CLAUSE_REDUCTION:
<span class="lineNum">   11708 </span>            :               while (c_parser_next_token_is (parser, CPP_OPEN_SQUARE))
<span class="lineNum">   11709 </span><span class="lineCov">       3774 :                 {</span>
<span class="lineNum">   11710 </span><span class="lineCov">       3774 :                   tree low_bound = NULL_TREE, length = NULL_TREE;</span>
<span class="lineNum">   11711 </span><span class="lineCov">       3774 : </span>
<span class="lineNum">   11712 </span><span class="lineCov">       3774 :                   c_parser_consume_token (parser);</span>
<span class="lineNum">   11713 </span>            :                   if (!c_parser_next_token_is (parser, CPP_COLON))
<span class="lineNum">   11714 </span><span class="lineCov">        137 :                     {</span>
<span class="lineNum">   11715 </span><span class="lineCov">        137 :                       location_t expr_loc</span>
<span class="lineNum">   11716 </span><span class="lineCov">        137 :                         = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   11717 </span>            :                       c_expr expr = c_parser_expression (parser);
<span class="lineNum">   11718 </span><span class="lineNoCov">          0 :                       expr = convert_lvalue_to_rvalue (expr_loc, expr,</span>
<span class="lineNum">   11719 </span><span class="lineNoCov">          0 :                                                        false, true);</span>
<span class="lineNum">   11720 </span><span class="lineNoCov">          0 :                       low_bound = expr.value;</span>
<span class="lineNum">   11721 </span>            :                     }
<span class="lineNum">   11722 </span>            :                   if (c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))
<span class="lineNum">   11723 </span><span class="lineCov">        137 :                     length = integer_one_node;</span>
<span class="lineNum">   11724 </span><span class="lineCov">        137 :                   else</span>
<span class="lineNum">   11725 </span><span class="lineCov">        137 :                     {</span>
<span class="lineNum">   11726 </span><span class="lineCov">        137 :                       /* Look for `:'.  */</span>
<span class="lineNum">   11727 </span><span class="lineCov">        137 :                       if (!c_parser_require (parser, CPP_COLON,</span>
<span class="lineNum">   11728 </span>            :                                              &quot;expected %&lt;:%&gt;&quot;))
<span class="lineNum">   11729 </span>            :                         {
<span class="lineNum">   11730 </span><span class="lineCov">       6420 :                           t = error_mark_node;</span>
<span class="lineNum">   11731 </span><span class="lineCov">       6420 :                           break;</span>
<span class="lineNum">   11732 </span><span class="lineCov">       6420 :                         }</span>
<span class="lineNum">   11733 </span>            :                       if (!c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))
<span class="lineNum">   11734 </span><span class="lineCov">       1527 :                         {</span>
<span class="lineNum">   11735 </span>            :                           location_t expr_loc
<span class="lineNum">   11736 </span><span class="lineCov">       1527 :                             = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   11737 </span><span class="lineCov">       1527 :                           c_expr expr = c_parser_expression (parser);</span>
<span class="lineNum">   11738 </span>            :                           expr = convert_lvalue_to_rvalue (expr_loc, expr,
<span class="lineNum">   11739 </span><span class="lineCov">       1365 :                                                            false, true);</span>
<span class="lineNum">   11740 </span><span class="lineCov">       1365 :                           length = expr.value;</span>
<span class="lineNum">   11741 </span><span class="lineCov">       1365 :                         }</span>
<span class="lineNum">   11742 </span><span class="lineCov">       1365 :                     }</span>
<span class="lineNum">   11743 </span><span class="lineCov">       1365 :                   /* Look for the closing `]'.  */</span>
<span class="lineNum">   11744 </span><span class="lineCov">       1365 :                   if (!c_parser_require (parser, CPP_CLOSE_SQUARE,</span>
<span class="lineNum">   11745 </span>            :                                          &quot;expected %&lt;]%&gt;&quot;))
<span class="lineNum">   11746 </span><span class="lineCov">       1527 :                     {</span>
<span class="lineNum">   11747 </span><span class="lineCov">        104 :                       t = error_mark_node;</span>
<span class="lineNum">   11748 </span>            :                       break;
<span class="lineNum">   11749 </span>            :                     }
<span class="lineNum">   11750 </span>            : 
<span class="lineNum">   11751 </span><span class="lineCov">       1423 :                   t = tree_cons (low_bound, length, t);</span>
<span class="lineNum">   11752 </span>            :                 }
<span class="lineNum">   11753 </span>            :               break;
<span class="lineNum">   11754 </span><span class="lineNoCov">          0 :             default:</span>
<span class="lineNum">   11755 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">   11756 </span>            :             }
<span class="lineNum">   11757 </span><span class="lineCov">       1423 : </span>
<span class="lineNum">   11758 </span>            :           if (t != error_mark_node)
<span class="lineNum">   11759 </span><span class="lineCov">       1349 :             {</span>
<span class="lineNum">   11760 </span><span class="lineCov">       1349 :               tree u = build_omp_clause (clause_loc, kind);</span>
<span class="lineNum">   11761 </span><span class="lineCov">       1349 :               OMP_CLAUSE_DECL (u) = t;</span>
<span class="lineNum">   11762 </span><span class="lineCov">       1349 :               OMP_CLAUSE_CHAIN (u) = list;</span>
<span class="lineNum">   11763 </span><span class="lineCov">       1349 :               list = u;</span>
<span class="lineNum">   11764 </span><span class="lineCov">       1349 :             }</span>
<span class="lineNum">   11765 </span>            :         }
<span class="lineNum">   11766 </span>            :       else
<span class="lineNum">   11767 </span>            :         list = tree_cons (t, NULL_TREE, list);
<span class="lineNum">   11768 </span><span class="lineCov">       1527 : </span>
<span class="lineNum">   11769 </span>            :       if (c_parser_next_token_is_not (parser, CPP_COMMA))
<span class="lineNum">   11770 </span>            :         break;
<span class="lineNum">   11771 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   11772 </span><span class="lineNoCov">          0 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   11773 </span>            :     }
<span class="lineNum">   11774 </span>            : 
<span class="lineNum">   11775 </span><span class="lineCov">       1527 :   return list;</span>
<span class="lineNum">   11776 </span>            : }
<span class="lineNum">   11777 </span>            : 
<span class="lineNum">   11778 </span>            : /* Similarly, but expect leading and trailing parenthesis.  This is a very
<span class="lineNum">   11779 </span>            :    common case for OpenACC and OpenMP clauses.  */
<a name="11780"><span class="lineNum">   11780 </span>            : </a>
<span class="lineNum">   11781 </span>            : static tree
<span class="lineNum">   11782 </span><span class="lineCov">       6849 : c_parser_omp_var_list_parens (c_parser *parser, enum omp_clause_code kind,</span>
<span class="lineNum">   11783 </span>            :                               tree list)
<span class="lineNum">   11784 </span><span class="lineCov">       6848 : {</span>
<span class="lineNum">   11785 </span><span class="lineCov">       6848 :   /* The clauses location.  */</span>
<span class="lineNum">   11786 </span><span class="lineCov">       6848 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   11787 </span><span class="lineCov">       6848 : </span>
<span class="lineNum">   11788 </span>            :   matching_parens parens;
<span class="lineNum">   11789 </span>            :   if (parens.require_open (parser))
<span class="lineNum">   11790 </span>            :     {
<span class="lineNum">   11791 </span><span class="lineCov">        108 :       list = c_parser_omp_variable_list (parser, loc, kind, list);</span>
<span class="lineNum">   11792 </span>            :       parens.skip_until_found_close (parser);
<span class="lineNum">   11793 </span><span class="lineCov">       6965 :     }</span>
<span class="lineNum">   11794 </span>            :   return list;
<span class="lineNum">   11795 </span>            : }
<span class="lineNum">   11796 </span><span class="lineCov">       1305 : </span>
<span class="lineNum">   11797 </span>            : /* OpenACC 2.0:
<span class="lineNum">   11798 </span>            :    copy ( variable-list )
<span class="lineNum">   11799 </span><span class="lineCov">       5668 :    copyin ( variable-list )</span>
<span class="lineNum">   11800 </span>            :    copyout ( variable-list )
<span class="lineNum">   11801 </span>            :    create ( variable-list )
<span class="lineNum">   11802 </span>            :    delete ( variable-list )
<span class="lineNum">   11803 </span>            :    present ( variable-list ) */
<a name="11804"><span class="lineNum">   11804 </span>            : </a>
<span class="lineNum">   11805 </span>            : static tree
<span class="lineNum">   11806 </span><span class="lineCov">       3585 : c_parser_oacc_data_clause (c_parser *parser, pragma_omp_clause c_kind,</span>
<span class="lineNum">   11807 </span>            :                            tree list)
<span class="lineNum">   11808 </span>            : {
<span class="lineNum">   11809 </span>            :   enum gomp_map_kind kind;
<span class="lineNum">   11810 </span><span class="lineCov">       3585 :   switch (c_kind)</span>
<span class="lineNum">   11811 </span>            :     {
<span class="lineNum">   11812 </span><span class="lineCov">       7170 :     case PRAGMA_OACC_CLAUSE_COPY:</span>
<span class="lineNum">   11813 </span><span class="lineCov">       3585 :       kind = GOMP_MAP_TOFROM;</span>
<span class="lineNum">   11814 </span>            :       break;
<span class="lineNum">   11815 </span><span class="lineCov">       3583 :     case PRAGMA_OACC_CLAUSE_COPYIN:</span>
<span class="lineNum">   11816 </span><span class="lineCov">       3583 :       kind = GOMP_MAP_TO;</span>
<span class="lineNum">   11817 </span>            :       break;
<span class="lineNum">   11818 </span><span class="lineCov">       3585 :     case PRAGMA_OACC_CLAUSE_COPYOUT:</span>
<span class="lineNum">   11819 </span>            :       kind = GOMP_MAP_FROM;
<span class="lineNum">   11820 </span>            :       break;
<span class="lineNum">   11821 </span>            :     case PRAGMA_OACC_CLAUSE_CREATE:
<span class="lineNum">   11822 </span>            :       kind = GOMP_MAP_ALLOC;
<span class="lineNum">   11823 </span>            :       break;
<span class="lineNum">   11824 </span>            :     case PRAGMA_OACC_CLAUSE_DELETE:
<span class="lineNum">   11825 </span>            :       kind = GOMP_MAP_RELEASE;
<span class="lineNum">   11826 </span>            :       break;
<span class="lineNum">   11827 </span>            :     case PRAGMA_OACC_CLAUSE_DEVICE:
<span class="lineNum">   11828 </span>            :       kind = GOMP_MAP_FORCE_TO;
<span class="lineNum">   11829 </span>            :       break;
<span class="lineNum">   11830 </span><span class="lineCov">       1283 :     case PRAGMA_OACC_CLAUSE_DEVICE_RESIDENT:</span>
<span class="lineNum">   11831 </span>            :       kind = GOMP_MAP_DEVICE_RESIDENT;
<span class="lineNum">   11832 </span>            :       break;
<span class="lineNum">   11833 </span><span class="lineCov">       1283 :     case PRAGMA_OACC_CLAUSE_HOST:</span>
<span class="lineNum">   11834 </span><span class="lineCov">       1283 :       kind = GOMP_MAP_FORCE_FROM;</span>
<span class="lineNum">   11835 </span>            :       break;
<span class="lineNum">   11836 </span>            :     case PRAGMA_OACC_CLAUSE_LINK:
<span class="lineNum">   11837 </span>            :       kind = GOMP_MAP_LINK;
<span class="lineNum">   11838 </span>            :       break;
<span class="lineNum">   11839 </span><span class="lineCov">        220 :     case PRAGMA_OACC_CLAUSE_PRESENT:</span>
<span class="lineNum">   11840 </span><span class="lineCov">        220 :       kind = GOMP_MAP_FORCE_PRESENT;</span>
<span class="lineNum">   11841 </span><span class="lineCov">        220 :       break;</span>
<span class="lineNum">   11842 </span><span class="lineCov">        214 :     default:</span>
<span class="lineNum">   11843 </span><span class="lineCov">        214 :       gcc_unreachable ();</span>
<span class="lineNum">   11844 </span><span class="lineCov">        214 :     }</span>
<span class="lineNum">   11845 </span><span class="lineCov">         67 :   tree nl, c;</span>
<span class="lineNum">   11846 </span><span class="lineCov">         67 :   nl = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_MAP, list);</span>
<span class="lineNum">   11847 </span><span class="lineCov">         67 : </span>
<span class="lineNum">   11848 </span><span class="lineCov">         28 :   for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))</span>
<span class="lineNum">   11849 </span><span class="lineCov">         28 :     OMP_CLAUSE_SET_MAP_KIND (c, kind);</span>
<span class="lineNum">   11850 </span><span class="lineCov">         28 : </span>
<span class="lineNum">   11851 </span><span class="lineCov">         19 :   return nl;</span>
<span class="lineNum">   11852 </span><span class="lineCov">         19 : }</span>
<span class="lineNum">   11853 </span><span class="lineCov">         19 : </span>
<span class="lineNum">   11854 </span><span class="lineCov">          7 : /* OpenACC 2.0:</span>
<span class="lineNum">   11855 </span><span class="lineCov">          7 :    deviceptr ( variable-list ) */</span>
<a name="11856"><span class="lineNum">   11856 </span><span class="lineCov">          7 : </span></a>
<span class="lineNum">   11857 </span><span class="lineCov">         42 : static tree</span>
<span class="lineNum">   11858 </span><span class="lineCov">         42 : c_parser_oacc_data_clause_deviceptr (c_parser *parser, tree list)</span>
<span class="lineNum">   11859 </span><span class="lineCov">         42 : {</span>
<span class="lineNum">   11860 </span><span class="lineCov">          9 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   11861 </span><span class="lineCov">          9 :   tree vars, t;</span>
<span class="lineNum">   11862 </span><span class="lineCov">          9 : </span>
<span class="lineNum">   11863 </span><span class="lineCov">         96 :   /* Can't use OMP_CLAUSE_MAP here (that is, can't use the generic</span>
<span class="lineNum">   11864 </span><span class="lineCov">         96 :      c_parser_oacc_data_clause), as for PRAGMA_OACC_CLAUSE_DEVICEPTR,</span>
<span class="lineNum">   11865 </span><span class="lineCov">         96 :      variable-list must only allow for pointer variables.  */</span>
<span class="lineNum">   11866 </span><span class="lineNoCov">          0 :   vars = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);</span>
<span class="lineNum">   11867 </span><span class="lineNoCov">          0 :   for (t = vars; t &amp;&amp; t; t = TREE_CHAIN (t))</span>
<span class="lineNum">   11868 </span>            :     {
<span class="lineNum">   11869 </span><span class="lineCov">       1283 :       tree v = TREE_PURPOSE (t);</span>
<span class="lineNum">   11870 </span><span class="lineCov">       1283 : </span>
<span class="lineNum">   11871 </span>            :       /* FIXME diagnostics: Ideally we should keep individual
<span class="lineNum">   11872 </span><span class="lineCov">       3009 :          locations for all the variables in the var list to make the</span>
<span class="lineNum">   11873 </span><span class="lineCov">       1726 :          following errors more precise.  Perhaps</span>
<span class="lineNum">   11874 </span>            :          c_parser_omp_var_list_parens() should construct a list of
<span class="lineNum">   11875 </span><span class="lineCov">       1283 :          locations to go along with the var list.  */</span>
<span class="lineNum">   11876 </span>            : 
<span class="lineNum">   11877 </span>            :       if (!VAR_P (v) &amp;&amp; TREE_CODE (v) != PARM_DECL)
<span class="lineNum">   11878 </span>            :         error_at (loc, &quot;%qD is not a variable&quot;, v);
<span class="lineNum">   11879 </span>            :       else if (TREE_TYPE (v) == error_mark_node)
<span class="lineNum">   11880 </span>            :         ;
<span class="lineNum">   11881 </span>            :       else if (!POINTER_TYPE_P (TREE_TYPE (v)))
<span class="lineNum">   11882 </span><span class="lineCov">         48 :         error_at (loc, &quot;%qD is not a pointer variable&quot;, v);</span>
<span class="lineNum">   11883 </span>            : 
<span class="lineNum">   11884 </span><span class="lineCov">         48 :       tree u = build_omp_clause (loc, OMP_CLAUSE_MAP);</span>
<span class="lineNum">   11885 </span><span class="lineCov">         48 :       OMP_CLAUSE_SET_MAP_KIND (u, GOMP_MAP_FORCE_DEVICEPTR);</span>
<span class="lineNum">   11886 </span>            :       OMP_CLAUSE_DECL (u) = v;
<span class="lineNum">   11887 </span>            :       OMP_CLAUSE_CHAIN (u) = list;
<span class="lineNum">   11888 </span>            :       list = u;
<span class="lineNum">   11889 </span>            :     }
<span class="lineNum">   11890 </span><span class="lineCov">         48 : </span>
<span class="lineNum">   11891 </span><span class="lineCov">         98 :   return list;</span>
<span class="lineNum">   11892 </span>            : }
<span class="lineNum">   11893 </span><span class="lineCov">         50 : </span>
<span class="lineNum">   11894 </span>            : /* OpenACC 2.0, OpenMP 3.0:
<span class="lineNum">   11895 </span>            :    collapse ( constant-expression ) */
<a name="11896"><span class="lineNum">   11896 </span>            : </a>
<span class="lineNum">   11897 </span>            : static tree
<span class="lineNum">   11898 </span>            : c_parser_omp_clause_collapse (c_parser *parser, tree list)
<span class="lineNum">   11899 </span>            : {
<span class="lineNum">   11900 </span>            :   tree c, num = error_mark_node;
<span class="lineNum">   11901 </span><span class="lineCov">         50 :   HOST_WIDE_INT n;</span>
<span class="lineNum">   11902 </span><span class="lineCov">          3 :   location_t loc;</span>
<span class="lineNum">   11903 </span><span class="lineCov">         47 : </span>
<span class="lineNum">   11904 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_COLLAPSE, &quot;collapse&quot;);
<span class="lineNum">   11905 </span><span class="lineCov">         92 :   check_no_duplicate_clause (list, OMP_CLAUSE_TILE, &quot;tile&quot;);</span>
<span class="lineNum">   11906 </span><span class="lineCov">          7 : </span>
<span class="lineNum">   11907 </span>            :   loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   11908 </span><span class="lineCov">         50 :   matching_parens parens;</span>
<span class="lineNum">   11909 </span><span class="lineCov">         50 :   if (parens.require_open (parser))</span>
<span class="lineNum">   11910 </span><span class="lineCov">         50 :     {</span>
<span class="lineNum">   11911 </span><span class="lineCov">         50 :       num = c_parser_expr_no_commas (parser, NULL).value;</span>
<span class="lineNum">   11912 </span><span class="lineCov">         50 :       parens.skip_until_found_close (parser);</span>
<span class="lineNum">   11913 </span>            :     }
<span class="lineNum">   11914 </span>            :   if (num == error_mark_node)
<span class="lineNum">   11915 </span><span class="lineCov">         48 :     return list;</span>
<span class="lineNum">   11916 </span>            :   mark_exp_read (num);
<span class="lineNum">   11917 </span>            :   num = c_fully_fold (num, false, NULL);
<span class="lineNum">   11918 </span>            :   if (!INTEGRAL_TYPE_P (TREE_TYPE (num))
<span class="lineNum">   11919 </span>            :       || !tree_fits_shwi_p (num)
<span class="lineNum">   11920 </span>            :       || (n = tree_to_shwi (num)) &lt;= 0
<span class="lineNum">   11921 </span>            :       || (int) n != n)
<span class="lineNum">   11922 </span><span class="lineCov">       1033 :     {</span>
<span class="lineNum">   11923 </span>            :       error_at (loc,
<span class="lineNum">   11924 </span><span class="lineCov">       1033 :                 &quot;collapse argument needs positive constant integer expression&quot;);</span>
<span class="lineNum">   11925 </span><span class="lineCov">       1033 :       return list;</span>
<span class="lineNum">   11926 </span><span class="lineCov">       1033 :     }</span>
<span class="lineNum">   11927 </span>            :   c = build_omp_clause (loc, OMP_CLAUSE_COLLAPSE);
<span class="lineNum">   11928 </span><span class="lineCov">       1033 :   OMP_CLAUSE_COLLAPSE_EXPR (c) = num;</span>
<span class="lineNum">   11929 </span><span class="lineCov">       1033 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   11930 </span>            :   return c;
<span class="lineNum">   11931 </span><span class="lineCov">       1033 : }</span>
<span class="lineNum">   11932 </span><span class="lineCov">       2066 : </span>
<span class="lineNum">   11933 </span><span class="lineCov">       1033 : /* OpenMP 2.5:</span>
<span class="lineNum">   11934 </span>            :    copyin ( variable-list ) */
<a name="11935"><span class="lineNum">   11935 </span><span class="lineCov">       1033 : </span></a>
<span class="lineNum">   11936 </span><span class="lineCov">       1033 : static tree</span>
<span class="lineNum">   11937 </span>            : c_parser_omp_clause_copyin (c_parser *parser, tree list)
<span class="lineNum">   11938 </span><span class="lineCov">       1033 : {</span>
<span class="lineNum">   11939 </span>            :   return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_COPYIN, list);
<span class="lineNum">   11940 </span><span class="lineCov">       1033 : }</span>
<span class="lineNum">   11941 </span><span class="lineCov">       1033 : </span>
<span class="lineNum">   11942 </span><span class="lineCov">       3099 : /* OpenMP 2.5:</span>
<span class="lineNum">   11943 </span><span class="lineCov">       1033 :    copyprivate ( variable-list ) */</span>
<a name="11944"><span class="lineNum">   11944 </span><span class="lineCov">       1033 : </span></a>
<span class="lineNum">   11945 </span><span class="lineCov">       2066 : static tree</span>
<span class="lineNum">   11946 </span>            : c_parser_omp_clause_copyprivate (c_parser *parser, tree list)
<span class="lineNum">   11947 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   11948 </span>            :   return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_COPYPRIVATE, list);
<span class="lineNum">   11949 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   11950 </span>            : 
<span class="lineNum">   11951 </span><span class="lineCov">       1033 : /* OpenMP 2.5:</span>
<span class="lineNum">   11952 </span><span class="lineCov">       1033 :    default ( none | shared )</span>
<span class="lineNum">   11953 </span><span class="lineCov">       1033 : </span>
<span class="lineNum">   11954 </span><span class="lineCov">       1033 :    OpenACC:</span>
<span class="lineNum">   11955 </span>            :    default ( none | present ) */
<a name="11956"><span class="lineNum">   11956 </span>            : </a>
<span class="lineNum">   11957 </span>            : static tree
<span class="lineNum">   11958 </span>            : c_parser_omp_clause_default (c_parser *parser, tree list, bool is_oacc)
<span class="lineNum">   11959 </span>            : {
<span class="lineNum">   11960 </span>            :   enum omp_clause_default_kind kind = OMP_CLAUSE_DEFAULT_UNSPECIFIED;
<span class="lineNum">   11961 </span><span class="lineNoCov">          0 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   11962 </span>            :   tree c;
<span class="lineNum">   11963 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   11964 </span>            :   matching_parens parens;
<span class="lineNum">   11965 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   11966 </span>            :     return list;
<span class="lineNum">   11967 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   11968 </span>            :     {
<span class="lineNum">   11969 </span>            :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   11970 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   11971 </span>            :       switch (p[0])
<span class="lineNum">   11972 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   11973 </span>            :         case 'n':
<span class="lineNum">   11974 </span>            :           if (strcmp (&quot;none&quot;, p) != 0)
<span class="lineNum">   11975 </span>            :             goto invalid_kind;
<span class="lineNum">   11976 </span>            :           kind = OMP_CLAUSE_DEFAULT_NONE;
<span class="lineNum">   11977 </span>            :           break;
<span class="lineNum">   11978 </span>            : 
<span class="lineNum">   11979 </span>            :         case 'p':
<span class="lineNum">   11980 </span>            :           if (strcmp (&quot;present&quot;, p) != 0 || !is_oacc)
<span class="lineNum">   11981 </span>            :             goto invalid_kind;
<span class="lineNum">   11982 </span><span class="lineCov">        155 :           kind = OMP_CLAUSE_DEFAULT_PRESENT;</span>
<span class="lineNum">   11983 </span>            :           break;
<span class="lineNum">   11984 </span><span class="lineCov">        155 : </span>
<span class="lineNum">   11985 </span><span class="lineCov">        155 :         case 's':</span>
<span class="lineNum">   11986 </span><span class="lineCov">        155 :           if (strcmp (&quot;shared&quot;, p) != 0 || is_oacc)</span>
<span class="lineNum">   11987 </span>            :             goto invalid_kind;
<span class="lineNum">   11988 </span><span class="lineCov">        310 :           kind = OMP_CLAUSE_DEFAULT_SHARED;</span>
<span class="lineNum">   11989 </span><span class="lineCov">        155 :           break;</span>
<span class="lineNum">   11990 </span>            : 
<span class="lineNum">   11991 </span><span class="lineCov">        153 :         default:</span>
<span class="lineNum">   11992 </span>            :           goto invalid_kind;
<span class="lineNum">   11993 </span><span class="lineCov">        145 :         }</span>
<span class="lineNum">   11994 </span>            : 
<span class="lineNum">   11995 </span><span class="lineCov">        145 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   11996 </span>            :     }
<span class="lineNum">   11997 </span><span class="lineCov">         64 :   else</span>
<span class="lineNum">   11998 </span><span class="lineCov">         64 :     {</span>
<span class="lineNum">   11999 </span>            :     invalid_kind:
<span class="lineNum">   12000 </span>            :       if (is_oacc)
<span class="lineNum">   12001 </span>            :         c_parser_error (parser, &quot;expected %&lt;none%&gt; or %&lt;present%&gt;&quot;);
<span class="lineNum">   12002 </span>            :       else
<span class="lineNum">   12003 </span><span class="lineCov">         10 :         c_parser_error (parser, &quot;expected %&lt;none%&gt; or %&lt;shared%&gt;&quot;);</span>
<span class="lineNum">   12004 </span><span class="lineCov">         10 :     }</span>
<span class="lineNum">   12005 </span>            :   parens.skip_until_found_close (parser);
<span class="lineNum">   12006 </span>            : 
<span class="lineNum">   12007 </span>            :   if (kind == OMP_CLAUSE_DEFAULT_UNSPECIFIED)
<span class="lineNum">   12008 </span>            :     return list;
<span class="lineNum">   12009 </span><span class="lineCov">         69 : </span>
<span class="lineNum">   12010 </span><span class="lineCov">         69 :   check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULT, &quot;default&quot;);</span>
<span class="lineNum">   12011 </span>            :   c = build_omp_clause (loc, OMP_CLAUSE_DEFAULT);
<span class="lineNum">   12012 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   12013 </span>            :   OMP_CLAUSE_DEFAULT_KIND (c) = kind;
<span class="lineNum">   12014 </span>            : 
<span class="lineNum">   12015 </span>            :   return c;
<span class="lineNum">   12016 </span>            : }
<span class="lineNum">   12017 </span>            : 
<span class="lineNum">   12018 </span>            : /* OpenMP 2.5:
<span class="lineNum">   12019 </span><span class="lineCov">        139 :    firstprivate ( variable-list ) */</span>
<a name="12020"><span class="lineNum">   12020 </span>            : </a>
<span class="lineNum">   12021 </span>            : static tree
<span class="lineNum">   12022 </span>            : c_parser_omp_clause_firstprivate (c_parser *parser, tree list)
<span class="lineNum">   12023 </span><span class="lineCov">          8 : {</span>
<span class="lineNum">   12024 </span><span class="lineCov">         14 :   return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_FIRSTPRIVATE, list);</span>
<span class="lineNum">   12025 </span><span class="lineCov">         14 : }</span>
<span class="lineNum">   12026 </span>            : 
<span class="lineNum">   12027 </span><span class="lineNoCov">          0 : /* OpenMP 3.1:</span>
<span class="lineNum">   12028 </span>            :    final ( expression ) */
<a name="12029"><span class="lineNum">   12029 </span><span class="lineCov">        153 : </span></a>
<span class="lineNum">   12030 </span>            : static tree
<span class="lineNum">   12031 </span><span class="lineCov">        153 : c_parser_omp_clause_final (c_parser *parser, tree list)</span>
<span class="lineNum">   12032 </span>            : {
<span class="lineNum">   12033 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   12034 </span><span class="lineCov">        139 :   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))</span>
<span class="lineNum">   12035 </span><span class="lineCov">        139 :     {</span>
<span class="lineNum">   12036 </span><span class="lineCov">        139 :       tree t = c_parser_paren_condition (parser);</span>
<span class="lineNum">   12037 </span><span class="lineCov">        139 :       tree c;</span>
<span class="lineNum">   12038 </span>            : 
<span class="lineNum">   12039 </span><span class="lineCov">        139 :       check_no_duplicate_clause (list, OMP_CLAUSE_FINAL, &quot;final&quot;);</span>
<span class="lineNum">   12040 </span>            : 
<span class="lineNum">   12041 </span>            :       c = build_omp_clause (loc, OMP_CLAUSE_FINAL);
<span class="lineNum">   12042 </span>            :       OMP_CLAUSE_FINAL_EXPR (c) = t;
<span class="lineNum">   12043 </span>            :       OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   12044 </span>            :       list = c;
<span class="lineNum">   12045 </span>            :     }
<span class="lineNum">   12046 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">   12047 </span>            :     c_parser_error (parser, &quot;expected %&lt;(%&gt;&quot;);
<span class="lineNum">   12048 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   12049 </span>            :   return list;
<span class="lineNum">   12050 </span>            : }
<span class="lineNum">   12051 </span>            : 
<span class="lineNum">   12052 </span>            : /* OpenACC, OpenMP 2.5:
<span class="lineNum">   12053 </span>            :    if ( expression )
<span class="lineNum">   12054 </span>            : 
<span class="lineNum">   12055 </span><span class="lineCov">          5 :    OpenMP 4.5:</span>
<span class="lineNum">   12056 </span>            :    if ( directive-name-modifier : expression )
<span class="lineNum">   12057 </span><span class="lineCov">          5 : </span>
<span class="lineNum">   12058 </span><span class="lineCov">          5 :    directive-name-modifier:</span>
<span class="lineNum">   12059 </span>            :      parallel | task | taskloop | target data | target | target update
<span class="lineNum">   12060 </span><span class="lineCov">          5 :      | target enter data | target exit data  */</span>
<a name="12061"><span class="lineNum">   12061 </span><span class="lineCov">          5 : </span></a>
<span class="lineNum">   12062 </span>            : static tree
<span class="lineNum">   12063 </span><span class="lineCov">          5 : c_parser_omp_clause_if (c_parser *parser, tree list, bool is_omp)</span>
<span class="lineNum">   12064 </span>            : {
<span class="lineNum">   12065 </span><span class="lineCov">          5 :   location_t location = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   12066 </span><span class="lineCov">          5 :   enum tree_code if_modifier = ERROR_MARK;</span>
<span class="lineNum">   12067 </span><span class="lineCov">          5 : </span>
<span class="lineNum">   12068 </span><span class="lineCov">          5 :   matching_parens parens;</span>
<span class="lineNum">   12069 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   12070 </span>            :     return list;
<span class="lineNum">   12071 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   12072 </span>            :   if (is_omp &amp;&amp; c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   12073 </span><span class="lineCov">          5 :     {</span>
<span class="lineNum">   12074 </span>            :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   12075 </span>            :       int n = 2;
<span class="lineNum">   12076 </span>            :       if (strcmp (p, &quot;parallel&quot;) == 0)
<span class="lineNum">   12077 </span>            :         if_modifier = OMP_PARALLEL;
<span class="lineNum">   12078 </span>            :       else if (strcmp (p, &quot;task&quot;) == 0)
<span class="lineNum">   12079 </span>            :         if_modifier = OMP_TASK;
<span class="lineNum">   12080 </span>            :       else if (strcmp (p, &quot;taskloop&quot;) == 0)
<span class="lineNum">   12081 </span>            :         if_modifier = OMP_TASKLOOP;
<span class="lineNum">   12082 </span>            :       else if (strcmp (p, &quot;target&quot;) == 0)
<span class="lineNum">   12083 </span>            :         {
<span class="lineNum">   12084 </span>            :           if_modifier = OMP_TARGET;
<span class="lineNum">   12085 </span>            :           if (c_parser_peek_2nd_token (parser)-&gt;type == CPP_NAME)
<span class="lineNum">   12086 </span>            :             {
<span class="lineNum">   12087 </span><span class="lineCov">        297 :               p = IDENTIFIER_POINTER (c_parser_peek_2nd_token (parser)-&gt;value);</span>
<span class="lineNum">   12088 </span>            :               if (strcmp (&quot;data&quot;, p) == 0)
<span class="lineNum">   12089 </span><span class="lineCov">        297 :                 if_modifier = OMP_TARGET_DATA;</span>
<span class="lineNum">   12090 </span><span class="lineCov">        297 :               else if (strcmp (&quot;update&quot;, p) == 0)</span>
<span class="lineNum">   12091 </span>            :                 if_modifier = OMP_TARGET_UPDATE;
<span class="lineNum">   12092 </span><span class="lineCov">        594 :               else if (strcmp (&quot;enter&quot;, p) == 0)</span>
<span class="lineNum">   12093 </span><span class="lineCov">        297 :                 if_modifier = OMP_TARGET_ENTER_DATA;</span>
<span class="lineNum">   12094 </span>            :               else if (strcmp (&quot;exit&quot;, p) == 0)
<span class="lineNum">   12095 </span>            :                 if_modifier = OMP_TARGET_EXIT_DATA;
<span class="lineNum">   12096 </span><span class="lineCov">        297 :               if (if_modifier != OMP_TARGET)</span>
<span class="lineNum">   12097 </span>            :                 {
<span class="lineNum">   12098 </span><span class="lineCov">        165 :                   n = 3;</span>
<span class="lineNum">   12099 </span><span class="lineCov">        165 :                   c_parser_consume_token (parser);</span>
<span class="lineNum">   12100 </span><span class="lineCov">        165 :                 }</span>
<span class="lineNum">   12101 </span>            :               else
<span class="lineNum">   12102 </span><span class="lineCov">        145 :                 {</span>
<span class="lineNum">   12103 </span>            :                   location_t loc = c_parser_peek_2nd_token (parser)-&gt;location;
<span class="lineNum">   12104 </span><span class="lineCov">        140 :                   error_at (loc, &quot;expected %&lt;data%&gt;, %&lt;update%&gt;, %&lt;enter%&gt; &quot;</span>
<span class="lineNum">   12105 </span>            :                                  &quot;or %&lt;exit%&gt;&quot;);
<span class="lineNum">   12106 </span><span class="lineCov">        135 :                   if_modifier = ERROR_MARK;</span>
<span class="lineNum">   12107 </span>            :                 }
<span class="lineNum">   12108 </span><span class="lineCov">         22 :               if (if_modifier == OMP_TARGET_ENTER_DATA</span>
<span class="lineNum">   12109 </span><span class="lineCov">         22 :                   || if_modifier == OMP_TARGET_EXIT_DATA)</span>
<span class="lineNum">   12110 </span>            :                 {
<span class="lineNum">   12111 </span><span class="lineCov">         10 :                   if (c_parser_peek_2nd_token (parser)-&gt;type == CPP_NAME)</span>
<span class="lineNum">   12112 </span><span class="lineCov">         10 :                     {</span>
<span class="lineNum">   12113 </span>            :                       p = IDENTIFIER_POINTER
<span class="lineNum">   12114 </span><span class="lineCov">          8 :                                 (c_parser_peek_2nd_token (parser)-&gt;value);</span>
<span class="lineNum">   12115 </span>            :                       if (strcmp (&quot;data&quot;, p) == 0)
<span class="lineNum">   12116 </span><span class="lineCov">          5 :                         n = 4;</span>
<span class="lineNum">   12117 </span>            :                     }
<span class="lineNum">   12118 </span><span class="lineCov">          3 :                   if (n == 4)</span>
<span class="lineNum">   12119 </span>            :                     c_parser_consume_token (parser);
<span class="lineNum">   12120 </span><span class="lineNoCov">          0 :                   else</span>
<span class="lineNum">   12121 </span>            :                     {
<span class="lineNum">   12122 </span><span class="lineCov">         10 :                       location_t loc</span>
<span class="lineNum">   12123 </span><span class="lineCov">         10 :                         = c_parser_peek_2nd_token (parser)-&gt;location;</span>
<span class="lineNum">   12124 </span>            :                       error_at (loc, &quot;expected %&lt;data%&gt;&quot;);
<span class="lineNum">   12125 </span>            :                       if_modifier = ERROR_MARK;
<span class="lineNum">   12126 </span>            :                     }
<span class="lineNum">   12127 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">   12128 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">   12129 </span>            :         }
<span class="lineNum">   12130 </span><span class="lineNoCov">          0 :       if (if_modifier != ERROR_MARK)</span>
<span class="lineNum">   12131 </span>            :         {
<span class="lineNum">   12132 </span><span class="lineCov">         20 :           if (c_parser_peek_2nd_token (parser)-&gt;type == CPP_COLON)</span>
<span class="lineNum">   12133 </span><span class="lineCov">         10 :             {</span>
<span class="lineNum">   12134 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">   12135 </span><span class="lineCov">          5 :               c_parser_consume_token (parser);</span>
<span class="lineNum">   12136 </span>            :             }
<span class="lineNum">   12137 </span><span class="lineCov">          5 :           else</span>
<span class="lineNum">   12138 </span>            :             {
<span class="lineNum">   12139 </span><span class="lineCov">          5 :               if (n &gt; 2)</span>
<span class="lineNum">   12140 </span><span class="lineCov">          5 :                 {</span>
<span class="lineNum">   12141 </span>            :                   location_t loc = c_parser_peek_2nd_token (parser)-&gt;location;
<span class="lineNum">   12142 </span><span class="lineCov">          5 :                   error_at (loc, &quot;expected %&lt;:%&gt;&quot;);</span>
<span class="lineNum">   12143 </span><span class="lineCov">          5 :                 }</span>
<span class="lineNum">   12144 </span>            :               if_modifier = ERROR_MARK;
<span class="lineNum">   12145 </span>            :             }
<span class="lineNum">   12146 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   12147 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   12148 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   12149 </span><span class="lineNoCov">          0 :   tree t = c_parser_condition (parser), c;</span>
<span class="lineNum">   12150 </span>            :   parens.skip_until_found_close (parser);
<span class="lineNum">   12151 </span>            : 
<span class="lineNum">   12152 </span>            :   for (c = list; c ; c = OMP_CLAUSE_CHAIN (c))
<span class="lineNum">   12153 </span>            :     if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IF)
<span class="lineNum">   12154 </span><span class="lineCov">         10 :       {</span>
<span class="lineNum">   12155 </span>            :         if (if_modifier != ERROR_MARK
<span class="lineNum">   12156 </span><span class="lineCov">         52 :             &amp;&amp; OMP_CLAUSE_IF_MODIFIER (c) == if_modifier)</span>
<span class="lineNum">   12157 </span>            :           {
<span class="lineNum">   12158 </span><span class="lineCov">         51 :             const char *p = NULL;</span>
<span class="lineNum">   12159 </span><span class="lineCov">         51 :             switch (if_modifier)</span>
<span class="lineNum">   12160 </span>            :               {
<span class="lineNum">   12161 </span>            :               case OMP_PARALLEL: p = &quot;parallel&quot;; break;
<span class="lineNum">   12162 </span>            :               case OMP_TASK: p = &quot;task&quot;; break;
<span class="lineNum">   12163 </span><span class="lineCov">          1 :               case OMP_TASKLOOP: p = &quot;taskloop&quot;; break;</span>
<span class="lineNum">   12164 </span>            :               case OMP_TARGET_DATA: p = &quot;target data&quot;; break;
<span class="lineNum">   12165 </span><span class="lineNoCov">          0 :               case OMP_TARGET: p = &quot;target&quot;; break;</span>
<span class="lineNum">   12166 </span><span class="lineNoCov">          0 :               case OMP_TARGET_UPDATE: p = &quot;target update&quot;; break;</span>
<span class="lineNum">   12167 </span>            :               case OMP_TARGET_ENTER_DATA: p = &quot;enter data&quot;; break;
<span class="lineNum">   12168 </span>            :               case OMP_TARGET_EXIT_DATA: p = &quot;exit data&quot;; break;
<span class="lineNum">   12169 </span>            :               default: gcc_unreachable ();
<span class="lineNum">   12170 </span>            :               }
<span class="lineNum">   12171 </span>            :             error_at (location, &quot;too many %&lt;if%&gt; clauses with %qs modifier&quot;,
<span class="lineNum">   12172 </span>            :                       p);
<span class="lineNum">   12173 </span><span class="lineCov">        297 :             return list;</span>
<span class="lineNum">   12174 </span><span class="lineCov">        594 :           }</span>
<span class="lineNum">   12175 </span>            :         else if (OMP_CLAUSE_IF_MODIFIER (c) == if_modifier)
<span class="lineNum">   12176 </span><span class="lineCov">        941 :           {</span>
<span class="lineNum">   12177 </span><span class="lineCov">        328 :             if (!is_omp)</span>
<span class="lineNum">   12178 </span>            :               error_at (location, &quot;too many %&lt;if%&gt; clauses&quot;);
<span class="lineNum">   12179 </span><span class="lineCov">         13 :             else</span>
<span class="lineNum">   12180 </span><span class="lineCov">         13 :               error_at (location, &quot;too many %&lt;if%&gt; clauses without modifier&quot;);</span>
<span class="lineNum">   12181 </span>            :             return list;
<span class="lineNum">   12182 </span><span class="lineCov">          1 :           }</span>
<span class="lineNum">   12183 </span><span class="lineCov">          1 :         else if (if_modifier == ERROR_MARK</span>
<span class="lineNum">   12184 </span>            :                  || OMP_CLAUSE_IF_MODIFIER (c) == ERROR_MARK)
<span class="lineNum">   12185 </span>            :           {
<span class="lineNum">   12186 </span><span class="lineNoCov">          0 :             error_at (location, &quot;if any %&lt;if%&gt; clause has modifier, then all &quot;</span>
<span class="lineNum">   12187 </span><span class="lineNoCov">          0 :                                 &quot;%&lt;if%&gt; clauses have to use modifier&quot;);</span>
<span class="lineNum">   12188 </span><span class="lineNoCov">          0 :             return list;</span>
<span class="lineNum">   12189 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">   12190 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">   12191 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   12192 </span><span class="lineNoCov">          0 :   c = build_omp_clause (location, OMP_CLAUSE_IF);</span>
<span class="lineNum">   12193 </span><span class="lineNoCov">          0 :   OMP_CLAUSE_IF_MODIFIER (c) = if_modifier;</span>
<span class="lineNum">   12194 </span>            :   OMP_CLAUSE_IF_EXPR (c) = t;
<span class="lineNum">   12195 </span><span class="lineCov">          1 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   12196 </span>            :   return c;
<span class="lineNum">   12197 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">   12198 </span>            : 
<span class="lineNum">   12199 </span><span class="lineCov">         12 : /* OpenMP 2.5:</span>
<span class="lineNum">   12200 </span>            :    lastprivate ( variable-list ) */
<a name="12201"><span class="lineNum">   12201 </span><span class="lineCov">          3 : </span></a>
<span class="lineNum">   12202 </span><span class="lineCov">          1 : static tree</span>
<span class="lineNum">   12203 </span>            : c_parser_omp_clause_lastprivate (c_parser *parser, tree list)
<span class="lineNum">   12204 </span><span class="lineCov">          2 : {</span>
<span class="lineNum">   12205 </span><span class="lineCov">          3 :   return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_LASTPRIVATE, list);</span>
<span class="lineNum">   12206 </span>            : }
<span class="lineNum">   12207 </span><span class="lineCov">          9 : </span>
<span class="lineNum">   12208 </span><span class="lineCov">          9 : /* OpenMP 3.1:</span>
<span class="lineNum">   12209 </span>            :    mergeable */
<a name="12210"><span class="lineNum">   12210 </span><span class="lineCov">          2 : </span></a>
<span class="lineNum">   12211 </span>            : static tree
<span class="lineNum">   12212 </span><span class="lineCov">          2 : c_parser_omp_clause_mergeable (c_parser *parser ATTRIBUTE_UNUSED, tree list)</span>
<span class="lineNum">   12213 </span>            : {
<span class="lineNum">   12214 </span>            :   tree c;
<span class="lineNum">   12215 </span>            : 
<span class="lineNum">   12216 </span><span class="lineCov">        291 :   /* FIXME: Should we allow duplicates?  */</span>
<span class="lineNum">   12217 </span><span class="lineCov">        291 :   check_no_duplicate_clause (list, OMP_CLAUSE_MERGEABLE, &quot;mergeable&quot;);</span>
<span class="lineNum">   12218 </span><span class="lineCov">        291 : </span>
<span class="lineNum">   12219 </span><span class="lineCov">        291 :   c = build_omp_clause (c_parser_peek_token (parser)-&gt;location,</span>
<span class="lineNum">   12220 </span><span class="lineCov">        291 :                         OMP_CLAUSE_MERGEABLE);</span>
<span class="lineNum">   12221 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   12222 </span>            : 
<span class="lineNum">   12223 </span>            :   return c;
<span class="lineNum">   12224 </span>            : }
<span class="lineNum">   12225 </span>            : 
<span class="lineNum">   12226 </span>            : /* OpenMP 2.5:
<span class="lineNum">   12227 </span><span class="lineNoCov">          0 :    nowait */</span>
<a name="12228"><span class="lineNum">   12228 </span>            : </a>
<span class="lineNum">   12229 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   12230 </span>            : c_parser_omp_clause_nowait (c_parser *parser ATTRIBUTE_UNUSED, tree list)
<span class="lineNum">   12231 </span>            : {
<span class="lineNum">   12232 </span>            :   tree c;
<span class="lineNum">   12233 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   12234 </span>            : 
<span class="lineNum">   12235 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_NOWAIT, &quot;nowait&quot;);
<span class="lineNum">   12236 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   12237 </span>            :   c = build_omp_clause (loc, OMP_CLAUSE_NOWAIT);
<span class="lineNum">   12238 </span><span class="lineCov">          1 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   12239 </span>            :   return c;
<span class="lineNum">   12240 </span>            : }
<span class="lineNum">   12241 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   12242 </span>            : /* OpenMP 2.5:
<span class="lineNum">   12243 </span><span class="lineCov">          1 :    num_threads ( expression ) */</span>
<a name="12244"><span class="lineNum">   12244 </span>            : </a>
<span class="lineNum">   12245 </span><span class="lineCov">          1 : static tree</span>
<span class="lineNum">   12246 </span>            : c_parser_omp_clause_num_threads (c_parser *parser, tree list)
<span class="lineNum">   12247 </span><span class="lineCov">          1 : {</span>
<span class="lineNum">   12248 </span>            :   location_t num_threads_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   12249 </span>            :   matching_parens parens;
<span class="lineNum">   12250 </span>            :   if (parens.require_open (parser))
<span class="lineNum">   12251 </span>            :     {
<span class="lineNum">   12252 </span>            :       location_t expr_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   12253 </span>            :       c_expr expr = c_parser_expression (parser);
<span class="lineNum">   12254 </span><span class="lineCov">        183 :       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);</span>
<span class="lineNum">   12255 </span>            :       tree c, t = expr.value;
<span class="lineNum">   12256 </span><span class="lineCov">        183 :       t = c_fully_fold (t, false, NULL);</span>
<span class="lineNum">   12257 </span><span class="lineCov">        183 : </span>
<span class="lineNum">   12258 </span>            :       parens.skip_until_found_close (parser);
<span class="lineNum">   12259 </span><span class="lineCov">        183 : </span>
<span class="lineNum">   12260 </span>            :       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))
<span class="lineNum">   12261 </span><span class="lineCov">        183 :         {</span>
<span class="lineNum">   12262 </span><span class="lineCov">        183 :           c_parser_error (parser, &quot;expected integer expression&quot;);</span>
<span class="lineNum">   12263 </span><span class="lineCov">        183 :           return list;</span>
<span class="lineNum">   12264 </span>            :         }
<span class="lineNum">   12265 </span>            : 
<span class="lineNum">   12266 </span>            :       /* Attempt to statically determine when the number isn't positive.  */
<span class="lineNum">   12267 </span>            :       c = fold_build2_loc (expr_loc, LE_EXPR, boolean_type_node, t,
<span class="lineNum">   12268 </span>            :                        build_int_cst (TREE_TYPE (t), 0));
<span class="lineNum">   12269 </span>            :       protected_set_expr_location (c, expr_loc);
<span class="lineNum">   12270 </span><span class="lineCov">        227 :       if (c == boolean_true_node)</span>
<span class="lineNum">   12271 </span>            :         {
<span class="lineNum">   12272 </span><span class="lineCov">        227 :           warning_at (expr_loc, 0,</span>
<span class="lineNum">   12273 </span><span class="lineCov">        454 :                       &quot;%&lt;num_threads%&gt; value must be positive&quot;);</span>
<span class="lineNum">   12274 </span><span class="lineCov">        227 :           t = integer_one_node;</span>
<span class="lineNum">   12275 </span>            :         }
<span class="lineNum">   12276 </span><span class="lineCov">        227 : </span>
<span class="lineNum">   12277 </span><span class="lineCov">        227 :       check_no_duplicate_clause (list, OMP_CLAUSE_NUM_THREADS, &quot;num_threads&quot;);</span>
<span class="lineNum">   12278 </span><span class="lineCov">        227 : </span>
<span class="lineNum">   12279 </span><span class="lineCov">        227 :       c = build_omp_clause (num_threads_loc, OMP_CLAUSE_NUM_THREADS);</span>
<span class="lineNum">   12280 </span><span class="lineCov">        227 :       OMP_CLAUSE_NUM_THREADS_EXPR (c) = t;</span>
<span class="lineNum">   12281 </span>            :       OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   12282 </span><span class="lineCov">        227 :       list = c;</span>
<span class="lineNum">   12283 </span>            :     }
<span class="lineNum">   12284 </span><span class="lineCov">        227 : </span>
<span class="lineNum">   12285 </span>            :   return list;
<span class="lineNum">   12286 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   12287 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   12288 </span>            : /* OpenMP 4.5:
<span class="lineNum">   12289 </span>            :    num_tasks ( expression ) */
<a name="12290"><span class="lineNum">   12290 </span>            : </a>
<span class="lineNum">   12291 </span><span class="lineCov">        227 : static tree</span>
<span class="lineNum">   12292 </span><span class="lineCov">        681 : c_parser_omp_clause_num_tasks (c_parser *parser, tree list)</span>
<span class="lineNum">   12293 </span><span class="lineCov">        227 : {</span>
<span class="lineNum">   12294 </span><span class="lineCov">        227 :   location_t num_tasks_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   12295 </span>            :   matching_parens parens;
<span class="lineNum">   12296 </span><span class="lineCov">          1 :   if (parens.require_open (parser))</span>
<span class="lineNum">   12297 </span>            :     {
<span class="lineNum">   12298 </span><span class="lineCov">          1 :       location_t expr_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   12299 </span>            :       c_expr expr = c_parser_expression (parser);
<span class="lineNum">   12300 </span>            :       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);
<span class="lineNum">   12301 </span><span class="lineCov">        227 :       tree c, t = expr.value;</span>
<span class="lineNum">   12302 </span>            :       t = c_fully_fold (t, false, NULL);
<span class="lineNum">   12303 </span><span class="lineCov">        227 : </span>
<span class="lineNum">   12304 </span><span class="lineCov">        227 :       parens.skip_until_found_close (parser);</span>
<span class="lineNum">   12305 </span><span class="lineCov">        227 : </span>
<span class="lineNum">   12306 </span><span class="lineCov">        227 :       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))</span>
<span class="lineNum">   12307 </span>            :         {
<span class="lineNum">   12308 </span>            :           c_parser_error (parser, &quot;expected integer expression&quot;);
<span class="lineNum">   12309 </span>            :           return list;
<span class="lineNum">   12310 </span>            :         }
<span class="lineNum">   12311 </span>            : 
<span class="lineNum">   12312 </span>            :       /* Attempt to statically determine when the number isn't positive.  */
<span class="lineNum">   12313 </span>            :       c = fold_build2_loc (expr_loc, LE_EXPR, boolean_type_node, t,
<span class="lineNum">   12314 </span>            :                            build_int_cst (TREE_TYPE (t), 0));
<span class="lineNum">   12315 </span>            :       if (CAN_HAVE_LOCATION_P (c))
<span class="lineNum">   12316 </span><span class="lineCov">          3 :         SET_EXPR_LOCATION (c, expr_loc);</span>
<span class="lineNum">   12317 </span>            :       if (c == boolean_true_node)
<span class="lineNum">   12318 </span><span class="lineCov">          3 :         {</span>
<span class="lineNum">   12319 </span><span class="lineCov">          6 :           warning_at (expr_loc, 0, &quot;%&lt;num_tasks%&gt; value must be positive&quot;);</span>
<span class="lineNum">   12320 </span><span class="lineCov">          3 :           t = integer_one_node;</span>
<span class="lineNum">   12321 </span>            :         }
<span class="lineNum">   12322 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   12323 </span><span class="lineCov">          3 :       check_no_duplicate_clause (list, OMP_CLAUSE_NUM_TASKS, &quot;num_tasks&quot;);</span>
<span class="lineNum">   12324 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   12325 </span><span class="lineCov">          3 :       c = build_omp_clause (num_tasks_loc, OMP_CLAUSE_NUM_TASKS);</span>
<span class="lineNum">   12326 </span><span class="lineCov">          3 :       OMP_CLAUSE_NUM_TASKS_EXPR (c) = t;</span>
<span class="lineNum">   12327 </span>            :       OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   12328 </span><span class="lineCov">          3 :       list = c;</span>
<span class="lineNum">   12329 </span>            :     }
<span class="lineNum">   12330 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   12331 </span>            :   return list;
<span class="lineNum">   12332 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   12333 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   12334 </span>            : /* OpenMP 4.5:
<span class="lineNum">   12335 </span>            :    grainsize ( expression ) */
<a name="12336"><span class="lineNum">   12336 </span>            : </a>
<span class="lineNum">   12337 </span><span class="lineCov">          3 : static tree</span>
<span class="lineNum">   12338 </span><span class="lineCov">          9 : c_parser_omp_clause_grainsize (c_parser *parser, tree list)</span>
<span class="lineNum">   12339 </span><span class="lineCov">          3 : {</span>
<span class="lineNum">   12340 </span><span class="lineCov">          6 :   location_t grainsize_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   12341 </span><span class="lineCov">          3 :   matching_parens parens;</span>
<span class="lineNum">   12342 </span>            :   if (parens.require_open (parser))
<span class="lineNum">   12343 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   12344 </span><span class="lineNoCov">          0 :       location_t expr_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   12345 </span>            :       c_expr expr = c_parser_expression (parser);
<span class="lineNum">   12346 </span>            :       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);
<span class="lineNum">   12347 </span><span class="lineCov">          3 :       tree c, t = expr.value;</span>
<span class="lineNum">   12348 </span>            :       t = c_fully_fold (t, false, NULL);
<span class="lineNum">   12349 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   12350 </span><span class="lineCov">          3 :       parens.skip_until_found_close (parser);</span>
<span class="lineNum">   12351 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   12352 </span><span class="lineCov">          3 :       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))</span>
<span class="lineNum">   12353 </span>            :         {
<span class="lineNum">   12354 </span>            :           c_parser_error (parser, &quot;expected integer expression&quot;);
<span class="lineNum">   12355 </span>            :           return list;
<span class="lineNum">   12356 </span>            :         }
<span class="lineNum">   12357 </span>            : 
<span class="lineNum">   12358 </span>            :       /* Attempt to statically determine when the number isn't positive.  */
<span class="lineNum">   12359 </span>            :       c = fold_build2_loc (expr_loc, LE_EXPR, boolean_type_node, t,
<span class="lineNum">   12360 </span>            :                            build_int_cst (TREE_TYPE (t), 0));
<span class="lineNum">   12361 </span>            :       if (CAN_HAVE_LOCATION_P (c))
<span class="lineNum">   12362 </span><span class="lineCov">          3 :         SET_EXPR_LOCATION (c, expr_loc);</span>
<span class="lineNum">   12363 </span>            :       if (c == boolean_true_node)
<span class="lineNum">   12364 </span><span class="lineCov">          3 :         {</span>
<span class="lineNum">   12365 </span><span class="lineCov">          6 :           warning_at (expr_loc, 0, &quot;%&lt;grainsize%&gt; value must be positive&quot;);</span>
<span class="lineNum">   12366 </span><span class="lineCov">          3 :           t = integer_one_node;</span>
<span class="lineNum">   12367 </span>            :         }
<span class="lineNum">   12368 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   12369 </span><span class="lineCov">          3 :       check_no_duplicate_clause (list, OMP_CLAUSE_GRAINSIZE, &quot;grainsize&quot;);</span>
<span class="lineNum">   12370 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   12371 </span><span class="lineCov">          3 :       c = build_omp_clause (grainsize_loc, OMP_CLAUSE_GRAINSIZE);</span>
<span class="lineNum">   12372 </span><span class="lineCov">          3 :       OMP_CLAUSE_GRAINSIZE_EXPR (c) = t;</span>
<span class="lineNum">   12373 </span>            :       OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   12374 </span><span class="lineCov">          3 :       list = c;</span>
<span class="lineNum">   12375 </span>            :     }
<span class="lineNum">   12376 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   12377 </span>            :   return list;
<span class="lineNum">   12378 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   12379 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   12380 </span>            : /* OpenMP 4.5:
<span class="lineNum">   12381 </span>            :    priority ( expression ) */
<a name="12382"><span class="lineNum">   12382 </span>            : </a>
<span class="lineNum">   12383 </span><span class="lineCov">          3 : static tree</span>
<span class="lineNum">   12384 </span><span class="lineCov">          9 : c_parser_omp_clause_priority (c_parser *parser, tree list)</span>
<span class="lineNum">   12385 </span><span class="lineCov">          3 : {</span>
<span class="lineNum">   12386 </span><span class="lineCov">          6 :   location_t priority_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   12387 </span><span class="lineCov">          3 :   matching_parens parens;</span>
<span class="lineNum">   12388 </span>            :   if (parens.require_open (parser))
<span class="lineNum">   12389 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   12390 </span><span class="lineNoCov">          0 :       location_t expr_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   12391 </span>            :       c_expr expr = c_parser_expression (parser);
<span class="lineNum">   12392 </span>            :       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);
<span class="lineNum">   12393 </span><span class="lineCov">          3 :       tree c, t = expr.value;</span>
<span class="lineNum">   12394 </span>            :       t = c_fully_fold (t, false, NULL);
<span class="lineNum">   12395 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   12396 </span><span class="lineCov">          3 :       parens.skip_until_found_close (parser);</span>
<span class="lineNum">   12397 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   12398 </span><span class="lineCov">          3 :       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))</span>
<span class="lineNum">   12399 </span>            :         {
<span class="lineNum">   12400 </span>            :           c_parser_error (parser, &quot;expected integer expression&quot;);
<span class="lineNum">   12401 </span>            :           return list;
<span class="lineNum">   12402 </span>            :         }
<span class="lineNum">   12403 </span>            : 
<span class="lineNum">   12404 </span>            :       /* Attempt to statically determine when the number isn't
<span class="lineNum">   12405 </span>            :          non-negative.  */
<span class="lineNum">   12406 </span>            :       c = fold_build2_loc (expr_loc, LT_EXPR, boolean_type_node, t,
<span class="lineNum">   12407 </span>            :                            build_int_cst (TREE_TYPE (t), 0));
<span class="lineNum">   12408 </span><span class="lineCov">          8 :       if (CAN_HAVE_LOCATION_P (c))</span>
<span class="lineNum">   12409 </span>            :         SET_EXPR_LOCATION (c, expr_loc);
<span class="lineNum">   12410 </span><span class="lineCov">          8 :       if (c == boolean_true_node)</span>
<span class="lineNum">   12411 </span><span class="lineCov">         16 :         {</span>
<span class="lineNum">   12412 </span><span class="lineCov">          8 :           warning_at (expr_loc, 0, &quot;%&lt;priority%&gt; value must be non-negative&quot;);</span>
<span class="lineNum">   12413 </span>            :           t = integer_one_node;
<span class="lineNum">   12414 </span><span class="lineCov">          8 :         }</span>
<span class="lineNum">   12415 </span><span class="lineCov">          8 : </span>
<span class="lineNum">   12416 </span><span class="lineCov">          8 :       check_no_duplicate_clause (list, OMP_CLAUSE_PRIORITY, &quot;priority&quot;);</span>
<span class="lineNum">   12417 </span><span class="lineCov">          8 : </span>
<span class="lineNum">   12418 </span><span class="lineCov">          8 :       c = build_omp_clause (priority_loc, OMP_CLAUSE_PRIORITY);</span>
<span class="lineNum">   12419 </span>            :       OMP_CLAUSE_PRIORITY_EXPR (c) = t;
<span class="lineNum">   12420 </span><span class="lineCov">          8 :       OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   12421 </span>            :       list = c;
<span class="lineNum">   12422 </span><span class="lineCov">          8 :     }</span>
<span class="lineNum">   12423 </span>            : 
<span class="lineNum">   12424 </span><span class="lineNoCov">          0 :   return list;</span>
<span class="lineNum">   12425 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   12426 </span>            : 
<span class="lineNum">   12427 </span>            : /* OpenMP 4.5:
<span class="lineNum">   12428 </span>            :    hint ( expression ) */
<a name="12429"><span class="lineNum">   12429 </span>            : </a>
<span class="lineNum">   12430 </span><span class="lineCov">          8 : static tree</span>
<span class="lineNum">   12431 </span><span class="lineCov">         24 : c_parser_omp_clause_hint (c_parser *parser, tree list)</span>
<span class="lineNum">   12432 </span><span class="lineCov">          8 : {</span>
<span class="lineNum">   12433 </span><span class="lineCov">         12 :   location_t hint_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   12434 </span><span class="lineCov">          8 :   matching_parens parens;</span>
<span class="lineNum">   12435 </span>            :   if (parens.require_open (parser))
<span class="lineNum">   12436 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   12437 </span><span class="lineNoCov">          0 :       location_t expr_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   12438 </span>            :       c_expr expr = c_parser_expression (parser);
<span class="lineNum">   12439 </span>            :       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);
<span class="lineNum">   12440 </span><span class="lineCov">          8 :       tree c, t = expr.value;</span>
<span class="lineNum">   12441 </span>            :       t = c_fully_fold (t, false, NULL);
<span class="lineNum">   12442 </span><span class="lineCov">          8 : </span>
<span class="lineNum">   12443 </span><span class="lineCov">          8 :       parens.skip_until_found_close (parser);</span>
<span class="lineNum">   12444 </span><span class="lineCov">          8 : </span>
<span class="lineNum">   12445 </span><span class="lineCov">          8 :       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))</span>
<span class="lineNum">   12446 </span>            :         {
<span class="lineNum">   12447 </span>            :           c_parser_error (parser, &quot;expected integer expression&quot;);
<span class="lineNum">   12448 </span>            :           return list;
<span class="lineNum">   12449 </span>            :         }
<span class="lineNum">   12450 </span>            : 
<span class="lineNum">   12451 </span>            :       check_no_duplicate_clause (list, OMP_CLAUSE_HINT, &quot;hint&quot;);
<span class="lineNum">   12452 </span>            : 
<span class="lineNum">   12453 </span>            :       c = build_omp_clause (hint_loc, OMP_CLAUSE_HINT);
<span class="lineNum">   12454 </span>            :       OMP_CLAUSE_HINT_EXPR (c) = t;
<span class="lineNum">   12455 </span><span class="lineNoCov">          0 :       OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   12456 </span>            :       list = c;
<span class="lineNum">   12457 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   12458 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   12459 </span><span class="lineNoCov">          0 :   return list;</span>
<span class="lineNum">   12460 </span>            : }
<span class="lineNum">   12461 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   12462 </span><span class="lineNoCov">          0 : /* OpenMP 4.5:</span>
<span class="lineNum">   12463 </span><span class="lineNoCov">          0 :    defaultmap ( tofrom : scalar ) */</span>
<a name="12464"><span class="lineNum">   12464 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   12465 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   12466 </span>            : c_parser_omp_clause_defaultmap (c_parser *parser, tree list)
<span class="lineNum">   12467 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   12468 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   12469 </span><span class="lineNoCov">          0 :   tree c;</span>
<span class="lineNum">   12470 </span>            :   const char *p;
<span class="lineNum">   12471 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   12472 </span><span class="lineNoCov">          0 :   matching_parens parens;</span>
<span class="lineNum">   12473 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   12474 </span>            :     return list;
<span class="lineNum">   12475 </span><span class="lineNoCov">          0 :   if (!c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">   12476 </span>            :     {
<span class="lineNum">   12477 </span><span class="lineNoCov">          0 :       c_parser_error (parser, &quot;expected %&lt;tofrom%&gt;&quot;);</span>
<span class="lineNum">   12478 </span><span class="lineNoCov">          0 :       goto out_err;</span>
<span class="lineNum">   12479 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   12480 </span><span class="lineNoCov">          0 :   p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">   12481 </span>            :   if (strcmp (p, &quot;tofrom&quot;) != 0)
<span class="lineNum">   12482 </span>            :     {
<span class="lineNum">   12483 </span>            :       c_parser_error (parser, &quot;expected %&lt;tofrom%&gt;&quot;);
<span class="lineNum">   12484 </span>            :       goto out_err;
<span class="lineNum">   12485 </span>            :     }
<span class="lineNum">   12486 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">   12487 </span>            :   if (!c_parser_require (parser, CPP_COLON, &quot;expected %&lt;:%&gt;&quot;))
<span class="lineNum">   12488 </span>            :     goto out_err;
<span class="lineNum">   12489 </span>            :   if (!c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   12490 </span><span class="lineCov">         14 :     {</span>
<span class="lineNum">   12491 </span>            :       c_parser_error (parser, &quot;expected %&lt;scalar%&gt;&quot;);
<span class="lineNum">   12492 </span><span class="lineCov">         14 :       goto out_err;</span>
<span class="lineNum">   12493 </span><span class="lineCov">         14 :     }</span>
<span class="lineNum">   12494 </span><span class="lineCov">         14 :   p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">   12495 </span>            :   if (strcmp (p, &quot;scalar&quot;) != 0)
<span class="lineNum">   12496 </span><span class="lineCov">         28 :     {</span>
<span class="lineNum">   12497 </span><span class="lineCov">         14 :       c_parser_error (parser, &quot;expected %&lt;scalar%&gt;&quot;);</span>
<span class="lineNum">   12498 </span>            :       goto out_err;
<span class="lineNum">   12499 </span><span class="lineCov">         14 :     }</span>
<span class="lineNum">   12500 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">   12501 </span><span class="lineNoCov">          0 :   parens.skip_until_found_close (parser);</span>
<span class="lineNum">   12502 </span><span class="lineNoCov">          0 :   check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULTMAP, &quot;defaultmap&quot;);</span>
<span class="lineNum">   12503 </span>            :   c = build_omp_clause (loc, OMP_CLAUSE_DEFAULTMAP);
<span class="lineNum">   12504 </span><span class="lineCov">         14 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   12505 </span><span class="lineCov">         14 :   return c;</span>
<span class="lineNum">   12506 </span>            : 
<span class="lineNum">   12507 </span><span class="lineNoCov">          0 :  out_err:</span>
<span class="lineNum">   12508 </span><span class="lineNoCov">          0 :   parens.skip_until_found_close (parser);</span>
<span class="lineNum">   12509 </span>            :   return list;
<span class="lineNum">   12510 </span><span class="lineCov">         14 : }</span>
<span class="lineNum">   12511 </span><span class="lineCov">         14 : </span>
<span class="lineNum">   12512 </span>            : /* OpenACC 2.0:
<span class="lineNum">   12513 </span><span class="lineCov">         14 :    use_device ( variable-list )</span>
<span class="lineNum">   12514 </span>            : 
<span class="lineNum">   12515 </span><span class="lineNoCov">          0 :    OpenMP 4.5:</span>
<span class="lineNum">   12516 </span><span class="lineNoCov">          0 :    use_device_ptr ( variable-list ) */</span>
<a name="12517"><span class="lineNum">   12517 </span>            : </a>
<span class="lineNum">   12518 </span><span class="lineCov">         14 : static tree</span>
<span class="lineNum">   12519 </span><span class="lineCov">         14 : c_parser_omp_clause_use_device_ptr (c_parser *parser, tree list)</span>
<span class="lineNum">   12520 </span>            : {
<span class="lineNum">   12521 </span><span class="lineNoCov">          0 :   return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_USE_DEVICE_PTR,</span>
<span class="lineNum">   12522 </span><span class="lineNoCov">          0 :                                        list);</span>
<span class="lineNum">   12523 </span>            : }
<span class="lineNum">   12524 </span><span class="lineCov">         14 : </span>
<span class="lineNum">   12525 </span><span class="lineCov">         14 : /* OpenMP 4.5:</span>
<span class="lineNum">   12526 </span><span class="lineCov">         14 :    is_device_ptr ( variable-list ) */</span>
<a name="12527"><span class="lineNum">   12527 </span><span class="lineCov">         14 : </span></a>
<span class="lineNum">   12528 </span><span class="lineCov">         14 : static tree</span>
<span class="lineNum">   12529 </span><span class="lineCov">         14 : c_parser_omp_clause_is_device_ptr (c_parser *parser, tree list)</span>
<span class="lineNum">   12530 </span>            : {
<span class="lineNum">   12531 </span><span class="lineNoCov">          0 :   return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_IS_DEVICE_PTR, list);</span>
<span class="lineNum">   12532 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   12533 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   12534 </span>            : /* OpenACC:
<span class="lineNum">   12535 </span>            :    num_gangs ( expression )
<span class="lineNum">   12536 </span>            :    num_workers ( expression )
<span class="lineNum">   12537 </span>            :    vector_length ( expression )  */
<a name="12538"><span class="lineNum">   12538 </span>            : </a>
<span class="lineNum">   12539 </span>            : static tree
<span class="lineNum">   12540 </span>            : c_parser_oacc_single_int_clause (c_parser *parser, omp_clause_code code,
<span class="lineNum">   12541 </span>            :                                  tree list)
<span class="lineNum">   12542 </span>            : {
<span class="lineNum">   12543 </span><span class="lineNoCov">          0 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   12544 </span>            : 
<span class="lineNum">   12545 </span><span class="lineNoCov">          0 :   matching_parens parens;</span>
<span class="lineNum">   12546 </span><span class="lineNoCov">          0 :   if (!parens.require_open (parser))</span>
<span class="lineNum">   12547 </span>            :     return list;
<span class="lineNum">   12548 </span>            : 
<span class="lineNum">   12549 </span>            :   location_t expr_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   12550 </span>            :   c_expr expr = c_parser_expression (parser);
<span class="lineNum">   12551 </span>            :   expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);
<span class="lineNum">   12552 </span>            :   tree c, t = expr.value;
<span class="lineNum">   12553 </span><span class="lineNoCov">          0 :   t = c_fully_fold (t, false, NULL);</span>
<span class="lineNum">   12554 </span>            : 
<span class="lineNum">   12555 </span><span class="lineNoCov">          0 :   parens.skip_until_found_close (parser);</span>
<span class="lineNum">   12556 </span>            : 
<span class="lineNum">   12557 </span>            :   if (t == error_mark_node)
<span class="lineNum">   12558 </span>            :     return list;
<span class="lineNum">   12559 </span>            :   else if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))
<span class="lineNum">   12560 </span>            :     {
<span class="lineNum">   12561 </span>            :       error_at (expr_loc, &quot;%qs expression must be integral&quot;,
<span class="lineNum">   12562 </span>            :                 omp_clause_code_name[code]);
<span class="lineNum">   12563 </span>            :       return list;
<span class="lineNum">   12564 </span><span class="lineCov">        684 :     }</span>
<span class="lineNum">   12565 </span>            : 
<span class="lineNum">   12566 </span>            :   /* Attempt to statically determine when the number isn't positive.  */
<span class="lineNum">   12567 </span><span class="lineCov">        684 :   c = fold_build2_loc (expr_loc, LE_EXPR, boolean_type_node, t,</span>
<span class="lineNum">   12568 </span>            :                        build_int_cst (TREE_TYPE (t), 0));
<span class="lineNum">   12569 </span><span class="lineCov">       1368 :   protected_set_expr_location (c, expr_loc);</span>
<span class="lineNum">   12570 </span><span class="lineCov">        684 :   if (c == boolean_true_node)</span>
<span class="lineNum">   12571 </span>            :     {
<span class="lineNum">   12572 </span>            :       warning_at (expr_loc, 0,
<span class="lineNum">   12573 </span><span class="lineCov">        678 :                   &quot;%qs value must be positive&quot;,</span>
<span class="lineNum">   12574 </span><span class="lineCov">        678 :                   omp_clause_code_name[code]);</span>
<span class="lineNum">   12575 </span><span class="lineCov">        678 :       t = integer_one_node;</span>
<span class="lineNum">   12576 </span><span class="lineCov">        678 :     }</span>
<span class="lineNum">   12577 </span><span class="lineCov">        678 : </span>
<span class="lineNum">   12578 </span>            :   check_no_duplicate_clause (list, code, omp_clause_code_name[code]);
<span class="lineNum">   12579 </span><span class="lineCov">        678 : </span>
<span class="lineNum">   12580 </span>            :   c = build_omp_clause (loc, code);
<span class="lineNum">   12581 </span><span class="lineCov">        678 :   OMP_CLAUSE_OPERAND (c, 0) = t;</span>
<span class="lineNum">   12582 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   12583 </span><span class="lineCov">        654 :   return c;</span>
<span class="lineNum">   12584 </span>            : }
<span class="lineNum">   12585 </span><span class="lineCov">         32 : </span>
<span class="lineNum">   12586 </span><span class="lineCov">         16 : /* OpenACC:</span>
<span class="lineNum">   12587 </span><span class="lineCov">         16 : </span>
<span class="lineNum">   12588 </span>            :     gang [( gang-arg-list )]
<span class="lineNum">   12589 </span>            :     worker [( [num:] int-expr )]
<span class="lineNum">   12590 </span>            :     vector [( [length:] int-expr )]
<span class="lineNum">   12591 </span><span class="lineCov">        638 : </span>
<span class="lineNum">   12592 </span><span class="lineCov">       1914 :   where gang-arg is one of:</span>
<span class="lineNum">   12593 </span><span class="lineCov">        638 : </span>
<span class="lineNum">   12594 </span><span class="lineCov">        638 :     [num:] int-expr</span>
<span class="lineNum">   12595 </span>            :     static: size-expr
<span class="lineNum">   12596 </span><span class="lineCov">         36 : </span>
<span class="lineNum">   12597 </span>            :   and size-expr may be:
<span class="lineNum">   12598 </span><span class="lineCov">         18 : </span>
<span class="lineNum">   12599 </span><span class="lineCov">         18 :     *</span>
<span class="lineNum">   12600 </span>            :     int-expr
<span class="lineNum">   12601 </span>            : */
<a name="12602"><span class="lineNum">   12602 </span><span class="lineCov">        638 : </span></a>
<span class="lineNum">   12603 </span>            : static tree
<span class="lineNum">   12604 </span><span class="lineCov">        638 : c_parser_oacc_shape_clause (c_parser *parser, omp_clause_code kind,</span>
<span class="lineNum">   12605 </span><span class="lineCov">        638 :                             const char *str, tree list)</span>
<span class="lineNum">   12606 </span><span class="lineCov">        638 : {</span>
<span class="lineNum">   12607 </span><span class="lineCov">        638 :   const char *id = &quot;num&quot;;</span>
<span class="lineNum">   12608 </span>            :   tree ops[2] = { NULL_TREE, NULL_TREE }, c;
<span class="lineNum">   12609 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   12610 </span>            : 
<span class="lineNum">   12611 </span>            :   if (kind == OMP_CLAUSE_VECTOR)
<span class="lineNum">   12612 </span>            :     id = &quot;length&quot;;
<span class="lineNum">   12613 </span>            : 
<span class="lineNum">   12614 </span>            :   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))
<span class="lineNum">   12615 </span>            :     {
<span class="lineNum">   12616 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   12617 </span>            : 
<span class="lineNum">   12618 </span>            :       do
<span class="lineNum">   12619 </span>            :         {
<span class="lineNum">   12620 </span>            :           c_token *next = c_parser_peek_token (parser);
<span class="lineNum">   12621 </span>            :           int idx = 0;
<span class="lineNum">   12622 </span>            : 
<span class="lineNum">   12623 </span>            :           /* Gang static argument.  */
<span class="lineNum">   12624 </span>            :           if (kind == OMP_CLAUSE_GANG
<span class="lineNum">   12625 </span>            :               &amp;&amp; c_parser_next_token_is_keyword (parser, RID_STATIC))
<span class="lineNum">   12626 </span>            :             {
<span class="lineNum">   12627 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">   12628 </span><span class="lineCov">       1009 : </span>
<span class="lineNum">   12629 </span>            :               if (!c_parser_require (parser, CPP_COLON, &quot;expected %&lt;:%&gt;&quot;))
<span class="lineNum">   12630 </span>            :                 goto cleanup_error;
<span class="lineNum">   12631 </span><span class="lineCov">       1009 : </span>
<span class="lineNum">   12632 </span><span class="lineCov">       1009 :               idx = 1;</span>
<span class="lineNum">   12633 </span><span class="lineCov">       1009 :               if (ops[idx] != NULL_TREE)</span>
<span class="lineNum">   12634 </span>            :                 {
<span class="lineNum">   12635 </span><span class="lineCov">       1009 :                   c_parser_error (parser, &quot;too many %&lt;static%&gt; arguments&quot;);</span>
<span class="lineNum">   12636 </span><span class="lineCov">        325 :                   goto cleanup_error;</span>
<span class="lineNum">   12637 </span>            :                 }
<span class="lineNum">   12638 </span><span class="lineCov">       1009 : </span>
<span class="lineNum">   12639 </span>            :               /* Check for the '*' argument.  */
<span class="lineNum">   12640 </span><span class="lineCov">        210 :               if (c_parser_next_token_is (parser, CPP_MULT)</span>
<span class="lineNum">   12641 </span>            :                   &amp;&amp; (c_parser_peek_2nd_token (parser)-&gt;type == CPP_COMMA
<span class="lineNum">   12642 </span><span class="lineCov">        225 :                       || c_parser_peek_2nd_token (parser)-&gt;type</span>
<span class="lineNum">   12643 </span>            :                          == CPP_CLOSE_PAREN))
<span class="lineNum">   12644 </span><span class="lineCov">        225 :                 {</span>
<span class="lineNum">   12645 </span><span class="lineCov">        225 :                   c_parser_consume_token (parser);</span>
<span class="lineNum">   12646 </span>            :                   ops[idx] = integer_minus_one_node;
<span class="lineNum">   12647 </span>            : 
<span class="lineNum">   12648 </span><span class="lineCov">        225 :                   if (c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">   12649 </span><span class="lineCov">        225 :                     {</span>
<span class="lineNum">   12650 </span>            :                       c_parser_consume_token (parser);
<span class="lineNum">   12651 </span><span class="lineCov">         64 :                       continue;</span>
<span class="lineNum">   12652 </span>            :                     }
<span class="lineNum">   12653 </span><span class="lineCov">         64 :                   else</span>
<span class="lineNum">   12654 </span><span class="lineCov">         12 :                     break;</span>
<span class="lineNum">   12655 </span>            :                 }
<span class="lineNum">   12656 </span><span class="lineCov">         64 :             }</span>
<span class="lineNum">   12657 </span><span class="lineCov">         64 :           /* Worker num: argument and vector length: arguments.  */</span>
<span class="lineNum">   12658 </span>            :           else if (c_parser_next_token_is (parser, CPP_NAME)
<span class="lineNum">   12659 </span><span class="lineNoCov">          0 :                    &amp;&amp; strcmp (id, IDENTIFIER_POINTER (next-&gt;value)) == 0</span>
<span class="lineNum">   12660 </span><span class="lineNoCov">          0 :                    &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type == CPP_COLON)</span>
<span class="lineNum">   12661 </span>            :             {
<span class="lineNum">   12662 </span>            :               c_parser_consume_token (parser);  /* id  */
<span class="lineNum">   12663 </span>            :               c_parser_consume_token (parser);  /* ':'  */
<span class="lineNum">   12664 </span><span class="lineCov">         64 :             }</span>
<span class="lineNum">   12665 </span><span class="lineCov">         64 : </span>
<span class="lineNum">   12666 </span><span class="lineCov">         27 :           /* Now collect the actual argument.  */</span>
<span class="lineNum">   12667 </span>            :           if (ops[idx] != NULL_TREE)
<span class="lineNum">   12668 </span>            :             {
<span class="lineNum">   12669 </span><span class="lineCov">         26 :               c_parser_error (parser, &quot;unexpected argument&quot;);</span>
<span class="lineNum">   12670 </span><span class="lineCov">         26 :               goto cleanup_error;</span>
<span class="lineNum">   12671 </span>            :             }
<span class="lineNum">   12672 </span><span class="lineCov">         26 : </span>
<span class="lineNum">   12673 </span>            :           location_t expr_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   12674 </span><span class="lineCov">          1 :           c_expr cexpr = c_parser_expr_no_commas (parser, NULL);</span>
<span class="lineNum">   12675 </span><span class="lineCov">          1 :           cexpr = convert_lvalue_to_rvalue (expr_loc, cexpr, false, true);</span>
<span class="lineNum">   12676 </span>            :           tree expr = cexpr.value;
<span class="lineNum">   12677 </span>            :           if (expr == error_mark_node)
<span class="lineNum">   12678 </span>            :             goto cleanup_error;
<span class="lineNum">   12679 </span>            : 
<span class="lineNum">   12680 </span>            :           expr = c_fully_fold (expr, false, NULL);
<span class="lineNum">   12681 </span>            : 
<span class="lineNum">   12682 </span><span class="lineCov">        161 :           /* Attempt to statically determine when the number isn't a</span>
<span class="lineNum">   12683 </span><span class="lineCov">        125 :              positive integer.  */</span>
<span class="lineNum">   12684 </span><span class="lineCov">        270 : </span>
<span class="lineNum">   12685 </span>            :           if (!INTEGRAL_TYPE_P (TREE_TYPE (expr)))
<span class="lineNum">   12686 </span><span class="lineCov">        103 :             {</span>
<span class="lineNum">   12687 </span><span class="lineCov">        103 :               c_parser_error (parser, &quot;expected integer expression&quot;);</span>
<span class="lineNum">   12688 </span>            :               return list;
<span class="lineNum">   12689 </span>            :             }
<span class="lineNum">   12690 </span>            : 
<span class="lineNum">   12691 </span><span class="lineCov">        199 :           tree c = fold_build2_loc (expr_loc, LE_EXPR, boolean_type_node, expr,</span>
<span class="lineNum">   12692 </span>            :                                     build_int_cst (TREE_TYPE (expr), 0));
<span class="lineNum">   12693 </span><span class="lineCov">          5 :           if (c == boolean_true_node)</span>
<span class="lineNum">   12694 </span><span class="lineCov">          5 :             {</span>
<span class="lineNum">   12695 </span>            :               warning_at (loc, 0,
<span class="lineNum">   12696 </span>            :                           &quot;%qs value must be positive&quot;, str);
<span class="lineNum">   12697 </span><span class="lineCov">        194 :               expr = integer_one_node;</span>
<span class="lineNum">   12698 </span><span class="lineCov">        194 :             }</span>
<span class="lineNum">   12699 </span><span class="lineCov">        194 : </span>
<span class="lineNum">   12700 </span><span class="lineCov">        194 :           ops[idx] = expr;</span>
<span class="lineNum">   12701 </span><span class="lineCov">        194 : </span>
<span class="lineNum">   12702 </span>            :           if (kind == OMP_CLAUSE_GANG
<span class="lineNum">   12703 </span>            :               &amp;&amp; c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">   12704 </span><span class="lineCov">        187 :             {</span>
<span class="lineNum">   12705 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">   12706 </span>            :               continue;
<span class="lineNum">   12707 </span>            :             }
<span class="lineNum">   12708 </span>            :           break;
<span class="lineNum">   12709 </span><span class="lineCov">        187 :         }</span>
<span class="lineNum">   12710 </span>            :       while (1);
<span class="lineNum">   12711 </span><span class="lineCov">         14 : </span>
<span class="lineNum">   12712 </span><span class="lineCov">         14 :       if (!c_parser_require (parser, CPP_CLOSE_PAREN, &quot;expected %&lt;)%&gt;&quot;))</span>
<span class="lineNum">   12713 </span>            :         goto cleanup_error;
<span class="lineNum">   12714 </span>            :     }
<span class="lineNum">   12715 </span><span class="lineCov">        173 : </span>
<span class="lineNum">   12716 </span><span class="lineCov">        519 :   check_no_duplicate_clause (list, kind, str);</span>
<span class="lineNum">   12717 </span><span class="lineCov">        173 : </span>
<span class="lineNum">   12718 </span>            :   c = build_omp_clause (loc, kind);
<span class="lineNum">   12719 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   12720 </span>            :   if (ops[1])
<span class="lineNum">   12721 </span><span class="lineCov">          1 :     OMP_CLAUSE_OPERAND (c, 1) = ops[1];</span>
<span class="lineNum">   12722 </span>            : 
<span class="lineNum">   12723 </span>            :   OMP_CLAUSE_OPERAND (c, 0) = ops[0];
<span class="lineNum">   12724 </span><span class="lineCov">        173 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   12725 </span>            : 
<span class="lineNum">   12726 </span><span class="lineCov">        173 :   return c;</span>
<span class="lineNum">   12727 </span><span class="lineCov">        173 : </span>
<span class="lineNum">   12728 </span>            :  cleanup_error:
<span class="lineNum">   12729 </span><span class="lineCov">         14 :   c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, 0);</span>
<span class="lineNum">   12730 </span><span class="lineCov">         14 :   return list;</span>
<span class="lineNum">   12731 </span>            : }
<span class="lineNum">   12732 </span><span class="lineCov">         15 : </span>
<span class="lineNum">   12733 </span>            : /* OpenACC 2.5:
<span class="lineNum">   12734 </span>            :    auto
<span class="lineNum">   12735 </span>            :    finalize
<span class="lineNum">   12736 </span><span class="lineCov">        184 :    independent</span>
<span class="lineNum">   12737 </span>            :    nohost
<span class="lineNum">   12738 </span>            :    seq */
<a name="12739"><span class="lineNum">   12739 </span>            : </a>
<span class="lineNum">   12740 </span><span class="lineCov">        976 : static tree</span>
<span class="lineNum">   12741 </span>            : c_parser_oacc_simple_clause (c_parser *parser, enum omp_clause_code code,
<span class="lineNum">   12742 </span><span class="lineCov">        976 :                              tree list)</span>
<span class="lineNum">   12743 </span>            : {
<span class="lineNum">   12744 </span><span class="lineCov">        976 :   check_no_duplicate_clause (list, code, omp_clause_code_name[code]);</span>
<span class="lineNum">   12745 </span><span class="lineCov">         61 : </span>
<span class="lineNum">   12746 </span>            :   tree c = build_omp_clause (c_parser_peek_token (parser)-&gt;location, code);
<span class="lineNum">   12747 </span><span class="lineCov">        976 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   12748 </span><span class="lineCov">        976 : </span>
<span class="lineNum">   12749 </span>            :   return c;
<span class="lineNum">   12750 </span><span class="lineCov">        976 : }</span>
<span class="lineNum">   12751 </span>            : 
<span class="lineNum">   12752 </span><span class="lineCov">         19 : /* OpenACC:</span>
<span class="lineNum">   12753 </span><span class="lineCov">         19 :    async [( int-expr )] */</span>
<a name="12754"><span class="lineNum">   12754 </span><span class="lineCov">         19 : </span></a>
<span class="lineNum">   12755 </span>            : static tree
<span class="lineNum">   12756 </span>            : c_parser_oacc_clause_async (c_parser *parser, tree list)
<span class="lineNum">   12757 </span>            : {
<span class="lineNum">   12758 </span>            :   tree c, t;
<span class="lineNum">   12759 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   12760 </span>            : 
<span class="lineNum">   12761 </span>            :   t = build_int_cst (integer_type_node, GOMP_ASYNC_NOVAL);
<span class="lineNum">   12762 </span>            : 
<span class="lineNum">   12763 </span>            :   if (c_parser_peek_token (parser)-&gt;type == CPP_OPEN_PAREN)
<span class="lineNum">   12764 </span>            :     {
<span class="lineNum">   12765 </span><span class="lineCov">        242 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   12766 </span>            : 
<span class="lineNum">   12767 </span>            :       t = c_parser_expression (parser).value;
<span class="lineNum">   12768 </span><span class="lineCov">        242 :       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))</span>
<span class="lineNum">   12769 </span>            :         c_parser_error (parser, &quot;expected integer expression&quot;);
<span class="lineNum">   12770 </span><span class="lineCov">        242 :       else if (t == error_mark_node</span>
<span class="lineNum">   12771 </span><span class="lineCov">        242 :           || !c_parser_require (parser, CPP_CLOSE_PAREN, &quot;expected %&lt;)%&gt;&quot;))</span>
<span class="lineNum">   12772 </span>            :         return list;
<span class="lineNum">   12773 </span><span class="lineCov">        242 :     }</span>
<span class="lineNum">   12774 </span>            :   else
<span class="lineNum">   12775 </span>            :     t = c_fully_fold (t, false, NULL);
<span class="lineNum">   12776 </span>            : 
<span class="lineNum">   12777 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_ASYNC, &quot;async&quot;);
<span class="lineNum">   12778 </span>            : 
<span class="lineNum">   12779 </span>            :   c = build_omp_clause (loc, OMP_CLAUSE_ASYNC);
<span class="lineNum">   12780 </span><span class="lineCov">        165 :   OMP_CLAUSE_ASYNC_EXPR (c) = t;</span>
<span class="lineNum">   12781 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   12782 </span><span class="lineCov">        165 :   list = c;</span>
<span class="lineNum">   12783 </span><span class="lineCov">        165 : </span>
<span class="lineNum">   12784 </span>            :   return list;
<span class="lineNum">   12785 </span><span class="lineCov">        330 : }</span>
<span class="lineNum">   12786 </span>            : 
<span class="lineNum">   12787 </span><span class="lineCov">        165 : /* OpenACC 2.0:</span>
<span class="lineNum">   12788 </span>            :    tile ( size-expr-list ) */
<a name="12789"><span class="lineNum">   12789 </span><span class="lineCov">        133 : </span></a>
<span class="lineNum">   12790 </span>            : static tree
<span class="lineNum">   12791 </span><span class="lineCov">        133 : c_parser_oacc_clause_tile (c_parser *parser, tree list)</span>
<span class="lineNum">   12792 </span><span class="lineCov">        133 : {</span>
<span class="lineNum">   12793 </span><span class="lineCov">         13 :   tree c, expr = error_mark_node;</span>
<span class="lineNum">   12794 </span><span class="lineCov">        120 :   location_t loc;</span>
<span class="lineNum">   12795 </span><span class="lineCov">        120 :   tree tile = NULL_TREE;</span>
<span class="lineNum">   12796 </span><span class="lineCov">          7 : </span>
<span class="lineNum">   12797 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_TILE, &quot;tile&quot;);
<span class="lineNum">   12798 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_COLLAPSE, &quot;collapse&quot;);
<span class="lineNum">   12799 </span><span class="lineCov">         32 : </span>
<span class="lineNum">   12800 </span>            :   loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   12801 </span><span class="lineCov">        158 :   if (!c_parser_require (parser, CPP_OPEN_PAREN, &quot;expected %&lt;(%&gt;&quot;))</span>
<span class="lineNum">   12802 </span>            :     return list;
<span class="lineNum">   12803 </span><span class="lineCov">        158 : </span>
<span class="lineNum">   12804 </span><span class="lineCov">        158 :   do</span>
<span class="lineNum">   12805 </span><span class="lineCov">        158 :     {</span>
<span class="lineNum">   12806 </span><span class="lineCov">        158 :       if (tile &amp;&amp; !c_parser_require (parser, CPP_COMMA, &quot;expected %&lt;,%&gt;&quot;))</span>
<span class="lineNum">   12807 </span>            :         return list;
<span class="lineNum">   12808 </span><span class="lineCov">        158 : </span>
<span class="lineNum">   12809 </span>            :       if (c_parser_next_token_is (parser, CPP_MULT)
<span class="lineNum">   12810 </span>            :           &amp;&amp; (c_parser_peek_2nd_token (parser)-&gt;type == CPP_COMMA
<span class="lineNum">   12811 </span>            :               || c_parser_peek_2nd_token (parser)-&gt;type == CPP_CLOSE_PAREN))
<span class="lineNum">   12812 </span>            :         {
<span class="lineNum">   12813 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   12814 </span>            :           expr = integer_zero_node;
<span class="lineNum">   12815 </span><span class="lineCov">        117 :         }</span>
<span class="lineNum">   12816 </span>            :       else
<span class="lineNum">   12817 </span><span class="lineCov">        117 :         {</span>
<span class="lineNum">   12818 </span><span class="lineCov">        117 :           location_t expr_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   12819 </span><span class="lineCov">        117 :           c_expr cexpr = c_parser_expr_no_commas (parser, NULL);</span>
<span class="lineNum">   12820 </span>            :           cexpr = convert_lvalue_to_rvalue (expr_loc, cexpr, false, true);
<span class="lineNum">   12821 </span><span class="lineCov">        117 :           expr = cexpr.value;</span>
<span class="lineNum">   12822 </span><span class="lineCov">        117 : </span>
<span class="lineNum">   12823 </span>            :           if (expr == error_mark_node)
<span class="lineNum">   12824 </span><span class="lineCov">        117 :             {</span>
<span class="lineNum">   12825 </span><span class="lineCov">        117 :               c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,</span>
<span class="lineNum">   12826 </span>            :                                          &quot;expected %&lt;)%&gt;&quot;);
<span class="lineNum">   12827 </span>            :               return list;
<span class="lineNum">   12828 </span><span class="lineCov">        151 :             }</span>
<span class="lineNum">   12829 </span>            : 
<span class="lineNum">   12830 </span><span class="lineCov">        151 :           expr = c_fully_fold (expr, false, NULL);</span>
<span class="lineNum">   12831 </span>            : 
<span class="lineNum">   12832 </span>            :           if (!INTEGRAL_TYPE_P (TREE_TYPE (expr))
<span class="lineNum">   12833 </span><span class="lineCov">        151 :               || !tree_fits_shwi_p (expr)</span>
<span class="lineNum">   12834 </span><span class="lineCov">        151 :               || tree_to_shwi (expr) &lt;= 0)</span>
<span class="lineNum">   12835 </span><span class="lineCov">         53 :             {</span>
<span class="lineNum">   12836 </span>            :               error_at (expr_loc, &quot;%&lt;tile%&gt; argument needs positive&quot;
<span class="lineNum">   12837 </span><span class="lineCov">         60 :                         &quot; integral constant&quot;);</span>
<span class="lineNum">   12838 </span><span class="lineCov">         60 :               expr = integer_zero_node;</span>
<span class="lineNum">   12839 </span>            :             }
<span class="lineNum">   12840 </span>            :         }
<span class="lineNum">   12841 </span>            : 
<span class="lineNum">   12842 </span><span class="lineCov">         91 :       tile = tree_cons (NULL_TREE, expr, tile);</span>
<span class="lineNum">   12843 </span><span class="lineCov">         91 :     }</span>
<span class="lineNum">   12844 </span><span class="lineCov">         91 :   while (c_parser_next_token_is_not (parser, CPP_CLOSE_PAREN));</span>
<span class="lineNum">   12845 </span><span class="lineCov">         91 : </span>
<span class="lineNum">   12846 </span>            :   /* Consume the trailing ')'.  */
<span class="lineNum">   12847 </span><span class="lineCov">         91 :   c_parser_consume_token (parser);</span>
<span class="lineNum">   12848 </span>            : 
<span class="lineNum">   12849 </span><span class="lineCov">          7 :   c = build_omp_clause (loc, OMP_CLAUSE_TILE);</span>
<span class="lineNum">   12850 </span>            :   tile = nreverse (tile);
<span class="lineNum">   12851 </span><span class="lineCov">          7 :   OMP_CLAUSE_TILE_LIST (c) = tile;</span>
<span class="lineNum">   12852 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   12853 </span>            :   return c;
<span class="lineNum">   12854 </span><span class="lineCov">         84 : }</span>
<span class="lineNum">   12855 </span>            : 
<span class="lineNum">   12856 </span><span class="lineCov">        252 : /* OpenACC:</span>
<span class="lineNum">   12857 </span><span class="lineCov">         83 :    wait ( int-expr-list ) */</span>
<a name="12858"><span class="lineNum">   12858 </span><span class="lineCov">        159 : </span></a>
<span class="lineNum">   12859 </span>            : static tree
<span class="lineNum">   12860 </span><span class="lineCov">         16 : c_parser_oacc_clause_wait (c_parser *parser, tree list)</span>
<span class="lineNum">   12861 </span>            : {
<span class="lineNum">   12862 </span><span class="lineCov">         16 :   location_t clause_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   12863 </span>            : 
<span class="lineNum">   12864 </span>            :   if (c_parser_peek_token (parser)-&gt;type == CPP_OPEN_PAREN)
<span class="lineNum">   12865 </span>            :     list = c_parser_oacc_wait_list (parser, clause_loc, list);
<span class="lineNum">   12866 </span><span class="lineCov">        144 : </span>
<span class="lineNum">   12867 </span>            :   return list;
<span class="lineNum">   12868 </span><span class="lineCov">        144 : }</span>
<span class="lineNum">   12869 </span>            : 
<span class="lineNum">   12870 </span>            : /* OpenMP 2.5:
<span class="lineNum">   12871 </span><span class="lineCov">        105 :    ordered</span>
<span class="lineNum">   12872 </span>            : 
<span class="lineNum">   12873 </span><span class="lineCov">        105 :    OpenMP 4.5:</span>
<span class="lineNum">   12874 </span><span class="lineCov">        105 :    ordered ( constant-expression ) */</span>
<a name="12875"><span class="lineNum">   12875 </span><span class="lineCov">        105 : </span></a>
<span class="lineNum">   12876 </span><span class="lineCov">        105 : static tree</span>
<span class="lineNum">   12877 </span><span class="lineCov">        105 : c_parser_omp_clause_ordered (c_parser *parser, tree list)</span>
<span class="lineNum">   12878 </span>            : {
<span class="lineNum">   12879 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_ORDERED, &quot;ordered&quot;);
<span class="lineNum">   12880 </span>            : 
<span class="lineNum">   12881 </span>            :   tree c, num = NULL_TREE;
<span class="lineNum">   12882 </span>            :   HOST_WIDE_INT n;
<span class="lineNum">   12883 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   12884 </span><span class="lineCov">         60 :   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))</span>
<span class="lineNum">   12885 </span>            :     {
<span class="lineNum">   12886 </span><span class="lineCov">         60 :       matching_parens parens;</span>
<span class="lineNum">   12887 </span>            :       parens.consume_open (parser);
<span class="lineNum">   12888 </span><span class="lineCov">         60 :       num = c_parser_expr_no_commas (parser, NULL).value;</span>
<span class="lineNum">   12889 </span><span class="lineCov">         46 :       parens.skip_until_found_close (parser);</span>
<span class="lineNum">   12890 </span>            :     }
<span class="lineNum">   12891 </span><span class="lineCov">         60 :   if (num == error_mark_node)</span>
<span class="lineNum">   12892 </span>            :     return list;
<span class="lineNum">   12893 </span>            :   if (num)
<span class="lineNum">   12894 </span>            :     {
<span class="lineNum">   12895 </span>            :       mark_exp_read (num);
<span class="lineNum">   12896 </span>            :       num = c_fully_fold (num, false, NULL);
<span class="lineNum">   12897 </span>            :       if (!INTEGRAL_TYPE_P (TREE_TYPE (num))
<span class="lineNum">   12898 </span>            :           || !tree_fits_shwi_p (num)
<span class="lineNum">   12899 </span>            :           || (n = tree_to_shwi (num)) &lt;= 0
<span class="lineNum">   12900 </span>            :           || (int) n != n)
<span class="lineNum">   12901 </span><span class="lineCov">        117 :         {</span>
<span class="lineNum">   12902 </span>            :           error_at (loc, &quot;ordered argument needs positive &quot;
<span class="lineNum">   12903 </span><span class="lineCov">        117 :                          &quot;constant integer expression&quot;);</span>
<span class="lineNum">   12904 </span>            :           return list;
<span class="lineNum">   12905 </span><span class="lineCov">        117 :         }</span>
<span class="lineNum">   12906 </span><span class="lineCov">        117 :     }</span>
<span class="lineNum">   12907 </span><span class="lineCov">        117 :   c = build_omp_clause (loc, OMP_CLAUSE_ORDERED);</span>
<span class="lineNum">   12908 </span><span class="lineCov">        117 :   OMP_CLAUSE_ORDERED_EXPR (c) = num;</span>
<span class="lineNum">   12909 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   12910 </span><span class="lineCov">        108 :   return c;</span>
<span class="lineNum">   12911 </span><span class="lineCov">         54 : }</span>
<span class="lineNum">   12912 </span><span class="lineCov">         54 : </span>
<span class="lineNum">   12913 </span><span class="lineCov">         54 : /* OpenMP 2.5:</span>
<span class="lineNum">   12914 </span>            :    private ( variable-list ) */
<a name="12915"><span class="lineNum">   12915 </span><span class="lineCov">        117 : </span></a>
<span class="lineNum">   12916 </span>            : static tree
<span class="lineNum">   12917 </span><span class="lineCov">        117 : c_parser_omp_clause_private (c_parser *parser, tree list)</span>
<span class="lineNum">   12918 </span>            : {
<span class="lineNum">   12919 </span><span class="lineCov">         54 :   return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_PRIVATE, list);</span>
<span class="lineNum">   12920 </span><span class="lineCov">         54 : }</span>
<span class="lineNum">   12921 </span><span class="lineCov">        162 : </span>
<span class="lineNum">   12922 </span><span class="lineCov">         54 : /* OpenMP 2.5:</span>
<span class="lineNum">   12923 </span><span class="lineCov">         54 :    reduction ( reduction-operator : variable-list )</span>
<span class="lineNum">   12924 </span><span class="lineCov">        108 : </span>
<span class="lineNum">   12925 </span>            :    reduction-operator:
<span class="lineNum">   12926 </span><span class="lineNoCov">          0 :      One of: + * - &amp; ^ | &amp;&amp; ||</span>
<span class="lineNum">   12927 </span>            : 
<span class="lineNum">   12928 </span><span class="lineNoCov">          0 :    OpenMP 3.1:</span>
<span class="lineNum">   12929 </span>            :    
<span class="lineNum">   12930 </span>            :    reduction-operator:
<span class="lineNum">   12931 </span><span class="lineCov">        117 :      One of: + * - &amp; ^ | &amp;&amp; || max min</span>
<span class="lineNum">   12932 </span><span class="lineCov">        117 : </span>
<span class="lineNum">   12933 </span><span class="lineCov">        117 :    OpenMP 4.0:</span>
<span class="lineNum">   12934 </span><span class="lineCov">        117 : </span>
<span class="lineNum">   12935 </span>            :    reduction-operator:
<span class="lineNum">   12936 </span>            :      One of: + * - &amp; ^ | &amp;&amp; ||
<span class="lineNum">   12937 </span>            :      identifier  */
<a name="12938"><span class="lineNum">   12938 </span>            : </a>
<span class="lineNum">   12939 </span>            : static tree
<span class="lineNum">   12940 </span>            : c_parser_omp_clause_reduction (c_parser *parser, tree list)
<span class="lineNum">   12941 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   12942 </span>            :   location_t clause_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   12943 </span><span class="lineNoCov">          0 :   matching_parens parens;</span>
<span class="lineNum">   12944 </span>            :   if (parens.require_open (parser))
<span class="lineNum">   12945 </span>            :     {
<span class="lineNum">   12946 </span>            :       enum tree_code code = ERROR_MARK;
<span class="lineNum">   12947 </span>            :       tree reduc_id = NULL_TREE;
<span class="lineNum">   12948 </span>            : 
<span class="lineNum">   12949 </span>            :       switch (c_parser_peek_token (parser)-&gt;type)
<span class="lineNum">   12950 </span>            :         {
<span class="lineNum">   12951 </span>            :         case CPP_PLUS:
<span class="lineNum">   12952 </span>            :           code = PLUS_EXPR;
<span class="lineNum">   12953 </span>            :           break;
<span class="lineNum">   12954 </span>            :         case CPP_MULT:
<span class="lineNum">   12955 </span>            :           code = MULT_EXPR;
<span class="lineNum">   12956 </span>            :           break;
<span class="lineNum">   12957 </span>            :         case CPP_MINUS:
<span class="lineNum">   12958 </span>            :           code = MINUS_EXPR;
<span class="lineNum">   12959 </span>            :           break;
<span class="lineNum">   12960 </span>            :         case CPP_AND:
<span class="lineNum">   12961 </span>            :           code = BIT_AND_EXPR;
<span class="lineNum">   12962 </span>            :           break;
<span class="lineNum">   12963 </span>            :         case CPP_XOR:
<span class="lineNum">   12964 </span><span class="lineCov">        804 :           code = BIT_XOR_EXPR;</span>
<span class="lineNum">   12965 </span>            :           break;
<span class="lineNum">   12966 </span><span class="lineCov">        804 :         case CPP_OR:</span>
<span class="lineNum">   12967 </span><span class="lineCov">       1608 :           code = BIT_IOR_EXPR;</span>
<span class="lineNum">   12968 </span><span class="lineCov">        804 :           break;</span>
<span class="lineNum">   12969 </span>            :         case CPP_AND_AND:
<span class="lineNum">   12970 </span><span class="lineCov">        804 :           code = TRUTH_ANDIF_EXPR;</span>
<span class="lineNum">   12971 </span><span class="lineCov">        804 :           break;</span>
<span class="lineNum">   12972 </span>            :         case CPP_OR_OR:
<span class="lineNum">   12973 </span><span class="lineCov">        804 :           code = TRUTH_ORIF_EXPR;</span>
<span class="lineNum">   12974 </span>            :           break;
<span class="lineNum">   12975 </span>            :         case CPP_NAME:
<span class="lineNum">   12976 </span>            :           {
<span class="lineNum">   12977 </span>            :             const char *p
<span class="lineNum">   12978 </span><span class="lineCov">         54 :               = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">   12979 </span><span class="lineCov">         54 :             if (strcmp (p, &quot;min&quot;) == 0)</span>
<span class="lineNum">   12980 </span><span class="lineCov">         54 :               {</span>
<span class="lineNum">   12981 </span><span class="lineCov">          2 :                 code = MIN_EXPR;</span>
<span class="lineNum">   12982 </span><span class="lineCov">          2 :                 break;</span>
<span class="lineNum">   12983 </span><span class="lineCov">          2 :               }</span>
<span class="lineNum">   12984 </span><span class="lineCov">         18 :             if (strcmp (p, &quot;max&quot;) == 0)</span>
<span class="lineNum">   12985 </span><span class="lineCov">         18 :               {</span>
<span class="lineNum">   12986 </span><span class="lineCov">         18 :                 code = MAX_EXPR;</span>
<span class="lineNum">   12987 </span><span class="lineCov">         12 :                 break;</span>
<span class="lineNum">   12988 </span><span class="lineCov">         12 :               }</span>
<span class="lineNum">   12989 </span><span class="lineCov">         12 :             reduc_id = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">   12990 </span><span class="lineCov">         43 :             break;</span>
<span class="lineNum">   12991 </span><span class="lineCov">         43 :           }</span>
<span class="lineNum">   12992 </span><span class="lineCov">         43 :         default:</span>
<span class="lineNum">   12993 </span><span class="lineCov">         10 :           c_parser_error (parser,</span>
<span class="lineNum">   12994 </span><span class="lineCov">         10 :                           &quot;expected %&lt;+%&gt;, %&lt;*%&gt;, %&lt;-%&gt;, %&lt;&amp;%&gt;, &quot;</span>
<span class="lineNum">   12995 </span><span class="lineCov">         10 :                           &quot;%&lt;^%&gt;, %&lt;|%&gt;, %&lt;&amp;&amp;%&gt;, %&lt;||%&gt; or identifier&quot;);</span>
<span class="lineNum">   12996 </span><span class="lineCov">         21 :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, 0);</span>
<span class="lineNum">   12997 </span><span class="lineCov">         21 :           return list;</span>
<span class="lineNum">   12998 </span><span class="lineCov">         21 :         }</span>
<span class="lineNum">   12999 </span><span class="lineCov">         94 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   13000 </span><span class="lineCov">         94 :       reduc_id = c_omp_reduction_id (code, reduc_id);</span>
<span class="lineNum">   13001 </span><span class="lineCov">         94 :       if (c_parser_require (parser, CPP_COLON, &quot;expected %&lt;:%&gt;&quot;))</span>
<span class="lineNum">   13002 </span><span class="lineCov">         94 :         {</span>
<span class="lineNum">   13003 </span><span class="lineCov">         94 :           tree nl, c;</span>
<span class="lineNum">   13004 </span>            : 
<span class="lineNum">   13005 </span>            :           nl = c_parser_omp_variable_list (parser, clause_loc,
<span class="lineNum">   13006 </span>            :                                            OMP_CLAUSE_REDUCTION, list);
<span class="lineNum">   13007 </span>            :           for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))
<span class="lineNum">   13008 </span><span class="lineCov">         60 :             {</span>
<span class="lineNum">   13009 </span>            :               tree d = OMP_CLAUSE_DECL (c), type;
<span class="lineNum">   13010 </span>            :               if (TREE_CODE (d) != TREE_LIST)
<span class="lineNum">   13011 </span>            :                 type = TREE_TYPE (d);
<span class="lineNum">   13012 </span>            :               else
<span class="lineNum">   13013 </span><span class="lineCov">         17 :                 {</span>
<span class="lineNum">   13014 </span><span class="lineCov">         17 :                   int cnt = 0;</span>
<span class="lineNum">   13015 </span>            :                   tree t;
<span class="lineNum">   13016 </span><span class="lineNoCov">          0 :                   for (t = d; TREE_CODE (t) == TREE_LIST; t = TREE_CHAIN (t))</span>
<span class="lineNum">   13017 </span><span class="lineNoCov">          0 :                     cnt++;</span>
<span class="lineNum">   13018 </span>            :                   type = TREE_TYPE (t);
<span class="lineNum">   13019 </span>            :                   while (cnt &gt; 0)
<span class="lineNum">   13020 </span><span class="lineNoCov">          0 :                     {</span>
<span class="lineNum">   13021 </span><span class="lineNoCov">          0 :                       if (TREE_CODE (type) != POINTER_TYPE</span>
<span class="lineNum">   13022 </span>            :                           &amp;&amp; TREE_CODE (type) != ARRAY_TYPE)
<span class="lineNum">   13023 </span><span class="lineCov">        804 :                         break;</span>
<span class="lineNum">   13024 </span><span class="lineCov">        804 :                       type = TREE_TYPE (type);</span>
<span class="lineNum">   13025 </span><span class="lineCov">        804 :                       cnt--;</span>
<span class="lineNum">   13026 </span>            :                     }
<span class="lineNum">   13027 </span><span class="lineCov">        804 :                 }</span>
<span class="lineNum">   13028 </span>            :               while (TREE_CODE (type) == ARRAY_TYPE)
<span class="lineNum">   13029 </span><span class="lineCov">        804 :                 type = TREE_TYPE (type);</span>
<span class="lineNum">   13030 </span>            :               OMP_CLAUSE_REDUCTION_CODE (c) = code;
<span class="lineNum">   13031 </span><span class="lineCov">       1738 :               if (code == ERROR_MARK</span>
<span class="lineNum">   13032 </span>            :                   || !(INTEGRAL_TYPE_P (type)
<span class="lineNum">   13033 </span><span class="lineCov">        934 :                        || TREE_CODE (type) == REAL_TYPE</span>
<span class="lineNum">   13034 </span><span class="lineCov">        934 :                        || TREE_CODE (type) == COMPLEX_TYPE))</span>
<span class="lineNum">   13035 </span><span class="lineCov">        862 :                 OMP_CLAUSE_REDUCTION_PLACEHOLDER (c)</span>
<span class="lineNum">   13036 </span>            :                   = c_omp_reduction_lookup (reduc_id,
<span class="lineNum">   13037 </span>            :                                             TYPE_MAIN_VARIANT (type));
<span class="lineNum">   13038 </span>            :             }
<span class="lineNum">   13039 </span>            : 
<span class="lineNum">   13040 </span><span class="lineCov">        182 :           list = nl;</span>
<span class="lineNum">   13041 </span><span class="lineCov">        110 :         }</span>
<span class="lineNum">   13042 </span><span class="lineCov">         72 :       parens.skip_until_found_close (parser);</span>
<span class="lineNum">   13043 </span><span class="lineCov">        180 :     }</span>
<span class="lineNum">   13044 </span>            :   return list;
<span class="lineNum">   13045 </span><span class="lineCov">        110 : }</span>
<span class="lineNum">   13046 </span><span class="lineCov">         68 : </span>
<span class="lineNum">   13047 </span>            : /* OpenMP 2.5:
<span class="lineNum">   13048 </span><span class="lineCov">        108 :    schedule ( schedule-kind )</span>
<span class="lineNum">   13049 </span><span class="lineCov">        108 :    schedule ( schedule-kind , expression )</span>
<span class="lineNum">   13050 </span>            : 
<span class="lineNum">   13051 </span>            :    schedule-kind:
<span class="lineNum">   13052 </span><span class="lineCov">        964 :      static | dynamic | guided | runtime | auto</span>
<span class="lineNum">   13053 </span><span class="lineCov">         30 : </span>
<span class="lineNum">   13054 </span><span class="lineCov">        934 :    OpenMP 4.5:</span>
<span class="lineNum">   13055 </span><span class="lineCov">        934 :    schedule ( schedule-modifier : schedule-kind )</span>
<span class="lineNum">   13056 </span><span class="lineCov">         66 :    schedule ( schedule-modifier [ , schedule-modifier ] : schedule-kind , expression )</span>
<span class="lineNum">   13057 </span><span class="lineCov">        908 : </span>
<span class="lineNum">   13058 </span>            :    schedule-modifier:
<span class="lineNum">   13059 </span><span class="lineCov">         66 :      simd</span>
<span class="lineNum">   13060 </span><span class="lineCov">         66 :      monotonic</span>
<span class="lineNum">   13061 </span><span class="lineCov">         66 :      nonmonotonic  */</span>
<a name="13062"><span class="lineNum">   13062 </span>            : </a>
<span class="lineNum">   13063 </span>            : static tree
<span class="lineNum">   13064 </span>            : c_parser_omp_clause_schedule (c_parser *parser, tree list)
<span class="lineNum">   13065 </span>            : {
<span class="lineNum">   13066 </span><span class="lineCov">        804 :   tree c, t;</span>
<span class="lineNum">   13067 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   13068 </span>            :   int modifiers = 0, nmodifiers = 0;
<span class="lineNum">   13069 </span>            : 
<span class="lineNum">   13070 </span>            :   matching_parens parens;
<span class="lineNum">   13071 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   13072 </span>            :     return list;
<span class="lineNum">   13073 </span>            : 
<span class="lineNum">   13074 </span>            :   c = build_omp_clause (loc, OMP_CLAUSE_SCHEDULE);
<span class="lineNum">   13075 </span>            : 
<span class="lineNum">   13076 </span>            :   while (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   13077 </span>            :     {
<span class="lineNum">   13078 </span>            :       tree kind = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">   13079 </span>            :       const char *p = IDENTIFIER_POINTER (kind);
<span class="lineNum">   13080 </span>            :       if (strcmp (&quot;simd&quot;, p) == 0)
<span class="lineNum">   13081 </span>            :         OMP_CLAUSE_SCHEDULE_SIMD (c) = 1;
<span class="lineNum">   13082 </span>            :       else if (strcmp (&quot;monotonic&quot;, p) == 0)
<span class="lineNum">   13083 </span>            :         modifiers |= OMP_CLAUSE_SCHEDULE_MONOTONIC;
<span class="lineNum">   13084 </span>            :       else if (strcmp (&quot;nonmonotonic&quot;, p) == 0)
<span class="lineNum">   13085 </span>            :         modifiers |= OMP_CLAUSE_SCHEDULE_NONMONOTONIC;
<span class="lineNum">   13086 </span>            :       else
<span class="lineNum">   13087 </span>            :         break;
<span class="lineNum">   13088 </span><span class="lineCov">       1564 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   13089 </span>            :       if (nmodifiers++ == 0
<span class="lineNum">   13090 </span><span class="lineCov">       1564 :           &amp;&amp; c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">   13091 </span><span class="lineCov">       1564 :         c_parser_consume_token (parser);</span>
<span class="lineNum">   13092 </span><span class="lineCov">       1564 :       else</span>
<span class="lineNum">   13093 </span>            :         {
<span class="lineNum">   13094 </span><span class="lineCov">       3128 :           c_parser_require (parser, CPP_COLON, &quot;expected %&lt;:%&gt;&quot;);</span>
<span class="lineNum">   13095 </span><span class="lineCov">       1564 :           break;</span>
<span class="lineNum">   13096 </span>            :         }
<span class="lineNum">   13097 </span>            :     }
<span class="lineNum">   13098 </span><span class="lineCov">       1562 : </span>
<span class="lineNum">   13099 </span>            :   if ((modifiers &amp; (OMP_CLAUSE_SCHEDULE_MONOTONIC
<span class="lineNum">   13100 </span><span class="lineCov">       1577 :                     | OMP_CLAUSE_SCHEDULE_NONMONOTONIC))</span>
<span class="lineNum">   13101 </span>            :       == (OMP_CLAUSE_SCHEDULE_MONOTONIC
<span class="lineNum">   13102 </span><span class="lineCov">        820 :           | OMP_CLAUSE_SCHEDULE_NONMONOTONIC))</span>
<span class="lineNum">   13103 </span><span class="lineCov">        820 :     {</span>
<span class="lineNum">   13104 </span><span class="lineCov">        820 :       error_at (loc, &quot;both %&lt;monotonic%&gt; and %&lt;nonmonotonic%&gt; modifiers &quot;</span>
<span class="lineNum">   13105 </span><span class="lineCov">         13 :                      &quot;specified&quot;);</span>
<span class="lineNum">   13106 </span><span class="lineCov">        807 :       modifiers = 0;</span>
<span class="lineNum">   13107 </span><span class="lineCov">         22 :     }</span>
<span class="lineNum">   13108 </span><span class="lineCov">        785 : </span>
<span class="lineNum">   13109 </span><span class="lineCov">         39 :   if (c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">   13110 </span>            :     {
<span class="lineNum">   13111 </span>            :       tree kind = c_parser_peek_token (parser)-&gt;value;
<span class="lineNum">   13112 </span><span class="lineCov">         74 :       const char *p = IDENTIFIER_POINTER (kind);</span>
<span class="lineNum">   13113 </span><span class="lineCov">         74 : </span>
<span class="lineNum">   13114 </span><span class="lineCov">         74 :       switch (p[0])</span>
<span class="lineNum">   13115 </span><span class="lineCov">         15 :         {</span>
<span class="lineNum">   13116 </span>            :         case 'd':
<span class="lineNum">   13117 </span>            :           if (strcmp (&quot;dynamic&quot;, p) != 0)
<span class="lineNum">   13118 </span><span class="lineCov">         59 :             goto invalid_kind;</span>
<span class="lineNum">   13119 </span><span class="lineCov">         59 :           OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_DYNAMIC;</span>
<span class="lineNum">   13120 </span>            :           break;
<span class="lineNum">   13121 </span>            : 
<span class="lineNum">   13122 </span>            :         case 'g':
<span class="lineNum">   13123 </span><span class="lineCov">       1562 :           if (strcmp (&quot;guided&quot;, p) != 0)</span>
<span class="lineNum">   13124 </span>            :             goto invalid_kind;
<span class="lineNum">   13125 </span>            :           OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_GUIDED;
<span class="lineNum">   13126 </span>            :           break;
<span class="lineNum">   13127 </span>            : 
<span class="lineNum">   13128 </span><span class="lineCov">          2 :         case 'r':</span>
<span class="lineNum">   13129 </span>            :           if (strcmp (&quot;runtime&quot;, p) != 0)
<span class="lineNum">   13130 </span><span class="lineCov">          2 :             goto invalid_kind;</span>
<span class="lineNum">   13131 </span>            :           OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_RUNTIME;
<span class="lineNum">   13132 </span>            :           break;
<span class="lineNum">   13133 </span><span class="lineCov">       1562 : </span>
<span class="lineNum">   13134 </span>            :         default:
<span class="lineNum">   13135 </span><span class="lineCov">        788 :           goto invalid_kind;</span>
<span class="lineNum">   13136 </span><span class="lineCov">        788 :         }</span>
<span class="lineNum">   13137 </span>            :     }
<span class="lineNum">   13138 </span><span class="lineCov">        788 :   else if (c_parser_next_token_is_keyword (parser, RID_STATIC))</span>
<span class="lineNum">   13139 </span>            :     OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_STATIC;
<span class="lineNum">   13140 </span><span class="lineCov">        107 :   else if (c_parser_next_token_is_keyword (parser, RID_AUTO))</span>
<span class="lineNum">   13141 </span><span class="lineCov">        107 :     OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_AUTO;</span>
<span class="lineNum">   13142 </span>            :   else
<span class="lineNum">   13143 </span><span class="lineCov">        107 :     goto invalid_kind;</span>
<span class="lineNum">   13144 </span><span class="lineCov">        107 : </span>
<span class="lineNum">   13145 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">   13146 </span><span class="lineCov">        330 :   if (c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">   13147 </span><span class="lineCov">        330 :     {</span>
<span class="lineNum">   13148 </span>            :       location_t here;
<span class="lineNum">   13149 </span><span class="lineCov">        330 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   13150 </span><span class="lineCov">        330 : </span>
<span class="lineNum">   13151 </span>            :       here = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   13152 </span><span class="lineCov">        350 :       c_expr expr = c_parser_expr_no_commas (parser, NULL);</span>
<span class="lineNum">   13153 </span><span class="lineCov">        350 :       expr = convert_lvalue_to_rvalue (here, expr, false, true);</span>
<span class="lineNum">   13154 </span>            :       t = expr.value;
<span class="lineNum">   13155 </span><span class="lineCov">        350 :       t = c_fully_fold (t, false, NULL);</span>
<span class="lineNum">   13156 </span><span class="lineCov">        350 : </span>
<span class="lineNum">   13157 </span>            :       if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_RUNTIME)
<span class="lineNum">   13158 </span>            :         error_at (here, &quot;schedule %&lt;runtime%&gt; does not take &quot;
<span class="lineNum">   13159 </span>            :                   &quot;a %&lt;chunk_size%&gt; parameter&quot;);
<span class="lineNum">   13160 </span>            :       else if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_AUTO)
<span class="lineNum">   13161 </span>            :         error_at (here,
<span class="lineNum">   13162 </span><span class="lineCov">        774 :                   &quot;schedule %&lt;auto%&gt; does not take &quot;</span>
<span class="lineNum">   13163 </span><span class="lineCov">        498 :                   &quot;a %&lt;chunk_size%&gt; parameter&quot;);</span>
<span class="lineNum">   13164 </span><span class="lineCov">        276 :       else if (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE)</span>
<span class="lineNum">   13165 </span><span class="lineCov">        275 :         {</span>
<span class="lineNum">   13166 </span>            :           /* Attempt to statically determine when the number isn't
<span class="lineNum">   13167 </span>            :              positive.  */
<span class="lineNum">   13168 </span>            :           tree s = fold_build2_loc (loc, LE_EXPR, boolean_type_node, t,
<span class="lineNum">   13169 </span><span class="lineCov">       1560 :                                     build_int_cst (TREE_TYPE (t), 0));</span>
<span class="lineNum">   13170 </span><span class="lineCov">       1560 :           protected_set_expr_location (s, loc);</span>
<span class="lineNum">   13171 </span>            :           if (s == boolean_true_node)
<span class="lineNum">   13172 </span><span class="lineCov">        827 :             {</span>
<span class="lineNum">   13173 </span><span class="lineCov">        827 :               warning_at (loc, 0,</span>
<span class="lineNum">   13174 </span>            :                           &quot;chunk size value must be positive&quot;);
<span class="lineNum">   13175 </span><span class="lineCov">        827 :               t = integer_one_node;</span>
<span class="lineNum">   13176 </span><span class="lineCov">        827 :             }</span>
<span class="lineNum">   13177 </span><span class="lineCov">        827 :           OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = t;</span>
<span class="lineNum">   13178 </span><span class="lineCov">        827 :         }</span>
<span class="lineNum">   13179 </span><span class="lineCov">        827 :       else</span>
<span class="lineNum">   13180 </span>            :         c_parser_error (parser, &quot;expected integer expression&quot;);
<span class="lineNum">   13181 </span><span class="lineCov">        827 : </span>
<span class="lineNum">   13182 </span><span class="lineCov">          1 :       parens.skip_until_found_close (parser);</span>
<span class="lineNum">   13183 </span>            :     }
<span class="lineNum">   13184 </span><span class="lineCov">        826 :   else</span>
<span class="lineNum">   13185 </span><span class="lineNoCov">          0 :     c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,</span>
<span class="lineNum">   13186 </span>            :                                &quot;expected %&lt;,%&gt; or %&lt;)%&gt;&quot;);
<span class="lineNum">   13187 </span>            : 
<span class="lineNum">   13188 </span><span class="lineCov">        826 :   OMP_CLAUSE_SCHEDULE_KIND (c)</span>
<span class="lineNum">   13189 </span>            :     = (enum omp_clause_schedule_kind)
<span class="lineNum">   13190 </span>            :       (OMP_CLAUSE_SCHEDULE_KIND (c) | modifiers);
<span class="lineNum">   13191 </span>            : 
<span class="lineNum">   13192 </span><span class="lineCov">        825 :   check_no_duplicate_clause (list, OMP_CLAUSE_SCHEDULE, &quot;schedule&quot;);</span>
<span class="lineNum">   13193 </span><span class="lineCov">       2475 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   13194 </span><span class="lineCov">        825 :   return c;</span>
<span class="lineNum">   13195 </span><span class="lineCov">        825 : </span>
<span class="lineNum">   13196 </span>            :  invalid_kind:
<span class="lineNum">   13197 </span><span class="lineCov">          2 :   c_parser_error (parser, &quot;invalid schedule kind&quot;);</span>
<span class="lineNum">   13198 </span>            :   c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, 0);
<span class="lineNum">   13199 </span><span class="lineCov">          2 :   return list;</span>
<span class="lineNum">   13200 </span>            : }
<span class="lineNum">   13201 </span><span class="lineCov">        825 : </span>
<span class="lineNum">   13202 </span>            : /* OpenMP 2.5:
<span class="lineNum">   13203 </span>            :    shared ( variable-list ) */
<a name="13204"><span class="lineNum">   13204 </span><span class="lineCov">          1 : </span></a>
<span class="lineNum">   13205 </span>            : static tree
<span class="lineNum">   13206 </span><span class="lineCov">        827 : c_parser_omp_clause_shared (c_parser *parser, tree list)</span>
<span class="lineNum">   13207 </span>            : {
<span class="lineNum">   13208 </span>            :   return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_SHARED, list);
<span class="lineNum">   13209 </span><span class="lineCov">        733 : }</span>
<span class="lineNum">   13210 </span>            : 
<span class="lineNum">   13211 </span>            : /* OpenMP 3.0:
<span class="lineNum">   13212 </span><span class="lineCov">       3120 :    untied */</span>
<a name="13213"><span class="lineNum">   13213 </span><span class="lineCov">       1560 : </span></a>
<span class="lineNum">   13214 </span><span class="lineCov">       1560 : static tree</span>
<span class="lineNum">   13215 </span>            : c_parser_omp_clause_untied (c_parser *parser ATTRIBUTE_UNUSED, tree list)
<span class="lineNum">   13216 </span><span class="lineCov">       1560 : {</span>
<span class="lineNum">   13217 </span><span class="lineCov">       1560 :   tree c;</span>
<span class="lineNum">   13218 </span><span class="lineCov">       1560 : </span>
<span class="lineNum">   13219 </span>            :   /* FIXME: Should we allow duplicates?  */
<span class="lineNum">   13220 </span><span class="lineCov">          2 :   check_no_duplicate_clause (list, OMP_CLAUSE_UNTIED, &quot;untied&quot;);</span>
<span class="lineNum">   13221 </span><span class="lineCov">          2 : </span>
<span class="lineNum">   13222 </span><span class="lineCov">          2 :   c = build_omp_clause (c_parser_peek_token (parser)-&gt;location,</span>
<span class="lineNum">   13223 </span><span class="lineCov">          2 :                         OMP_CLAUSE_UNTIED);</span>
<span class="lineNum">   13224 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   13225 </span>            : 
<span class="lineNum">   13226 </span>            :   return c;
<span class="lineNum">   13227 </span>            : }
<span class="lineNum">   13228 </span>            : 
<span class="lineNum">   13229 </span>            : /* OpenMP 4.0:
<span class="lineNum">   13230 </span><span class="lineNoCov">          0 :    inbranch</span>
<span class="lineNum">   13231 </span>            :    notinbranch */
<a name="13232"><span class="lineNum">   13232 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   13233 </span>            : static tree
<span class="lineNum">   13234 </span>            : c_parser_omp_clause_branch (c_parser *parser ATTRIBUTE_UNUSED,
<span class="lineNum">   13235 </span>            :                             enum omp_clause_code code, tree list)
<span class="lineNum">   13236 </span>            : {
<span class="lineNum">   13237 </span>            :   check_no_duplicate_clause (list, code, omp_clause_code_name[code]);
<span class="lineNum">   13238 </span>            : 
<span class="lineNum">   13239 </span><span class="lineCov">          3 :   tree c = build_omp_clause (c_parser_peek_token (parser)-&gt;location, code);</span>
<span class="lineNum">   13240 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   13241 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   13242 </span>            :   return c;
<span class="lineNum">   13243 </span>            : }
<span class="lineNum">   13244 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   13245 </span>            : /* OpenMP 4.0:
<span class="lineNum">   13246 </span><span class="lineCov">          3 :    parallel</span>
<span class="lineNum">   13247 </span>            :    for
<span class="lineNum">   13248 </span><span class="lineCov">          3 :    sections</span>
<span class="lineNum">   13249 </span>            :    taskgroup */
<a name="13250"><span class="lineNum">   13250 </span><span class="lineCov">          3 : </span></a>
<span class="lineNum">   13251 </span>            : static tree
<span class="lineNum">   13252 </span>            : c_parser_omp_clause_cancelkind (c_parser *parser ATTRIBUTE_UNUSED,
<span class="lineNum">   13253 </span>            :                                 enum omp_clause_code code, tree list)
<span class="lineNum">   13254 </span>            : {
<span class="lineNum">   13255 </span>            :   tree c = build_omp_clause (c_parser_peek_token (parser)-&gt;location, code);
<span class="lineNum">   13256 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   13257 </span>            : 
<span class="lineNum">   13258 </span><span class="lineCov">         91 :   return c;</span>
<span class="lineNum">   13259 </span>            : }
<span class="lineNum">   13260 </span>            : 
<span class="lineNum">   13261 </span><span class="lineCov">         91 : /* OpenMP 4.5:</span>
<span class="lineNum">   13262 </span>            :    nogroup */
<a name="13263"><span class="lineNum">   13263 </span><span class="lineCov">         91 : </span></a>
<span class="lineNum">   13264 </span><span class="lineCov">         91 : static tree</span>
<span class="lineNum">   13265 </span>            : c_parser_omp_clause_nogroup (c_parser *parser ATTRIBUTE_UNUSED, tree list)
<span class="lineNum">   13266 </span><span class="lineCov">         91 : {</span>
<span class="lineNum">   13267 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_NOGROUP, &quot;nogroup&quot;);
<span class="lineNum">   13268 </span>            :   tree c = build_omp_clause (c_parser_peek_token (parser)-&gt;location,
<span class="lineNum">   13269 </span>            :                              OMP_CLAUSE_NOGROUP);
<span class="lineNum">   13270 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   13271 </span>            :   return c;
<span class="lineNum">   13272 </span>            : }
<span class="lineNum">   13273 </span>            : 
<span class="lineNum">   13274 </span>            : /* OpenMP 4.5:
<span class="lineNum">   13275 </span>            :    simd
<span class="lineNum">   13276 </span><span class="lineCov">        289 :    threads */</span>
<a name="13277"><span class="lineNum">   13277 </span>            : </a>
<span class="lineNum">   13278 </span>            : static tree
<span class="lineNum">   13279 </span><span class="lineCov">        289 : c_parser_omp_clause_orderedkind (c_parser *parser ATTRIBUTE_UNUSED,</span>
<span class="lineNum">   13280 </span><span class="lineCov">        289 :                                  enum omp_clause_code code, tree list)</span>
<span class="lineNum">   13281 </span>            : {
<span class="lineNum">   13282 </span><span class="lineCov">        289 :   check_no_duplicate_clause (list, code, omp_clause_code_name[code]);</span>
<span class="lineNum">   13283 </span>            :   tree c = build_omp_clause (c_parser_peek_token (parser)-&gt;location, code);
<span class="lineNum">   13284 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   13285 </span>            :   return c;
<span class="lineNum">   13286 </span>            : }
<span class="lineNum">   13287 </span>            : 
<span class="lineNum">   13288 </span>            : /* OpenMP 4.0:
<span class="lineNum">   13289 </span><span class="lineCov">          4 :    num_teams ( expression ) */</span>
<a name="13290"><span class="lineNum">   13290 </span>            : </a>
<span class="lineNum">   13291 </span><span class="lineCov">          4 : static tree</span>
<span class="lineNum">   13292 </span><span class="lineCov">          4 : c_parser_omp_clause_num_teams (c_parser *parser, tree list)</span>
<span class="lineNum">   13293 </span><span class="lineCov">          4 : {</span>
<span class="lineNum">   13294 </span><span class="lineCov">          4 :   location_t num_teams_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   13295 </span><span class="lineCov">          4 :   matching_parens parens;</span>
<span class="lineNum">   13296 </span>            :   if (parens.require_open (parser))
<span class="lineNum">   13297 </span>            :     {
<span class="lineNum">   13298 </span>            :       location_t expr_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   13299 </span>            :       c_expr expr = c_parser_expression (parser);
<span class="lineNum">   13300 </span>            :       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);
<span class="lineNum">   13301 </span>            :       tree c, t = expr.value;
<span class="lineNum">   13302 </span>            :       t = c_fully_fold (t, false, NULL);
<span class="lineNum">   13303 </span><span class="lineCov">         73 : </span>
<span class="lineNum">   13304 </span>            :       parens.skip_until_found_close (parser);
<span class="lineNum">   13305 </span>            : 
<span class="lineNum">   13306 </span><span class="lineCov">         73 :       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))</span>
<span class="lineNum">   13307 </span><span class="lineCov">         73 :         {</span>
<span class="lineNum">   13308 </span><span class="lineCov">         73 :           c_parser_error (parser, &quot;expected integer expression&quot;);</span>
<span class="lineNum">   13309 </span><span class="lineCov">         73 :           return list;</span>
<span class="lineNum">   13310 </span>            :         }
<span class="lineNum">   13311 </span>            : 
<span class="lineNum">   13312 </span>            :       /* Attempt to statically determine when the number isn't positive.  */
<span class="lineNum">   13313 </span>            :       c = fold_build2_loc (expr_loc, LE_EXPR, boolean_type_node, t,
<span class="lineNum">   13314 </span>            :                            build_int_cst (TREE_TYPE (t), 0));
<span class="lineNum">   13315 </span>            :       protected_set_expr_location (c, expr_loc);
<span class="lineNum">   13316 </span><span class="lineCov">         66 :       if (c == boolean_true_node)</span>
<span class="lineNum">   13317 </span>            :         {
<span class="lineNum">   13318 </span><span class="lineCov">         66 :           warning_at (expr_loc, 0, &quot;%&lt;num_teams%&gt; value must be positive&quot;);</span>
<span class="lineNum">   13319 </span><span class="lineCov">        132 :           t = integer_one_node;</span>
<span class="lineNum">   13320 </span><span class="lineCov">         66 :         }</span>
<span class="lineNum">   13321 </span>            : 
<span class="lineNum">   13322 </span><span class="lineCov">         66 :       check_no_duplicate_clause (list, OMP_CLAUSE_NUM_TEAMS, &quot;num_teams&quot;);</span>
<span class="lineNum">   13323 </span><span class="lineCov">         66 : </span>
<span class="lineNum">   13324 </span><span class="lineCov">         66 :       c = build_omp_clause (num_teams_loc, OMP_CLAUSE_NUM_TEAMS);</span>
<span class="lineNum">   13325 </span><span class="lineCov">         66 :       OMP_CLAUSE_NUM_TEAMS_EXPR (c) = t;</span>
<span class="lineNum">   13326 </span><span class="lineCov">         66 :       OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   13327 </span>            :       list = c;
<span class="lineNum">   13328 </span><span class="lineCov">         66 :     }</span>
<span class="lineNum">   13329 </span>            : 
<span class="lineNum">   13330 </span><span class="lineCov">         66 :   return list;</span>
<span class="lineNum">   13331 </span>            : }
<span class="lineNum">   13332 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   13333 </span><span class="lineNoCov">          0 : /* OpenMP 4.0:</span>
<span class="lineNum">   13334 </span>            :    thread_limit ( expression ) */
<a name="13335"><span class="lineNum">   13335 </span>            : </a>
<span class="lineNum">   13336 </span>            : static tree
<span class="lineNum">   13337 </span><span class="lineCov">         66 : c_parser_omp_clause_thread_limit (c_parser *parser, tree list)</span>
<span class="lineNum">   13338 </span><span class="lineCov">        198 : {</span>
<span class="lineNum">   13339 </span><span class="lineCov">         66 :   location_t num_thread_limit_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   13340 </span><span class="lineCov">         66 :   matching_parens parens;</span>
<span class="lineNum">   13341 </span>            :   if (parens.require_open (parser))
<span class="lineNum">   13342 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   13343 </span><span class="lineNoCov">          0 :       location_t expr_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   13344 </span>            :       c_expr expr = c_parser_expression (parser);
<span class="lineNum">   13345 </span>            :       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);
<span class="lineNum">   13346 </span><span class="lineCov">         66 :       tree c, t = expr.value;</span>
<span class="lineNum">   13347 </span>            :       t = c_fully_fold (t, false, NULL);
<span class="lineNum">   13348 </span><span class="lineCov">         66 : </span>
<span class="lineNum">   13349 </span><span class="lineCov">         66 :       parens.skip_until_found_close (parser);</span>
<span class="lineNum">   13350 </span><span class="lineCov">         66 : </span>
<span class="lineNum">   13351 </span><span class="lineCov">         66 :       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))</span>
<span class="lineNum">   13352 </span>            :         {
<span class="lineNum">   13353 </span>            :           c_parser_error (parser, &quot;expected integer expression&quot;);
<span class="lineNum">   13354 </span>            :           return list;
<span class="lineNum">   13355 </span>            :         }
<span class="lineNum">   13356 </span>            : 
<span class="lineNum">   13357 </span>            :       /* Attempt to statically determine when the number isn't positive.  */
<span class="lineNum">   13358 </span>            :       c = fold_build2_loc (expr_loc, LE_EXPR, boolean_type_node, t,
<span class="lineNum">   13359 </span>            :                            build_int_cst (TREE_TYPE (t), 0));
<span class="lineNum">   13360 </span>            :       protected_set_expr_location (c, expr_loc);
<span class="lineNum">   13361 </span><span class="lineCov">         69 :       if (c == boolean_true_node)</span>
<span class="lineNum">   13362 </span>            :         {
<span class="lineNum">   13363 </span><span class="lineCov">         69 :           warning_at (expr_loc, 0, &quot;%&lt;thread_limit%&gt; value must be positive&quot;);</span>
<span class="lineNum">   13364 </span><span class="lineCov">        138 :           t = integer_one_node;</span>
<span class="lineNum">   13365 </span><span class="lineCov">         69 :         }</span>
<span class="lineNum">   13366 </span>            : 
<span class="lineNum">   13367 </span><span class="lineCov">         69 :       check_no_duplicate_clause (list, OMP_CLAUSE_THREAD_LIMIT,</span>
<span class="lineNum">   13368 </span><span class="lineCov">         69 :                                  &quot;thread_limit&quot;);</span>
<span class="lineNum">   13369 </span><span class="lineCov">         69 : </span>
<span class="lineNum">   13370 </span><span class="lineCov">         69 :       c = build_omp_clause (num_thread_limit_loc, OMP_CLAUSE_THREAD_LIMIT);</span>
<span class="lineNum">   13371 </span><span class="lineCov">         69 :       OMP_CLAUSE_THREAD_LIMIT_EXPR (c) = t;</span>
<span class="lineNum">   13372 </span>            :       OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   13373 </span><span class="lineCov">         69 :       list = c;</span>
<span class="lineNum">   13374 </span>            :     }
<span class="lineNum">   13375 </span><span class="lineCov">         69 : </span>
<span class="lineNum">   13376 </span>            :   return list;
<span class="lineNum">   13377 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   13378 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   13379 </span>            : /* OpenMP 4.0:
<span class="lineNum">   13380 </span>            :    aligned ( variable-list )
<span class="lineNum">   13381 </span>            :    aligned ( variable-list : constant-expression ) */
<a name="13382"><span class="lineNum">   13382 </span><span class="lineCov">         69 : </span></a>
<span class="lineNum">   13383 </span><span class="lineCov">        207 : static tree</span>
<span class="lineNum">   13384 </span><span class="lineCov">         69 : c_parser_omp_clause_aligned (c_parser *parser, tree list)</span>
<span class="lineNum">   13385 </span><span class="lineCov">         69 : {</span>
<span class="lineNum">   13386 </span>            :   location_t clause_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   13387 </span><span class="lineNoCov">          0 :   tree nl, c;</span>
<span class="lineNum">   13388 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   13389 </span>            :   matching_parens parens;
<span class="lineNum">   13390 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   13391 </span><span class="lineCov">         69 :     return list;</span>
<span class="lineNum">   13392 </span>            : 
<span class="lineNum">   13393 </span>            :   nl = c_parser_omp_variable_list (parser, clause_loc,
<span class="lineNum">   13394 </span><span class="lineCov">         69 :                                    OMP_CLAUSE_ALIGNED, list);</span>
<span class="lineNum">   13395 </span><span class="lineCov">         69 : </span>
<span class="lineNum">   13396 </span><span class="lineCov">         69 :   if (c_parser_next_token_is (parser, CPP_COLON))</span>
<span class="lineNum">   13397 </span><span class="lineCov">         69 :     {</span>
<span class="lineNum">   13398 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   13399 </span>            :       location_t expr_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   13400 </span>            :       c_expr expr = c_parser_expr_no_commas (parser, NULL);
<span class="lineNum">   13401 </span>            :       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);
<span class="lineNum">   13402 </span>            :       tree alignment = expr.value;
<span class="lineNum">   13403 </span>            :       alignment = c_fully_fold (alignment, false, NULL);
<span class="lineNum">   13404 </span>            :       if (TREE_CODE (alignment) != INTEGER_CST
<span class="lineNum">   13405 </span>            :           || !INTEGRAL_TYPE_P (TREE_TYPE (alignment))
<span class="lineNum">   13406 </span>            :           || tree_int_cst_sgn (alignment) != 1)
<span class="lineNum">   13407 </span>            :         {
<span class="lineNum">   13408 </span><span class="lineCov">         84 :           error_at (clause_loc, &quot;%&lt;aligned%&gt; clause alignment expression must &quot;</span>
<span class="lineNum">   13409 </span>            :                                 &quot;be positive constant integer expression&quot;);
<span class="lineNum">   13410 </span><span class="lineCov">         84 :           alignment = NULL_TREE;</span>
<span class="lineNum">   13411 </span><span class="lineCov">         84 :         }</span>
<span class="lineNum">   13412 </span>            : 
<span class="lineNum">   13413 </span><span class="lineCov">        168 :       for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))</span>
<span class="lineNum">   13414 </span><span class="lineCov">         84 :         OMP_CLAUSE_ALIGNED_ALIGNMENT (c) = alignment;</span>
<span class="lineNum">   13415 </span>            :     }
<span class="lineNum">   13416 </span>            : 
<span class="lineNum">   13417 </span><span class="lineCov">         84 :   parens.skip_until_found_close (parser);</span>
<span class="lineNum">   13418 </span>            :   return nl;
<span class="lineNum">   13419 </span>            : }
<span class="lineNum">   13420 </span><span class="lineCov">         84 : </span>
<span class="lineNum">   13421 </span>            : /* OpenMP 4.0:
<span class="lineNum">   13422 </span><span class="lineCov">         76 :    linear ( variable-list )</span>
<span class="lineNum">   13423 </span><span class="lineCov">         76 :    linear ( variable-list : expression )</span>
<span class="lineNum">   13424 </span><span class="lineCov">         76 : </span>
<span class="lineNum">   13425 </span><span class="lineCov">         76 :    OpenMP 4.5:</span>
<span class="lineNum">   13426 </span><span class="lineCov">         76 :    linear ( modifier ( variable-list ) )</span>
<span class="lineNum">   13427 </span><span class="lineCov">         76 :    linear ( modifier ( variable-list ) : expression ) */</span>
<a name="13428"><span class="lineNum">   13428 </span><span class="lineCov">         76 : </span></a>
<span class="lineNum">   13429 </span><span class="lineCov">         74 : static tree</span>
<span class="lineNum">   13430 </span><span class="lineCov">        150 : c_parser_omp_clause_linear (c_parser *parser, tree list)</span>
<span class="lineNum">   13431 </span>            : {
<span class="lineNum">   13432 </span><span class="lineCov">          4 :   location_t clause_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   13433 </span>            :   tree nl, c, step;
<span class="lineNum">   13434 </span><span class="lineCov">          4 :   enum omp_clause_linear_kind kind = OMP_CLAUSE_LINEAR_DEFAULT;</span>
<span class="lineNum">   13435 </span>            : 
<span class="lineNum">   13436 </span>            :   matching_parens parens;
<span class="lineNum">   13437 </span><span class="lineCov">        170 :   if (!parens.require_open (parser))</span>
<span class="lineNum">   13438 </span><span class="lineCov">         94 :     return list;</span>
<span class="lineNum">   13439 </span>            : 
<span class="lineNum">   13440 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   13441 </span><span class="lineCov">        168 :     {</span>
<span class="lineNum">   13442 </span><span class="lineCov">         84 :       c_token *tok = c_parser_peek_token (parser);</span>
<span class="lineNum">   13443 </span>            :       const char *p = IDENTIFIER_POINTER (tok-&gt;value);
<span class="lineNum">   13444 </span>            :       if (strcmp (&quot;val&quot;, p) == 0)
<span class="lineNum">   13445 </span>            :         kind = OMP_CLAUSE_LINEAR_VAL;
<span class="lineNum">   13446 </span>            :       if (c_parser_peek_2nd_token (parser)-&gt;type != CPP_OPEN_PAREN)
<span class="lineNum">   13447 </span>            :         kind = OMP_CLAUSE_LINEAR_DEFAULT;
<span class="lineNum">   13448 </span>            :       if (kind != OMP_CLAUSE_LINEAR_DEFAULT)
<span class="lineNum">   13449 </span>            :         {
<span class="lineNum">   13450 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   13451 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   13452 </span>            :         }
<span class="lineNum">   13453 </span>            :     }
<span class="lineNum">   13454 </span><span class="lineCov">        244 : </span>
<span class="lineNum">   13455 </span>            :   nl = c_parser_omp_variable_list (parser, clause_loc,
<span class="lineNum">   13456 </span><span class="lineCov">        244 :                                    OMP_CLAUSE_LINEAR, list);</span>
<span class="lineNum">   13457 </span><span class="lineCov">        244 : </span>
<span class="lineNum">   13458 </span><span class="lineCov">        244 :   if (kind != OMP_CLAUSE_LINEAR_DEFAULT)</span>
<span class="lineNum">   13459 </span>            :     parens.skip_until_found_close (parser);
<span class="lineNum">   13460 </span><span class="lineCov">        488 : </span>
<span class="lineNum">   13461 </span><span class="lineCov">        244 :   if (c_parser_next_token_is (parser, CPP_COLON))</span>
<span class="lineNum">   13462 </span>            :     {
<span class="lineNum">   13463 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   13464 </span><span class="lineCov">        244 :       location_t expr_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   13465 </span>            :       c_expr expr = c_parser_expression (parser);
<span class="lineNum">   13466 </span><span class="lineCov">        244 :       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);</span>
<span class="lineNum">   13467 </span><span class="lineCov">        244 :       step = expr.value;</span>
<span class="lineNum">   13468 </span><span class="lineCov">        244 :       step = c_fully_fold (step, false, NULL);</span>
<span class="lineNum">   13469 </span><span class="lineCov">          9 :       if (!INTEGRAL_TYPE_P (TREE_TYPE (step)))</span>
<span class="lineNum">   13470 </span><span class="lineCov">        244 :         {</span>
<span class="lineNum">   13471 </span>            :           error_at (clause_loc, &quot;%&lt;linear%&gt; clause step expression must &quot;
<span class="lineNum">   13472 </span><span class="lineCov">          9 :                                 &quot;be integral&quot;);</span>
<span class="lineNum">   13473 </span>            :           step = integer_one_node;
<span class="lineNum">   13474 </span><span class="lineCov">          9 :         }</span>
<span class="lineNum">   13475 </span><span class="lineCov">          9 : </span>
<span class="lineNum">   13476 </span>            :     }
<span class="lineNum">   13477 </span>            :   else
<span class="lineNum">   13478 </span>            :     step = integer_one_node;
<span class="lineNum">   13479 </span><span class="lineCov">        244 : </span>
<span class="lineNum">   13480 </span>            :   for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))
<span class="lineNum">   13481 </span>            :     {
<span class="lineNum">   13482 </span><span class="lineCov">        244 :       OMP_CLAUSE_LINEAR_STEP (c) = step;</span>
<span class="lineNum">   13483 </span><span class="lineCov">          9 :       OMP_CLAUSE_LINEAR_KIND (c) = kind;</span>
<span class="lineNum">   13484 </span>            :     }
<span class="lineNum">   13485 </span><span class="lineCov">        244 : </span>
<span class="lineNum">   13486 </span>            :   parens.skip_until_found_close (parser);
<span class="lineNum">   13487 </span><span class="lineCov">        196 :   return nl;</span>
<span class="lineNum">   13488 </span><span class="lineCov">        196 : }</span>
<span class="lineNum">   13489 </span><span class="lineCov">        196 : </span>
<span class="lineNum">   13490 </span><span class="lineCov">        196 : /* OpenMP 4.0:</span>
<span class="lineNum">   13491 </span><span class="lineCov">        196 :    safelen ( constant-expression ) */</span>
<a name="13492"><span class="lineNum">   13492 </span><span class="lineCov">        196 : </span></a>
<span class="lineNum">   13493 </span><span class="lineCov">        196 : static tree</span>
<span class="lineNum">   13494 </span>            : c_parser_omp_clause_safelen (c_parser *parser, tree list)
<span class="lineNum">   13495 </span><span class="lineCov">          2 : {</span>
<span class="lineNum">   13496 </span>            :   location_t clause_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   13497 </span><span class="lineCov">          2 :   tree c, t;</span>
<span class="lineNum">   13498 </span>            : 
<span class="lineNum">   13499 </span>            :   matching_parens parens;
<span class="lineNum">   13500 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   13501 </span>            :     return list;
<span class="lineNum">   13502 </span><span class="lineCov">         48 : </span>
<span class="lineNum">   13503 </span>            :   location_t expr_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   13504 </span><span class="lineCov">        495 :   c_expr expr = c_parser_expr_no_commas (parser, NULL);</span>
<span class="lineNum">   13505 </span>            :   expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);
<span class="lineNum">   13506 </span><span class="lineCov">        251 :   t = expr.value;</span>
<span class="lineNum">   13507 </span><span class="lineCov">        251 :   t = c_fully_fold (t, false, NULL);</span>
<span class="lineNum">   13508 </span>            :   if (TREE_CODE (t) != INTEGER_CST
<span class="lineNum">   13509 </span>            :       || !INTEGRAL_TYPE_P (TREE_TYPE (t))
<span class="lineNum">   13510 </span><span class="lineCov">        488 :       || tree_int_cst_sgn (t) != 1)</span>
<span class="lineNum">   13511 </span><span class="lineCov">        244 :     {</span>
<span class="lineNum">   13512 </span>            :       error_at (clause_loc, &quot;%&lt;safelen%&gt; clause expression must &quot;
<span class="lineNum">   13513 </span>            :                             &quot;be positive constant integer expression&quot;);
<span class="lineNum">   13514 </span>            :       t = NULL_TREE;
<span class="lineNum">   13515 </span>            :     }
<span class="lineNum">   13516 </span>            : 
<span class="lineNum">   13517 </span>            :   parens.skip_until_found_close (parser);
<span class="lineNum">   13518 </span><span class="lineCov">         85 :   if (t == NULL_TREE || t == error_mark_node)</span>
<span class="lineNum">   13519 </span>            :     return list;
<span class="lineNum">   13520 </span><span class="lineCov">         85 : </span>
<span class="lineNum">   13521 </span><span class="lineCov">         85 :   check_no_duplicate_clause (list, OMP_CLAUSE_SAFELEN, &quot;safelen&quot;);</span>
<span class="lineNum">   13522 </span>            : 
<span class="lineNum">   13523 </span><span class="lineCov">        170 :   c = build_omp_clause (clause_loc, OMP_CLAUSE_SAFELEN);</span>
<span class="lineNum">   13524 </span><span class="lineCov">         85 :   OMP_CLAUSE_SAFELEN_EXPR (c) = t;</span>
<span class="lineNum">   13525 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   13526 </span>            :   return c;
<span class="lineNum">   13527 </span><span class="lineCov">         85 : }</span>
<span class="lineNum">   13528 </span><span class="lineCov">         85 : </span>
<span class="lineNum">   13529 </span><span class="lineCov">         85 : /* OpenMP 4.0:</span>
<span class="lineNum">   13530 </span><span class="lineCov">         85 :    simdlen ( constant-expression ) */</span>
<a name="13531"><span class="lineNum">   13531 </span><span class="lineCov">         85 : </span></a>
<span class="lineNum">   13532 </span><span class="lineCov">         85 : static tree</span>
<span class="lineNum">   13533 </span><span class="lineCov">         83 : c_parser_omp_clause_simdlen (c_parser *parser, tree list)</span>
<span class="lineNum">   13534 </span><span class="lineCov">        168 : {</span>
<span class="lineNum">   13535 </span>            :   location_t clause_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   13536 </span><span class="lineCov">          4 :   tree c, t;</span>
<span class="lineNum">   13537 </span>            : 
<span class="lineNum">   13538 </span><span class="lineCov">          4 :   matching_parens parens;</span>
<span class="lineNum">   13539 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   13540 </span>            :     return list;
<span class="lineNum">   13541 </span><span class="lineCov">         85 : </span>
<span class="lineNum">   13542 </span><span class="lineCov">         85 :   location_t expr_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   13543 </span>            :   c_expr expr = c_parser_expr_no_commas (parser, NULL);
<span class="lineNum">   13544 </span>            :   expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);
<span class="lineNum">   13545 </span><span class="lineCov">         81 :   t = expr.value;</span>
<span class="lineNum">   13546 </span>            :   t = c_fully_fold (t, false, NULL);
<span class="lineNum">   13547 </span><span class="lineCov">         81 :   if (TREE_CODE (t) != INTEGER_CST</span>
<span class="lineNum">   13548 </span><span class="lineCov">         81 :       || !INTEGRAL_TYPE_P (TREE_TYPE (t))</span>
<span class="lineNum">   13549 </span><span class="lineCov">         81 :       || tree_int_cst_sgn (t) != 1)</span>
<span class="lineNum">   13550 </span><span class="lineCov">         81 :     {</span>
<span class="lineNum">   13551 </span>            :       error_at (clause_loc, &quot;%&lt;simdlen%&gt; clause expression must &quot;
<span class="lineNum">   13552 </span>            :                             &quot;be positive constant integer expression&quot;);
<span class="lineNum">   13553 </span>            :       t = NULL_TREE;
<span class="lineNum">   13554 </span>            :     }
<span class="lineNum">   13555 </span>            : 
<span class="lineNum">   13556 </span>            :   parens.skip_until_found_close (parser);
<span class="lineNum">   13557 </span><span class="lineCov">         71 :   if (t == NULL_TREE || t == error_mark_node)</span>
<span class="lineNum">   13558 </span>            :     return list;
<span class="lineNum">   13559 </span><span class="lineCov">         71 : </span>
<span class="lineNum">   13560 </span><span class="lineCov">         71 :   check_no_duplicate_clause (list, OMP_CLAUSE_SIMDLEN, &quot;simdlen&quot;);</span>
<span class="lineNum">   13561 </span>            : 
<span class="lineNum">   13562 </span><span class="lineCov">        142 :   c = build_omp_clause (clause_loc, OMP_CLAUSE_SIMDLEN);</span>
<span class="lineNum">   13563 </span><span class="lineCov">         71 :   OMP_CLAUSE_SIMDLEN_EXPR (c) = t;</span>
<span class="lineNum">   13564 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   13565 </span>            :   return c;
<span class="lineNum">   13566 </span><span class="lineCov">         71 : }</span>
<span class="lineNum">   13567 </span><span class="lineCov">         71 : </span>
<span class="lineNum">   13568 </span><span class="lineCov">         71 : /* OpenMP 4.5:</span>
<span class="lineNum">   13569 </span><span class="lineCov">         71 :    vec:</span>
<span class="lineNum">   13570 </span><span class="lineCov">         71 :      identifier [+/- integer]</span>
<span class="lineNum">   13571 </span><span class="lineCov">         71 :      vec , identifier [+/- integer]</span>
<span class="lineNum">   13572 </span><span class="lineCov">         69 : */</span>
<a name="13573"><span class="lineNum">   13573 </span><span class="lineCov">        140 : </span></a>
<span class="lineNum">   13574 </span>            : static tree
<span class="lineNum">   13575 </span><span class="lineCov">          4 : c_parser_omp_clause_depend_sink (c_parser *parser, location_t clause_loc,</span>
<span class="lineNum">   13576 </span>            :                                  tree list)
<span class="lineNum">   13577 </span><span class="lineCov">          4 : {</span>
<span class="lineNum">   13578 </span>            :   tree vec = NULL;
<span class="lineNum">   13579 </span>            :   if (c_parser_next_token_is_not (parser, CPP_NAME)
<span class="lineNum">   13580 </span><span class="lineCov">         71 :       || c_parser_peek_token (parser)-&gt;id_kind != C_ID_ID)</span>
<span class="lineNum">   13581 </span><span class="lineCov">         71 :     {</span>
<span class="lineNum">   13582 </span>            :       c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">   13583 </span>            :       return list;
<span class="lineNum">   13584 </span><span class="lineCov">         67 :     }</span>
<span class="lineNum">   13585 </span>            : 
<span class="lineNum">   13586 </span><span class="lineCov">         67 :   while (c_parser_next_token_is (parser, CPP_NAME)</span>
<span class="lineNum">   13587 </span><span class="lineCov">         67 :          &amp;&amp; c_parser_peek_token (parser)-&gt;id_kind == C_ID_ID)</span>
<span class="lineNum">   13588 </span><span class="lineCov">         67 :     {</span>
<span class="lineNum">   13589 </span><span class="lineCov">         67 :       tree t = lookup_name (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">   13590 </span>            :       tree addend = NULL;
<span class="lineNum">   13591 </span>            : 
<span class="lineNum">   13592 </span>            :       if (t == NULL_TREE)
<span class="lineNum">   13593 </span>            :         {
<span class="lineNum">   13594 </span>            :           undeclared_variable (c_parser_peek_token (parser)-&gt;location,
<span class="lineNum">   13595 </span>            :                                c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   13596 </span>            :           t = error_mark_node;
<span class="lineNum">   13597 </span>            :         }
<span class="lineNum">   13598 </span>            : 
<span class="lineNum">   13599 </span><span class="lineCov">         77 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   13600 </span>            : 
<span class="lineNum">   13601 </span>            :       bool neg = false;
<span class="lineNum">   13602 </span><span class="lineCov">         77 :       if (c_parser_next_token_is (parser, CPP_MINUS))</span>
<span class="lineNum">   13603 </span><span class="lineCov">         77 :         neg = true;</span>
<span class="lineNum">   13604 </span><span class="lineCov">         77 :       else if (!c_parser_next_token_is (parser, CPP_PLUS))</span>
<span class="lineNum">   13605 </span>            :         {
<span class="lineNum">   13606 </span><span class="lineNoCov">          0 :           addend = integer_zero_node;</span>
<span class="lineNum">   13607 </span><span class="lineNoCov">          0 :           neg = false;</span>
<span class="lineNum">   13608 </span>            :           goto add_to_vector;
<span class="lineNum">   13609 </span>            :         }
<span class="lineNum">   13610 </span><span class="lineCov">        698 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   13611 </span><span class="lineCov">        698 : </span>
<span class="lineNum">   13612 </span>            :       if (c_parser_next_token_is_not (parser, CPP_NUMBER))
<span class="lineNum">   13613 </span><span class="lineCov">        698 :         {</span>
<span class="lineNum">   13614 </span><span class="lineCov">        698 :           c_parser_error (parser, &quot;expected integer&quot;);</span>
<span class="lineNum">   13615 </span>            :           return list;
<span class="lineNum">   13616 </span><span class="lineCov">        698 :         }</span>
<span class="lineNum">   13617 </span>            : 
<span class="lineNum">   13618 </span><span class="lineCov">          2 :       addend = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">   13619 </span><span class="lineCov">          2 :       if (TREE_CODE (addend) != INTEGER_CST)</span>
<span class="lineNum">   13620 </span><span class="lineCov">          2 :         {</span>
<span class="lineNum">   13621 </span>            :           c_parser_error (parser, &quot;expected integer&quot;);
<span class="lineNum">   13622 </span>            :           return list;
<span class="lineNum">   13623 </span><span class="lineCov">        698 :         }</span>
<span class="lineNum">   13624 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   13625 </span><span class="lineCov">        698 : </span>
<span class="lineNum">   13626 </span><span class="lineCov">        698 :     add_to_vector:</span>
<span class="lineNum">   13627 </span>            :       if (t != error_mark_node)
<span class="lineNum">   13628 </span><span class="lineCov">        589 :         {</span>
<span class="lineNum">   13629 </span>            :           vec = tree_cons (addend, t, vec);
<span class="lineNum">   13630 </span><span class="lineCov">        553 :           if (neg)</span>
<span class="lineNum">   13631 </span><span class="lineCov">        553 :             OMP_CLAUSE_DEPEND_SINK_NEGATIVE (vec) = 1;</span>
<span class="lineNum">   13632 </span><span class="lineCov">        553 :         }</span>
<span class="lineNum">   13633 </span>            : 
<span class="lineNum">   13634 </span><span class="lineCov">        145 :       if (c_parser_next_token_is_not (parser, CPP_COMMA))</span>
<span class="lineNum">   13635 </span>            :         break;
<span class="lineNum">   13636 </span><span class="lineCov">        145 : </span>
<span class="lineNum">   13637 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   13638 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   13639 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   13640 </span>            :   if (vec == NULL_TREE)
<span class="lineNum">   13641 </span>            :     return list;
<span class="lineNum">   13642 </span><span class="lineCov">        145 : </span>
<span class="lineNum">   13643 </span><span class="lineCov">        145 :   tree u = build_omp_clause (clause_loc, OMP_CLAUSE_DEPEND);</span>
<span class="lineNum">   13644 </span>            :   OMP_CLAUSE_DEPEND_KIND (u) = OMP_CLAUSE_DEPEND_SINK;
<span class="lineNum">   13645 </span><span class="lineNoCov">          0 :   OMP_CLAUSE_DECL (u) = nreverse (vec);</span>
<span class="lineNum">   13646 </span><span class="lineNoCov">          0 :   OMP_CLAUSE_CHAIN (u) = list;</span>
<span class="lineNum">   13647 </span>            :   return u;
<span class="lineNum">   13648 </span><span class="lineCov">        145 : }</span>
<span class="lineNum">   13649 </span>            : 
<span class="lineNum">   13650 </span><span class="lineCov">        698 : /* OpenMP 4.0:</span>
<span class="lineNum">   13651 </span><span class="lineCov">        698 :    depend ( depend-kind: variable-list )</span>
<span class="lineNum">   13652 </span>            : 
<span class="lineNum">   13653 </span><span class="lineCov">        696 :    depend-kind:</span>
<span class="lineNum">   13654 </span><span class="lineCov">        696 :      in | out | inout</span>
<span class="lineNum">   13655 </span><span class="lineCov">        108 : </span>
<span class="lineNum">   13656 </span>            :    OpenMP 4.5:
<span class="lineNum">   13657 </span>            :    depend ( source )
<span class="lineNum">   13658 </span><span class="lineCov">        698 : </span>
<span class="lineNum">   13659 </span>            :    depend ( sink  : vec )  */
<a name="13660"><span class="lineNum">   13660 </span>            : </a>
<span class="lineNum">   13661 </span><span class="lineCov">        621 : static tree</span>
<span class="lineNum">   13662 </span>            : c_parser_omp_clause_depend (c_parser *parser, tree list)
<span class="lineNum">   13663 </span>            : {
<span class="lineNum">   13664 </span><span class="lineCov">         77 :   location_t clause_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   13665 </span>            :   enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_INOUT;
<span class="lineNum">   13666 </span>            :   tree nl, c;
<span class="lineNum">   13667 </span><span class="lineCov">         76 : </span>
<span class="lineNum">   13668 </span><span class="lineCov">         76 :   matching_parens parens;</span>
<span class="lineNum">   13669 </span><span class="lineCov">         76 :   if (!parens.require_open (parser))</span>
<span class="lineNum">   13670 </span><span class="lineCov">         76 :     return list;</span>
<span class="lineNum">   13671 </span><span class="lineCov">         76 : </span>
<span class="lineNum">   13672 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   13673 </span>            :     {
<span class="lineNum">   13674 </span>            :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   13675 </span>            :       if (strcmp (&quot;in&quot;, p) == 0)
<span class="lineNum">   13676 </span>            :         kind = OMP_CLAUSE_DEPEND_IN;
<span class="lineNum">   13677 </span>            :       else if (strcmp (&quot;inout&quot;, p) == 0)
<span class="lineNum">   13678 </span>            :         kind = OMP_CLAUSE_DEPEND_INOUT;
<span class="lineNum">   13679 </span>            :       else if (strcmp (&quot;out&quot;, p) == 0)
<span class="lineNum">   13680 </span>            :         kind = OMP_CLAUSE_DEPEND_OUT;
<span class="lineNum">   13681 </span>            :       else if (strcmp (&quot;source&quot;, p) == 0)
<span class="lineNum">   13682 </span>            :         kind = OMP_CLAUSE_DEPEND_SOURCE;
<span class="lineNum">   13683 </span>            :       else if (strcmp (&quot;sink&quot;, p) == 0)
<span class="lineNum">   13684 </span>            :         kind = OMP_CLAUSE_DEPEND_SINK;
<span class="lineNum">   13685 </span>            :       else
<span class="lineNum">   13686 </span><span class="lineCov">        414 :         goto invalid_kind;</span>
<span class="lineNum">   13687 </span>            :     }
<span class="lineNum">   13688 </span><span class="lineCov">        414 :   else</span>
<span class="lineNum">   13689 </span><span class="lineCov">        414 :     goto invalid_kind;</span>
<span class="lineNum">   13690 </span><span class="lineCov">        414 : </span>
<span class="lineNum">   13691 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">   13692 </span><span class="lineCov">        828 : </span>
<span class="lineNum">   13693 </span><span class="lineCov">        414 :   if (kind == OMP_CLAUSE_DEPEND_SOURCE)</span>
<span class="lineNum">   13694 </span>            :     {
<span class="lineNum">   13695 </span>            :       c = build_omp_clause (clause_loc, OMP_CLAUSE_DEPEND);
<span class="lineNum">   13696 </span><span class="lineCov">        414 :       OMP_CLAUSE_DEPEND_KIND (c) = kind;</span>
<span class="lineNum">   13697 </span>            :       OMP_CLAUSE_DECL (c) = NULL_TREE;
<span class="lineNum">   13698 </span><span class="lineCov">        414 :       OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   13699 </span><span class="lineCov">        414 :       parens.skip_until_found_close (parser);</span>
<span class="lineNum">   13700 </span>            :       return c;
<span class="lineNum">   13701 </span><span class="lineCov">        284 :     }</span>
<span class="lineNum">   13702 </span>            : 
<span class="lineNum">   13703 </span><span class="lineCov">        209 :   if (!c_parser_require (parser, CPP_COLON, &quot;expected %&lt;:%&gt;&quot;))</span>
<span class="lineNum">   13704 </span>            :     goto resync_fail;
<span class="lineNum">   13705 </span><span class="lineCov">        125 : </span>
<span class="lineNum">   13706 </span>            :   if (kind == OMP_CLAUSE_DEPEND_SINK)
<span class="lineNum">   13707 </span><span class="lineCov">         77 :     nl = c_parser_omp_clause_depend_sink (parser, clause_loc, list);</span>
<span class="lineNum">   13708 </span>            :   else
<span class="lineNum">   13709 </span>            :     {
<span class="lineNum">   13710 </span>            :       nl = c_parser_omp_variable_list (parser, clause_loc,
<span class="lineNum">   13711 </span>            :                                        OMP_CLAUSE_DEPEND, list);
<span class="lineNum">   13712 </span>            : 
<span class="lineNum">   13713 </span>            :       for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))
<span class="lineNum">   13714 </span>            :         OMP_CLAUSE_DEPEND_KIND (c) = kind;
<span class="lineNum">   13715 </span><span class="lineCov">        414 :     }</span>
<span class="lineNum">   13716 </span>            : 
<span class="lineNum">   13717 </span><span class="lineCov">        414 :   parens.skip_until_found_close (parser);</span>
<span class="lineNum">   13718 </span>            :   return nl;
<span class="lineNum">   13719 </span><span class="lineCov">         48 : </span>
<span class="lineNum">   13720 </span><span class="lineCov">         48 :  invalid_kind:</span>
<span class="lineNum">   13721 </span><span class="lineCov">         48 :   c_parser_error (parser, &quot;invalid depend kind&quot;);</span>
<span class="lineNum">   13722 </span><span class="lineCov">         48 :  resync_fail:</span>
<span class="lineNum">   13723 </span><span class="lineCov">         96 :   parens.skip_until_found_close (parser);</span>
<span class="lineNum">   13724 </span><span class="lineCov">         48 :   return list;</span>
<span class="lineNum">   13725 </span>            : }
<span class="lineNum">   13726 </span>            : 
<span class="lineNum">   13727 </span><span class="lineCov">        366 : /* OpenMP 4.0:</span>
<span class="lineNum">   13728 </span>            :    map ( map-kind: variable-list )
<span class="lineNum">   13729 </span>            :    map ( variable-list )
<span class="lineNum">   13730 </span><span class="lineCov">        366 : </span>
<span class="lineNum">   13731 </span><span class="lineCov">         77 :    map-kind:</span>
<span class="lineNum">   13732 </span>            :      alloc | to | from | tofrom
<span class="lineNum">   13733 </span>            : 
<span class="lineNum">   13734 </span><span class="lineCov">        289 :    OpenMP 4.5:</span>
<span class="lineNum">   13735 </span>            :    map-kind:
<span class="lineNum">   13736 </span>            :      alloc | to | from | tofrom | release | delete
<span class="lineNum">   13737 </span><span class="lineCov">        611 : </span>
<span class="lineNum">   13738 </span><span class="lineCov">        322 :    map ( always [,] map-kind: variable-list ) */</span>
<a name="13739"><span class="lineNum">   13739 </span>            : </a>
<span class="lineNum">   13740 </span>            : static tree
<span class="lineNum">   13741 </span><span class="lineCov">        732 : c_parser_omp_clause_map (c_parser *parser, tree list)</span>
<span class="lineNum">   13742 </span><span class="lineCov">        366 : {</span>
<span class="lineNum">   13743 </span>            :   location_t clause_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   13744 </span><span class="lineNoCov">          0 :   enum gomp_map_kind kind = GOMP_MAP_TOFROM;</span>
<span class="lineNum">   13745 </span><span class="lineNoCov">          0 :   int always = 0;</span>
<span class="lineNum">   13746 </span><span class="lineNoCov">          0 :   enum c_id_kind always_id_kind = C_ID_NONE;</span>
<span class="lineNum">   13747 </span><span class="lineNoCov">          0 :   location_t always_loc = UNKNOWN_LOCATION;</span>
<span class="lineNum">   13748 </span><span class="lineNoCov">          0 :   tree always_id = NULL_TREE;</span>
<span class="lineNum">   13749 </span>            :   tree nl, c;
<span class="lineNum">   13750 </span>            : 
<span class="lineNum">   13751 </span>            :   matching_parens parens;
<span class="lineNum">   13752 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   13753 </span>            :     return list;
<span class="lineNum">   13754 </span>            : 
<span class="lineNum">   13755 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   13756 </span>            :     {
<span class="lineNum">   13757 </span>            :       c_token *tok = c_parser_peek_token (parser);
<span class="lineNum">   13758 </span>            :       const char *p = IDENTIFIER_POINTER (tok-&gt;value);
<span class="lineNum">   13759 </span>            :       always_id_kind = tok-&gt;id_kind;
<span class="lineNum">   13760 </span>            :       always_loc = tok-&gt;location;
<span class="lineNum">   13761 </span>            :       always_id = tok-&gt;value;
<span class="lineNum">   13762 </span>            :       if (strcmp (&quot;always&quot;, p) == 0)
<span class="lineNum">   13763 </span>            :         {
<span class="lineNum">   13764 </span>            :           c_token *sectok = c_parser_peek_2nd_token (parser);
<span class="lineNum">   13765 </span><span class="lineCov">        611 :           if (sectok-&gt;type == CPP_COMMA)</span>
<span class="lineNum">   13766 </span>            :             {
<span class="lineNum">   13767 </span><span class="lineCov">        611 :               c_parser_consume_token (parser);</span>
<span class="lineNum">   13768 </span><span class="lineCov">        611 :               c_parser_consume_token (parser);</span>
<span class="lineNum">   13769 </span><span class="lineCov">        611 :               always = 2;</span>
<span class="lineNum">   13770 </span><span class="lineCov">        611 :             }</span>
<span class="lineNum">   13771 </span><span class="lineCov">        611 :           else if (sectok-&gt;type == CPP_NAME)</span>
<span class="lineNum">   13772 </span><span class="lineCov">        611 :             {</span>
<span class="lineNum">   13773 </span><span class="lineCov">        611 :               p = IDENTIFIER_POINTER (sectok-&gt;value);</span>
<span class="lineNum">   13774 </span>            :               if (strcmp (&quot;alloc&quot;, p) == 0
<span class="lineNum">   13775 </span><span class="lineCov">       1222 :                   || strcmp (&quot;to&quot;, p) == 0</span>
<span class="lineNum">   13776 </span><span class="lineCov">        611 :                   || strcmp (&quot;from&quot;, p) == 0</span>
<span class="lineNum">   13777 </span>            :                   || strcmp (&quot;tofrom&quot;, p) == 0
<span class="lineNum">   13778 </span>            :                   || strcmp (&quot;release&quot;, p) == 0
<span class="lineNum">   13779 </span><span class="lineCov">        611 :                   || strcmp (&quot;delete&quot;, p) == 0)</span>
<span class="lineNum">   13780 </span>            :                 {
<span class="lineNum">   13781 </span><span class="lineCov">        611 :                   c_parser_consume_token (parser);</span>
<span class="lineNum">   13782 </span><span class="lineCov">        611 :                   always = 1;</span>
<span class="lineNum">   13783 </span><span class="lineCov">        611 :                 }</span>
<span class="lineNum">   13784 </span><span class="lineCov">        611 :             }</span>
<span class="lineNum">   13785 </span><span class="lineCov">        611 :         }</span>
<span class="lineNum">   13786 </span><span class="lineCov">        611 :     }</span>
<span class="lineNum">   13787 </span>            : 
<span class="lineNum">   13788 </span><span class="lineCov">         13 :   if (c_parser_next_token_is (parser, CPP_NAME)</span>
<span class="lineNum">   13789 </span><span class="lineCov">         13 :       &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type == CPP_COLON)</span>
<span class="lineNum">   13790 </span>            :     {
<span class="lineNum">   13791 </span><span class="lineCov">         11 :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">   13792 </span><span class="lineCov">         11 :       if (strcmp (&quot;alloc&quot;, p) == 0)</span>
<span class="lineNum">   13793 </span><span class="lineCov">         11 :         kind = GOMP_MAP_ALLOC;</span>
<span class="lineNum">   13794 </span>            :       else if (strcmp (&quot;to&quot;, p) == 0)
<span class="lineNum">   13795 </span><span class="lineCov">          2 :         kind = always ? GOMP_MAP_ALWAYS_TO : GOMP_MAP_TO;</span>
<span class="lineNum">   13796 </span>            :       else if (strcmp (&quot;from&quot;, p) == 0)
<span class="lineNum">   13797 </span><span class="lineCov">          2 :         kind = always ? GOMP_MAP_ALWAYS_FROM : GOMP_MAP_FROM;</span>
<span class="lineNum">   13798 </span><span class="lineCov">          2 :       else if (strcmp (&quot;tofrom&quot;, p) == 0)</span>
<span class="lineNum">   13799 </span><span class="lineCov">          2 :         kind = always ? GOMP_MAP_ALWAYS_TOFROM : GOMP_MAP_TOFROM;</span>
<span class="lineNum">   13800 </span><span class="lineNoCov">          0 :       else if (strcmp (&quot;release&quot;, p) == 0)</span>
<span class="lineNum">   13801 </span><span class="lineNoCov">          0 :         kind = GOMP_MAP_RELEASE;</span>
<span class="lineNum">   13802 </span><span class="lineNoCov">          0 :       else if (strcmp (&quot;delete&quot;, p) == 0)</span>
<span class="lineNum">   13803 </span><span class="lineNoCov">          0 :         kind = GOMP_MAP_DELETE;</span>
<span class="lineNum">   13804 </span>            :       else
<span class="lineNum">   13805 </span><span class="lineCov">          2 :         {</span>
<span class="lineNum">   13806 </span><span class="lineCov">          2 :           c_parser_error (parser, &quot;invalid map kind&quot;);</span>
<span class="lineNum">   13807 </span>            :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,
<span class="lineNum">   13808 </span>            :                                      &quot;expected %&lt;)%&gt;&quot;);
<span class="lineNum">   13809 </span>            :           return list;
<span class="lineNum">   13810 </span>            :         }
<span class="lineNum">   13811 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   13812 </span><span class="lineCov">        611 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   13813 </span><span class="lineCov">        611 :     }</span>
<span class="lineNum">   13814 </span>            :   else if (always)
<span class="lineNum">   13815 </span><span class="lineCov">        496 :     {</span>
<span class="lineNum">   13816 </span><span class="lineCov">        496 :       if (always_id_kind != C_ID_ID)</span>
<span class="lineNum">   13817 </span>            :         {
<span class="lineNum">   13818 </span><span class="lineCov">        431 :           c_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">   13819 </span><span class="lineCov">        146 :           parens.skip_until_found_close (parser);</span>
<span class="lineNum">   13820 </span><span class="lineCov">        285 :           return list;</span>
<span class="lineNum">   13821 </span><span class="lineCov">        168 :         }</span>
<span class="lineNum">   13822 </span><span class="lineCov">        117 : </span>
<span class="lineNum">   13823 </span><span class="lineCov">        107 :       tree t = lookup_name (always_id);</span>
<span class="lineNum">   13824 </span><span class="lineCov">         10 :       if (t == NULL_TREE)</span>
<span class="lineNum">   13825 </span>            :         {
<span class="lineNum">   13826 </span><span class="lineCov">          2 :           undeclared_variable (always_loc, always_id);</span>
<span class="lineNum">   13827 </span>            :           t = error_mark_node;
<span class="lineNum">   13828 </span>            :         }
<span class="lineNum">   13829 </span>            :       if (t != error_mark_node)
<span class="lineNum">   13830 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   13831 </span><span class="lineNoCov">          0 :           tree u = build_omp_clause (clause_loc, OMP_CLAUSE_MAP);</span>
<span class="lineNum">   13832 </span>            :           OMP_CLAUSE_DECL (u) = t;
<span class="lineNum">   13833 </span><span class="lineNoCov">          0 :           OMP_CLAUSE_CHAIN (u) = list;</span>
<span class="lineNum">   13834 </span>            :           OMP_CLAUSE_SET_MAP_KIND (u, kind);
<span class="lineNum">   13835 </span><span class="lineCov">        496 :           list = u;</span>
<span class="lineNum">   13836 </span><span class="lineCov">        496 :         }</span>
<span class="lineNum">   13837 </span>            :       if (always == 1)
<span class="lineNum">   13838 </span><span class="lineCov">        115 :         {</span>
<span class="lineNum">   13839 </span>            :           parens.skip_until_found_close (parser);
<span class="lineNum">   13840 </span><span class="lineNoCov">          0 :           return list;</span>
<span class="lineNum">   13841 </span>            :         }
<span class="lineNum">   13842 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   13843 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   13844 </span><span class="lineNoCov">          0 :   nl = c_parser_omp_variable_list (parser, clause_loc, OMP_CLAUSE_MAP, list);</span>
<span class="lineNum">   13845 </span>            : 
<span class="lineNum">   13846 </span>            :   for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))
<span class="lineNum">   13847 </span><span class="lineNoCov">          0 :     OMP_CLAUSE_SET_MAP_KIND (c, kind);</span>
<span class="lineNum">   13848 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   13849 </span>            :   parens.skip_until_found_close (parser);
<span class="lineNum">   13850 </span><span class="lineNoCov">          0 :   return nl;</span>
<span class="lineNum">   13851 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   13852 </span>            : 
<span class="lineNum">   13853 </span><span class="lineNoCov">          0 : /* OpenMP 4.0:</span>
<span class="lineNum">   13854 </span>            :    device ( expression ) */
<a name="13855"><span class="lineNum">   13855 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   13856 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   13857 </span><span class="lineNoCov">          0 : c_parser_omp_clause_device (c_parser *parser, tree list)</span>
<span class="lineNum">   13858 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   13859 </span><span class="lineNoCov">          0 :   location_t clause_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   13860 </span>            :   matching_parens parens;
<span class="lineNum">   13861 </span><span class="lineNoCov">          0 :   if (parens.require_open (parser))</span>
<span class="lineNum">   13862 </span>            :     {
<span class="lineNum">   13863 </span><span class="lineNoCov">          0 :       location_t expr_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   13864 </span><span class="lineNoCov">          0 :       c_expr expr = c_parser_expr_no_commas (parser, NULL);</span>
<span class="lineNum">   13865 </span>            :       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);
<span class="lineNum">   13866 </span>            :       tree c, t = expr.value;
<span class="lineNum">   13867 </span>            :       t = c_fully_fold (t, false, NULL);
<span class="lineNum">   13868 </span><span class="lineCov">        611 : </span>
<span class="lineNum">   13869 </span>            :       parens.skip_until_found_close (parser);
<span class="lineNum">   13870 </span><span class="lineCov">       1375 : </span>
<span class="lineNum">   13871 </span><span class="lineCov">        764 :       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))</span>
<span class="lineNum">   13872 </span>            :         {
<span class="lineNum">   13873 </span><span class="lineCov">       1222 :           c_parser_error (parser, &quot;expected integer expression&quot;);</span>
<span class="lineNum">   13874 </span><span class="lineCov">        611 :           return list;</span>
<span class="lineNum">   13875 </span>            :         }
<span class="lineNum">   13876 </span>            : 
<span class="lineNum">   13877 </span>            :       check_no_duplicate_clause (list, OMP_CLAUSE_DEVICE, &quot;device&quot;);
<span class="lineNum">   13878 </span>            : 
<span class="lineNum">   13879 </span>            :       c = build_omp_clause (clause_loc, OMP_CLAUSE_DEVICE);
<span class="lineNum">   13880 </span>            :       OMP_CLAUSE_DEVICE_ID (c) = t;
<span class="lineNum">   13881 </span><span class="lineCov">         65 :       OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   13882 </span>            :       list = c;
<span class="lineNum">   13883 </span><span class="lineCov">         65 :     }</span>
<span class="lineNum">   13884 </span><span class="lineCov">        130 : </span>
<span class="lineNum">   13885 </span><span class="lineCov">         65 :   return list;</span>
<span class="lineNum">   13886 </span>            : }
<span class="lineNum">   13887 </span><span class="lineCov">         65 : </span>
<span class="lineNum">   13888 </span><span class="lineCov">         65 : /* OpenMP 4.0:</span>
<span class="lineNum">   13889 </span><span class="lineCov">         65 :    dist_schedule ( static )</span>
<span class="lineNum">   13890 </span><span class="lineCov">         65 :    dist_schedule ( static , expression ) */</span>
<a name="13891"><span class="lineNum">   13891 </span><span class="lineCov">         65 : </span></a>
<span class="lineNum">   13892 </span>            : static tree
<span class="lineNum">   13893 </span><span class="lineCov">         65 : c_parser_omp_clause_dist_schedule (c_parser *parser, tree list)</span>
<span class="lineNum">   13894 </span>            : {
<span class="lineNum">   13895 </span><span class="lineCov">         65 :   tree c, t = NULL_TREE;</span>
<span class="lineNum">   13896 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   13897 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   13898 </span><span class="lineNoCov">          0 :   matching_parens parens;</span>
<span class="lineNum">   13899 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   13900 </span>            :     return list;
<span class="lineNum">   13901 </span><span class="lineCov">         65 : </span>
<span class="lineNum">   13902 </span>            :   if (!c_parser_next_token_is_keyword (parser, RID_STATIC))
<span class="lineNum">   13903 </span><span class="lineCov">         65 :     {</span>
<span class="lineNum">   13904 </span><span class="lineCov">         65 :       c_parser_error (parser, &quot;invalid dist_schedule kind&quot;);</span>
<span class="lineNum">   13905 </span><span class="lineCov">         65 :       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,</span>
<span class="lineNum">   13906 </span><span class="lineCov">         65 :                                  &quot;expected %&lt;)%&gt;&quot;);</span>
<span class="lineNum">   13907 </span>            :       return list;
<span class="lineNum">   13908 </span>            :     }
<span class="lineNum">   13909 </span>            : 
<span class="lineNum">   13910 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">   13911 </span>            :   if (c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">   13912 </span>            :     {
<span class="lineNum">   13913 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   13914 </span>            : 
<span class="lineNum">   13915 </span>            :       location_t expr_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   13916 </span>            :       c_expr expr = c_parser_expr_no_commas (parser, NULL);
<span class="lineNum">   13917 </span><span class="lineCov">        586 :       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);</span>
<span class="lineNum">   13918 </span>            :       t = expr.value;
<span class="lineNum">   13919 </span><span class="lineCov">        586 :       t = c_fully_fold (t, false, NULL);</span>
<span class="lineNum">   13920 </span><span class="lineCov">        586 :       parens.skip_until_found_close (parser);</span>
<span class="lineNum">   13921 </span>            :     }
<span class="lineNum">   13922 </span><span class="lineCov">       1172 :   else</span>
<span class="lineNum">   13923 </span><span class="lineCov">        586 :     c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,</span>
<span class="lineNum">   13924 </span>            :                                &quot;expected %&lt;,%&gt; or %&lt;)%&gt;&quot;);
<span class="lineNum">   13925 </span>            : 
<span class="lineNum">   13926 </span><span class="lineCov">        586 :   check_no_duplicate_clause (list, OMP_CLAUSE_SCHEDULE, &quot;schedule&quot;);</span>
<span class="lineNum">   13927 </span>            :   if (t == error_mark_node)
<span class="lineNum">   13928 </span><span class="lineNoCov">          0 :     return list;</span>
<span class="lineNum">   13929 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   13930 </span>            :   c = build_omp_clause (loc, OMP_CLAUSE_DIST_SCHEDULE);
<span class="lineNum">   13931 </span><span class="lineNoCov">          0 :   OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR (c) = t;</span>
<span class="lineNum">   13932 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   13933 </span>            :   return c;
<span class="lineNum">   13934 </span><span class="lineCov">        586 : }</span>
<span class="lineNum">   13935 </span><span class="lineCov">        586 : </span>
<span class="lineNum">   13936 </span>            : /* OpenMP 4.0:
<span class="lineNum">   13937 </span><span class="lineCov">        586 :    proc_bind ( proc-bind-kind )</span>
<span class="lineNum">   13938 </span>            : 
<span class="lineNum">   13939 </span><span class="lineCov">        586 :    proc-bind-kind:</span>
<span class="lineNum">   13940 </span><span class="lineCov">        586 :      master | close | spread  */</span>
<a name="13941"><span class="lineNum">   13941 </span><span class="lineCov">        586 : </span></a>
<span class="lineNum">   13942 </span><span class="lineCov">        586 : static tree</span>
<span class="lineNum">   13943 </span><span class="lineCov">        586 : c_parser_omp_clause_proc_bind (c_parser *parser, tree list)</span>
<span class="lineNum">   13944 </span><span class="lineCov">        586 : {</span>
<span class="lineNum">   13945 </span>            :   location_t clause_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   13946 </span>            :   enum omp_clause_proc_bind_kind kind;
<span class="lineNum">   13947 </span><span class="lineNoCov">          0 :   tree c;</span>
<span class="lineNum">   13948 </span>            : 
<span class="lineNum">   13949 </span>            :   matching_parens parens;
<span class="lineNum">   13950 </span><span class="lineCov">        586 :   if (!parens.require_open (parser))</span>
<span class="lineNum">   13951 </span><span class="lineCov">        586 :     return list;</span>
<span class="lineNum">   13952 </span>            : 
<span class="lineNum">   13953 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   13954 </span><span class="lineCov">        586 :     {</span>
<span class="lineNum">   13955 </span><span class="lineCov">        586 :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">   13956 </span><span class="lineCov">        586 :       if (strcmp (&quot;master&quot;, p) == 0)</span>
<span class="lineNum">   13957 </span><span class="lineCov">        586 :         kind = OMP_CLAUSE_PROC_BIND_MASTER;</span>
<span class="lineNum">   13958 </span>            :       else if (strcmp (&quot;close&quot;, p) == 0)
<span class="lineNum">   13959 </span>            :         kind = OMP_CLAUSE_PROC_BIND_CLOSE;
<span class="lineNum">   13960 </span>            :       else if (strcmp (&quot;spread&quot;, p) == 0)
<span class="lineNum">   13961 </span>            :         kind = OMP_CLAUSE_PROC_BIND_SPREAD;
<span class="lineNum">   13962 </span>            :       else
<span class="lineNum">   13963 </span>            :         goto invalid_kind;
<span class="lineNum">   13964 </span>            :     }
<span class="lineNum">   13965 </span>            :   else
<span class="lineNum">   13966 </span>            :     goto invalid_kind;
<span class="lineNum">   13967 </span><span class="lineCov">         52 : </span>
<span class="lineNum">   13968 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">   13969 </span><span class="lineCov">         52 :   parens.skip_until_found_close (parser);</span>
<span class="lineNum">   13970 </span><span class="lineCov">         52 :   c = build_omp_clause (clause_loc, OMP_CLAUSE_PROC_BIND);</span>
<span class="lineNum">   13971 </span><span class="lineCov">         52 :   OMP_CLAUSE_PROC_BIND_KIND (c) = kind;</span>
<span class="lineNum">   13972 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   13973 </span><span class="lineCov">        104 :   return c;</span>
<span class="lineNum">   13974 </span><span class="lineCov">         52 : </span>
<span class="lineNum">   13975 </span>            :  invalid_kind:
<span class="lineNum">   13976 </span>            :   c_parser_error (parser, &quot;invalid proc_bind kind&quot;);
<span class="lineNum">   13977 </span><span class="lineCov">         52 :   parens.skip_until_found_close (parser);</span>
<span class="lineNum">   13978 </span>            :   return list;
<span class="lineNum">   13979 </span><span class="lineCov">         52 : }</span>
<span class="lineNum">   13980 </span><span class="lineCov">         52 : </span>
<span class="lineNum">   13981 </span>            : /* OpenMP 4.0:
<span class="lineNum">   13982 </span><span class="lineCov">         38 :    to ( variable-list ) */</span>
<a name="13983"><span class="lineNum">   13983 </span>            : </a>
<span class="lineNum">   13984 </span><span class="lineCov">         27 : static tree</span>
<span class="lineNum">   13985 </span>            : c_parser_omp_clause_to (c_parser *parser, tree list)
<span class="lineNum">   13986 </span>            : {
<span class="lineNum">   13987 </span>            :   return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_TO, list);
<span class="lineNum">   13988 </span>            : }
<span class="lineNum">   13989 </span>            : 
<span class="lineNum">   13990 </span>            : /* OpenMP 4.0:
<span class="lineNum">   13991 </span>            :    from ( variable-list ) */
<a name="13992"><span class="lineNum">   13992 </span><span class="lineCov">         52 : </span></a>
<span class="lineNum">   13993 </span><span class="lineCov">         52 : static tree</span>
<span class="lineNum">   13994 </span><span class="lineCov">         52 : c_parser_omp_clause_from (c_parser *parser, tree list)</span>
<span class="lineNum">   13995 </span><span class="lineCov">         52 : {</span>
<span class="lineNum">   13996 </span><span class="lineCov">         52 :   return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_FROM, list);</span>
<span class="lineNum">   13997 </span><span class="lineCov">         52 : }</span>
<span class="lineNum">   13998 </span>            : 
<span class="lineNum">   13999 </span><span class="lineNoCov">          0 : /* OpenMP 4.0:</span>
<span class="lineNum">   14000 </span><span class="lineNoCov">          0 :    uniform ( variable-list ) */</span>
<a name="14001"><span class="lineNum">   14001 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   14002 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   14003 </span>            : c_parser_omp_clause_uniform (c_parser *parser, tree list)
<span class="lineNum">   14004 </span>            : {
<span class="lineNum">   14005 </span>            :   /* The clauses location.  */
<span class="lineNum">   14006 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   14007 </span>            : 
<span class="lineNum">   14008 </span>            :   matching_parens parens;
<span class="lineNum">   14009 </span><span class="lineNoCov">          0 :   if (parens.require_open (parser))</span>
<span class="lineNum">   14010 </span>            :     {
<span class="lineNum">   14011 </span><span class="lineNoCov">          0 :       list = c_parser_omp_variable_list (parser, loc, OMP_CLAUSE_UNIFORM,</span>
<span class="lineNum">   14012 </span>            :                                          list);
<span class="lineNum">   14013 </span>            :       parens.skip_until_found_close (parser);
<span class="lineNum">   14014 </span>            :     }
<span class="lineNum">   14015 </span>            :   return list;
<span class="lineNum">   14016 </span>            : }
<span class="lineNum">   14017 </span>            : 
<span class="lineNum">   14018 </span><span class="lineNoCov">          0 : /* Parse all OpenACC clauses.  The set clauses allowed by the directive</span>
<span class="lineNum">   14019 </span>            :    is a bitmask in MASK.  Return the list of clauses found.  */
<a name="14020"><span class="lineNum">   14020 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   14021 </span>            : static tree
<span class="lineNum">   14022 </span>            : c_parser_oacc_all_clauses (c_parser *parser, omp_clause_mask mask,
<span class="lineNum">   14023 </span>            :                            const char *where, bool finish_p = true)
<span class="lineNum">   14024 </span>            : {
<span class="lineNum">   14025 </span>            :   tree clauses = NULL;
<span class="lineNum">   14026 </span>            :   bool first = true;
<span class="lineNum">   14027 </span><span class="lineCov">         53 : </span>
<span class="lineNum">   14028 </span>            :   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))
<span class="lineNum">   14029 </span>            :     {
<span class="lineNum">   14030 </span><span class="lineCov">         53 :       location_t here;</span>
<span class="lineNum">   14031 </span>            :       pragma_omp_clause c_kind;
<span class="lineNum">   14032 </span><span class="lineCov">        106 :       const char *c_name;</span>
<span class="lineNum">   14033 </span><span class="lineCov">         53 :       tree prev = clauses;</span>
<span class="lineNum">   14034 </span>            : 
<span class="lineNum">   14035 </span><span class="lineCov">         53 :       if (!first &amp;&amp; c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">   14036 </span>            :         c_parser_consume_token (parser);
<span class="lineNum">   14037 </span><span class="lineCov">         53 : </span>
<span class="lineNum">   14038 </span>            :       here = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   14039 </span><span class="lineCov">         53 :       c_kind = c_parser_omp_clause_name (parser);</span>
<span class="lineNum">   14040 </span>            : 
<span class="lineNum">   14041 </span>            :       switch (c_kind)
<span class="lineNum">   14042 </span>            :         {
<span class="lineNum">   14043 </span>            :         case PRAGMA_OACC_CLAUSE_ASYNC:
<span class="lineNum">   14044 </span>            :           clauses = c_parser_oacc_clause_async (parser, clauses);
<span class="lineNum">   14045 </span>            :           c_name = &quot;async&quot;;
<span class="lineNum">   14046 </span><span class="lineCov">       3183 :           break;</span>
<span class="lineNum">   14047 </span>            :         case PRAGMA_OACC_CLAUSE_AUTO:
<span class="lineNum">   14048 </span>            :           clauses = c_parser_oacc_simple_clause (parser, OMP_CLAUSE_AUTO,
<span class="lineNum">   14049 </span><span class="lineCov">       3183 :                                                 clauses);</span>
<span class="lineNum">   14050 </span><span class="lineCov">       3183 :           c_name = &quot;auto&quot;;</span>
<span class="lineNum">   14051 </span>            :           break;
<span class="lineNum">   14052 </span><span class="lineCov">       7303 :         case PRAGMA_OACC_CLAUSE_COLLAPSE:</span>
<span class="lineNum">   14053 </span>            :           clauses = c_parser_omp_clause_collapse (parser, clauses);
<span class="lineNum">   14054 </span><span class="lineCov">       4163 :           c_name = &quot;collapse&quot;;</span>
<span class="lineNum">   14055 </span><span class="lineCov">       4163 :           break;</span>
<span class="lineNum">   14056 </span><span class="lineCov">       4163 :         case PRAGMA_OACC_CLAUSE_COPY:</span>
<span class="lineNum">   14057 </span><span class="lineCov">       4163 :           clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   14058 </span>            :           c_name = &quot;copy&quot;;
<span class="lineNum">   14059 </span><span class="lineCov">       4163 :           break;</span>
<span class="lineNum">   14060 </span><span class="lineNoCov">          0 :         case PRAGMA_OACC_CLAUSE_COPYIN:</span>
<span class="lineNum">   14061 </span>            :           clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);
<span class="lineNum">   14062 </span><span class="lineCov">       4163 :           c_name = &quot;copyin&quot;;</span>
<span class="lineNum">   14063 </span><span class="lineCov">       4163 :           break;</span>
<span class="lineNum">   14064 </span>            :         case PRAGMA_OACC_CLAUSE_COPYOUT:
<span class="lineNum">   14065 </span><span class="lineCov">       4163 :           clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   14066 </span>            :           c_name = &quot;copyout&quot;;
<span class="lineNum">   14067 </span><span class="lineCov">        165 :           break;</span>
<span class="lineNum">   14068 </span><span class="lineCov">        165 :         case PRAGMA_OACC_CLAUSE_CREATE:</span>
<span class="lineNum">   14069 </span><span class="lineCov">        165 :           clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   14070 </span><span class="lineCov">        165 :           c_name = &quot;create&quot;;</span>
<span class="lineNum">   14071 </span><span class="lineCov">        103 :           break;</span>
<span class="lineNum">   14072 </span><span class="lineCov">        103 :         case PRAGMA_OACC_CLAUSE_DELETE:</span>
<span class="lineNum">   14073 </span>            :           clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);
<span class="lineNum">   14074 </span><span class="lineCov">        103 :           c_name = &quot;delete&quot;;</span>
<span class="lineNum">   14075 </span><span class="lineCov">        103 :           break;</span>
<span class="lineNum">   14076 </span><span class="lineCov">         24 :         case PRAGMA_OMP_CLAUSE_DEFAULT:</span>
<span class="lineNum">   14077 </span><span class="lineCov">         24 :           clauses = c_parser_omp_clause_default (parser, clauses, true);</span>
<span class="lineNum">   14078 </span><span class="lineCov">         24 :           c_name = &quot;default&quot;;</span>
<span class="lineNum">   14079 </span><span class="lineCov">         24 :           break;</span>
<span class="lineNum">   14080 </span><span class="lineCov">        581 :         case PRAGMA_OACC_CLAUSE_DEVICE:</span>
<span class="lineNum">   14081 </span><span class="lineCov">        581 :           clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   14082 </span><span class="lineCov">        581 :           c_name = &quot;device&quot;;</span>
<span class="lineNum">   14083 </span><span class="lineCov">        581 :           break;</span>
<span class="lineNum">   14084 </span><span class="lineCov">        220 :         case PRAGMA_OACC_CLAUSE_DEVICEPTR:</span>
<span class="lineNum">   14085 </span><span class="lineCov">        220 :           clauses = c_parser_oacc_data_clause_deviceptr (parser, clauses);</span>
<span class="lineNum">   14086 </span><span class="lineCov">        220 :           c_name = &quot;deviceptr&quot;;</span>
<span class="lineNum">   14087 </span><span class="lineCov">        220 :           break;</span>
<span class="lineNum">   14088 </span><span class="lineCov">        214 :         case PRAGMA_OACC_CLAUSE_DEVICE_RESIDENT:</span>
<span class="lineNum">   14089 </span><span class="lineCov">        214 :           clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   14090 </span><span class="lineCov">        214 :           c_name = &quot;device_resident&quot;;</span>
<span class="lineNum">   14091 </span><span class="lineCov">        214 :           break;</span>
<span class="lineNum">   14092 </span><span class="lineCov">         67 :         case PRAGMA_OACC_CLAUSE_FINALIZE:</span>
<span class="lineNum">   14093 </span><span class="lineCov">         67 :           clauses = c_parser_oacc_simple_clause (parser, OMP_CLAUSE_FINALIZE,</span>
<span class="lineNum">   14094 </span><span class="lineCov">         67 :                                                  clauses);</span>
<span class="lineNum">   14095 </span><span class="lineCov">         67 :           c_name = &quot;finalize&quot;;</span>
<span class="lineNum">   14096 </span><span class="lineCov">         28 :           break;</span>
<span class="lineNum">   14097 </span><span class="lineCov">         28 :         case PRAGMA_OACC_CLAUSE_FIRSTPRIVATE:</span>
<span class="lineNum">   14098 </span><span class="lineCov">         28 :           clauses = c_parser_omp_clause_firstprivate (parser, clauses);</span>
<span class="lineNum">   14099 </span><span class="lineCov">         28 :           c_name = &quot;firstprivate&quot;;</span>
<span class="lineNum">   14100 </span><span class="lineCov">         38 :           break;</span>
<span class="lineNum">   14101 </span><span class="lineCov">         38 :         case PRAGMA_OACC_CLAUSE_GANG:</span>
<span class="lineNum">   14102 </span><span class="lineCov">         38 :           c_name = &quot;gang&quot;;</span>
<span class="lineNum">   14103 </span><span class="lineCov">         38 :           clauses = c_parser_oacc_shape_clause (parser, OMP_CLAUSE_GANG,</span>
<span class="lineNum">   14104 </span><span class="lineCov">         19 :                                                 c_name, clauses);</span>
<span class="lineNum">   14105 </span><span class="lineCov">         19 :           break;</span>
<span class="lineNum">   14106 </span><span class="lineCov">         19 :         case PRAGMA_OACC_CLAUSE_HOST:</span>
<span class="lineNum">   14107 </span><span class="lineCov">         19 :           clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   14108 </span><span class="lineCov">         48 :           c_name = &quot;host&quot;;</span>
<span class="lineNum">   14109 </span><span class="lineCov">         48 :           break;</span>
<span class="lineNum">   14110 </span><span class="lineCov">         48 :         case PRAGMA_OACC_CLAUSE_IF:</span>
<span class="lineNum">   14111 </span><span class="lineCov">         48 :           clauses = c_parser_omp_clause_if (parser, clauses, false);</span>
<span class="lineNum">   14112 </span><span class="lineCov">          7 :           c_name = &quot;if&quot;;</span>
<span class="lineNum">   14113 </span><span class="lineCov">          7 :           break;</span>
<span class="lineNum">   14114 </span><span class="lineCov">          7 :         case PRAGMA_OACC_CLAUSE_IF_PRESENT:</span>
<span class="lineNum">   14115 </span><span class="lineCov">          7 :           clauses = c_parser_oacc_simple_clause (parser, OMP_CLAUSE_IF_PRESENT,</span>
<span class="lineNum">   14116 </span><span class="lineCov">          2 :                                                  clauses);</span>
<span class="lineNum">   14117 </span><span class="lineCov">          2 :           c_name = &quot;if_present&quot;;</span>
<span class="lineNum">   14118 </span>            :           break;
<span class="lineNum">   14119 </span><span class="lineCov">          2 :         case PRAGMA_OACC_CLAUSE_INDEPENDENT:</span>
<span class="lineNum">   14120 </span><span class="lineCov">          2 :           clauses = c_parser_oacc_simple_clause (parser, OMP_CLAUSE_INDEPENDENT,</span>
<span class="lineNum">   14121 </span><span class="lineCov">         27 :                                                 clauses);</span>
<span class="lineNum">   14122 </span><span class="lineCov">         54 :           c_name = &quot;independent&quot;;</span>
<span class="lineNum">   14123 </span><span class="lineCov">         27 :           break;</span>
<span class="lineNum">   14124 </span><span class="lineCov">         27 :         case PRAGMA_OACC_CLAUSE_LINK:</span>
<span class="lineNum">   14125 </span><span class="lineCov">        407 :           clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   14126 </span><span class="lineCov">        407 :           c_name = &quot;link&quot;;</span>
<span class="lineNum">   14127 </span><span class="lineCov">        407 :           break;</span>
<span class="lineNum">   14128 </span>            :         case PRAGMA_OACC_CLAUSE_NUM_GANGS:
<span class="lineNum">   14129 </span><span class="lineCov">        407 :           clauses = c_parser_oacc_single_int_clause (parser,</span>
<span class="lineNum">   14130 </span><span class="lineCov">         42 :                                                      OMP_CLAUSE_NUM_GANGS,</span>
<span class="lineNum">   14131 </span><span class="lineCov">         42 :                                                      clauses);</span>
<span class="lineNum">   14132 </span><span class="lineCov">         42 :           c_name = &quot;num_gangs&quot;;</span>
<span class="lineNum">   14133 </span><span class="lineCov">         42 :           break;</span>
<span class="lineNum">   14134 </span><span class="lineCov">         69 :         case PRAGMA_OACC_CLAUSE_NUM_WORKERS:</span>
<span class="lineNum">   14135 </span><span class="lineCov">         69 :           clauses = c_parser_oacc_single_int_clause (parser,</span>
<span class="lineNum">   14136 </span><span class="lineCov">         69 :                                                      OMP_CLAUSE_NUM_WORKERS,</span>
<span class="lineNum">   14137 </span><span class="lineCov">         69 :                                                      clauses);</span>
<span class="lineNum">   14138 </span><span class="lineCov">         12 :           c_name = &quot;num_workers&quot;;</span>
<span class="lineNum">   14139 </span><span class="lineCov">         12 :           break;</span>
<span class="lineNum">   14140 </span>            :         case PRAGMA_OACC_CLAUSE_PRESENT:
<span class="lineNum">   14141 </span><span class="lineCov">         12 :           clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   14142 </span><span class="lineCov">         12 :           c_name = &quot;present&quot;;</span>
<span class="lineNum">   14143 </span><span class="lineCov">         25 :           break;</span>
<span class="lineNum">   14144 </span><span class="lineCov">         25 :         case PRAGMA_OACC_CLAUSE_PRIVATE:</span>
<span class="lineNum">   14145 </span>            :           clauses = c_parser_omp_clause_private (parser, clauses);
<span class="lineNum">   14146 </span><span class="lineCov">         25 :           c_name = &quot;private&quot;;</span>
<span class="lineNum">   14147 </span><span class="lineCov">         25 :           break;</span>
<span class="lineNum">   14148 </span><span class="lineCov">          9 :         case PRAGMA_OACC_CLAUSE_REDUCTION:</span>
<span class="lineNum">   14149 </span><span class="lineCov">          9 :           clauses = c_parser_omp_clause_reduction (parser, clauses);</span>
<span class="lineNum">   14150 </span><span class="lineCov">          9 :           c_name = &quot;reduction&quot;;</span>
<span class="lineNum">   14151 </span><span class="lineCov">          9 :           break;</span>
<span class="lineNum">   14152 </span><span class="lineCov">        283 :         case PRAGMA_OACC_CLAUSE_SEQ:</span>
<span class="lineNum">   14153 </span><span class="lineCov">        283 :           clauses = c_parser_oacc_simple_clause (parser, OMP_CLAUSE_SEQ,</span>
<span class="lineNum">   14154 </span>            :                                                 clauses);
<span class="lineNum">   14155 </span>            :           c_name = &quot;seq&quot;;
<span class="lineNum">   14156 </span><span class="lineCov">        283 :           break;</span>
<span class="lineNum">   14157 </span><span class="lineCov">        283 :         case PRAGMA_OACC_CLAUSE_TILE:</span>
<span class="lineNum">   14158 </span><span class="lineCov">        195 :           clauses = c_parser_oacc_clause_tile (parser, clauses);</span>
<span class="lineNum">   14159 </span><span class="lineCov">        195 :           c_name = &quot;tile&quot;;</span>
<span class="lineNum">   14160 </span>            :           break;
<span class="lineNum">   14161 </span>            :         case PRAGMA_OACC_CLAUSE_USE_DEVICE:
<span class="lineNum">   14162 </span><span class="lineCov">        195 :           clauses = c_parser_omp_clause_use_device_ptr (parser, clauses);</span>
<span class="lineNum">   14163 </span><span class="lineCov">        195 :           c_name = &quot;use_device&quot;;</span>
<span class="lineNum">   14164 </span><span class="lineCov">         96 :           break;</span>
<span class="lineNum">   14165 </span><span class="lineCov">         96 :         case PRAGMA_OACC_CLAUSE_VECTOR:</span>
<span class="lineNum">   14166 </span><span class="lineCov">         96 :           c_name = &quot;vector&quot;;</span>
<span class="lineNum">   14167 </span><span class="lineCov">         96 :           clauses = c_parser_oacc_shape_clause (parser, OMP_CLAUSE_VECTOR,</span>
<span class="lineNum">   14168 </span><span class="lineCov">         51 :                                                 c_name, clauses);</span>
<span class="lineNum">   14169 </span><span class="lineCov">        102 :           break;</span>
<span class="lineNum">   14170 </span><span class="lineCov">         51 :         case PRAGMA_OACC_CLAUSE_VECTOR_LENGTH:</span>
<span class="lineNum">   14171 </span><span class="lineCov">         51 :           clauses = c_parser_oacc_single_int_clause (parser,</span>
<span class="lineNum">   14172 </span><span class="lineCov">        292 :                                                      OMP_CLAUSE_VECTOR_LENGTH,</span>
<span class="lineNum">   14173 </span><span class="lineCov">        292 :                                                      clauses);</span>
<span class="lineNum">   14174 </span><span class="lineCov">        292 :           c_name = &quot;vector_length&quot;;</span>
<span class="lineNum">   14175 </span><span class="lineCov">        292 :           break;</span>
<span class="lineNum">   14176 </span><span class="lineCov">        100 :         case PRAGMA_OACC_CLAUSE_WAIT:</span>
<span class="lineNum">   14177 </span><span class="lineCov">        100 :           clauses = c_parser_oacc_clause_wait (parser, clauses);</span>
<span class="lineNum">   14178 </span>            :           c_name = &quot;wait&quot;;
<span class="lineNum">   14179 </span><span class="lineCov">        100 :           break;</span>
<span class="lineNum">   14180 </span><span class="lineCov">        100 :         case PRAGMA_OACC_CLAUSE_WORKER:</span>
<span class="lineNum">   14181 </span><span class="lineCov">        117 :           c_name = &quot;worker&quot;;</span>
<span class="lineNum">   14182 </span><span class="lineCov">        117 :           clauses = c_parser_oacc_shape_clause (parser, OMP_CLAUSE_WORKER,</span>
<span class="lineNum">   14183 </span><span class="lineCov">        117 :                                                 c_name, clauses);</span>
<span class="lineNum">   14184 </span><span class="lineCov">        117 :           break;</span>
<span class="lineNum">   14185 </span><span class="lineCov">         11 :         default:</span>
<span class="lineNum">   14186 </span><span class="lineCov">         22 :           c_parser_error (parser, &quot;expected %&lt;#pragma acc%&gt; clause&quot;);</span>
<span class="lineNum">   14187 </span><span class="lineCov">         11 :           goto saw_error;</span>
<span class="lineNum">   14188 </span><span class="lineCov">         11 :         }</span>
<span class="lineNum">   14189 </span><span class="lineCov">        325 : </span>
<span class="lineNum">   14190 </span><span class="lineCov">        325 :       first = false;</span>
<span class="lineNum">   14191 </span><span class="lineCov">        325 : </span>
<span class="lineNum">   14192 </span>            :       if (((mask &gt;&gt; c_kind) &amp; 1) == 0)
<span class="lineNum">   14193 </span><span class="lineCov">        325 :         {</span>
<span class="lineNum">   14194 </span><span class="lineCov">        206 :           /* Remove the invalid clause(s) from the list to avoid</span>
<span class="lineNum">   14195 </span><span class="lineCov">        206 :              confusing the rest of the compiler.  */</span>
<span class="lineNum">   14196 </span>            :           clauses = prev;
<span class="lineNum">   14197 </span>            :           error_at (here, &quot;%qs is not valid for %qs&quot;, c_name, where);
<span class="lineNum">   14198 </span><span class="lineCov">        206 :         }</span>
<span class="lineNum">   14199 </span><span class="lineCov">        206 :     }</span>
<span class="lineNum">   14200 </span><span class="lineCov">         60 : </span>
<span class="lineNum">   14201 </span><span class="lineCov">         60 :  saw_error:</span>
<span class="lineNum">   14202 </span><span class="lineCov">         60 :   c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   14203 </span><span class="lineCov">         60 : </span>
<span class="lineNum">   14204 </span><span class="lineCov">        277 :   if (finish_p)</span>
<span class="lineNum">   14205 </span><span class="lineCov">        277 :     return c_finish_omp_clauses (clauses, C_ORT_ACC);</span>
<span class="lineNum">   14206 </span><span class="lineCov">        277 : </span>
<span class="lineNum">   14207 </span>            :   return clauses;
<span class="lineNum">   14208 </span><span class="lineCov">        277 : }</span>
<span class="lineNum">   14209 </span><span class="lineCov">         43 : </span>
<span class="lineNum">   14210 </span><span class="lineCov">         43 : /* Parse all OpenMP clauses.  The set clauses allowed by the directive</span>
<span class="lineNum">   14211 </span><span class="lineCov">         43 :    is a bitmask in MASK.  Return the list of clauses found.  */</span>
<a name="14212"><span class="lineNum">   14212 </span>            : </a>
<span class="lineNum">   14213 </span>            : static tree
<span class="lineNum">   14214 </span><span class="lineCov">       4120 : c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,</span>
<span class="lineNum">   14215 </span>            :                           const char *where, bool finish_p = true)
<span class="lineNum">   14216 </span><span class="lineCov">      12360 : {</span>
<span class="lineNum">   14217 </span>            :   tree clauses = NULL;
<span class="lineNum">   14218 </span>            :   bool first = true;
<span class="lineNum">   14219 </span>            : 
<span class="lineNum">   14220 </span><span class="lineCov">          9 :   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))</span>
<span class="lineNum">   14221 </span><span class="lineCov">          9 :     {</span>
<span class="lineNum">   14222 </span>            :       location_t here;
<span class="lineNum">   14223 </span>            :       pragma_omp_clause c_kind;
<span class="lineNum">   14224 </span>            :       const char *c_name;
<span class="lineNum">   14225 </span><span class="lineCov">       3140 :       tree prev = clauses;</span>
<span class="lineNum">   14226 </span><span class="lineCov">       3183 : </span>
<span class="lineNum">   14227 </span>            :       if (!first &amp;&amp; c_parser_next_token_is (parser, CPP_COMMA))
<span class="lineNum">   14228 </span><span class="lineCov">       3183 :         c_parser_consume_token (parser);</span>
<span class="lineNum">   14229 </span><span class="lineCov">       2719 : </span>
<span class="lineNum">   14230 </span>            :       here = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   14231 </span>            :       c_kind = c_parser_omp_clause_name (parser);
<span class="lineNum">   14232 </span>            : 
<span class="lineNum">   14233 </span>            :       switch (c_kind)
<span class="lineNum">   14234 </span>            :         {
<span class="lineNum">   14235 </span>            :         case PRAGMA_OMP_CLAUSE_COLLAPSE:
<span class="lineNum">   14236 </span>            :           clauses = c_parser_omp_clause_collapse (parser, clauses);
<span class="lineNum">   14237 </span>            :           c_name = &quot;collapse&quot;;
<span class="lineNum">   14238 </span><span class="lineCov">       7079 :           break;</span>
<span class="lineNum">   14239 </span>            :         case PRAGMA_OMP_CLAUSE_COPYIN:
<span class="lineNum">   14240 </span>            :           clauses = c_parser_omp_clause_copyin (parser, clauses);
<span class="lineNum">   14241 </span><span class="lineCov">       7079 :           c_name = &quot;copyin&quot;;</span>
<span class="lineNum">   14242 </span><span class="lineCov">       7079 :           break;</span>
<span class="lineNum">   14243 </span>            :         case PRAGMA_OMP_CLAUSE_COPYPRIVATE:
<span class="lineNum">   14244 </span><span class="lineCov">      15965 :           clauses = c_parser_omp_clause_copyprivate (parser, clauses);</span>
<span class="lineNum">   14245 </span>            :           c_name = &quot;copyprivate&quot;;
<span class="lineNum">   14246 </span><span class="lineCov">       8894 :           break;</span>
<span class="lineNum">   14247 </span><span class="lineCov">       8894 :         case PRAGMA_OMP_CLAUSE_DEFAULT:</span>
<span class="lineNum">   14248 </span><span class="lineCov">       8894 :           clauses = c_parser_omp_clause_default (parser, clauses, false);</span>
<span class="lineNum">   14249 </span><span class="lineCov">       8894 :           c_name = &quot;default&quot;;</span>
<span class="lineNum">   14250 </span>            :           break;
<span class="lineNum">   14251 </span><span class="lineCov">       8894 :         case PRAGMA_OMP_CLAUSE_FIRSTPRIVATE:</span>
<span class="lineNum">   14252 </span><span class="lineCov">         25 :           clauses = c_parser_omp_clause_firstprivate (parser, clauses);</span>
<span class="lineNum">   14253 </span>            :           c_name = &quot;firstprivate&quot;;
<span class="lineNum">   14254 </span><span class="lineCov">       8894 :           break;</span>
<span class="lineNum">   14255 </span><span class="lineCov">       8894 :         case PRAGMA_OMP_CLAUSE_FINAL:</span>
<span class="lineNum">   14256 </span>            :           clauses = c_parser_omp_clause_final (parser, clauses);
<span class="lineNum">   14257 </span><span class="lineCov">       8894 :           c_name = &quot;final&quot;;</span>
<span class="lineNum">   14258 </span>            :           break;
<span class="lineNum">   14259 </span><span class="lineCov">       1009 :         case PRAGMA_OMP_CLAUSE_GRAINSIZE:</span>
<span class="lineNum">   14260 </span><span class="lineCov">       1009 :           clauses = c_parser_omp_clause_grainsize (parser, clauses);</span>
<span class="lineNum">   14261 </span><span class="lineCov">       1009 :           c_name = &quot;grainsize&quot;;</span>
<span class="lineNum">   14262 </span><span class="lineCov">       1009 :           break;</span>
<span class="lineNum">   14263 </span><span class="lineCov">         20 :         case PRAGMA_OMP_CLAUSE_HINT:</span>
<span class="lineNum">   14264 </span><span class="lineCov">         40 :           clauses = c_parser_omp_clause_hint (parser, clauses);</span>
<span class="lineNum">   14265 </span><span class="lineCov">         20 :           c_name = &quot;hint&quot;;</span>
<span class="lineNum">   14266 </span><span class="lineCov">         20 :           break;</span>
<span class="lineNum">   14267 </span><span class="lineCov">         19 :         case PRAGMA_OMP_CLAUSE_DEFAULTMAP:</span>
<span class="lineNum">   14268 </span><span class="lineCov">         38 :           clauses = c_parser_omp_clause_defaultmap (parser, clauses);</span>
<span class="lineNum">   14269 </span><span class="lineCov">         19 :           c_name = &quot;defaultmap&quot;;</span>
<span class="lineNum">   14270 </span><span class="lineCov">         19 :           break;</span>
<span class="lineNum">   14271 </span><span class="lineCov">        117 :         case PRAGMA_OMP_CLAUSE_IF:</span>
<span class="lineNum">   14272 </span><span class="lineCov">        117 :           clauses = c_parser_omp_clause_if (parser, clauses, true);</span>
<span class="lineNum">   14273 </span><span class="lineCov">        117 :           c_name = &quot;if&quot;;</span>
<span class="lineNum">   14274 </span><span class="lineCov">        117 :           break;</span>
<span class="lineNum">   14275 </span><span class="lineCov">        200 :         case PRAGMA_OMP_CLAUSE_LASTPRIVATE:</span>
<span class="lineNum">   14276 </span><span class="lineCov">        400 :           clauses = c_parser_omp_clause_lastprivate (parser, clauses);</span>
<span class="lineNum">   14277 </span><span class="lineCov">        200 :           c_name = &quot;lastprivate&quot;;</span>
<span class="lineNum">   14278 </span><span class="lineCov">        200 :           break;</span>
<span class="lineNum">   14279 </span><span class="lineCov">          5 :         case PRAGMA_OMP_CLAUSE_MERGEABLE:</span>
<span class="lineNum">   14280 </span><span class="lineCov">          5 :           clauses = c_parser_omp_clause_mergeable (parser, clauses);</span>
<span class="lineNum">   14281 </span><span class="lineCov">          5 :           c_name = &quot;mergeable&quot;;</span>
<span class="lineNum">   14282 </span><span class="lineCov">          5 :           break;</span>
<span class="lineNum">   14283 </span><span class="lineCov">          3 :         case PRAGMA_OMP_CLAUSE_NOWAIT:</span>
<span class="lineNum">   14284 </span><span class="lineCov">          3 :           clauses = c_parser_omp_clause_nowait (parser, clauses);</span>
<span class="lineNum">   14285 </span><span class="lineCov">          3 :           c_name = &quot;nowait&quot;;</span>
<span class="lineNum">   14286 </span><span class="lineCov">          3 :           break;</span>
<span class="lineNum">   14287 </span><span class="lineNoCov">          0 :         case PRAGMA_OMP_CLAUSE_NUM_TASKS:</span>
<span class="lineNum">   14288 </span><span class="lineNoCov">          0 :           clauses = c_parser_omp_clause_num_tasks (parser, clauses);</span>
<span class="lineNum">   14289 </span><span class="lineNoCov">          0 :           c_name = &quot;num_tasks&quot;;</span>
<span class="lineNum">   14290 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   14291 </span><span class="lineCov">         14 :         case PRAGMA_OMP_CLAUSE_NUM_THREADS:</span>
<span class="lineNum">   14292 </span><span class="lineCov">         14 :           clauses = c_parser_omp_clause_num_threads (parser, clauses);</span>
<span class="lineNum">   14293 </span><span class="lineCov">         14 :           c_name = &quot;num_threads&quot;;</span>
<span class="lineNum">   14294 </span><span class="lineCov">         14 :           break;</span>
<span class="lineNum">   14295 </span><span class="lineCov">        228 :         case PRAGMA_OMP_CLAUSE_ORDERED:</span>
<span class="lineNum">   14296 </span><span class="lineCov">        228 :           clauses = c_parser_omp_clause_ordered (parser, clauses);</span>
<span class="lineNum">   14297 </span><span class="lineCov">        228 :           c_name = &quot;ordered&quot;;</span>
<span class="lineNum">   14298 </span><span class="lineCov">        228 :           break;</span>
<span class="lineNum">   14299 </span><span class="lineCov">        146 :         case PRAGMA_OMP_CLAUSE_PRIORITY:</span>
<span class="lineNum">   14300 </span><span class="lineCov">        292 :           clauses = c_parser_omp_clause_priority (parser, clauses);</span>
<span class="lineNum">   14301 </span><span class="lineCov">        146 :           c_name = &quot;priority&quot;;</span>
<span class="lineNum">   14302 </span><span class="lineCov">        146 :           break;</span>
<span class="lineNum">   14303 </span><span class="lineCov">          1 :         case PRAGMA_OMP_CLAUSE_PRIVATE:</span>
<span class="lineNum">   14304 </span><span class="lineCov">          1 :           clauses = c_parser_omp_clause_private (parser, clauses);</span>
<span class="lineNum">   14305 </span><span class="lineCov">          1 :           c_name = &quot;private&quot;;</span>
<span class="lineNum">   14306 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">   14307 </span><span class="lineCov">        183 :         case PRAGMA_OMP_CLAUSE_REDUCTION:</span>
<span class="lineNum">   14308 </span><span class="lineCov">        183 :           clauses = c_parser_omp_clause_reduction (parser, clauses);</span>
<span class="lineNum">   14309 </span><span class="lineCov">        183 :           c_name = &quot;reduction&quot;;</span>
<span class="lineNum">   14310 </span><span class="lineCov">        183 :           break;</span>
<span class="lineNum">   14311 </span><span class="lineCov">          3 :         case PRAGMA_OMP_CLAUSE_SCHEDULE:</span>
<span class="lineNum">   14312 </span><span class="lineCov">          3 :           clauses = c_parser_omp_clause_schedule (parser, clauses);</span>
<span class="lineNum">   14313 </span><span class="lineCov">          3 :           c_name = &quot;schedule&quot;;</span>
<span class="lineNum">   14314 </span><span class="lineCov">          3 :           break;</span>
<span class="lineNum">   14315 </span><span class="lineCov">        227 :         case PRAGMA_OMP_CLAUSE_SHARED:</span>
<span class="lineNum">   14316 </span><span class="lineCov">        227 :           clauses = c_parser_omp_clause_shared (parser, clauses);</span>
<span class="lineNum">   14317 </span><span class="lineCov">        227 :           c_name = &quot;shared&quot;;</span>
<span class="lineNum">   14318 </span><span class="lineCov">        227 :           break;</span>
<span class="lineNum">   14319 </span><span class="lineCov">        117 :         case PRAGMA_OMP_CLAUSE_UNTIED:</span>
<span class="lineNum">   14320 </span><span class="lineCov">        117 :           clauses = c_parser_omp_clause_untied (parser, clauses);</span>
<span class="lineNum">   14321 </span><span class="lineCov">        117 :           c_name = &quot;untied&quot;;</span>
<span class="lineNum">   14322 </span><span class="lineCov">        117 :           break;</span>
<span class="lineNum">   14323 </span><span class="lineCov">          8 :         case PRAGMA_OMP_CLAUSE_INBRANCH:</span>
<span class="lineNum">   14324 </span><span class="lineCov">          8 :           clauses = c_parser_omp_clause_branch (parser, OMP_CLAUSE_INBRANCH,</span>
<span class="lineNum">   14325 </span><span class="lineCov">          8 :                                                 clauses);</span>
<span class="lineNum">   14326 </span><span class="lineCov">          8 :           c_name = &quot;inbranch&quot;;</span>
<span class="lineNum">   14327 </span><span class="lineCov">        201 :           break;</span>
<span class="lineNum">   14328 </span><span class="lineCov">        402 :         case PRAGMA_OMP_CLAUSE_NOTINBRANCH:</span>
<span class="lineNum">   14329 </span><span class="lineCov">        201 :           clauses = c_parser_omp_clause_branch (parser, OMP_CLAUSE_NOTINBRANCH,</span>
<span class="lineNum">   14330 </span><span class="lineCov">        201 :                                                 clauses);</span>
<span class="lineNum">   14331 </span><span class="lineCov">        512 :           c_name = &quot;notinbranch&quot;;</span>
<span class="lineNum">   14332 </span><span class="lineCov">        512 :           break;</span>
<span class="lineNum">   14333 </span><span class="lineCov">        512 :         case PRAGMA_OMP_CLAUSE_PARALLEL:</span>
<span class="lineNum">   14334 </span><span class="lineCov">        512 :           clauses</span>
<span class="lineNum">   14335 </span><span class="lineCov">       1564 :             = c_parser_omp_clause_cancelkind (parser, OMP_CLAUSE_PARALLEL,</span>
<span class="lineNum">   14336 </span><span class="lineCov">       1564 :                                               clauses);</span>
<span class="lineNum">   14337 </span><span class="lineCov">       1564 :           c_name = &quot;parallel&quot;;</span>
<span class="lineNum">   14338 </span><span class="lineCov">       1564 :           if (!first)</span>
<span class="lineNum">   14339 </span><span class="lineCov">        330 :             {</span>
<span class="lineNum">   14340 </span><span class="lineCov">        660 :              clause_not_first:</span>
<span class="lineNum">   14341 </span><span class="lineCov">        330 :               error_at (here, &quot;%qs must be the first clause of %qs&quot;,</span>
<span class="lineNum">   14342 </span><span class="lineCov">        330 :                         c_name, where);</span>
<span class="lineNum">   14343 </span><span class="lineCov">          3 :               clauses = prev;</span>
<span class="lineNum">   14344 </span><span class="lineCov">          3 :             }</span>
<span class="lineNum">   14345 </span><span class="lineCov">          3 :           break;</span>
<span class="lineNum">   14346 </span><span class="lineCov">          3 :         case PRAGMA_OMP_CLAUSE_FOR:</span>
<span class="lineNum">   14347 </span><span class="lineCov">          5 :           clauses</span>
<span class="lineNum">   14348 </span><span class="lineCov">          5 :             = c_parser_omp_clause_cancelkind (parser, OMP_CLAUSE_FOR,</span>
<span class="lineNum">   14349 </span>            :                                               clauses);
<span class="lineNum">   14350 </span><span class="lineCov">          5 :           c_name = &quot;for&quot;;</span>
<span class="lineNum">   14351 </span><span class="lineCov">          5 :           if (!first)</span>
<span class="lineNum">   14352 </span><span class="lineCov">         86 :             goto clause_not_first;</span>
<span class="lineNum">   14353 </span><span class="lineCov">         86 :           break;</span>
<span class="lineNum">   14354 </span>            :         case PRAGMA_OMP_CLAUSE_SECTIONS:
<span class="lineNum">   14355 </span><span class="lineCov">         86 :           clauses</span>
<span class="lineNum">   14356 </span><span class="lineCov">         86 :             = c_parser_omp_clause_cancelkind (parser, OMP_CLAUSE_SECTIONS,</span>
<span class="lineNum">   14357 </span><span class="lineCov">         72 :                                               clauses);</span>
<span class="lineNum">   14358 </span><span class="lineCov">         72 :           c_name = &quot;sections&quot;;</span>
<span class="lineNum">   14359 </span><span class="lineCov">         72 :           if (!first)</span>
<span class="lineNum">   14360 </span>            :             goto clause_not_first;
<span class="lineNum">   14361 </span><span class="lineCov">         72 :           break;</span>
<span class="lineNum">   14362 </span><span class="lineCov">         72 :         case PRAGMA_OMP_CLAUSE_TASKGROUP:</span>
<span class="lineNum">   14363 </span>            :           clauses
<span class="lineNum">   14364 </span><span class="lineNoCov">          0 :             = c_parser_omp_clause_cancelkind (parser, OMP_CLAUSE_TASKGROUP,</span>
<span class="lineNum">   14365 </span><span class="lineNoCov">          0 :                                               clauses);</span>
<span class="lineNum">   14366 </span>            :           c_name = &quot;taskgroup&quot;;
<span class="lineNum">   14367 </span><span class="lineNoCov">          0 :           if (!first)</span>
<span class="lineNum">   14368 </span>            :             goto clause_not_first;
<span class="lineNum">   14369 </span>            :           break;
<span class="lineNum">   14370 </span><span class="lineCov">         73 :         case PRAGMA_OMP_CLAUSE_LINK:</span>
<span class="lineNum">   14371 </span><span class="lineCov">         73 :           clauses</span>
<span class="lineNum">   14372 </span><span class="lineCov">         73 :             = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_LINK, clauses);</span>
<span class="lineNum">   14373 </span>            :           c_name = &quot;link&quot;;
<span class="lineNum">   14374 </span><span class="lineCov">         73 :           break;</span>
<span class="lineNum">   14375 </span><span class="lineCov">         73 :         case PRAGMA_OMP_CLAUSE_TO:</span>
<span class="lineNum">   14376 </span>            :           if ((mask &amp; (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LINK)) != 0)
<span class="lineNum">   14377 </span>            :             clauses
<span class="lineNum">   14378 </span><span class="lineCov">         68 :               = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_TO_DECLARE,</span>
<span class="lineNum">   14379 </span><span class="lineCov">         68 :                                               clauses);</span>
<span class="lineNum">   14380 </span><span class="lineCov">         68 :           else</span>
<span class="lineNum">   14381 </span>            :             clauses = c_parser_omp_clause_to (parser, clauses);
<span class="lineNum">   14382 </span><span class="lineCov">         68 :           c_name = &quot;to&quot;;</span>
<span class="lineNum">   14383 </span><span class="lineCov">         68 :           break;</span>
<span class="lineNum">   14384 </span>            :         case PRAGMA_OMP_CLAUSE_FROM:
<span class="lineNum">   14385 </span>            :           clauses = c_parser_omp_clause_from (parser, clauses);
<span class="lineNum">   14386 </span><span class="lineCov">         76 :           c_name = &quot;from&quot;;</span>
<span class="lineNum">   14387 </span><span class="lineCov">         76 :           break;</span>
<span class="lineNum">   14388 </span><span class="lineCov">         76 :         case PRAGMA_OMP_CLAUSE_UNIFORM:</span>
<span class="lineNum">   14389 </span>            :           clauses = c_parser_omp_clause_uniform (parser, clauses);
<span class="lineNum">   14390 </span><span class="lineCov">         76 :           c_name = &quot;uniform&quot;;</span>
<span class="lineNum">   14391 </span><span class="lineCov">         76 :           break;</span>
<span class="lineNum">   14392 </span>            :         case PRAGMA_OMP_CLAUSE_NUM_TEAMS:
<span class="lineNum">   14393 </span>            :           clauses = c_parser_omp_clause_num_teams (parser, clauses);
<span class="lineNum">   14394 </span><span class="lineCov">         12 :           c_name = &quot;num_teams&quot;;</span>
<span class="lineNum">   14395 </span><span class="lineCov">         12 :           break;</span>
<span class="lineNum">   14396 </span><span class="lineCov">         12 :         case PRAGMA_OMP_CLAUSE_THREAD_LIMIT:</span>
<span class="lineNum">   14397 </span><span class="lineCov">         12 :           clauses = c_parser_omp_clause_thread_limit (parser, clauses);</span>
<span class="lineNum">   14398 </span><span class="lineCov">         12 :           c_name = &quot;thread_limit&quot;;</span>
<span class="lineNum">   14399 </span><span class="lineCov">        178 :           break;</span>
<span class="lineNum">   14400 </span><span class="lineCov">        534 :         case PRAGMA_OMP_CLAUSE_ALIGNED:</span>
<span class="lineNum">   14401 </span><span class="lineCov">         27 :           clauses = c_parser_omp_clause_aligned (parser, clauses);</span>
<span class="lineNum">   14402 </span><span class="lineCov">         27 :           c_name = &quot;aligned&quot;;</span>
<span class="lineNum">   14403 </span>            :           break;
<span class="lineNum">   14404 </span>            :         case PRAGMA_OMP_CLAUSE_LINEAR: 
<span class="lineNum">   14405 </span><span class="lineCov">        151 :           clauses = c_parser_omp_clause_linear (parser, clauses); </span>
<span class="lineNum">   14406 </span>            :           c_name = &quot;linear&quot;;
<span class="lineNum">   14407 </span>            :           break;
<span class="lineNum">   14408 </span><span class="lineCov">        912 :         case PRAGMA_OMP_CLAUSE_DEPEND:</span>
<span class="lineNum">   14409 </span><span class="lineCov">       1824 :           clauses = c_parser_omp_clause_depend (parser, clauses);</span>
<span class="lineNum">   14410 </span><span class="lineCov">        912 :           c_name = &quot;depend&quot;;</span>
<span class="lineNum">   14411 </span><span class="lineCov">        912 :           break;</span>
<span class="lineNum">   14412 </span><span class="lineCov">         53 :         case PRAGMA_OMP_CLAUSE_MAP:</span>
<span class="lineNum">   14413 </span><span class="lineCov">         53 :           clauses = c_parser_omp_clause_map (parser, clauses);</span>
<span class="lineNum">   14414 </span><span class="lineCov">         53 :           c_name = &quot;map&quot;;</span>
<span class="lineNum">   14415 </span><span class="lineCov">         53 :           break;</span>
<span class="lineNum">   14416 </span><span class="lineCov">         66 :         case PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR:</span>
<span class="lineNum">   14417 </span><span class="lineCov">         66 :           clauses = c_parser_omp_clause_use_device_ptr (parser, clauses);</span>
<span class="lineNum">   14418 </span><span class="lineCov">         66 :           c_name = &quot;use_device_ptr&quot;;</span>
<span class="lineNum">   14419 </span><span class="lineCov">         66 :           break;</span>
<span class="lineNum">   14420 </span><span class="lineCov">         69 :         case PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR:</span>
<span class="lineNum">   14421 </span><span class="lineCov">         69 :           clauses = c_parser_omp_clause_is_device_ptr (parser, clauses);</span>
<span class="lineNum">   14422 </span><span class="lineCov">         69 :           c_name = &quot;is_device_ptr&quot;;</span>
<span class="lineNum">   14423 </span><span class="lineCov">         69 :           break;</span>
<span class="lineNum">   14424 </span><span class="lineCov">         84 :         case PRAGMA_OMP_CLAUSE_DEVICE:</span>
<span class="lineNum">   14425 </span><span class="lineCov">         84 :           clauses = c_parser_omp_clause_device (parser, clauses);</span>
<span class="lineNum">   14426 </span><span class="lineCov">         84 :           c_name = &quot;device&quot;;</span>
<span class="lineNum">   14427 </span><span class="lineCov">         84 :           break;</span>
<span class="lineNum">   14428 </span><span class="lineCov">        244 :         case PRAGMA_OMP_CLAUSE_DIST_SCHEDULE:</span>
<span class="lineNum">   14429 </span><span class="lineCov">        244 :           clauses = c_parser_omp_clause_dist_schedule (parser, clauses);</span>
<span class="lineNum">   14430 </span><span class="lineCov">        244 :           c_name = &quot;dist_schedule&quot;;</span>
<span class="lineNum">   14431 </span><span class="lineCov">        244 :           break;</span>
<span class="lineNum">   14432 </span><span class="lineCov">        414 :         case PRAGMA_OMP_CLAUSE_PROC_BIND:</span>
<span class="lineNum">   14433 </span><span class="lineCov">        414 :           clauses = c_parser_omp_clause_proc_bind (parser, clauses);</span>
<span class="lineNum">   14434 </span><span class="lineCov">        414 :           c_name = &quot;proc_bind&quot;;</span>
<span class="lineNum">   14435 </span><span class="lineCov">        414 :           break;</span>
<span class="lineNum">   14436 </span><span class="lineCov">        611 :         case PRAGMA_OMP_CLAUSE_SAFELEN:</span>
<span class="lineNum">   14437 </span><span class="lineCov">        611 :           clauses = c_parser_omp_clause_safelen (parser, clauses);</span>
<span class="lineNum">   14438 </span><span class="lineCov">        611 :           c_name = &quot;safelen&quot;;</span>
<span class="lineNum">   14439 </span><span class="lineCov">        611 :           break;</span>
<span class="lineNum">   14440 </span><span class="lineCov">          3 :         case PRAGMA_OMP_CLAUSE_SIMDLEN:</span>
<span class="lineNum">   14441 </span><span class="lineCov">          6 :           clauses = c_parser_omp_clause_simdlen (parser, clauses);</span>
<span class="lineNum">   14442 </span><span class="lineCov">          3 :           c_name = &quot;simdlen&quot;;</span>
<span class="lineNum">   14443 </span><span class="lineCov">          3 :           break;</span>
<span class="lineNum">   14444 </span><span class="lineCov">         14 :         case PRAGMA_OMP_CLAUSE_NOGROUP:</span>
<span class="lineNum">   14445 </span><span class="lineCov">         28 :           clauses = c_parser_omp_clause_nogroup (parser, clauses);</span>
<span class="lineNum">   14446 </span><span class="lineCov">         14 :           c_name = &quot;nogroup&quot;;</span>
<span class="lineNum">   14447 </span><span class="lineCov">         14 :           break;</span>
<span class="lineNum">   14448 </span><span class="lineCov">         65 :         case PRAGMA_OMP_CLAUSE_THREADS:</span>
<span class="lineNum">   14449 </span><span class="lineCov">         65 :           clauses</span>
<span class="lineNum">   14450 </span><span class="lineCov">         65 :             = c_parser_omp_clause_orderedkind (parser, OMP_CLAUSE_THREADS,</span>
<span class="lineNum">   14451 </span><span class="lineCov">         65 :                                                clauses);</span>
<span class="lineNum">   14452 </span><span class="lineCov">        586 :           c_name = &quot;threads&quot;;</span>
<span class="lineNum">   14453 </span><span class="lineCov">        586 :           break;</span>
<span class="lineNum">   14454 </span><span class="lineCov">        586 :         case PRAGMA_OMP_CLAUSE_SIMD:</span>
<span class="lineNum">   14455 </span><span class="lineCov">        586 :           clauses</span>
<span class="lineNum">   14456 </span><span class="lineCov">         52 :             = c_parser_omp_clause_orderedkind (parser, OMP_CLAUSE_SIMD,</span>
<span class="lineNum">   14457 </span><span class="lineCov">         52 :                                                clauses);</span>
<span class="lineNum">   14458 </span><span class="lineCov">         52 :           c_name = &quot;simd&quot;;</span>
<span class="lineNum">   14459 </span><span class="lineCov">         52 :           break;</span>
<span class="lineNum">   14460 </span><span class="lineCov">         85 :         default:</span>
<span class="lineNum">   14461 </span><span class="lineCov">         85 :           c_parser_error (parser, &quot;expected %&lt;#pragma omp%&gt; clause&quot;);</span>
<span class="lineNum">   14462 </span><span class="lineCov">         85 :           goto saw_error;</span>
<span class="lineNum">   14463 </span><span class="lineCov">         85 :         }</span>
<span class="lineNum">   14464 </span><span class="lineCov">         71 : </span>
<span class="lineNum">   14465 </span><span class="lineCov">         71 :       first = false;</span>
<span class="lineNum">   14466 </span><span class="lineCov">         71 : </span>
<span class="lineNum">   14467 </span><span class="lineCov">         71 :       if (((mask &gt;&gt; c_kind) &amp; 1) == 0)</span>
<span class="lineNum">   14468 </span><span class="lineCov">          4 :         {</span>
<span class="lineNum">   14469 </span><span class="lineCov">          4 :           /* Remove the invalid clause(s) from the list to avoid</span>
<span class="lineNum">   14470 </span><span class="lineCov">          4 :              confusing the rest of the compiler.  */</span>
<span class="lineNum">   14471 </span><span class="lineCov">          4 :           clauses = prev;</span>
<span class="lineNum">   14472 </span><span class="lineCov">         33 :           error_at (here, &quot;%qs is not valid for %qs&quot;, c_name, where);</span>
<span class="lineNum">   14473 </span><span class="lineCov">         33 :         }</span>
<span class="lineNum">   14474 </span><span class="lineCov">         33 :     }</span>
<span class="lineNum">   14475 </span>            : 
<span class="lineNum">   14476 </span><span class="lineCov">         33 :  saw_error:</span>
<span class="lineNum">   14477 </span><span class="lineCov">         33 :   c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   14478 </span><span class="lineCov">         40 : </span>
<span class="lineNum">   14479 </span><span class="lineCov">         40 :   if (finish_p)</span>
<span class="lineNum">   14480 </span><span class="lineCov">         40 :     {</span>
<span class="lineNum">   14481 </span>            :       if ((mask &amp; (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_UNIFORM)) != 0)
<span class="lineNum">   14482 </span><span class="lineCov">         40 :         return c_finish_omp_clauses (clauses, C_ORT_OMP_DECLARE_SIMD);</span>
<span class="lineNum">   14483 </span><span class="lineCov">         40 :       return c_finish_omp_clauses (clauses, C_ORT_OMP);</span>
<span class="lineNum">   14484 </span><span class="lineCov">          8 :     }</span>
<span class="lineNum">   14485 </span><span class="lineCov">          8 : </span>
<span class="lineNum">   14486 </span><span class="lineCov">          8 :   return clauses;</span>
<span class="lineNum">   14487 </span>            : }
<span class="lineNum">   14488 </span>            : 
<span class="lineNum">   14489 </span><span class="lineCov">       8886 : /* OpenACC 2.0, OpenMP 2.5:</span>
<span class="lineNum">   14490 </span>            :    structured-block:
<span class="lineNum">   14491 </span><span class="lineCov">      26658 :      statement</span>
<span class="lineNum">   14492 </span>            : 
<span class="lineNum">   14493 </span>            :    In practice, we're also interested in adding the statement to an
<span class="lineNum">   14494 </span>            :    outer node.  So it is convenient if we work around the fact that
<span class="lineNum">   14495 </span><span class="lineCov">         17 :    c_parser_statement calls add_stmt.  */</span>
<a name="14496"><span class="lineNum">   14496 </span><span class="lineCov">         17 : </span></a>
<span class="lineNum">   14497 </span>            : static tree
<span class="lineNum">   14498 </span>            : c_parser_omp_structured_block (c_parser *parser, bool *if_p)
<span class="lineNum">   14499 </span>            : {
<span class="lineNum">   14500 </span><span class="lineCov">       7071 :   tree stmt = push_stmt_list ();</span>
<span class="lineNum">   14501 </span><span class="lineCov">       7079 :   c_parser_statement (parser, if_p);</span>
<span class="lineNum">   14502 </span>            :   return pop_stmt_list (stmt);
<span class="lineNum">   14503 </span><span class="lineCov">       7079 : }</span>
<span class="lineNum">   14504 </span>            : 
<span class="lineNum">   14505 </span><span class="lineCov">      14781 : /* OpenACC 2.0:</span>
<span class="lineNum">   14506 </span><span class="lineCov">        168 :    # pragma acc cache (variable-list) new-line</span>
<span class="lineNum">   14507 </span><span class="lineCov">       4759 : </span>
<span class="lineNum">   14508 </span>            :    LOC is the location of the #pragma token.
<span class="lineNum">   14509 </span>            : */
<a name="14510"><span class="lineNum">   14510 </span>            : </a>
<span class="lineNum">   14511 </span>            : static tree
<span class="lineNum">   14512 </span>            : c_parser_oacc_cache (location_t loc, c_parser *parser)
<span class="lineNum">   14513 </span>            : {
<span class="lineNum">   14514 </span>            :   tree stmt, clauses;
<span class="lineNum">   14515 </span>            : 
<span class="lineNum">   14516 </span>            :   clauses = c_parser_omp_var_list_parens (parser, OMP_CLAUSE__CACHE_, NULL);
<span class="lineNum">   14517 </span>            :   clauses = c_finish_omp_clauses (clauses, C_ORT_ACC);
<span class="lineNum">   14518 </span>            : 
<span class="lineNum">   14519 </span>            :   c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   14520 </span>            : 
<span class="lineNum">   14521 </span>            :   stmt = make_node (OACC_CACHE);
<span class="lineNum">   14522 </span><span class="lineCov">       2936 :   TREE_TYPE (stmt) = void_type_node;</span>
<span class="lineNum">   14523 </span>            :   OACC_CACHE_CLAUSES (stmt) = clauses;
<span class="lineNum">   14524 </span><span class="lineCov">       2936 :   SET_EXPR_LOCATION (stmt, loc);</span>
<span class="lineNum">   14525 </span><span class="lineCov">       2936 :   add_stmt (stmt);</span>
<span class="lineNum">   14526 </span><span class="lineCov">       2936 : </span>
<span class="lineNum">   14527 </span>            :   return stmt;
<span class="lineNum">   14528 </span>            : }
<span class="lineNum">   14529 </span>            : 
<span class="lineNum">   14530 </span>            : /* OpenACC 2.0:
<span class="lineNum">   14531 </span>            :    # pragma acc data oacc-data-clause[optseq] new-line
<span class="lineNum">   14532 </span>            :      structured-block
<span class="lineNum">   14533 </span>            : 
<span class="lineNum">   14534 </span>            :    LOC is the location of the #pragma token.
<span class="lineNum">   14535 </span>            : */
<span class="lineNum">   14536 </span><span class="lineCov">         68 : </span>
<span class="lineNum">   14537 </span>            : #define OACC_DATA_CLAUSE_MASK                                           \
<span class="lineNum">   14538 </span><span class="lineCov">         68 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPY)          \</span>
<span class="lineNum">   14539 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYIN)                \
<span class="lineNum">   14540 </span><span class="lineCov">         68 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYOUT)               \</span>
<span class="lineNum">   14541 </span><span class="lineCov">         68 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_CREATE)                \</span>
<span class="lineNum">   14542 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEVICEPTR)             \
<span class="lineNum">   14543 </span><span class="lineCov">         68 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_IF)                    \</span>
<span class="lineNum">   14544 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_PRESENT))
<a name="14545"><span class="lineNum">   14545 </span><span class="lineCov">         68 : </span></a>
<span class="lineNum">   14546 </span><span class="lineCov">         68 : static tree</span>
<span class="lineNum">   14547 </span><span class="lineCov">         68 : c_parser_oacc_data (location_t loc, c_parser *parser, bool *if_p)</span>
<span class="lineNum">   14548 </span><span class="lineCov">         68 : {</span>
<span class="lineNum">   14549 </span><span class="lineCov">         68 :   tree stmt, clauses, block;</span>
<span class="lineNum">   14550 </span>            : 
<span class="lineNum">   14551 </span><span class="lineCov">         68 :   clauses = c_parser_oacc_all_clauses (parser, OACC_DATA_CLAUSE_MASK,</span>
<span class="lineNum">   14552 </span>            :                                        &quot;#pragma acc data&quot;);
<span class="lineNum">   14553 </span>            : 
<span class="lineNum">   14554 </span>            :   block = c_begin_omp_parallel ();
<span class="lineNum">   14555 </span>            :   add_stmt (c_parser_omp_structured_block (parser, if_p));
<span class="lineNum">   14556 </span>            : 
<span class="lineNum">   14557 </span>            :   stmt = c_finish_oacc_data (loc, clauses, block);
<span class="lineNum">   14558 </span>            : 
<span class="lineNum">   14559 </span>            :   return stmt;
<span class="lineNum">   14560 </span>            : }
<span class="lineNum">   14561 </span>            : 
<span class="lineNum">   14562 </span>            : /* OpenACC 2.0:
<span class="lineNum">   14563 </span>            :    # pragma acc declare oacc-data-clause[optseq] new-line
<span class="lineNum">   14564 </span>            : */
<span class="lineNum">   14565 </span>            : 
<span class="lineNum">   14566 </span>            : #define OACC_DECLARE_CLAUSE_MASK                                        \
<span class="lineNum">   14567 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPY)          \
<span class="lineNum">   14568 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYIN)                \
<span class="lineNum">   14569 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYOUT)               \
<span class="lineNum">   14570 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_CREATE)                \
<span class="lineNum">   14571 </span><span class="lineCov">        322 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEVICEPTR)             \</span>
<span class="lineNum">   14572 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEVICE_RESIDENT)       \
<span class="lineNum">   14573 </span><span class="lineCov">        322 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_LINK)          \</span>
<span class="lineNum">   14574 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_PRESENT))
<a name="14575"><span class="lineNum">   14575 </span><span class="lineCov">       4508 : </span></a>
<span class="lineNum">   14576 </span>            : static void
<span class="lineNum">   14577 </span>            : c_parser_oacc_declare (c_parser *parser)
<span class="lineNum">   14578 </span><span class="lineCov">        322 : {</span>
<span class="lineNum">   14579 </span><span class="lineCov">        322 :   location_t pragma_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   14580 </span>            :   tree clauses, stmt, t, decl;
<span class="lineNum">   14581 </span><span class="lineCov">        322 : </span>
<span class="lineNum">   14582 </span>            :   bool error = false;
<span class="lineNum">   14583 </span><span class="lineCov">        322 : </span>
<span class="lineNum">   14584 </span>            :   c_parser_consume_pragma (parser);
<span class="lineNum">   14585 </span>            : 
<span class="lineNum">   14586 </span>            :   clauses = c_parser_oacc_all_clauses (parser, OACC_DECLARE_CLAUSE_MASK,
<span class="lineNum">   14587 </span>            :                                        &quot;#pragma acc declare&quot;);
<span class="lineNum">   14588 </span>            :   if (!clauses)
<span class="lineNum">   14589 </span>            :     {
<span class="lineNum">   14590 </span>            :       error_at (pragma_loc,
<span class="lineNum">   14591 </span>            :                 &quot;no valid clauses specified in %&lt;#pragma acc declare%&gt;&quot;);
<span class="lineNum">   14592 </span>            :       return;
<span class="lineNum">   14593 </span>            :     }
<span class="lineNum">   14594 </span>            : 
<span class="lineNum">   14595 </span>            :   for (t = clauses; t; t = OMP_CLAUSE_CHAIN (t))
<span class="lineNum">   14596 </span>            :     {
<span class="lineNum">   14597 </span>            :       location_t loc = OMP_CLAUSE_LOCATION (t);
<span class="lineNum">   14598 </span>            :       decl = OMP_CLAUSE_DECL (t);
<span class="lineNum">   14599 </span>            :       if (!DECL_P (decl))
<span class="lineNum">   14600 </span>            :         {
<span class="lineNum">   14601 </span><span class="lineCov">         72 :           error_at (loc, &quot;array section in %&lt;#pragma acc declare%&gt;&quot;);</span>
<span class="lineNum">   14602 </span>            :           error = true;
<span class="lineNum">   14603 </span><span class="lineCov">         72 :           continue;</span>
<span class="lineNum">   14604 </span><span class="lineCov">         72 :         }</span>
<span class="lineNum">   14605 </span>            : 
<span class="lineNum">   14606 </span><span class="lineCov">         72 :       switch (OMP_CLAUSE_MAP_KIND (t))</span>
<span class="lineNum">   14607 </span>            :         {
<span class="lineNum">   14608 </span><span class="lineCov">         72 :         case GOMP_MAP_FIRSTPRIVATE_POINTER:</span>
<span class="lineNum">   14609 </span>            :         case GOMP_MAP_ALLOC:
<span class="lineNum">   14610 </span><span class="lineCov">       1152 :         case GOMP_MAP_TO:</span>
<span class="lineNum">   14611 </span>            :         case GOMP_MAP_FORCE_DEVICEPTR:
<span class="lineNum">   14612 </span><span class="lineCov">         72 :         case GOMP_MAP_DEVICE_RESIDENT:</span>
<span class="lineNum">   14613 </span>            :           break;
<span class="lineNum">   14614 </span><span class="lineCov">          2 : </span>
<span class="lineNum">   14615 </span>            :         case GOMP_MAP_LINK:
<span class="lineNum">   14616 </span><span class="lineCov">          2 :           if (!global_bindings_p ()</span>
<span class="lineNum">   14617 </span>            :               &amp;&amp; (TREE_STATIC (decl)
<span class="lineNum">   14618 </span>            :                || !DECL_EXTERNAL (decl)))
<span class="lineNum">   14619 </span><span class="lineCov">        146 :             {</span>
<span class="lineNum">   14620 </span>            :               error_at (loc,
<span class="lineNum">   14621 </span><span class="lineCov">         76 :                         &quot;%qD must be a global variable in &quot;</span>
<span class="lineNum">   14622 </span><span class="lineCov">        152 :                         &quot;%&lt;#pragma acc declare link%&gt;&quot;,</span>
<span class="lineNum">   14623 </span><span class="lineCov">         76 :                         decl);</span>
<span class="lineNum">   14624 </span>            :               error = true;
<span class="lineNum">   14625 </span><span class="lineCov">          1 :               continue;</span>
<span class="lineNum">   14626 </span><span class="lineCov">          1 :             }</span>
<span class="lineNum">   14627 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">   14628 </span>            : 
<span class="lineNum">   14629 </span>            :         default:
<span class="lineNum">   14630 </span><span class="lineCov">         75 :           if (global_bindings_p ())</span>
<span class="lineNum">   14631 </span>            :             {
<span class="lineNum">   14632 </span>            :               error_at (loc, &quot;invalid OpenACC clause at file scope&quot;);
<span class="lineNum">   14633 </span>            :               error = true;
<span class="lineNum">   14634 </span>            :               continue;
<span class="lineNum">   14635 </span>            :             }
<span class="lineNum">   14636 </span>            :           if (DECL_EXTERNAL (decl))
<span class="lineNum">   14637 </span>            :             {
<span class="lineNum">   14638 </span>            :               error_at (loc,
<span class="lineNum">   14639 </span><span class="lineCov">          9 :                         &quot;invalid use of %&lt;extern%&gt; variable %qD &quot;</span>
<span class="lineNum">   14640 </span><span class="lineCov">          9 :                         &quot;in %&lt;#pragma acc declare%&gt;&quot;, decl);</span>
<span class="lineNum">   14641 </span><span class="lineCov">          9 :               error = true;</span>
<span class="lineNum">   14642 </span><span class="lineCov">          2 :               continue;</span>
<span class="lineNum">   14643 </span>            :             }
<span class="lineNum">   14644 </span><span class="lineCov">          1 :           else if (TREE_PUBLIC (decl))</span>
<span class="lineNum">   14645 </span>            :             {
<span class="lineNum">   14646 </span>            :               error_at (loc,
<span class="lineNum">   14647 </span>            :                         &quot;invalid use of %&lt;global%&gt; variable %qD &quot;
<span class="lineNum">   14648 </span><span class="lineCov">          1 :                         &quot;in %&lt;#pragma acc declare%&gt;&quot;, decl);</span>
<span class="lineNum">   14649 </span><span class="lineCov">          1 :               error = true;</span>
<span class="lineNum">   14650 </span>            :               continue;
<span class="lineNum">   14651 </span>            :             }
<span class="lineNum">   14652 </span>            :           break;
<span class="lineNum">   14653 </span><span class="lineCov">         19 :         }</span>
<span class="lineNum">   14654 </span><span class="lineCov">         19 : </span>
<span class="lineNum">   14655 </span>            :       if (lookup_attribute (&quot;omp declare target&quot;, DECL_ATTRIBUTES (decl))
<span class="lineNum">   14656 </span><span class="lineCov">          5 :           || lookup_attribute (&quot;omp declare target link&quot;,</span>
<span class="lineNum">   14657 </span><span class="lineCov">          5 :                                DECL_ATTRIBUTES (decl)))</span>
<span class="lineNum">   14658 </span><span class="lineCov">          5 :         {</span>
<span class="lineNum">   14659 </span>            :           error_at (loc, &quot;variable %qD used more than once with &quot;
<span class="lineNum">   14660 </span><span class="lineCov">         14 :                     &quot;%&lt;#pragma acc declare%&gt;&quot;, decl);</span>
<span class="lineNum">   14661 </span>            :           error = true;
<span class="lineNum">   14662 </span><span class="lineCov">          5 :           continue;</span>
<span class="lineNum">   14663 </span>            :         }
<span class="lineNum">   14664 </span>            : 
<span class="lineNum">   14665 </span><span class="lineCov">          5 :       if (!error)</span>
<span class="lineNum">   14666 </span><span class="lineCov">          5 :         {</span>
<span class="lineNum">   14667 </span>            :           tree id;
<span class="lineNum">   14668 </span><span class="lineCov">          9 : </span>
<span class="lineNum">   14669 </span>            :           if (OMP_CLAUSE_MAP_KIND (t) == GOMP_MAP_LINK)
<span class="lineNum">   14670 </span><span class="lineCov">          1 :             id = get_identifier (&quot;omp declare target link&quot;);</span>
<span class="lineNum">   14671 </span>            :           else
<span class="lineNum">   14672 </span>            :             id = get_identifier (&quot;omp declare target&quot;);
<span class="lineNum">   14673 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   14674 </span><span class="lineCov">          1 :           DECL_ATTRIBUTES (decl)</span>
<span class="lineNum">   14675 </span>            :                            = tree_cons (id, NULL_TREE, DECL_ATTRIBUTES (decl));
<span class="lineNum">   14676 </span>            : 
<span class="lineNum">   14677 </span>            :           if (global_bindings_p ())
<span class="lineNum">   14678 </span>            :             {
<span class="lineNum">   14679 </span><span class="lineCov">         63 :               symtab_node *node = symtab_node::get (decl);</span>
<span class="lineNum">   14680 </span><span class="lineCov">        124 :               if (node != NULL)</span>
<span class="lineNum">   14681 </span><span class="lineCov">         61 :                 {</span>
<span class="lineNum">   14682 </span>            :                   node-&gt;offloadable = 1;
<span class="lineNum">   14683 </span><span class="lineCov">          3 :                   if (ENABLE_OFFLOADING)</span>
<span class="lineNum">   14684 </span>            :                     {
<span class="lineNum">   14685 </span><span class="lineCov">          3 :                       g-&gt;have_offload = true;</span>
<span class="lineNum">   14686 </span><span class="lineCov">          3 :                       if (is_a &lt;varpool_node *&gt; (node))</span>
<span class="lineNum">   14687 </span>            :                         vec_safe_push (offload_vars, decl);
<span class="lineNum">   14688 </span>            :                     }
<span class="lineNum">   14689 </span><span class="lineCov">         60 :                 }</span>
<span class="lineNum">   14690 </span>            :             }
<span class="lineNum">   14691 </span><span class="lineCov">         59 :         }</span>
<span class="lineNum">   14692 </span>            :     }
<span class="lineNum">   14693 </span><span class="lineCov">         59 : </span>
<span class="lineNum">   14694 </span><span class="lineCov">          6 :   if (error || global_bindings_p ())</span>
<span class="lineNum">   14695 </span>            :     return;
<span class="lineNum">   14696 </span><span class="lineCov">         53 : </span>
<span class="lineNum">   14697 </span>            :   stmt = make_node (OACC_DECLARE);
<span class="lineNum">   14698 </span><span class="lineCov">        177 :   TREE_TYPE (stmt) = void_type_node;</span>
<span class="lineNum">   14699 </span><span class="lineCov">         59 :   OACC_DECLARE_CLAUSES (stmt) = clauses;</span>
<span class="lineNum">   14700 </span>            :   SET_EXPR_LOCATION (stmt, pragma_loc);
<span class="lineNum">   14701 </span><span class="lineCov">         59 : </span>
<span class="lineNum">   14702 </span>            :   add_stmt (stmt);
<span class="lineNum">   14703 </span><span class="lineCov">         33 : </span>
<span class="lineNum">   14704 </span><span class="lineCov">         33 :   return;</span>
<span class="lineNum">   14705 </span>            : }
<span class="lineNum">   14706 </span><span class="lineCov">         25 : </span>
<span class="lineNum">   14707 </span><span class="lineCov">         25 : /* OpenACC 2.0:</span>
<span class="lineNum">   14708 </span>            :    # pragma acc enter data oacc-enter-data-clause[optseq] new-line
<span class="lineNum">   14709 </span>            : 
<span class="lineNum">   14710 </span>            :    or
<span class="lineNum">   14711 </span>            : 
<span class="lineNum">   14712 </span>            :    # pragma acc exit data oacc-exit-data-clause[optseq] new-line
<span class="lineNum">   14713 </span>            : 
<span class="lineNum">   14714 </span>            : 
<span class="lineNum">   14715 </span>            :    LOC is the location of the #pragma token.
<span class="lineNum">   14716 </span>            : */
<span class="lineNum">   14717 </span>            : 
<span class="lineNum">   14718 </span><span class="lineCov">         70 : #define OACC_ENTER_DATA_CLAUSE_MASK                                     \</span>
<span class="lineNum">   14719 </span><span class="lineCov">         44 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_IF)                    \</span>
<span class="lineNum">   14720 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_ASYNC)         \
<span class="lineNum">   14721 </span><span class="lineCov">         26 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYIN)                \</span>
<span class="lineNum">   14722 </span><span class="lineCov">         26 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_CREATE)                \</span>
<span class="lineNum">   14723 </span><span class="lineCov">         26 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_WAIT) )</span>
<span class="lineNum">   14724 </span><span class="lineCov">         26 : </span>
<span class="lineNum">   14725 </span>            : #define OACC_EXIT_DATA_CLAUSE_MASK                                      \
<span class="lineNum">   14726 </span><span class="lineCov">         26 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_IF)                    \</span>
<span class="lineNum">   14727 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_ASYNC)         \
<span class="lineNum">   14728 </span><span class="lineCov">         26 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYOUT)               \</span>
<span class="lineNum">   14729 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DELETE)                \
<span class="lineNum">   14730 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_FINALIZE)              \
<span class="lineNum">   14731 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_WAIT) )
<a name="14732"><span class="lineNum">   14732 </span>            : </a>
<span class="lineNum">   14733 </span>            : static void
<span class="lineNum">   14734 </span>            : c_parser_oacc_enter_exit_data (c_parser *parser, bool enter)
<span class="lineNum">   14735 </span>            : {
<span class="lineNum">   14736 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   14737 </span>            :   tree clauses, stmt;
<span class="lineNum">   14738 </span>            :   const char *p = &quot;&quot;;
<span class="lineNum">   14739 </span>            : 
<span class="lineNum">   14740 </span>            :   c_parser_consume_pragma (parser);
<span class="lineNum">   14741 </span>            : 
<span class="lineNum">   14742 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   14743 </span>            :     {
<span class="lineNum">   14744 </span>            :       p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   14745 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   14746 </span>            :     }
<span class="lineNum">   14747 </span>            : 
<span class="lineNum">   14748 </span>            :   if (strcmp (p, &quot;data&quot;) != 0)
<span class="lineNum">   14749 </span>            :     {
<span class="lineNum">   14750 </span>            :       error_at (loc, &quot;expected %&lt;data%&gt; after %&lt;#pragma acc %s%&gt;&quot;,
<span class="lineNum">   14751 </span>            :                 enter ? &quot;enter&quot; : &quot;exit&quot;);
<span class="lineNum">   14752 </span>            :       parser-&gt;error = true;
<span class="lineNum">   14753 </span>            :       c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   14754 </span>            :       return;
<span class="lineNum">   14755 </span>            :     }
<span class="lineNum">   14756 </span>            : 
<span class="lineNum">   14757 </span>            :   if (enter)
<span class="lineNum">   14758 </span><span class="lineCov">        123 :     clauses = c_parser_oacc_all_clauses (parser, OACC_ENTER_DATA_CLAUSE_MASK,</span>
<span class="lineNum">   14759 </span>            :                                          &quot;#pragma acc enter data&quot;);
<span class="lineNum">   14760 </span><span class="lineCov">        123 :   else</span>
<span class="lineNum">   14761 </span><span class="lineCov">        123 :     clauses = c_parser_oacc_all_clauses (parser, OACC_EXIT_DATA_CLAUSE_MASK,</span>
<span class="lineNum">   14762 </span><span class="lineCov">        123 :                                          &quot;#pragma acc exit data&quot;);</span>
<span class="lineNum">   14763 </span>            : 
<span class="lineNum">   14764 </span><span class="lineCov">        123 :   if (omp_find_clause (clauses, OMP_CLAUSE_MAP) == NULL_TREE)</span>
<span class="lineNum">   14765 </span>            :     {
<span class="lineNum">   14766 </span><span class="lineCov">        123 :       error_at (loc, &quot;%&lt;#pragma acc %s data%&gt; has no data movement clause&quot;,</span>
<span class="lineNum">   14767 </span>            :                 enter ? &quot;enter&quot; : &quot;exit&quot;);
<span class="lineNum">   14768 </span><span class="lineCov">        120 :       return;</span>
<span class="lineNum">   14769 </span><span class="lineCov">        120 :     }</span>
<span class="lineNum">   14770 </span>            : 
<span class="lineNum">   14771 </span>            :   stmt = enter ? make_node (OACC_ENTER_DATA) : make_node (OACC_EXIT_DATA);
<span class="lineNum">   14772 </span><span class="lineCov">        123 :   TREE_TYPE (stmt) = void_type_node;</span>
<span class="lineNum">   14773 </span>            :   OMP_STANDALONE_CLAUSES (stmt) = clauses;
<span class="lineNum">   14774 </span><span class="lineCov">          8 :   SET_EXPR_LOCATION (stmt, loc);</span>
<span class="lineNum">   14775 </span>            :   add_stmt (stmt);
<span class="lineNum">   14776 </span><span class="lineCov">          6 : }</span>
<span class="lineNum">   14777 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   14778 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   14779 </span>            : /* OpenACC 2.0:
<span class="lineNum">   14780 </span>            :    # pragma acc host_data oacc-data-clause[optseq] new-line
<span class="lineNum">   14781 </span><span class="lineCov">        117 :      structured-block</span>
<span class="lineNum">   14782 </span><span class="lineCov">        682 : */</span>
<span class="lineNum">   14783 </span>            : 
<span class="lineNum">   14784 </span>            : #define OACC_HOST_DATA_CLAUSE_MASK                                      \
<span class="lineNum">   14785 </span><span class="lineCov">        715 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_USE_DEVICE) )</span>
<a name="14786"><span class="lineNum">   14786 </span>            : </a>
<span class="lineNum">   14787 </span>            : static tree
<span class="lineNum">   14788 </span><span class="lineCov">        117 : c_parser_oacc_host_data (location_t loc, c_parser *parser, bool *if_p)</span>
<span class="lineNum">   14789 </span>            : {
<span class="lineNum">   14790 </span><span class="lineCov">          3 :   tree stmt, clauses, block;</span>
<span class="lineNum">   14791 </span>            : 
<span class="lineNum">   14792 </span><span class="lineCov">          3 :   clauses = c_parser_oacc_all_clauses (parser, OACC_HOST_DATA_CLAUSE_MASK,</span>
<span class="lineNum">   14793 </span>            :                                        &quot;#pragma acc host_data&quot;);
<span class="lineNum">   14794 </span>            : 
<span class="lineNum">   14795 </span><span class="lineCov">        114 :   block = c_begin_omp_parallel ();</span>
<span class="lineNum">   14796 </span><span class="lineCov">        114 :   add_stmt (c_parser_omp_structured_block (parser, if_p));</span>
<span class="lineNum">   14797 </span><span class="lineCov">        228 :   stmt = c_finish_oacc_host_data (loc, clauses, block);</span>
<span class="lineNum">   14798 </span><span class="lineCov">        114 :   return stmt;</span>
<span class="lineNum">   14799 </span><span class="lineCov">        114 : }</span>
<span class="lineNum">   14800 </span>            : 
<span class="lineNum">   14801 </span>            : 
<span class="lineNum">   14802 </span>            : /* OpenACC 2.0:
<span class="lineNum">   14803 </span>            : 
<span class="lineNum">   14804 </span>            :    # pragma acc loop oacc-loop-clause[optseq] new-line
<span class="lineNum">   14805 </span>            :      structured-block
<span class="lineNum">   14806 </span>            : 
<span class="lineNum">   14807 </span>            :    LOC is the location of the #pragma token.
<span class="lineNum">   14808 </span>            : */
<span class="lineNum">   14809 </span>            : 
<span class="lineNum">   14810 </span>            : #define OACC_LOOP_CLAUSE_MASK                                           \
<span class="lineNum">   14811 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COLLAPSE)              \
<span class="lineNum">   14812 </span><span class="lineCov">         12 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_PRIVATE)               \</span>
<span class="lineNum">   14813 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_REDUCTION)             \
<span class="lineNum">   14814 </span><span class="lineCov">         12 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_GANG)          \</span>
<span class="lineNum">   14815 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_WORKER)                \
<span class="lineNum">   14816 </span><span class="lineCov">         36 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_VECTOR)                \</span>
<span class="lineNum">   14817 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_AUTO)          \
<span class="lineNum">   14818 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_INDEPENDENT)   \
<span class="lineNum">   14819 </span><span class="lineCov">         12 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_SEQ)                   \</span>
<a name="14820"><span class="lineNum">   14820 </span><span class="lineCov">         12 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_TILE) )</span></a>
<span class="lineNum">   14821 </span><span class="lineCov">         12 : static tree</span>
<span class="lineNum">   14822 </span><span class="lineCov">         12 : c_parser_oacc_loop (location_t loc, c_parser *parser, char *p_name,</span>
<span class="lineNum">   14823 </span>            :                     omp_clause_mask mask, tree *cclauses, bool *if_p)
<span class="lineNum">   14824 </span>            : {
<span class="lineNum">   14825 </span>            :   bool is_parallel = ((mask &gt;&gt; PRAGMA_OACC_CLAUSE_REDUCTION) &amp; 1) == 1;
<span class="lineNum">   14826 </span>            : 
<span class="lineNum">   14827 </span>            :   strcat (p_name, &quot; loop&quot;);
<span class="lineNum">   14828 </span>            :   mask |= OACC_LOOP_CLAUSE_MASK;
<span class="lineNum">   14829 </span>            : 
<span class="lineNum">   14830 </span>            :   tree clauses = c_parser_oacc_all_clauses (parser, mask, p_name,
<span class="lineNum">   14831 </span>            :                                             cclauses == NULL);
<span class="lineNum">   14832 </span>            :   if (cclauses)
<span class="lineNum">   14833 </span>            :     {
<span class="lineNum">   14834 </span>            :       clauses = c_oacc_split_loop_clauses (clauses, cclauses, is_parallel);
<span class="lineNum">   14835 </span>            :       if (*cclauses)
<span class="lineNum">   14836 </span>            :         *cclauses = c_finish_omp_clauses (*cclauses, C_ORT_ACC);
<span class="lineNum">   14837 </span>            :       if (clauses)
<span class="lineNum">   14838 </span>            :         clauses = c_finish_omp_clauses (clauses, C_ORT_ACC);
<span class="lineNum">   14839 </span>            :     }
<span class="lineNum">   14840 </span>            : 
<span class="lineNum">   14841 </span>            :   tree block = c_begin_compound_stmt (true);
<span class="lineNum">   14842 </span>            :   tree stmt = c_parser_omp_for_loop (loc, parser, OACC_LOOP, clauses, NULL,
<span class="lineNum">   14843 </span>            :                                      if_p);
<span class="lineNum">   14844 </span>            :   block = c_end_compound_stmt (loc, block, true);
<span class="lineNum">   14845 </span>            :   add_stmt (block);
<span class="lineNum">   14846 </span><span class="lineCov">       1430 : </span>
<span class="lineNum">   14847 </span>            :   return stmt;
<span class="lineNum">   14848 </span>            : }
<span class="lineNum">   14849 </span><span class="lineCov">       4290 : </span>
<span class="lineNum">   14850 </span>            : /* OpenACC 2.0:
<span class="lineNum">   14851 </span><span class="lineCov">       1430 :    # pragma acc kernels oacc-kernels-clause[optseq] new-line</span>
<span class="lineNum">   14852 </span><span class="lineCov">      34320 :      structured-block</span>
<span class="lineNum">   14853 </span>            : 
<span class="lineNum">   14854 </span><span class="lineCov">       1430 :    or</span>
<span class="lineNum">   14855 </span>            : 
<span class="lineNum">   14856 </span><span class="lineCov">       1430 :    # pragma acc parallel oacc-parallel-clause[optseq] new-line</span>
<span class="lineNum">   14857 </span>            :      structured-block
<span class="lineNum">   14858 </span><span class="lineCov">        464 : </span>
<span class="lineNum">   14859 </span><span class="lineCov">        464 :    LOC is the location of the #pragma token.</span>
<span class="lineNum">   14860 </span><span class="lineCov">        107 : */</span>
<span class="lineNum">   14861 </span><span class="lineCov">        464 : </span>
<span class="lineNum">   14862 </span><span class="lineCov">        196 : #define OACC_KERNELS_CLAUSE_MASK                                        \</span>
<span class="lineNum">   14863 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_ASYNC)         \
<span class="lineNum">   14864 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPY)          \
<span class="lineNum">   14865 </span><span class="lineCov">       1430 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYIN)                \</span>
<span class="lineNum">   14866 </span><span class="lineCov">       1430 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYOUT)               \</span>
<span class="lineNum">   14867 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_CREATE)                \
<span class="lineNum">   14868 </span><span class="lineCov">       1430 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEFAULT)               \</span>
<span class="lineNum">   14869 </span><span class="lineCov">       1430 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEVICEPTR)             \</span>
<span class="lineNum">   14870 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_IF)                    \
<span class="lineNum">   14871 </span><span class="lineCov">       1430 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_NUM_GANGS)             \</span>
<span class="lineNum">   14872 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_NUM_WORKERS)           \
<span class="lineNum">   14873 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_PRESENT)               \
<span class="lineNum">   14874 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_VECTOR_LENGTH) \
<span class="lineNum">   14875 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_WAIT) )
<span class="lineNum">   14876 </span>            : 
<span class="lineNum">   14877 </span>            : #define OACC_PARALLEL_CLAUSE_MASK                                       \
<span class="lineNum">   14878 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_ASYNC)         \
<span class="lineNum">   14879 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPY)          \
<span class="lineNum">   14880 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYIN)                \
<span class="lineNum">   14881 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYOUT)               \
<span class="lineNum">   14882 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_CREATE)                \
<span class="lineNum">   14883 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEFAULT)               \
<span class="lineNum">   14884 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEVICEPTR)             \
<span class="lineNum">   14885 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_IF)                    \
<span class="lineNum">   14886 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_PRIVATE)               \
<span class="lineNum">   14887 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_FIRSTPRIVATE)  \
<span class="lineNum">   14888 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_NUM_GANGS)             \
<span class="lineNum">   14889 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_NUM_WORKERS)           \
<span class="lineNum">   14890 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_PRESENT)               \
<span class="lineNum">   14891 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_REDUCTION)             \
<span class="lineNum">   14892 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_VECTOR_LENGTH) \
<span class="lineNum">   14893 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_WAIT) )
<a name="14894"><span class="lineNum">   14894 </span>            : </a>
<span class="lineNum">   14895 </span>            : static tree
<span class="lineNum">   14896 </span>            : c_parser_oacc_kernels_parallel (location_t loc, c_parser *parser,
<span class="lineNum">   14897 </span>            :                                 enum pragma_kind p_kind, char *p_name,
<span class="lineNum">   14898 </span>            :                                 bool *if_p)
<span class="lineNum">   14899 </span>            : {
<span class="lineNum">   14900 </span>            :   omp_clause_mask mask;
<span class="lineNum">   14901 </span>            :   enum tree_code code;
<span class="lineNum">   14902 </span>            :   switch (p_kind)
<span class="lineNum">   14903 </span>            :     {
<span class="lineNum">   14904 </span>            :     case PRAGMA_OACC_KERNELS:
<span class="lineNum">   14905 </span>            :       strcat (p_name, &quot; kernels&quot;);
<span class="lineNum">   14906 </span>            :       mask = OACC_KERNELS_CLAUSE_MASK;
<span class="lineNum">   14907 </span>            :       code = OACC_KERNELS;
<span class="lineNum">   14908 </span>            :       break;
<span class="lineNum">   14909 </span>            :     case PRAGMA_OACC_PARALLEL:
<span class="lineNum">   14910 </span>            :       strcat (p_name, &quot; parallel&quot;);
<span class="lineNum">   14911 </span>            :       mask = OACC_PARALLEL_CLAUSE_MASK;
<span class="lineNum">   14912 </span>            :       code = OACC_PARALLEL;
<span class="lineNum">   14913 </span>            :       break;
<span class="lineNum">   14914 </span>            :     default:
<span class="lineNum">   14915 </span>            :       gcc_unreachable ();
<span class="lineNum">   14916 </span>            :     }
<span class="lineNum">   14917 </span>            : 
<span class="lineNum">   14918 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   14919 </span>            :     {
<span class="lineNum">   14920 </span><span class="lineCov">       1472 :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">   14921 </span>            :       if (strcmp (p, &quot;loop&quot;) == 0)
<span class="lineNum">   14922 </span>            :         {
<span class="lineNum">   14923 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   14924 </span><span class="lineCov">       1472 :           tree block = c_begin_omp_parallel ();</span>
<span class="lineNum">   14925 </span><span class="lineCov">       1472 :           tree clauses;</span>
<span class="lineNum">   14926 </span><span class="lineCov">       1472 :           c_parser_oacc_loop (loc, parser, p_name, mask, &amp;clauses, if_p);</span>
<span class="lineNum">   14927 </span>            :           return c_finish_omp_construct (loc, code, block, clauses);
<span class="lineNum">   14928 </span><span class="lineCov">        431 :         }</span>
<span class="lineNum">   14929 </span><span class="lineCov">        431 :     }</span>
<span class="lineNum">   14930 </span><span class="lineCov">      11637 : </span>
<span class="lineNum">   14931 </span><span class="lineCov">        431 :   tree clauses = c_parser_oacc_all_clauses (parser, mask, p_name);</span>
<span class="lineNum">   14932 </span><span class="lineCov">        431 : </span>
<span class="lineNum">   14933 </span><span class="lineCov">       1041 :   tree block = c_begin_omp_parallel ();</span>
<span class="lineNum">   14934 </span><span class="lineCov">       1041 :   add_stmt (c_parser_omp_structured_block (parser, if_p));</span>
<span class="lineNum">   14935 </span><span class="lineCov">      34353 : </span>
<span class="lineNum">   14936 </span><span class="lineCov">       1041 :   return c_finish_omp_construct (loc, code, block, clauses);</span>
<span class="lineNum">   14937 </span><span class="lineCov">       1041 : }</span>
<span class="lineNum">   14938 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   14939 </span><span class="lineNoCov">          0 : /* OpenACC 2.0:</span>
<span class="lineNum">   14940 </span>            :    # pragma acc routine oacc-routine-clause[optseq] new-line
<span class="lineNum">   14941 </span>            :      function-definition
<span class="lineNum">   14942 </span><span class="lineCov">       1472 : </span>
<span class="lineNum">   14943 </span>            :    # pragma acc routine ( name ) oacc-routine-clause[optseq] new-line
<span class="lineNum">   14944 </span><span class="lineCov">       1193 : */</span>
<span class="lineNum">   14945 </span><span class="lineCov">       1193 : </span>
<span class="lineNum">   14946 </span>            : #define OACC_ROUTINE_CLAUSE_MASK                                        \
<span class="lineNum">   14947 </span><span class="lineCov">        464 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_GANG)          \</span>
<span class="lineNum">   14948 </span><span class="lineCov">        464 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_WORKER)                \</span>
<span class="lineNum">   14949 </span><span class="lineCov">        464 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_VECTOR)                \</span>
<span class="lineNum">   14950 </span><span class="lineCov">        464 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_SEQ) )</span>
<span class="lineNum">   14951 </span><span class="lineCov">        464 : </span>
<span class="lineNum">   14952 </span>            : /* Parse an OpenACC routine directive.  For named directives, we apply
<span class="lineNum">   14953 </span>            :    immediately to the named function.  For unnamed ones we then parse
<span class="lineNum">   14954 </span>            :    a declaration or definition, which must be for a function.  */
<a name="14955"><span class="lineNum">   14955 </span><span class="lineCov">       1008 : </span></a>
<span class="lineNum">   14956 </span>            : static void
<span class="lineNum">   14957 </span><span class="lineCov">       1008 : c_parser_oacc_routine (c_parser *parser, enum pragma_context context)</span>
<span class="lineNum">   14958 </span><span class="lineCov">       1008 : {</span>
<span class="lineNum">   14959 </span>            :   gcc_checking_assert (context == pragma_external);
<span class="lineNum">   14960 </span><span class="lineCov">       1008 : </span>
<span class="lineNum">   14961 </span>            :   oacc_routine_data data;
<span class="lineNum">   14962 </span>            :   data.error_seen = false;
<span class="lineNum">   14963 </span>            :   data.fndecl_seen = false;
<span class="lineNum">   14964 </span>            :   data.clauses = NULL_TREE;
<span class="lineNum">   14965 </span>            :   data.loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   14966 </span>            : 
<span class="lineNum">   14967 </span>            :   c_parser_consume_pragma (parser);
<span class="lineNum">   14968 </span>            : 
<span class="lineNum">   14969 </span>            :   /* Look for optional '( name )'.  */
<span class="lineNum">   14970 </span>            :   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))
<span class="lineNum">   14971 </span>            :     {
<span class="lineNum">   14972 </span>            :       c_parser_consume_token (parser); /* '(' */
<span class="lineNum">   14973 </span>            : 
<span class="lineNum">   14974 </span>            :       tree decl = NULL_TREE;
<span class="lineNum">   14975 </span>            :       c_token *name_token = c_parser_peek_token (parser);
<span class="lineNum">   14976 </span>            :       location_t name_loc = name_token-&gt;location;
<span class="lineNum">   14977 </span>            :       if (name_token-&gt;type == CPP_NAME
<span class="lineNum">   14978 </span>            :           &amp;&amp; (name_token-&gt;id_kind == C_ID_ID
<span class="lineNum">   14979 </span>            :               || name_token-&gt;id_kind == C_ID_TYPENAME))
<span class="lineNum">   14980 </span>            :         {
<span class="lineNum">   14981 </span><span class="lineCov">        117 :           decl = lookup_name (name_token-&gt;value);</span>
<span class="lineNum">   14982 </span>            :           if (!decl)
<span class="lineNum">   14983 </span><span class="lineCov">        117 :             error_at (name_loc,</span>
<span class="lineNum">   14984 </span>            :                       &quot;%qE has not been declared&quot;, name_token-&gt;value);
<span class="lineNum">   14985 </span><span class="lineCov">        117 :           c_parser_consume_token (parser);</span>
<span class="lineNum">   14986 </span><span class="lineCov">        117 :         }</span>
<span class="lineNum">   14987 </span><span class="lineCov">        117 :       else</span>
<span class="lineNum">   14988 </span><span class="lineCov">        117 :         c_parser_error (parser, &quot;expected function name&quot;);</span>
<span class="lineNum">   14989 </span><span class="lineCov">        117 : </span>
<span class="lineNum">   14990 </span>            :       if (!decl
<span class="lineNum">   14991 </span><span class="lineCov">        117 :           || !c_parser_require (parser, CPP_CLOSE_PAREN, &quot;expected %&lt;)%&gt;&quot;))</span>
<span class="lineNum">   14992 </span>            :         {
<span class="lineNum">   14993 </span>            :           c_parser_skip_to_pragma_eol (parser, false);
<span class="lineNum">   14994 </span><span class="lineCov">        117 :           return;</span>
<span class="lineNum">   14995 </span>            :         }
<span class="lineNum">   14996 </span><span class="lineCov">         29 : </span>
<span class="lineNum">   14997 </span>            :       data.clauses
<span class="lineNum">   14998 </span><span class="lineCov">         29 :         = c_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,</span>
<span class="lineNum">   14999 </span><span class="lineCov">         29 :                                      &quot;#pragma acc routine&quot;);</span>
<span class="lineNum">   15000 </span><span class="lineCov">         29 : </span>
<span class="lineNum">   15001 </span><span class="lineCov">         29 :       if (TREE_CODE (decl) != FUNCTION_DECL)</span>
<span class="lineNum">   15002 </span><span class="lineCov">         21 :         {</span>
<span class="lineNum">   15003 </span>            :           error_at (name_loc, &quot;%qD does not refer to a function&quot;, decl);
<span class="lineNum">   15004 </span>            :           return;
<span class="lineNum">   15005 </span><span class="lineCov">         21 :         }</span>
<span class="lineNum">   15006 </span><span class="lineCov">         21 : </span>
<span class="lineNum">   15007 </span><span class="lineCov">          4 :       c_finish_oacc_routine (&amp;data, decl, false);</span>
<span class="lineNum">   15008 </span>            :     }
<span class="lineNum">   15009 </span><span class="lineCov">         21 :   else /* No optional '( name )'.  */</span>
<span class="lineNum">   15010 </span>            :     {
<span class="lineNum">   15011 </span>            :       data.clauses
<span class="lineNum">   15012 </span><span class="lineCov">          8 :         = c_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,</span>
<span class="lineNum">   15013 </span>            :                                      &quot;#pragma acc routine&quot;);
<span class="lineNum">   15014 </span><span class="lineCov">          8 : </span>
<span class="lineNum">   15015 </span><span class="lineCov">         21 :       /* Emit a helpful diagnostic if there's another pragma following this</span>
<span class="lineNum">   15016 </span>            :          one.  Also don't allow a static assertion declaration, as in the
<span class="lineNum">   15017 </span><span class="lineCov">         14 :          following we'll just parse a *single* &quot;declaration or function</span>
<span class="lineNum">   15018 </span><span class="lineCov">         14 :          definition&quot;, and the static assertion counts an one.  */</span>
<span class="lineNum">   15019 </span>            :       if (c_parser_next_token_is (parser, CPP_PRAGMA)
<span class="lineNum">   15020 </span>            :           || c_parser_next_token_is_keyword (parser, RID_STATIC_ASSERT))
<span class="lineNum">   15021 </span><span class="lineCov">         15 :         {</span>
<span class="lineNum">   15022 </span><span class="lineCov">        165 :           error_at (data.loc,</span>
<span class="lineNum">   15023 </span>            :                     &quot;%&lt;#pragma acc routine%&gt; not immediately followed by&quot;
<span class="lineNum">   15024 </span>            :                     &quot; function declaration or definition&quot;);
<span class="lineNum">   15025 </span><span class="lineCov">         15 :           /* ..., and then just keep going.  */</span>
<span class="lineNum">   15026 </span>            :           return;
<span class="lineNum">   15027 </span><span class="lineCov">          3 :         }</span>
<span class="lineNum">   15028 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   15029 </span>            :       /* We only have to consider the pragma_external case here.  */
<span class="lineNum">   15030 </span>            :       if (c_parser_next_token_is (parser, CPP_KEYWORD)
<span class="lineNum">   15031 </span><span class="lineCov">         12 :           &amp;&amp; c_parser_peek_token (parser)-&gt;keyword == RID_EXTENSION)</span>
<span class="lineNum">   15032 </span>            :         {
<span class="lineNum">   15033 </span>            :           int ext = disable_extension_diagnostics ();
<span class="lineNum">   15034 </span>            :           do
<span class="lineNum">   15035 </span><span class="lineCov">         88 :             c_parser_consume_token (parser);</span>
<span class="lineNum">   15036 </span><span class="lineCov">        968 :           while (c_parser_next_token_is (parser, CPP_KEYWORD)</span>
<span class="lineNum">   15037 </span>            :                  &amp;&amp; c_parser_peek_token (parser)-&gt;keyword == RID_EXTENSION);
<span class="lineNum">   15038 </span>            :           c_parser_declaration_or_fndef (parser, true, true, true, false, true,
<span class="lineNum">   15039 </span>            :                                          NULL, vNULL, &amp;data);
<span class="lineNum">   15040 </span>            :           restore_extension_diagnostics (ext);
<span class="lineNum">   15041 </span>            :         }
<span class="lineNum">   15042 </span>            :       else
<span class="lineNum">   15043 </span><span class="lineCov">         88 :         c_parser_declaration_or_fndef (parser, true, true, true, false, true,</span>
<span class="lineNum">   15044 </span><span class="lineCov">         88 :                                        NULL, vNULL, &amp;data);</span>
<span class="lineNum">   15045 </span>            :     }
<span class="lineNum">   15046 </span><span class="lineCov">         10 : }</span>
<span class="lineNum">   15047 </span>            : 
<span class="lineNum">   15048 </span>            : /* Finalize an OpenACC routine pragma, applying it to FNDECL.
<span class="lineNum">   15049 </span>            :    IS_DEFN is true if we're applying it to the definition.  */
<a name="15050"><span class="lineNum">   15050 </span><span class="lineCov">         10 : </span></a>
<span class="lineNum">   15051 </span>            : static void
<span class="lineNum">   15052 </span>            : c_finish_oacc_routine (struct oacc_routine_data *data, tree fndecl,
<span class="lineNum">   15053 </span>            :                        bool is_defn)
<span class="lineNum">   15054 </span><span class="lineCov">         78 : {</span>
<span class="lineNum">   15055 </span><span class="lineCov">         78 :   /* Keep going if we're in error reporting mode.  */</span>
<span class="lineNum">   15056 </span>            :   if (data-&gt;error_seen
<span class="lineNum">   15057 </span><span class="lineCov">          3 :       || fndecl == error_mark_node)</span>
<span class="lineNum">   15058 </span><span class="lineCov">          7 :     return;</span>
<span class="lineNum">   15059 </span><span class="lineCov">          7 : </span>
<span class="lineNum">   15060 </span><span class="lineCov">          7 :   if (data-&gt;fndecl_seen)</span>
<span class="lineNum">   15061 </span><span class="lineCov">          7 :     {</span>
<span class="lineNum">   15062 </span><span class="lineCov">          3 :       error_at (data-&gt;loc,</span>
<span class="lineNum">   15063 </span>            :                 &quot;%&lt;#pragma acc routine%&gt; not immediately followed by&quot;
<span class="lineNum">   15064 </span><span class="lineCov">          3 :                 &quot; a single function declaration or definition&quot;);</span>
<span class="lineNum">   15065 </span>            :       data-&gt;error_seen = true;
<span class="lineNum">   15066 </span>            :       return;
<span class="lineNum">   15067 </span><span class="lineCov">         75 :     }</span>
<span class="lineNum">   15068 </span>            :   if (fndecl == NULL_TREE || TREE_CODE (fndecl) != FUNCTION_DECL)
<span class="lineNum">   15069 </span>            :     {
<span class="lineNum">   15070 </span>            :       error_at (data-&gt;loc,
<span class="lineNum">   15071 </span>            :                 &quot;%&lt;#pragma acc routine%&gt; not immediately followed by&quot;
<span class="lineNum">   15072 </span>            :                 &quot; function declaration or definition&quot;);
<span class="lineNum">   15073 </span>            :       data-&gt;error_seen = true;
<span class="lineNum">   15074 </span>            :       return;
<span class="lineNum">   15075 </span>            :     }
<span class="lineNum">   15076 </span><span class="lineCov">        100 : </span>
<span class="lineNum">   15077 </span>            :   if (oacc_get_fn_attrib (fndecl))
<span class="lineNum">   15078 </span>            :     {
<span class="lineNum">   15079 </span>            :       error_at (data-&gt;loc,
<span class="lineNum">   15080 </span><span class="lineCov">        100 :                 &quot;%&lt;#pragma acc routine%&gt; already applied to %qD&quot;, fndecl);</span>
<span class="lineNum">   15081 </span><span class="lineCov">         94 :       data-&gt;error_seen = true;</span>
<span class="lineNum">   15082 </span>            :       return;
<span class="lineNum">   15083 </span>            :     }
<span class="lineNum">   15084 </span><span class="lineCov">         94 : </span>
<span class="lineNum">   15085 </span>            :   if (TREE_USED (fndecl) || (!is_defn &amp;&amp; DECL_SAVED_TREE (fndecl)))
<span class="lineNum">   15086 </span><span class="lineCov">          4 :     {</span>
<span class="lineNum">   15087 </span>            :       error_at (data-&gt;loc,
<span class="lineNum">   15088 </span>            :                 TREE_USED (fndecl)
<span class="lineNum">   15089 </span><span class="lineCov">          4 :                 ? G_(&quot;%&lt;#pragma acc routine%&gt; must be applied before use&quot;)</span>
<span class="lineNum">   15090 </span><span class="lineCov">          4 :                 : G_(&quot;%&lt;#pragma acc routine%&gt; must be applied before &quot;</span>
<span class="lineNum">   15091 </span>            :                      &quot;definition&quot;));
<span class="lineNum">   15092 </span><span class="lineCov">         90 :       data-&gt;error_seen = true;</span>
<span class="lineNum">   15093 </span>            :       return;
<span class="lineNum">   15094 </span><span class="lineCov">         10 :     }</span>
<span class="lineNum">   15095 </span>            : 
<span class="lineNum">   15096 </span>            :   /* Process the routine's dimension clauses.  */
<span class="lineNum">   15097 </span><span class="lineCov">         10 :   tree dims = oacc_build_routine_dims (data-&gt;clauses);</span>
<span class="lineNum">   15098 </span><span class="lineCov">         10 :   oacc_replace_fn_attrib (fndecl, dims);</span>
<span class="lineNum">   15099 </span>            : 
<span class="lineNum">   15100 </span>            :   /* Add an &quot;omp declare target&quot; attribute.  */
<span class="lineNum">   15101 </span><span class="lineCov">         80 :   DECL_ATTRIBUTES (fndecl)</span>
<span class="lineNum">   15102 </span>            :     = tree_cons (get_identifier (&quot;omp declare target&quot;),
<span class="lineNum">   15103 </span><span class="lineCov">          2 :                  NULL_TREE, DECL_ATTRIBUTES (fndecl));</span>
<span class="lineNum">   15104 </span>            : 
<span class="lineNum">   15105 </span><span class="lineCov">          2 :   /* Remember that we've used this &quot;#pragma acc routine&quot;.  */</span>
<span class="lineNum">   15106 </span><span class="lineCov">          2 :   data-&gt;fndecl_seen = true;</span>
<span class="lineNum">   15107 </span>            : }
<span class="lineNum">   15108 </span>            : 
<span class="lineNum">   15109 </span><span class="lineCov">         78 : /* OpenACC 2.0:</span>
<span class="lineNum">   15110 </span>            :    # pragma acc update oacc-update-clause[optseq] new-line
<span class="lineNum">   15111 </span><span class="lineCov">          3 : */</span>
<span class="lineNum">   15112 </span>            : 
<span class="lineNum">   15113 </span>            : #define OACC_UPDATE_CLAUSE_MASK                                         \
<span class="lineNum">   15114 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_ASYNC)         \
<span class="lineNum">   15115 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEVICE)                \
<span class="lineNum">   15116 </span><span class="lineCov">          2 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_HOST)          \</span>
<span class="lineNum">   15117 </span><span class="lineCov">          2 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_IF)                    \</span>
<span class="lineNum">   15118 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_IF_PRESENT)            \
<span class="lineNum">   15119 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_WAIT) )
<a name="15120"><span class="lineNum">   15120 </span>            : </a>
<span class="lineNum">   15121 </span><span class="lineCov">         76 : static void</span>
<span class="lineNum">   15122 </span><span class="lineCov">         76 : c_parser_oacc_update (c_parser *parser)</span>
<span class="lineNum">   15123 </span>            : {
<span class="lineNum">   15124 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   15125 </span><span class="lineCov">         76 : </span>
<span class="lineNum">   15126 </span><span class="lineCov">         76 :   c_parser_consume_pragma (parser);</span>
<span class="lineNum">   15127 </span><span class="lineCov">         76 : </span>
<span class="lineNum">   15128 </span>            :   tree clauses = c_parser_oacc_all_clauses (parser, OACC_UPDATE_CLAUSE_MASK,
<span class="lineNum">   15129 </span>            :                                             &quot;#pragma acc update&quot;);
<span class="lineNum">   15130 </span><span class="lineCov">         76 :   if (omp_find_clause (clauses, OMP_CLAUSE_MAP) == NULL_TREE)</span>
<span class="lineNum">   15131 </span>            :     {
<span class="lineNum">   15132 </span>            :       error_at (loc,
<span class="lineNum">   15133 </span>            :                 &quot;%&lt;#pragma acc update%&gt; must contain at least one &quot;
<span class="lineNum">   15134 </span>            :                 &quot;%&lt;device%&gt; or %&lt;host%&gt; or %&lt;self%&gt; clause&quot;);
<span class="lineNum">   15135 </span>            :       return;
<span class="lineNum">   15136 </span>            :     }
<span class="lineNum">   15137 </span>            : 
<span class="lineNum">   15138 </span>            :   if (parser-&gt;error)
<span class="lineNum">   15139 </span>            :     return;
<span class="lineNum">   15140 </span>            : 
<span class="lineNum">   15141 </span>            :   tree stmt = make_node (OACC_UPDATE);
<span class="lineNum">   15142 </span>            :   TREE_TYPE (stmt) = void_type_node;
<span class="lineNum">   15143 </span>            :   OACC_UPDATE_CLAUSES (stmt) = clauses;
<span class="lineNum">   15144 </span>            :   SET_EXPR_LOCATION (stmt, loc);
<span class="lineNum">   15145 </span>            :   add_stmt (stmt);
<span class="lineNum">   15146 </span><span class="lineCov">         58 : }</span>
<span class="lineNum">   15147 </span>            : 
<span class="lineNum">   15148 </span><span class="lineCov">         58 : /* OpenACC 2.0:</span>
<span class="lineNum">   15149 </span>            :    # pragma acc wait [(intseq)] oacc-wait-clause[optseq] new-line
<span class="lineNum">   15150 </span><span class="lineCov">         58 : </span>
<span class="lineNum">   15151 </span>            :    LOC is the location of the #pragma token.
<span class="lineNum">   15152 </span><span class="lineCov">        812 : */</span>
<span class="lineNum">   15153 </span>            : 
<span class="lineNum">   15154 </span><span class="lineCov">         58 : #define OACC_WAIT_CLAUSE_MASK                                           \</span>
<span class="lineNum">   15155 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_ASYNC) )
<a name="15156"><span class="lineNum">   15156 </span><span class="lineCov">          1 : </span></a>
<span class="lineNum">   15157 </span>            : static tree
<span class="lineNum">   15158 </span>            : c_parser_oacc_wait (location_t loc, c_parser *parser, char *p_name)
<span class="lineNum">   15159 </span><span class="lineCov">          1 : {</span>
<span class="lineNum">   15160 </span>            :   tree clauses, list = NULL_TREE, stmt = NULL_TREE;
<span class="lineNum">   15161 </span>            : 
<span class="lineNum">   15162 </span><span class="lineCov">         57 :   if (c_parser_peek_token (parser)-&gt;type == CPP_OPEN_PAREN)</span>
<span class="lineNum">   15163 </span>            :     list = c_parser_oacc_wait_list (parser, loc, list);
<span class="lineNum">   15164 </span>            : 
<span class="lineNum">   15165 </span><span class="lineCov">         57 :   strcpy (p_name, &quot; wait&quot;);</span>
<span class="lineNum">   15166 </span><span class="lineCov">         57 :   clauses = c_parser_oacc_all_clauses (parser, OACC_WAIT_CLAUSE_MASK, p_name);</span>
<span class="lineNum">   15167 </span><span class="lineCov">         57 :   stmt = c_finish_oacc_wait (loc, list, clauses);</span>
<span class="lineNum">   15168 </span><span class="lineCov">         57 :   add_stmt (stmt);</span>
<span class="lineNum">   15169 </span><span class="lineCov">         57 : </span>
<span class="lineNum">   15170 </span>            :   return stmt;
<span class="lineNum">   15171 </span>            : }
<span class="lineNum">   15172 </span>            : 
<span class="lineNum">   15173 </span>            : /* OpenMP 2.5:
<span class="lineNum">   15174 </span>            :    # pragma omp atomic new-line
<span class="lineNum">   15175 </span>            :      expression-stmt
<span class="lineNum">   15176 </span>            : 
<span class="lineNum">   15177 </span>            :    expression-stmt:
<span class="lineNum">   15178 </span>            :      x binop= expr | x++ | ++x | x-- | --x
<span class="lineNum">   15179 </span>            :    binop:
<span class="lineNum">   15180 </span>            :      +, *, -, /, &amp;, ^, |, &lt;&lt;, &gt;&gt;
<span class="lineNum">   15181 </span>            : 
<span class="lineNum">   15182 </span><span class="lineCov">         61 :   where x is an lvalue expression with scalar type.</span>
<span class="lineNum">   15183 </span>            : 
<span class="lineNum">   15184 </span><span class="lineCov">         61 :    OpenMP 3.1:</span>
<span class="lineNum">   15185 </span>            :    # pragma omp atomic new-line
<span class="lineNum">   15186 </span><span class="lineCov">         61 :      update-stmt</span>
<span class="lineNum">   15187 </span><span class="lineCov">         39 : </span>
<span class="lineNum">   15188 </span>            :    # pragma omp atomic read new-line
<span class="lineNum">   15189 </span><span class="lineCov">         61 :      read-stmt</span>
<span class="lineNum">   15190 </span><span class="lineCov">        122 : </span>
<span class="lineNum">   15191 </span><span class="lineCov">         61 :    # pragma omp atomic write new-line</span>
<span class="lineNum">   15192 </span><span class="lineCov">         61 :      write-stmt</span>
<span class="lineNum">   15193 </span>            : 
<span class="lineNum">   15194 </span><span class="lineCov">         61 :    # pragma omp atomic update new-line</span>
<span class="lineNum">   15195 </span>            :      update-stmt
<span class="lineNum">   15196 </span>            : 
<span class="lineNum">   15197 </span>            :    # pragma omp atomic capture new-line
<span class="lineNum">   15198 </span>            :      capture-stmt
<span class="lineNum">   15199 </span>            : 
<span class="lineNum">   15200 </span>            :    # pragma omp atomic capture new-line
<span class="lineNum">   15201 </span>            :      capture-block
<span class="lineNum">   15202 </span>            : 
<span class="lineNum">   15203 </span>            :    read-stmt:
<span class="lineNum">   15204 </span>            :      v = x
<span class="lineNum">   15205 </span>            :    write-stmt:
<span class="lineNum">   15206 </span>            :      x = expr
<span class="lineNum">   15207 </span>            :    update-stmt:
<span class="lineNum">   15208 </span>            :      expression-stmt | x = x binop expr
<span class="lineNum">   15209 </span>            :    capture-stmt:
<span class="lineNum">   15210 </span>            :      v = expression-stmt
<span class="lineNum">   15211 </span>            :    capture-block:
<span class="lineNum">   15212 </span>            :      { v = x; update-stmt; } | { update-stmt; v = x; }
<span class="lineNum">   15213 </span>            : 
<span class="lineNum">   15214 </span>            :    OpenMP 4.0:
<span class="lineNum">   15215 </span>            :    update-stmt:
<span class="lineNum">   15216 </span>            :      expression-stmt | x = x binop expr | x = expr binop x
<span class="lineNum">   15217 </span>            :    capture-stmt:
<span class="lineNum">   15218 </span>            :      v = update-stmt
<span class="lineNum">   15219 </span>            :    capture-block:
<span class="lineNum">   15220 </span>            :      { v = x; update-stmt; } | { update-stmt; v = x; } | { v = x; x = expr; }
<span class="lineNum">   15221 </span>            : 
<span class="lineNum">   15222 </span>            :   where x and v are lvalue expressions with scalar type.
<span class="lineNum">   15223 </span>            : 
<span class="lineNum">   15224 </span>            :   LOC is the location of the #pragma token.  */
<a name="15225"><span class="lineNum">   15225 </span>            : </a>
<span class="lineNum">   15226 </span>            : static void
<span class="lineNum">   15227 </span>            : c_parser_omp_atomic (location_t loc, c_parser *parser)
<span class="lineNum">   15228 </span>            : {
<span class="lineNum">   15229 </span>            :   tree lhs = NULL_TREE, rhs = NULL_TREE, v = NULL_TREE;
<span class="lineNum">   15230 </span>            :   tree lhs1 = NULL_TREE, rhs1 = NULL_TREE;
<span class="lineNum">   15231 </span>            :   tree stmt, orig_lhs, unfolded_lhs = NULL_TREE, unfolded_lhs1 = NULL_TREE;
<span class="lineNum">   15232 </span>            :   enum tree_code code = OMP_ATOMIC, opcode = NOP_EXPR;
<span class="lineNum">   15233 </span>            :   struct c_expr expr;
<span class="lineNum">   15234 </span>            :   location_t eloc;
<span class="lineNum">   15235 </span>            :   bool structured_block = false;
<span class="lineNum">   15236 </span>            :   bool swapped = false;
<span class="lineNum">   15237 </span>            :   bool seq_cst = false;
<span class="lineNum">   15238 </span>            :   bool non_lvalue_p;
<span class="lineNum">   15239 </span>            : 
<span class="lineNum">   15240 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   15241 </span>            :     {
<span class="lineNum">   15242 </span>            :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   15243 </span>            :       if (!strcmp (p, &quot;seq_cst&quot;))
<span class="lineNum">   15244 </span>            :         {
<span class="lineNum">   15245 </span>            :           seq_cst = true;
<span class="lineNum">   15246 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   15247 </span>            :           if (c_parser_next_token_is (parser, CPP_COMMA)
<span class="lineNum">   15248 </span>            :               &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type == CPP_NAME)
<span class="lineNum">   15249 </span>            :             c_parser_consume_token (parser);
<span class="lineNum">   15250 </span>            :         }
<span class="lineNum">   15251 </span><span class="lineCov">       1034 :     }</span>
<span class="lineNum">   15252 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   15253 </span><span class="lineCov">       1034 :     {</span>
<span class="lineNum">   15254 </span><span class="lineCov">       1034 :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">   15255 </span><span class="lineCov">       1034 : </span>
<span class="lineNum">   15256 </span><span class="lineCov">       1034 :       if (!strcmp (p, &quot;read&quot;))</span>
<span class="lineNum">   15257 </span><span class="lineCov">       1034 :         code = OMP_ATOMIC_READ;</span>
<span class="lineNum">   15258 </span><span class="lineCov">       1034 :       else if (!strcmp (p, &quot;write&quot;))</span>
<span class="lineNum">   15259 </span><span class="lineCov">       1034 :         code = NOP_EXPR;</span>
<span class="lineNum">   15260 </span><span class="lineCov">       1034 :       else if (!strcmp (p, &quot;update&quot;))</span>
<span class="lineNum">   15261 </span><span class="lineCov">       1034 :         code = OMP_ATOMIC;</span>
<span class="lineNum">   15262 </span><span class="lineCov">       1034 :       else if (!strcmp (p, &quot;capture&quot;))</span>
<span class="lineNum">   15263 </span>            :         code = OMP_ATOMIC_CAPTURE_NEW;
<span class="lineNum">   15264 </span><span class="lineCov">       1034 :       else</span>
<span class="lineNum">   15265 </span>            :         p = NULL;
<span class="lineNum">   15266 </span><span class="lineCov">        526 :       if (p)</span>
<span class="lineNum">   15267 </span><span class="lineCov">        526 :         c_parser_consume_token (parser);</span>
<span class="lineNum">   15268 </span>            :     }
<span class="lineNum">   15269 </span><span class="lineCov">         17 :   if (!seq_cst)</span>
<span class="lineNum">   15270 </span><span class="lineCov">         17 :     {</span>
<span class="lineNum">   15271 </span><span class="lineCov">         17 :       if (c_parser_next_token_is (parser, CPP_COMMA)</span>
<span class="lineNum">   15272 </span><span class="lineCov">         17 :           &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type == CPP_NAME)</span>
<span class="lineNum">   15273 </span><span class="lineCov">          6 :         c_parser_consume_token (parser);</span>
<span class="lineNum">   15274 </span>            : 
<span class="lineNum">   15275 </span>            :       if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   15276 </span><span class="lineCov">       1034 :         {</span>
<span class="lineNum">   15277 </span>            :           const char *p
<span class="lineNum">   15278 </span><span class="lineCov">        525 :             = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">   15279 </span>            :           if (!strcmp (p, &quot;seq_cst&quot;))
<span class="lineNum">   15280 </span><span class="lineCov">        525 :             {</span>
<span class="lineNum">   15281 </span>            :               seq_cst = true;
<span class="lineNum">   15282 </span><span class="lineCov">        422 :               c_parser_consume_token (parser);</span>
<span class="lineNum">   15283 </span>            :             }
<span class="lineNum">   15284 </span><span class="lineCov">        342 :         }</span>
<span class="lineNum">   15285 </span>            :     }
<span class="lineNum">   15286 </span><span class="lineCov">        262 :   c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   15287 </span>            : 
<span class="lineNum">   15288 </span>            :   switch (code)
<span class="lineNum">   15289 </span>            :     {
<span class="lineNum">   15290 </span><span class="lineCov">        524 :     case OMP_ATOMIC_READ:</span>
<span class="lineNum">   15291 </span><span class="lineCov">        524 :     case NOP_EXPR: /* atomic write */</span>
<span class="lineNum">   15292 </span>            :       v = c_parser_cast_expression (parser, NULL).value;
<span class="lineNum">   15293 </span><span class="lineCov">       1034 :       non_lvalue_p = !lvalue_p (v);</span>
<span class="lineNum">   15294 </span>            :       v = c_fully_fold (v, false, NULL, true);
<span class="lineNum">   15295 </span><span class="lineCov">       1017 :       if (v == error_mark_node)</span>
<span class="lineNum">   15296 </span><span class="lineCov">       1017 :         goto saw_error;</span>
<span class="lineNum">   15297 </span><span class="lineCov">          9 :       if (non_lvalue_p)</span>
<span class="lineNum">   15298 </span>            :         v = non_lvalue (v);
<span class="lineNum">   15299 </span><span class="lineCov">       1017 :       loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   15300 </span>            :       if (!c_parser_require (parser, CPP_EQ, &quot;expected %&lt;=%&gt;&quot;))
<span class="lineNum">   15301 </span><span class="lineCov">         21 :         goto saw_error;</span>
<span class="lineNum">   15302 </span><span class="lineCov">         21 :       if (code == NOP_EXPR)</span>
<span class="lineNum">   15303 </span><span class="lineCov">         21 :         {</span>
<span class="lineNum">   15304 </span>            :           lhs = c_parser_expression (parser).value;
<span class="lineNum">   15305 </span><span class="lineCov">         20 :           lhs = c_fully_fold (lhs, false, NULL);</span>
<span class="lineNum">   15306 </span><span class="lineCov">         20 :           if (lhs == error_mark_node)</span>
<span class="lineNum">   15307 </span>            :             goto saw_error;
<span class="lineNum">   15308 </span>            :         }
<span class="lineNum">   15309 </span>            :       else
<span class="lineNum">   15310 </span><span class="lineCov">       1034 :         {</span>
<span class="lineNum">   15311 </span>            :           lhs = c_parser_cast_expression (parser, NULL).value;
<span class="lineNum">   15312 </span><span class="lineCov">       1034 :           non_lvalue_p = !lvalue_p (lhs);</span>
<span class="lineNum">   15313 </span>            :           lhs = c_fully_fold (lhs, false, NULL, true);
<span class="lineNum">   15314 </span><span class="lineCov">        183 :           if (lhs == error_mark_node)</span>
<span class="lineNum">   15315 </span><span class="lineCov">        183 :             goto saw_error;</span>
<span class="lineNum">   15316 </span><span class="lineCov">        183 :           if (non_lvalue_p)</span>
<span class="lineNum">   15317 </span><span class="lineCov">        183 :             lhs = non_lvalue (lhs);</span>
<span class="lineNum">   15318 </span><span class="lineCov">        183 :         }</span>
<span class="lineNum">   15319 </span><span class="lineCov">        183 :       if (code == NOP_EXPR)</span>
<span class="lineNum">   15320 </span>            :         {
<span class="lineNum">   15321 </span><span class="lineCov">        183 :           /* atomic write is represented by OMP_ATOMIC with NOP_EXPR</span>
<span class="lineNum">   15322 </span><span class="lineCov">          4 :              opcode.  */</span>
<span class="lineNum">   15323 </span><span class="lineCov">        183 :           code = OMP_ATOMIC;</span>
<span class="lineNum">   15324 </span><span class="lineCov">        183 :           rhs = lhs;</span>
<span class="lineNum">   15325 </span>            :           lhs = v;
<span class="lineNum">   15326 </span><span class="lineCov">        183 :           v = NULL_TREE;</span>
<span class="lineNum">   15327 </span>            :         }
<span class="lineNum">   15328 </span><span class="lineCov">         80 :       goto done;</span>
<span class="lineNum">   15329 </span><span class="lineCov">         80 :     case OMP_ATOMIC_CAPTURE_NEW:</span>
<span class="lineNum">   15330 </span><span class="lineCov">         80 :       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))</span>
<span class="lineNum">   15331 </span>            :         {
<span class="lineNum">   15332 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   15333 </span>            :           structured_block = true;
<span class="lineNum">   15334 </span>            :         }
<span class="lineNum">   15335 </span><span class="lineCov">        103 :       else</span>
<span class="lineNum">   15336 </span><span class="lineCov">        103 :         {</span>
<span class="lineNum">   15337 </span><span class="lineCov">        103 :           v = c_parser_cast_expression (parser, NULL).value;</span>
<span class="lineNum">   15338 </span><span class="lineCov">        103 :           non_lvalue_p = !lvalue_p (v);</span>
<span class="lineNum">   15339 </span>            :           v = c_fully_fold (v, false, NULL, true);
<span class="lineNum">   15340 </span><span class="lineCov">        103 :           if (v == error_mark_node)</span>
<span class="lineNum">   15341 </span><span class="lineCov">          2 :             goto saw_error;</span>
<span class="lineNum">   15342 </span>            :           if (non_lvalue_p)
<span class="lineNum">   15343 </span><span class="lineCov">        183 :             v = non_lvalue (v);</span>
<span class="lineNum">   15344 </span>            :           if (!c_parser_require (parser, CPP_EQ, &quot;expected %&lt;=%&gt;&quot;))
<span class="lineNum">   15345 </span>            :             goto saw_error;
<span class="lineNum">   15346 </span>            :         }
<span class="lineNum">   15347 </span><span class="lineCov">         80 :       break;</span>
<span class="lineNum">   15348 </span><span class="lineCov">         80 :     default:</span>
<span class="lineNum">   15349 </span><span class="lineCov">         80 :       break;</span>
<span class="lineNum">   15350 </span><span class="lineCov">         80 :     }</span>
<span class="lineNum">   15351 </span>            : 
<span class="lineNum">   15352 </span><span class="lineCov">        183 :   /* For structured_block case we don't know yet whether</span>
<span class="lineNum">   15353 </span><span class="lineCov">        261 :      old or new x should be captured.  */</span>
<span class="lineNum">   15354 </span><span class="lineCov">        261 : restart:</span>
<span class="lineNum">   15355 </span>            :   eloc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   15356 </span><span class="lineCov">        170 :   expr = c_parser_cast_expression (parser, NULL);</span>
<span class="lineNum">   15357 </span><span class="lineCov">        170 :   lhs = expr.value;</span>
<span class="lineNum">   15358 </span>            :   expr = default_function_array_conversion (eloc, expr);
<span class="lineNum">   15359 </span>            :   unfolded_lhs = expr.value;
<span class="lineNum">   15360 </span>            :   lhs = c_fully_fold (lhs, false, NULL, true);
<span class="lineNum">   15361 </span><span class="lineCov">         91 :   orig_lhs = lhs;</span>
<span class="lineNum">   15362 </span><span class="lineCov">         91 :   switch (TREE_CODE (lhs))</span>
<span class="lineNum">   15363 </span><span class="lineCov">         91 :     {</span>
<span class="lineNum">   15364 </span><span class="lineCov">         91 :     case ERROR_MARK:</span>
<span class="lineNum">   15365 </span>            :     saw_error:
<span class="lineNum">   15366 </span><span class="lineCov">         91 :       c_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">   15367 </span><span class="lineCov">          2 :       if (structured_block)</span>
<span class="lineNum">   15368 </span><span class="lineCov">         91 :         {</span>
<span class="lineNum">   15369 </span>            :           if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))
<span class="lineNum">   15370 </span>            :             c_parser_consume_token (parser);
<span class="lineNum">   15371 </span>            :           else if (code == OMP_ATOMIC_CAPTURE_NEW)
<span class="lineNum">   15372 </span>            :             {
<span class="lineNum">   15373 </span>            :               c_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   15374 </span>            :               if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))
<span class="lineNum">   15375 </span>            :                 c_parser_consume_token (parser);
<span class="lineNum">   15376 </span>            :             }
<span class="lineNum">   15377 </span>            :         }
<span class="lineNum">   15378 </span><span class="lineCov">        851 :       return;</span>
<span class="lineNum">   15379 </span><span class="lineCov">        947 : </span>
<span class="lineNum">   15380 </span><span class="lineCov">        947 :     case POSTINCREMENT_EXPR:</span>
<span class="lineNum">   15381 </span><span class="lineCov">        947 :       if (code == OMP_ATOMIC_CAPTURE_NEW &amp;&amp; !structured_block)</span>
<span class="lineNum">   15382 </span><span class="lineCov">        947 :         code = OMP_ATOMIC_CAPTURE_OLD;</span>
<span class="lineNum">   15383 </span><span class="lineCov">        947 :       /* FALLTHROUGH */</span>
<span class="lineNum">   15384 </span><span class="lineCov">        947 :     case PREINCREMENT_EXPR:</span>
<span class="lineNum">   15385 </span><span class="lineCov">        947 :       lhs = TREE_OPERAND (lhs, 0);</span>
<span class="lineNum">   15386 </span><span class="lineCov">        947 :       unfolded_lhs = NULL_TREE;</span>
<span class="lineNum">   15387 </span>            :       opcode = PLUS_EXPR;
<span class="lineNum">   15388 </span><span class="lineCov">         16 :       rhs = integer_one_node;</span>
<span class="lineNum">   15389 </span><span class="lineCov">         32 :       break;</span>
<span class="lineNum">   15390 </span><span class="lineCov">         16 : </span>
<span class="lineNum">   15391 </span><span class="lineCov">         16 :     case POSTDECREMENT_EXPR:</span>
<span class="lineNum">   15392 </span>            :       if (code == OMP_ATOMIC_CAPTURE_NEW &amp;&amp; !structured_block)
<span class="lineNum">   15393 </span><span class="lineNoCov">          0 :         code = OMP_ATOMIC_CAPTURE_OLD;</span>
<span class="lineNum">   15394 </span><span class="lineNoCov">          0 :       /* FALLTHROUGH */</span>
<span class="lineNum">   15395 </span><span class="lineNoCov">          0 :     case PREDECREMENT_EXPR:</span>
<span class="lineNum">   15396 </span>            :       lhs = TREE_OPERAND (lhs, 0);
<span class="lineNum">   15397 </span><span class="lineNoCov">          0 :       unfolded_lhs = NULL_TREE;</span>
<span class="lineNum">   15398 </span><span class="lineNoCov">          0 :       opcode = MINUS_EXPR;</span>
<span class="lineNum">   15399 </span><span class="lineNoCov">          0 :       rhs = integer_one_node;</span>
<span class="lineNum">   15400 </span>            :       break;
<span class="lineNum">   15401 </span>            : 
<span class="lineNum">   15402 </span><span class="lineCov">         16 :     case COMPOUND_EXPR:</span>
<span class="lineNum">   15403 </span>            :       if (TREE_CODE (TREE_OPERAND (lhs, 0)) == SAVE_EXPR
<span class="lineNum">   15404 </span><span class="lineCov">         69 :           &amp;&amp; TREE_CODE (TREE_OPERAND (lhs, 1)) == COMPOUND_EXPR</span>
<span class="lineNum">   15405 </span><span class="lineCov">         69 :           &amp;&amp; TREE_CODE (TREE_OPERAND (TREE_OPERAND (lhs, 1), 0)) == MODIFY_EXPR</span>
<span class="lineNum">   15406 </span><span class="lineCov">          7 :           &amp;&amp; TREE_OPERAND (TREE_OPERAND (lhs, 1), 1) == TREE_OPERAND (lhs, 0)</span>
<span class="lineNum">   15407 </span>            :           &amp;&amp; TREE_CODE (TREE_TYPE (TREE_OPERAND (TREE_OPERAND
<span class="lineNum">   15408 </span><span class="lineCov">        115 :                                               (TREE_OPERAND (lhs, 1), 0), 0)))</span>
<span class="lineNum">   15409 </span><span class="lineCov">        115 :              == BOOLEAN_TYPE)</span>
<span class="lineNum">   15410 </span><span class="lineCov">        115 :         /* Undo effects of boolean_increment for post {in,de}crement.  */</span>
<span class="lineNum">   15411 </span><span class="lineCov">        115 :         lhs = TREE_OPERAND (TREE_OPERAND (lhs, 1), 0);</span>
<span class="lineNum">   15412 </span><span class="lineCov">        115 :       /* FALLTHRU */</span>
<span class="lineNum">   15413 </span><span class="lineCov">        115 :     case MODIFY_EXPR:</span>
<span class="lineNum">   15414 </span>            :       if (TREE_CODE (lhs) == MODIFY_EXPR
<span class="lineNum">   15415 </span><span class="lineCov">         21 :           &amp;&amp; TREE_CODE (TREE_TYPE (TREE_OPERAND (lhs, 0))) == BOOLEAN_TYPE)</span>
<span class="lineNum">   15416 </span><span class="lineCov">         21 :         {</span>
<span class="lineNum">   15417 </span><span class="lineCov">          2 :           /* Undo effects of boolean_increment.  */</span>
<span class="lineNum">   15418 </span>            :           if (integer_onep (TREE_OPERAND (lhs, 1)))
<span class="lineNum">   15419 </span><span class="lineCov">         45 :             {</span>
<span class="lineNum">   15420 </span><span class="lineCov">         45 :               /* This is pre or post increment.  */</span>
<span class="lineNum">   15421 </span><span class="lineCov">         45 :               rhs = TREE_OPERAND (lhs, 1);</span>
<span class="lineNum">   15422 </span><span class="lineCov">         45 :               lhs = TREE_OPERAND (lhs, 0);</span>
<span class="lineNum">   15423 </span><span class="lineCov">         45 :               unfolded_lhs = NULL_TREE;</span>
<span class="lineNum">   15424 </span><span class="lineCov">         45 :               opcode = NOP_EXPR;</span>
<span class="lineNum">   15425 </span>            :               if (code == OMP_ATOMIC_CAPTURE_NEW
<span class="lineNum">   15426 </span><span class="lineCov">         12 :                   &amp;&amp; !structured_block</span>
<span class="lineNum">   15427 </span><span class="lineCov">         12 :                   &amp;&amp; TREE_CODE (orig_lhs) == COMPOUND_EXPR)</span>
<span class="lineNum">   15428 </span><span class="lineCov">         12 :                 code = OMP_ATOMIC_CAPTURE_OLD;</span>
<span class="lineNum">   15429 </span><span class="lineCov">         12 :               break;</span>
<span class="lineNum">   15430 </span><span class="lineCov">         12 :             }</span>
<span class="lineNum">   15431 </span><span class="lineCov">         24 :           if (TREE_CODE (TREE_OPERAND (lhs, 1)) == TRUTH_NOT_EXPR</span>
<span class="lineNum">   15432 </span>            :               &amp;&amp; TREE_OPERAND (lhs, 0)
<span class="lineNum">   15433 </span>            :                  == TREE_OPERAND (TREE_OPERAND (lhs, 1), 0))
<span class="lineNum">   15434 </span>            :             {
<span class="lineNum">   15435 </span><span class="lineCov">         12 :               /* This is pre or post decrement.  */</span>
<span class="lineNum">   15436 </span>            :               rhs = TREE_OPERAND (lhs, 1);
<span class="lineNum">   15437 </span><span class="lineCov">         24 :               lhs = TREE_OPERAND (lhs, 0);</span>
<span class="lineNum">   15438 </span><span class="lineCov">         24 :               unfolded_lhs = NULL_TREE;</span>
<span class="lineNum">   15439 </span><span class="lineCov">         24 :               opcode = NOP_EXPR;</span>
<span class="lineNum">   15440 </span>            :               if (code == OMP_ATOMIC_CAPTURE_NEW
<span class="lineNum">   15441 </span>            :                   &amp;&amp; !structured_block
<span class="lineNum">   15442 </span><span class="lineCov">         24 :                   &amp;&amp; TREE_CODE (orig_lhs) == COMPOUND_EXPR)</span>
<span class="lineNum">   15443 </span>            :                 code = OMP_ATOMIC_CAPTURE_OLD;
<span class="lineNum">   15444 </span>            :               break;
<span class="lineNum">   15445 </span><span class="lineCov">         12 :             }</span>
<span class="lineNum">   15446 </span><span class="lineCov">         12 :         }</span>
<span class="lineNum">   15447 </span><span class="lineCov">         12 :       /* FALLTHRU */</span>
<span class="lineNum">   15448 </span><span class="lineCov">         12 :     default:</span>
<span class="lineNum">   15449 </span><span class="lineCov">         24 :       if (!lvalue_p (unfolded_lhs))</span>
<span class="lineNum">   15450 </span><span class="lineCov">         12 :         lhs = non_lvalue (lhs);</span>
<span class="lineNum">   15451 </span><span class="lineCov">          2 :       switch (c_parser_peek_token (parser)-&gt;type)</span>
<span class="lineNum">   15452 </span><span class="lineCov">          1 :         {</span>
<span class="lineNum">   15453 </span>            :         case CPP_MULT_EQ:
<span class="lineNum">   15454 </span>            :           opcode = MULT_EXPR;
<span class="lineNum">   15455 </span><span class="lineCov">         12 :           break;</span>
<span class="lineNum">   15456 </span><span class="lineCov">         12 :         case CPP_DIV_EQ:</span>
<span class="lineNum">   15457 </span><span class="lineCov">         12 :           opcode = TRUNC_DIV_EXPR;</span>
<span class="lineNum">   15458 </span>            :           break;
<span class="lineNum">   15459 </span>            :         case CPP_PLUS_EQ:
<span class="lineNum">   15460 </span><span class="lineCov">         12 :           opcode = PLUS_EXPR;</span>
<span class="lineNum">   15461 </span><span class="lineCov">         12 :           break;</span>
<span class="lineNum">   15462 </span><span class="lineCov">         12 :         case CPP_MINUS_EQ:</span>
<span class="lineNum">   15463 </span><span class="lineCov">         12 :           opcode = MINUS_EXPR;</span>
<span class="lineNum">   15464 </span><span class="lineCov">         24 :           break;</span>
<span class="lineNum">   15465 </span><span class="lineCov">         12 :         case CPP_LSHIFT_EQ:</span>
<span class="lineNum">   15466 </span><span class="lineCov">          2 :           opcode = LSHIFT_EXPR;</span>
<span class="lineNum">   15467 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">   15468 </span>            :         case CPP_RSHIFT_EQ:
<span class="lineNum">   15469 </span>            :           opcode = RSHIFT_EXPR;
<span class="lineNum">   15470 </span>            :           break;
<span class="lineNum">   15471 </span>            :         case CPP_AND_EQ:
<span class="lineNum">   15472 </span><span class="lineCov">        759 :           opcode = BIT_AND_EXPR;</span>
<span class="lineNum">   15473 </span><span class="lineCov">        759 :           break;</span>
<span class="lineNum">   15474 </span><span class="lineCov">          4 :         case CPP_OR_EQ:</span>
<span class="lineNum">   15475 </span><span class="lineCov">        759 :           opcode = BIT_IOR_EXPR;</span>
<span class="lineNum">   15476 </span>            :           break;
<span class="lineNum">   15477 </span>            :         case CPP_XOR_EQ:
<span class="lineNum">   15478 </span>            :           opcode = BIT_XOR_EXPR;
<span class="lineNum">   15479 </span>            :           break;
<span class="lineNum">   15480 </span>            :         case CPP_EQ:
<span class="lineNum">   15481 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   15482 </span>            :           eloc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   15483 </span>            :           expr = c_parser_expr_no_commas (parser, NULL, unfolded_lhs);
<span class="lineNum">   15484 </span>            :           rhs1 = expr.value;
<span class="lineNum">   15485 </span>            :           switch (TREE_CODE (rhs1))
<span class="lineNum">   15486 </span>            :             {
<span class="lineNum">   15487 </span>            :             case MULT_EXPR:
<span class="lineNum">   15488 </span>            :             case TRUNC_DIV_EXPR:
<span class="lineNum">   15489 </span>            :             case RDIV_EXPR:
<span class="lineNum">   15490 </span>            :             case PLUS_EXPR:
<span class="lineNum">   15491 </span>            :             case MINUS_EXPR:
<span class="lineNum">   15492 </span>            :             case LSHIFT_EXPR:
<span class="lineNum">   15493 </span>            :             case RSHIFT_EXPR:
<span class="lineNum">   15494 </span>            :             case BIT_AND_EXPR:
<span class="lineNum">   15495 </span>            :             case BIT_IOR_EXPR:
<span class="lineNum">   15496 </span>            :             case BIT_XOR_EXPR:
<span class="lineNum">   15497 </span>            :               if (c_tree_equal (TREE_OPERAND (rhs1, 0), unfolded_lhs))
<span class="lineNum">   15498 </span>            :                 {
<span class="lineNum">   15499 </span>            :                   opcode = TREE_CODE (rhs1);
<span class="lineNum">   15500 </span>            :                   rhs = c_fully_fold (TREE_OPERAND (rhs1, 1), false, NULL,
<span class="lineNum">   15501 </span>            :                                       true);
<span class="lineNum">   15502 </span>            :                   rhs1 = c_fully_fold (TREE_OPERAND (rhs1, 0), false, NULL,
<span class="lineNum">   15503 </span>            :                                        true);
<span class="lineNum">   15504 </span><span class="lineCov">        296 :                   goto stmt_done;</span>
<span class="lineNum">   15505 </span><span class="lineCov">        296 :                 }</span>
<span class="lineNum">   15506 </span><span class="lineCov">        296 :               if (c_tree_equal (TREE_OPERAND (rhs1, 1), unfolded_lhs))</span>
<span class="lineNum">   15507 </span><span class="lineCov">        296 :                 {</span>
<span class="lineNum">   15508 </span><span class="lineCov">        296 :                   opcode = TREE_CODE (rhs1);</span>
<span class="lineNum">   15509 </span><span class="lineCov">        296 :                   rhs = c_fully_fold (TREE_OPERAND (rhs1, 0), false, NULL,</span>
<span class="lineNum">   15510 </span>            :                                       true);
<span class="lineNum">   15511 </span><span class="lineCov">        185 :                   rhs1 = c_fully_fold (TREE_OPERAND (rhs1, 1), false, NULL,</span>
<span class="lineNum">   15512 </span><span class="lineCov">        185 :                                        true);</span>
<span class="lineNum">   15513 </span><span class="lineCov">        185 :                   swapped = !commutative_tree_code (opcode);</span>
<span class="lineNum">   15514 </span><span class="lineCov">        185 :                   goto stmt_done;</span>
<span class="lineNum">   15515 </span><span class="lineCov">        185 :                 }</span>
<span class="lineNum">   15516 </span><span class="lineCov">        185 :               break;</span>
<span class="lineNum">   15517 </span><span class="lineCov">        185 :             case ERROR_MARK:</span>
<span class="lineNum">   15518 </span><span class="lineCov">        185 :               goto saw_error;</span>
<span class="lineNum">   15519 </span><span class="lineCov">        185 :             default:</span>
<span class="lineNum">   15520 </span><span class="lineCov">        185 :               break;</span>
<span class="lineNum">   15521 </span><span class="lineCov">        185 :             }</span>
<span class="lineNum">   15522 </span>            :           if (c_parser_peek_token (parser)-&gt;type == CPP_SEMICOLON)
<span class="lineNum">   15523 </span><span class="lineCov">         78 :             {</span>
<span class="lineNum">   15524 </span><span class="lineCov">         78 :               if (structured_block &amp;&amp; code == OMP_ATOMIC_CAPTURE_NEW)</span>
<span class="lineNum">   15525 </span>            :                 {
<span class="lineNum">   15526 </span><span class="lineCov">         78 :                   code = OMP_ATOMIC_CAPTURE_OLD;</span>
<span class="lineNum">   15527 </span>            :                   v = lhs;
<span class="lineNum">   15528 </span><span class="lineCov">         78 :                   lhs = NULL_TREE;</span>
<span class="lineNum">   15529 </span>            :                   expr = default_function_array_read_conversion (eloc, expr);
<span class="lineNum">   15530 </span><span class="lineCov">        107 :                   unfolded_lhs1 = expr.value;</span>
<span class="lineNum">   15531 </span>            :                   lhs1 = c_fully_fold (unfolded_lhs1, false, NULL, true);
<span class="lineNum">   15532 </span><span class="lineCov">         90 :                   rhs1 = NULL_TREE;</span>
<span class="lineNum">   15533 </span><span class="lineCov">         90 :                   c_parser_consume_token (parser);</span>
<span class="lineNum">   15534 </span>            :                   goto restart;
<span class="lineNum">   15535 </span><span class="lineCov">         90 :                 }</span>
<span class="lineNum">   15536 </span>            :               if (structured_block)
<span class="lineNum">   15537 </span><span class="lineCov">         90 :                 {</span>
<span class="lineNum">   15538 </span><span class="lineCov">         90 :                   opcode = NOP_EXPR;</span>
<span class="lineNum">   15539 </span>            :                   expr = default_function_array_read_conversion (eloc, expr);
<span class="lineNum">   15540 </span>            :                   rhs = c_fully_fold (expr.value, false, NULL, true);
<span class="lineNum">   15541 </span><span class="lineNoCov">          0 :                   rhs1 = NULL_TREE;</span>
<span class="lineNum">   15542 </span><span class="lineNoCov">          0 :                   goto stmt_done;</span>
<span class="lineNum">   15543 </span>            :                 }
<span class="lineNum">   15544 </span>            :             }
<span class="lineNum">   15545 </span>            :           c_parser_error (parser, &quot;invalid form of %&lt;#pragma omp atomic%&gt;&quot;);
<span class="lineNum">   15546 </span><span class="lineCov">        128 :           goto saw_error;</span>
<span class="lineNum">   15547 </span>            :         default:
<span class="lineNum">   15548 </span><span class="lineCov">        128 :           c_parser_error (parser,</span>
<span class="lineNum">   15549 </span>            :                           &quot;invalid operator for %&lt;#pragma omp atomic%&gt;&quot;);
<span class="lineNum">   15550 </span><span class="lineCov">         96 :           goto saw_error;</span>
<span class="lineNum">   15551 </span><span class="lineCov">         96 :         }</span>
<span class="lineNum">   15552 </span><span class="lineCov">         96 : </span>
<span class="lineNum">   15553 </span><span class="lineCov">         96 :       /* Arrange to pass the location of the assignment operator to</span>
<span class="lineNum">   15554 </span><span class="lineCov">         96 :          c_finish_omp_atomic.  */</span>
<span class="lineNum">   15555 </span><span class="lineCov">         96 :       loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   15556 </span><span class="lineCov">         96 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   15557 </span><span class="lineCov">         96 :       eloc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   15558 </span><span class="lineCov">         96 :       expr = c_parser_expression (parser);</span>
<span class="lineNum">   15559 </span>            :       expr = default_function_array_read_conversion (eloc, expr);
<span class="lineNum">   15560 </span><span class="lineCov">         32 :       rhs = expr.value;</span>
<span class="lineNum">   15561 </span>            :       rhs = c_fully_fold (rhs, false, NULL, true);
<span class="lineNum">   15562 </span><span class="lineCov">         24 :       break;</span>
<span class="lineNum">   15563 </span><span class="lineCov">         24 :     }</span>
<span class="lineNum">   15564 </span><span class="lineCov">         24 : stmt_done:</span>
<span class="lineNum">   15565 </span><span class="lineCov">         24 :   if (structured_block &amp;&amp; code == OMP_ATOMIC_CAPTURE_NEW)</span>
<span class="lineNum">   15566 </span><span class="lineCov">         24 :     {</span>
<span class="lineNum">   15567 </span>            :       if (!c_parser_require (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;))
<span class="lineNum">   15568 </span>            :         goto saw_error;
<span class="lineNum">   15569 </span><span class="lineCov">          8 :       v = c_parser_cast_expression (parser, NULL).value;</span>
<span class="lineNum">   15570 </span><span class="lineCov">          8 :       non_lvalue_p = !lvalue_p (v);</span>
<span class="lineNum">   15571 </span><span class="lineCov">          4 :       v = c_fully_fold (v, false, NULL, true);</span>
<span class="lineNum">   15572 </span><span class="lineCov">          4 :       if (v == error_mark_node)</span>
<span class="lineNum">   15573 </span>            :         goto saw_error;
<span class="lineNum">   15574 </span><span class="lineCov">          4 :       if (non_lvalue_p)</span>
<span class="lineNum">   15575 </span>            :         v = non_lvalue (v);
<span class="lineNum">   15576 </span>            :       if (!c_parser_require (parser, CPP_EQ, &quot;expected %&lt;=%&gt;&quot;))
<span class="lineNum">   15577 </span>            :         goto saw_error;
<span class="lineNum">   15578 </span>            :       eloc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   15579 </span><span class="lineCov">        459 :       expr = c_parser_cast_expression (parser, NULL);</span>
<span class="lineNum">   15580 </span><span class="lineCov">        459 :       lhs1 = expr.value;</span>
<span class="lineNum">   15581 </span><span class="lineCov">        459 :       expr = default_function_array_read_conversion (eloc, expr);</span>
<span class="lineNum">   15582 </span><span class="lineCov">        459 :       unfolded_lhs1 = expr.value;</span>
<span class="lineNum">   15583 </span><span class="lineCov">        459 :       lhs1 = c_fully_fold (lhs1, false, NULL, true);</span>
<span class="lineNum">   15584 </span><span class="lineCov">        459 :       if (lhs1 == error_mark_node)</span>
<span class="lineNum">   15585 </span><span class="lineCov">        459 :         goto saw_error;</span>
<span class="lineNum">   15586 </span><span class="lineCov">        459 :       if (!lvalue_p (unfolded_lhs1))</span>
<span class="lineNum">   15587 </span>            :         lhs1 = non_lvalue (lhs1);
<span class="lineNum">   15588 </span><span class="lineCov">        835 :     }</span>
<span class="lineNum">   15589 </span><span class="lineCov">        835 :   if (structured_block)</span>
<span class="lineNum">   15590 </span>            :     {
<span class="lineNum">   15591 </span><span class="lineCov">         74 :       c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);</span>
<span class="lineNum">   15592 </span>            :       c_parser_require (parser, CPP_CLOSE_BRACE, &quot;expected %&lt;}%&gt;&quot;);
<span class="lineNum">   15593 </span><span class="lineCov">         74 :     }</span>
<span class="lineNum">   15594 </span><span class="lineCov">         74 : done:</span>
<span class="lineNum">   15595 </span><span class="lineCov">         74 :   if (unfolded_lhs &amp;&amp; unfolded_lhs1</span>
<span class="lineNum">   15596 </span><span class="lineCov">         74 :       &amp;&amp; !c_tree_equal (unfolded_lhs, unfolded_lhs1))</span>
<span class="lineNum">   15597 </span>            :     {
<span class="lineNum">   15598 </span><span class="lineCov">         74 :       error (&quot;%&lt;#pragma omp atomic capture%&gt; uses two different &quot;</span>
<span class="lineNum">   15599 </span><span class="lineCov">          2 :              &quot;expressions for memory&quot;);</span>
<span class="lineNum">   15600 </span><span class="lineCov">         74 :       stmt = error_mark_node;</span>
<span class="lineNum">   15601 </span>            :     }
<span class="lineNum">   15602 </span><span class="lineCov">         74 :   else</span>
<span class="lineNum">   15603 </span><span class="lineCov">         74 :     stmt = c_finish_omp_atomic (loc, code, opcode, lhs, rhs, v, lhs1, rhs1,</span>
<span class="lineNum">   15604 </span><span class="lineCov">         74 :                                 swapped, seq_cst);</span>
<span class="lineNum">   15605 </span><span class="lineCov">         74 :   if (stmt != error_mark_node)</span>
<span class="lineNum">   15606 </span><span class="lineCov">         74 :     add_stmt (stmt);</span>
<span class="lineNum">   15607 </span><span class="lineCov">         74 : </span>
<span class="lineNum">   15608 </span><span class="lineCov">         74 :   if (!structured_block)</span>
<span class="lineNum">   15609 </span>            :     c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);
<span class="lineNum">   15610 </span><span class="lineCov">         74 : }</span>
<span class="lineNum">   15611 </span><span class="lineCov">          2 : </span>
<span class="lineNum">   15612 </span>            : 
<span class="lineNum">   15613 </span><span class="lineCov">        835 : /* OpenMP 2.5:</span>
<span class="lineNum">   15614 </span>            :    # pragma omp barrier new-line
<span class="lineNum">   15615 </span><span class="lineCov">        170 : */</span>
<a name="15616"><span class="lineNum">   15616 </span><span class="lineCov">        170 : </span></a>
<span class="lineNum">   15617 </span>            : static void
<span class="lineNum">   15618 </span><span class="lineCov">        665 : c_parser_omp_barrier (c_parser *parser)</span>
<span class="lineNum">   15619 </span><span class="lineCov">       1018 : {</span>
<span class="lineNum">   15620 </span><span class="lineCov">       1018 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   15621 </span>            :   c_parser_consume_pragma (parser);
<span class="lineNum">   15622 </span><span class="lineCov">          5 :   c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   15623 </span>            : 
<span class="lineNum">   15624 </span><span class="lineCov">          5 :   c_finish_omp_barrier (loc);</span>
<span class="lineNum">   15625 </span>            : }
<span class="lineNum">   15626 </span>            : 
<span class="lineNum">   15627 </span><span class="lineCov">       1013 : /* OpenMP 2.5:</span>
<span class="lineNum">   15628 </span>            :    # pragma omp critical [(name)] new-line
<span class="lineNum">   15629 </span><span class="lineCov">       1018 :      structured-block</span>
<span class="lineNum">   15630 </span><span class="lineCov">        991 : </span>
<span class="lineNum">   15631 </span>            :    OpenMP 4.5:
<span class="lineNum">   15632 </span><span class="lineCov">       1018 :    # pragma omp critical [(name) [hint(expression)]] new-line</span>
<span class="lineNum">   15633 </span><span class="lineCov">        848 : </span>
<span class="lineNum">   15634 </span>            :   LOC is the location of the #pragma itself.  */
<span class="lineNum">   15635 </span>            : 
<span class="lineNum">   15636 </span>            : #define OMP_CRITICAL_CLAUSE_MASK                \
<span class="lineNum">   15637 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_HINT) )
<a name="15638"><span class="lineNum">   15638 </span>            : </a>
<span class="lineNum">   15639 </span>            : static tree
<span class="lineNum">   15640 </span>            : c_parser_omp_critical (location_t loc, c_parser *parser, bool *if_p)
<span class="lineNum">   15641 </span>            : {
<span class="lineNum">   15642 </span><span class="lineCov">        253 :   tree stmt, name = NULL_TREE, clauses = NULL_TREE;</span>
<span class="lineNum">   15643 </span>            : 
<span class="lineNum">   15644 </span><span class="lineCov">        253 :   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))</span>
<span class="lineNum">   15645 </span><span class="lineCov">        253 :     {</span>
<span class="lineNum">   15646 </span><span class="lineCov">        253 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   15647 </span>            :       if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   15648 </span><span class="lineCov">        253 :         {</span>
<span class="lineNum">   15649 </span><span class="lineCov">        253 :           name = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">   15650 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   15651 </span>            :           c_parser_require (parser, CPP_CLOSE_PAREN, &quot;expected %&lt;)%&gt;&quot;);
<span class="lineNum">   15652 </span>            :         }
<span class="lineNum">   15653 </span>            :       else
<span class="lineNum">   15654 </span>            :         c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">   15655 </span>            : 
<span class="lineNum">   15656 </span>            :       clauses = c_parser_omp_all_clauses (parser,
<span class="lineNum">   15657 </span>            :                                           OMP_CRITICAL_CLAUSE_MASK,
<span class="lineNum">   15658 </span>            :                                           &quot;#pragma omp critical&quot;);
<span class="lineNum">   15659 </span>            :     }
<span class="lineNum">   15660 </span>            :   else
<span class="lineNum">   15661 </span>            :     {
<span class="lineNum">   15662 </span>            :       if (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))
<span class="lineNum">   15663 </span>            :         c_parser_error (parser, &quot;expected %&lt;(%&gt; or end of line&quot;);
<span class="lineNum">   15664 </span><span class="lineCov">         90 :       c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   15665 </span>            :     }
<span class="lineNum">   15666 </span><span class="lineCov">         90 : </span>
<span class="lineNum">   15667 </span>            :   stmt = c_parser_omp_structured_block (parser, if_p);
<span class="lineNum">   15668 </span><span class="lineCov">         90 :   return c_finish_omp_critical (loc, stmt, name, clauses);</span>
<span class="lineNum">   15669 </span>            : }
<span class="lineNum">   15670 </span><span class="lineCov">         22 : </span>
<span class="lineNum">   15671 </span><span class="lineCov">         22 : /* OpenMP 2.5:</span>
<span class="lineNum">   15672 </span>            :    # pragma omp flush flush-vars[opt] new-line
<span class="lineNum">   15673 </span><span class="lineCov">         21 : </span>
<span class="lineNum">   15674 </span><span class="lineCov">         21 :    flush-vars:</span>
<span class="lineNum">   15675 </span><span class="lineCov">         21 :      ( variable-list ) */</span>
<a name="15676"><span class="lineNum">   15676 </span>            : </a>
<span class="lineNum">   15677 </span>            : static void
<span class="lineNum">   15678 </span><span class="lineCov">          1 : c_parser_omp_flush (c_parser *parser)</span>
<span class="lineNum">   15679 </span>            : {
<span class="lineNum">   15680 </span><span class="lineCov">         22 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   15681 </span><span class="lineCov">         22 :   c_parser_consume_pragma (parser);</span>
<span class="lineNum">   15682 </span>            :   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))
<span class="lineNum">   15683 </span>            :     c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);
<span class="lineNum">   15684 </span>            :   else if (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))
<span class="lineNum">   15685 </span>            :     c_parser_error (parser, &quot;expected %&lt;(%&gt; or end of line&quot;);
<span class="lineNum">   15686 </span><span class="lineCov">         68 :   c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   15687 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   15688 </span><span class="lineCov">         68 :   c_finish_omp_flush (loc);</span>
<span class="lineNum">   15689 </span>            : }
<span class="lineNum">   15690 </span>            : 
<span class="lineNum">   15691 </span><span class="lineCov">         90 : /* Parse the restricted form of loop statements allowed by OpenACC and OpenMP.</span>
<span class="lineNum">   15692 </span><span class="lineCov">         90 :    The real trick here is to determine the loop control variable early</span>
<span class="lineNum">   15693 </span>            :    so that we can push a new decl if necessary to make it private.
<span class="lineNum">   15694 </span>            :    LOC is the location of the &quot;acc&quot; or &quot;omp&quot; in &quot;#pragma acc&quot; or &quot;#pragma omp&quot;,
<span class="lineNum">   15695 </span>            :    respectively.  */
<a name="15696"><span class="lineNum">   15696 </span>            : </a>
<span class="lineNum">   15697 </span>            : static tree
<span class="lineNum">   15698 </span>            : c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,
<span class="lineNum">   15699 </span>            :                        tree clauses, tree *cclauses, bool *if_p)
<span class="lineNum">   15700 </span>            : {
<span class="lineNum">   15701 </span>            :   tree decl, cond, incr, save_break, save_cont, body, init, stmt, cl;
<span class="lineNum">   15702 </span><span class="lineCov">         14 :   tree declv, condv, incrv, initv, ret = NULL_TREE;</span>
<span class="lineNum">   15703 </span>            :   tree pre_body = NULL_TREE, this_pre_body;
<span class="lineNum">   15704 </span><span class="lineCov">         14 :   tree ordered_cl = NULL_TREE;</span>
<span class="lineNum">   15705 </span><span class="lineCov">         14 :   bool fail = false, open_brace_parsed = false;</span>
<span class="lineNum">   15706 </span><span class="lineCov">         14 :   int i, collapse = 1, ordered = 0, count, nbraces = 0;</span>
<span class="lineNum">   15707 </span><span class="lineCov">         11 :   location_t for_loc;</span>
<span class="lineNum">   15708 </span><span class="lineCov">          3 :   bool tiling = false;</span>
<span class="lineNum">   15709 </span><span class="lineCov">          1 :   vec&lt;tree, va_gc&gt; *for_block = make_tree_vector ();</span>
<span class="lineNum">   15710 </span><span class="lineCov">         14 : </span>
<span class="lineNum">   15711 </span>            :   for (cl = clauses; cl; cl = OMP_CLAUSE_CHAIN (cl))
<span class="lineNum">   15712 </span><span class="lineCov">         14 :     if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_COLLAPSE)</span>
<span class="lineNum">   15713 </span><span class="lineCov">         14 :       collapse = tree_to_shwi (OMP_CLAUSE_COLLAPSE_EXPR (cl));</span>
<span class="lineNum">   15714 </span>            :     else if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_TILE)
<span class="lineNum">   15715 </span>            :       {
<span class="lineNum">   15716 </span>            :         tiling = true;
<span class="lineNum">   15717 </span>            :         collapse = list_length (OMP_CLAUSE_TILE_LIST (cl));
<span class="lineNum">   15718 </span>            :       }
<span class="lineNum">   15719 </span>            :     else if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_ORDERED
<span class="lineNum">   15720 </span>            :              &amp;&amp; OMP_CLAUSE_ORDERED_EXPR (cl))
<span class="lineNum">   15721 </span>            :       {
<span class="lineNum">   15722 </span><span class="lineCov">       4556 :         ordered_cl = cl;</span>
<span class="lineNum">   15723 </span>            :         ordered = tree_to_shwi (OMP_CLAUSE_ORDERED_EXPR (cl));
<span class="lineNum">   15724 </span>            :       }
<span class="lineNum">   15725 </span><span class="lineCov">       4556 : </span>
<span class="lineNum">   15726 </span><span class="lineCov">       4556 :   if (ordered &amp;&amp; ordered &lt; collapse)</span>
<span class="lineNum">   15727 </span><span class="lineCov">       4556 :     {</span>
<span class="lineNum">   15728 </span><span class="lineCov">       4556 :       error_at (OMP_CLAUSE_LOCATION (ordered_cl),</span>
<span class="lineNum">   15729 </span><span class="lineCov">       4556 :                 &quot;%&lt;ordered%&gt; clause parameter is less than %&lt;collapse%&gt;&quot;);</span>
<span class="lineNum">   15730 </span><span class="lineCov">       4556 :       OMP_CLAUSE_ORDERED_EXPR (ordered_cl)</span>
<span class="lineNum">   15731 </span><span class="lineCov">       4556 :         = build_int_cst (NULL_TREE, collapse);</span>
<span class="lineNum">   15732 </span><span class="lineCov">       4556 :       ordered = collapse;</span>
<span class="lineNum">   15733 </span><span class="lineCov">       4556 :     }</span>
<span class="lineNum">   15734 </span>            :   if (ordered)
<span class="lineNum">   15735 </span><span class="lineCov">      10171 :     {</span>
<span class="lineNum">   15736 </span><span class="lineCov">       5615 :       for (tree *pc = &amp;clauses; *pc; )</span>
<span class="lineNum">   15737 </span><span class="lineCov">       1033 :         if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_LINEAR)</span>
<span class="lineNum">   15738 </span><span class="lineCov">       9164 :           {</span>
<span class="lineNum">   15739 </span>            :             error_at (OMP_CLAUSE_LOCATION (*pc),
<span class="lineNum">   15740 </span><span class="lineCov">        105 :                       &quot;%&lt;linear%&gt; clause may not be specified together &quot;</span>
<span class="lineNum">   15741 </span><span class="lineCov">        105 :                       &quot;with %&lt;ordered%&gt; clause with a parameter&quot;);</span>
<span class="lineNum">   15742 </span>            :             *pc = OMP_CLAUSE_CHAIN (*pc);
<span class="lineNum">   15743 </span><span class="lineCov">       4477 :           }</span>
<span class="lineNum">   15744 </span><span class="lineCov">       4477 :         else</span>
<span class="lineNum">   15745 </span>            :           pc = &amp;OMP_CLAUSE_CHAIN (*pc);
<span class="lineNum">   15746 </span><span class="lineCov">         52 :     }</span>
<span class="lineNum">   15747 </span><span class="lineCov">         52 : </span>
<span class="lineNum">   15748 </span>            :   gcc_assert (tiling || (collapse &gt;= 1 &amp;&amp; ordered &gt;= 0));
<span class="lineNum">   15749 </span>            :   count = ordered ? ordered : collapse;
<span class="lineNum">   15750 </span><span class="lineCov">       4556 : </span>
<span class="lineNum">   15751 </span>            :   declv = make_tree_vec (count);
<span class="lineNum">   15752 </span><span class="lineCov">          2 :   initv = make_tree_vec (count);</span>
<span class="lineNum">   15753 </span>            :   condv = make_tree_vec (count);
<span class="lineNum">   15754 </span><span class="lineCov">          2 :   incrv = make_tree_vec (count);</span>
<span class="lineNum">   15755 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   15756 </span><span class="lineCov">          2 :   if (!c_parser_next_token_is_keyword (parser, RID_FOR))</span>
<span class="lineNum">   15757 </span>            :     {
<span class="lineNum">   15758 </span><span class="lineCov">       4556 :       c_parser_error (parser, &quot;for statement expected&quot;);</span>
<span class="lineNum">   15759 </span>            :       return NULL;
<span class="lineNum">   15760 </span><span class="lineCov">        181 :     }</span>
<span class="lineNum">   15761 </span><span class="lineCov">        129 :   for_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   15762 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">   15763 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   15764 </span>            :   for (i = 0; i &lt; count; i++)
<span class="lineNum">   15765 </span>            :     {
<span class="lineNum">   15766 </span><span class="lineNoCov">          0 :       int bracecount = 0;</span>
<span class="lineNum">   15767 </span>            : 
<span class="lineNum">   15768 </span>            :       matching_parens parens;
<span class="lineNum">   15769 </span><span class="lineCov">        258 :       if (!parens.require_open (parser))</span>
<span class="lineNum">   15770 </span>            :         goto pop_scopes;
<span class="lineNum">   15771 </span>            : 
<span class="lineNum">   15772 </span><span class="lineCov">       4556 :       /* Parse the initialization declaration or expression.  */</span>
<span class="lineNum">   15773 </span><span class="lineCov">       4556 :       if (c_parser_next_tokens_start_declaration (parser))</span>
<span class="lineNum">   15774 </span>            :         {
<span class="lineNum">   15775 </span><span class="lineCov">       4556 :           if (i &gt; 0)</span>
<span class="lineNum">   15776 </span><span class="lineCov">       4556 :             vec_safe_push (for_block, c_begin_compound_stmt (true));</span>
<span class="lineNum">   15777 </span><span class="lineCov">       4556 :           this_pre_body = push_stmt_list ();</span>
<span class="lineNum">   15778 </span><span class="lineCov">       4556 :           c_parser_declaration_or_fndef (parser, true, true, true, true, true,</span>
<span class="lineNum">   15779 </span>            :                                          NULL, vNULL);
<span class="lineNum">   15780 </span><span class="lineCov">       4556 :           if (this_pre_body)</span>
<span class="lineNum">   15781 </span>            :             {
<span class="lineNum">   15782 </span><span class="lineCov">          7 :               this_pre_body = pop_stmt_list (this_pre_body);</span>
<span class="lineNum">   15783 </span><span class="lineCov">          7 :               if (pre_body)</span>
<span class="lineNum">   15784 </span>            :                 {
<span class="lineNum">   15785 </span><span class="lineCov">       4549 :                   tree t = pre_body;   </span>
<span class="lineNum">   15786 </span><span class="lineCov">       4549 :                   pre_body = push_stmt_list ();</span>
<span class="lineNum">   15787 </span>            :                   add_stmt (t);
<span class="lineNum">   15788 </span><span class="lineCov">       6674 :                   add_stmt (this_pre_body);</span>
<span class="lineNum">   15789 </span>            :                   pre_body = pop_stmt_list (pre_body);
<span class="lineNum">   15790 </span><span class="lineCov">       6669 :                 }</span>
<span class="lineNum">   15791 </span>            :               else
<span class="lineNum">   15792 </span><span class="lineCov">      13338 :                 pre_body = this_pre_body;</span>
<span class="lineNum">   15793 </span><span class="lineCov">       6669 :             }</span>
<span class="lineNum">   15794 </span><span class="lineNoCov">          0 :           decl = check_for_loop_decls (for_loc, flag_isoc99);</span>
<span class="lineNum">   15795 </span>            :           if (decl == NULL)
<span class="lineNum">   15796 </span>            :             goto error_init;
<span class="lineNum">   15797 </span><span class="lineCov">       6669 :           if (DECL_INITIAL (decl) == error_mark_node)</span>
<span class="lineNum">   15798 </span>            :             decl = error_mark_node;
<span class="lineNum">   15799 </span><span class="lineCov">       1385 :           init = decl;</span>
<span class="lineNum">   15800 </span><span class="lineCov">        698 :         }</span>
<span class="lineNum">   15801 </span><span class="lineCov">       1385 :       else if (c_parser_next_token_is (parser, CPP_NAME)</span>
<span class="lineNum">   15802 </span><span class="lineCov">       1385 :                &amp;&amp; c_parser_peek_2nd_token (parser)-&gt;type == CPP_EQ)</span>
<span class="lineNum">   15803 </span>            :         {
<span class="lineNum">   15804 </span><span class="lineCov">       1385 :           struct c_expr decl_exp;</span>
<span class="lineNum">   15805 </span>            :           struct c_expr init_exp;
<span class="lineNum">   15806 </span><span class="lineCov">       1385 :           location_t init_loc;</span>
<span class="lineNum">   15807 </span><span class="lineCov">       1385 : </span>
<span class="lineNum">   15808 </span>            :           decl_exp = c_parser_postfix_expression (parser);
<span class="lineNum">   15809 </span><span class="lineCov">        366 :           decl = decl_exp.value;</span>
<span class="lineNum">   15810 </span><span class="lineCov">        366 : </span>
<span class="lineNum">   15811 </span><span class="lineCov">        366 :           c_parser_require (parser, CPP_EQ, &quot;expected %&lt;=%&gt;&quot;);</span>
<span class="lineNum">   15812 </span><span class="lineCov">        366 : </span>
<span class="lineNum">   15813 </span><span class="lineCov">        366 :           init_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   15814 </span>            :           init_exp = c_parser_expr_no_commas (parser, NULL);
<span class="lineNum">   15815 </span>            :           init_exp = default_function_array_read_conversion (init_loc,
<span class="lineNum">   15816 </span>            :                                                              init_exp);
<span class="lineNum">   15817 </span>            :           init = build_modify_expr (init_loc, decl, decl_exp.original_type,
<span class="lineNum">   15818 </span><span class="lineCov">       1385 :                                     NOP_EXPR, init_loc, init_exp.value,</span>
<span class="lineNum">   15819 </span><span class="lineCov">       1385 :                                     init_exp.original_type);</span>
<span class="lineNum">   15820 </span>            :           init = c_process_expr_stmt (init_loc, init);
<span class="lineNum">   15821 </span><span class="lineCov">       1385 : </span>
<span class="lineNum">   15822 </span><span class="lineCov">          1 :           c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);</span>
<span class="lineNum">   15823 </span>            :         }
<span class="lineNum">   15824 </span>            :       else
<span class="lineNum">   15825 </span><span class="lineCov">       5284 :         {</span>
<span class="lineNum">   15826 </span><span class="lineCov">       5284 :         error_init:</span>
<span class="lineNum">   15827 </span>            :           c_parser_error (parser,
<span class="lineNum">   15828 </span><span class="lineCov">       5282 :                           &quot;expected iteration declaration or initialization&quot;);</span>
<span class="lineNum">   15829 </span><span class="lineCov">       5282 :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,</span>
<span class="lineNum">   15830 </span><span class="lineCov">       5282 :                                      &quot;expected %&lt;)%&gt;&quot;);</span>
<span class="lineNum">   15831 </span>            :           fail = true;
<span class="lineNum">   15832 </span><span class="lineCov">       5282 :           goto parse_next;</span>
<span class="lineNum">   15833 </span><span class="lineCov">       5282 :         }</span>
<span class="lineNum">   15834 </span>            : 
<span class="lineNum">   15835 </span><span class="lineCov">       5282 :       /* Parse the loop condition.  */</span>
<span class="lineNum">   15836 </span>            :       cond = NULL_TREE;
<span class="lineNum">   15837 </span><span class="lineCov">       5282 :       if (c_parser_next_token_is_not (parser, CPP_SEMICOLON))</span>
<span class="lineNum">   15838 </span><span class="lineCov">       5282 :         {</span>
<span class="lineNum">   15839 </span><span class="lineCov">       5282 :           location_t cond_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   15840 </span><span class="lineCov">       5282 :           struct c_expr cond_expr</span>
<span class="lineNum">   15841 </span><span class="lineCov">       5282 :             = c_parser_binary_expression (parser, NULL, NULL_TREE);</span>
<span class="lineNum">   15842 </span>            : 
<span class="lineNum">   15843 </span>            :           cond = cond_expr.value;
<span class="lineNum">   15844 </span><span class="lineCov">       5282 :           cond = c_objc_common_truthvalue_conversion (cond_loc, cond);</span>
<span class="lineNum">   15845 </span>            :           if (COMPARISON_CLASS_P (cond))
<span class="lineNum">   15846 </span><span class="lineCov">       5282 :             {</span>
<span class="lineNum">   15847 </span>            :               tree op0 = TREE_OPERAND (cond, 0), op1 = TREE_OPERAND (cond, 1);
<span class="lineNum">   15848 </span>            :               op0 = c_fully_fold (op0, false, NULL);
<span class="lineNum">   15849 </span>            :               op1 = c_fully_fold (op1, false, NULL);
<span class="lineNum">   15850 </span><span class="lineCov">          2 :               TREE_OPERAND (cond, 0) = op0;</span>
<span class="lineNum">   15851 </span><span class="lineCov">          2 :               TREE_OPERAND (cond, 1) = op1;</span>
<span class="lineNum">   15852 </span>            :             }
<span class="lineNum">   15853 </span><span class="lineCov">          2 :           switch (cond_expr.original_code)</span>
<span class="lineNum">   15854 </span>            :             {
<span class="lineNum">   15855 </span><span class="lineCov">          2 :             case GT_EXPR:</span>
<span class="lineNum">   15856 </span><span class="lineCov">          2 :             case GE_EXPR:</span>
<span class="lineNum">   15857 </span>            :             case LT_EXPR:
<span class="lineNum">   15858 </span>            :             case LE_EXPR:
<span class="lineNum">   15859 </span>            :               break;
<span class="lineNum">   15860 </span><span class="lineCov">       6667 :             default:</span>
<span class="lineNum">   15861 </span><span class="lineCov">       6667 :               /* Can't be cond = error_mark_node, because we want to preserve</span>
<span class="lineNum">   15862 </span>            :                  the location until c_finish_omp_for.  */
<span class="lineNum">   15863 </span><span class="lineCov">       6665 :               cond = build1 (NOP_EXPR, boolean_type_node, error_mark_node);</span>
<span class="lineNum">   15864 </span><span class="lineCov">       6665 :               break;</span>
<span class="lineNum">   15865 </span><span class="lineCov">       6665 :             }</span>
<span class="lineNum">   15866 </span>            :           protected_set_expr_location (cond, cond_loc);
<span class="lineNum">   15867 </span><span class="lineCov">       6665 :         }</span>
<span class="lineNum">   15868 </span><span class="lineCov">       6665 :       c_parser_skip_until_found (parser, CPP_SEMICOLON, &quot;expected %&lt;;%&gt;&quot;);</span>
<span class="lineNum">   15869 </span><span class="lineCov">       6665 : </span>
<span class="lineNum">   15870 </span>            :       /* Parse the increment expression.  */
<span class="lineNum">   15871 </span><span class="lineCov">       6661 :       incr = NULL_TREE;</span>
<span class="lineNum">   15872 </span><span class="lineCov">       6661 :       if (c_parser_next_token_is_not (parser, CPP_CLOSE_PAREN))</span>
<span class="lineNum">   15873 </span><span class="lineCov">       6661 :         {</span>
<span class="lineNum">   15874 </span><span class="lineCov">       6661 :           location_t incr_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   15875 </span><span class="lineCov">       6661 : </span>
<span class="lineNum">   15876 </span>            :           incr = c_process_expr_stmt (incr_loc,
<span class="lineNum">   15877 </span><span class="lineCov">       6665 :                                       c_parser_expression (parser).value);</span>
<span class="lineNum">   15878 </span>            :         }
<span class="lineNum">   15879 </span>            :       parens.skip_until_found_close (parser);
<span class="lineNum">   15880 </span>            : 
<span class="lineNum">   15881 </span>            :       if (decl == NULL || decl == error_mark_node || init == error_mark_node)
<span class="lineNum">   15882 </span>            :         fail = true;
<span class="lineNum">   15883 </span>            :       else
<span class="lineNum">   15884 </span><span class="lineCov">         11 :         {</span>
<span class="lineNum">   15885 </span>            :           TREE_VEC_ELT (declv, i) = decl;
<span class="lineNum">   15886 </span>            :           TREE_VEC_ELT (initv, i) = init;
<span class="lineNum">   15887 </span><span class="lineCov">         11 :           TREE_VEC_ELT (condv, i) = cond;</span>
<span class="lineNum">   15888 </span><span class="lineCov">         11 :           TREE_VEC_ELT (incrv, i) = incr;</span>
<span class="lineNum">   15889 </span>            :         }
<span class="lineNum">   15890 </span><span class="lineCov">       6665 : </span>
<span class="lineNum">   15891 </span>            :     parse_next:
<span class="lineNum">   15892 </span><span class="lineCov">       6667 :       if (i == count - 1)</span>
<span class="lineNum">   15893 </span>            :         break;
<span class="lineNum">   15894 </span>            : 
<span class="lineNum">   15895 </span><span class="lineCov">       6667 :       /* FIXME: OpenMP 3.0 draft isn't very clear on what exactly is allowed</span>
<span class="lineNum">   15896 </span><span class="lineCov">       6667 :          in between the collapsed for loops to be still considered perfectly</span>
<span class="lineNum">   15897 </span>            :          nested.  Hopefully the final version clarifies this.
<span class="lineNum">   15898 </span><span class="lineCov">       6667 :          For now handle (multiple) {'s and empty statements.  */</span>
<span class="lineNum">   15899 </span>            :       do
<span class="lineNum">   15900 </span><span class="lineCov">       6667 :         {</span>
<span class="lineNum">   15901 </span><span class="lineCov">      13334 :           if (c_parser_next_token_is_keyword (parser, RID_FOR))</span>
<span class="lineNum">   15902 </span>            :             {
<span class="lineNum">   15903 </span><span class="lineCov">       6667 :               c_parser_consume_token (parser);</span>
<span class="lineNum">   15904 </span>            :               break;
<span class="lineNum">   15905 </span><span class="lineCov">       6667 :             }</span>
<span class="lineNum">   15906 </span>            :           else if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))
<span class="lineNum">   15907 </span>            :             {
<span class="lineNum">   15908 </span>            :               c_parser_consume_token (parser);
<span class="lineNum">   15909 </span><span class="lineCov">       6664 :               bracecount++;</span>
<span class="lineNum">   15910 </span><span class="lineCov">       6664 :             }</span>
<span class="lineNum">   15911 </span><span class="lineCov">       6664 :           else if (bracecount</span>
<span class="lineNum">   15912 </span><span class="lineCov">       6664 :                    &amp;&amp; c_parser_next_token_is (parser, CPP_SEMICOLON))</span>
<span class="lineNum">   15913 </span>            :             c_parser_consume_token (parser);
<span class="lineNum">   15914 </span>            :           else
<span class="lineNum">   15915 </span><span class="lineCov">       6669 :             {</span>
<span class="lineNum">   15916 </span><span class="lineCov">       6669 :               c_parser_error (parser, &quot;not enough perfectly nested loops&quot;);</span>
<span class="lineNum">   15917 </span>            :               if (bracecount)
<span class="lineNum">   15918 </span>            :                 {
<span class="lineNum">   15919 </span>            :                   open_brace_parsed = true;
<span class="lineNum">   15920 </span>            :                   bracecount--;
<span class="lineNum">   15921 </span>            :                 }
<span class="lineNum">   15922 </span>            :               fail = true;
<span class="lineNum">   15923 </span><span class="lineCov">       2163 :               count = 0;</span>
<span class="lineNum">   15924 </span>            :               break;
<span class="lineNum">   15925 </span><span class="lineCov">       2163 :             }</span>
<span class="lineNum">   15926 </span>            :         }
<span class="lineNum">   15927 </span><span class="lineCov">       2120 :       while (1);</span>
<span class="lineNum">   15928 </span><span class="lineCov">       2120 : </span>
<span class="lineNum">   15929 </span>            :       nbraces += bracecount;
<span class="lineNum">   15930 </span><span class="lineCov">         43 :     }</span>
<span class="lineNum">   15931 </span>            : 
<span class="lineNum">   15932 </span><span class="lineCov">         38 :   if (nbraces)</span>
<span class="lineNum">   15933 </span><span class="lineCov">         38 :     if_p = NULL;</span>
<span class="lineNum">   15934 </span>            : 
<span class="lineNum">   15935 </span><span class="lineCov">          5 :   save_break = c_break_label;</span>
<span class="lineNum">   15936 </span><span class="lineCov">          5 :   c_break_label = size_one_node;</span>
<span class="lineNum">   15937 </span><span class="lineNoCov">          0 :   save_cont = c_cont_label;</span>
<span class="lineNum">   15938 </span>            :   c_cont_label = NULL_TREE;
<span class="lineNum">   15939 </span>            :   body = push_stmt_list ();
<span class="lineNum">   15940 </span><span class="lineCov">          5 : </span>
<span class="lineNum">   15941 </span><span class="lineCov">          5 :   if (open_brace_parsed)</span>
<span class="lineNum">   15942 </span>            :     {
<span class="lineNum">   15943 </span><span class="lineCov">          2 :       location_t here = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   15944 </span><span class="lineCov">          2 :       stmt = c_begin_compound_stmt (true);</span>
<span class="lineNum">   15945 </span>            :       c_parser_compound_statement_nostart (parser);
<span class="lineNum">   15946 </span>            :       add_stmt (c_end_compound_stmt (here, stmt, true));
<span class="lineNum">   15947 </span>            :     }
<span class="lineNum">   15948 </span>            :   else
<span class="lineNum">   15949 </span>            :     add_stmt (c_parser_c99_block_statement (parser, if_p));
<span class="lineNum">   15950 </span>            :   if (c_cont_label)
<span class="lineNum">   15951 </span>            :     {
<span class="lineNum">   15952 </span>            :       tree t = build1 (LABEL_EXPR, void_type_node, c_cont_label);
<span class="lineNum">   15953 </span><span class="lineCov">       2125 :       SET_EXPR_LOCATION (t, loc);</span>
<span class="lineNum">   15954 </span>            :       add_stmt (t);
<span class="lineNum">   15955 </span>            :     }
<span class="lineNum">   15956 </span><span class="lineCov">       4549 : </span>
<span class="lineNum">   15957 </span><span class="lineCov">         24 :   body = pop_stmt_list (body);</span>
<span class="lineNum">   15958 </span>            :   c_break_label = save_break;
<span class="lineNum">   15959 </span><span class="lineCov">       4549 :   c_cont_label = save_cont;</span>
<span class="lineNum">   15960 </span><span class="lineCov">       4549 : </span>
<span class="lineNum">   15961 </span><span class="lineCov">       4549 :   while (nbraces)</span>
<span class="lineNum">   15962 </span><span class="lineCov">       4549 :     {</span>
<span class="lineNum">   15963 </span><span class="lineCov">       4549 :       if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))</span>
<span class="lineNum">   15964 </span>            :         {
<span class="lineNum">   15965 </span><span class="lineCov">       4549 :           c_parser_consume_token (parser);</span>
<span class="lineNum">   15966 </span>            :           nbraces--;
<span class="lineNum">   15967 </span><span class="lineCov">          2 :         }</span>
<span class="lineNum">   15968 </span><span class="lineCov">          2 :       else if (c_parser_next_token_is (parser, CPP_SEMICOLON))</span>
<span class="lineNum">   15969 </span><span class="lineCov">          2 :         c_parser_consume_token (parser);</span>
<span class="lineNum">   15970 </span><span class="lineCov">          2 :       else</span>
<span class="lineNum">   15971 </span>            :         {
<span class="lineNum">   15972 </span>            :           c_parser_error (parser, &quot;collapsed loops not perfectly nested&quot;);
<span class="lineNum">   15973 </span><span class="lineCov">       4547 :           while (nbraces)</span>
<span class="lineNum">   15974 </span><span class="lineCov">       4549 :             {</span>
<span class="lineNum">   15975 </span>            :               location_t here = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   15976 </span><span class="lineCov">          6 :               stmt = c_begin_compound_stmt (true);</span>
<span class="lineNum">   15977 </span><span class="lineCov">          6 :               add_stmt (body);</span>
<span class="lineNum">   15978 </span><span class="lineCov">          6 :               c_parser_compound_statement_nostart (parser);</span>
<span class="lineNum">   15979 </span>            :               body = c_end_compound_stmt (here, stmt, true);
<span class="lineNum">   15980 </span>            :               nbraces--;
<span class="lineNum">   15981 </span><span class="lineCov">       4549 :             }</span>
<span class="lineNum">   15982 </span><span class="lineCov">       4549 :           goto pop_scopes;</span>
<span class="lineNum">   15983 </span><span class="lineCov">       4549 :         }</span>
<span class="lineNum">   15984 </span>            :     }
<span class="lineNum">   15985 </span><span class="lineCov">       4579 : </span>
<span class="lineNum">   15986 </span>            :   /* Only bother calling c_finish_omp_for if we haven't already generated
<span class="lineNum">   15987 </span><span class="lineCov">         34 :      an error from the initialization parsing.  */</span>
<span class="lineNum">   15988 </span>            :   if (!fail)
<span class="lineNum">   15989 </span><span class="lineCov">         30 :     {</span>
<span class="lineNum">   15990 </span><span class="lineCov">         30 :       stmt = c_finish_omp_for (loc, code, declv, NULL, initv, condv,</span>
<span class="lineNum">   15991 </span>            :                                incrv, body, pre_body);
<span class="lineNum">   15992 </span><span class="lineCov">          4 : </span>
<span class="lineNum">   15993 </span><span class="lineNoCov">          0 :       /* Check for iterators appearing in lb, b or incr expressions.  */</span>
<span class="lineNum">   15994 </span>            :       if (stmt &amp;&amp; !c_omp_check_loop_iv (stmt, declv, NULL))
<span class="lineNum">   15995 </span>            :         stmt = NULL_TREE;
<span class="lineNum">   15996 </span><span class="lineCov">          4 : </span>
<span class="lineNum">   15997 </span><span class="lineCov">         10 :       if (stmt)</span>
<span class="lineNum">   15998 </span>            :         {
<span class="lineNum">   15999 </span><span class="lineCov">          6 :           add_stmt (stmt);</span>
<span class="lineNum">   16000 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   16001 </span><span class="lineCov">          6 :           if (cclauses != NULL</span>
<span class="lineNum">   16002 </span><span class="lineCov">          6 :               &amp;&amp; cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL] != NULL)</span>
<span class="lineNum">   16003 </span><span class="lineCov">          6 :             {</span>
<span class="lineNum">   16004 </span><span class="lineCov">          6 :               tree *c;</span>
<span class="lineNum">   16005 </span>            :               for (c = &amp;cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL]; *c ; )
<span class="lineNum">   16006 </span>            :                 if (OMP_CLAUSE_CODE (*c) != OMP_CLAUSE_FIRSTPRIVATE
<span class="lineNum">   16007 </span>            :                     &amp;&amp; OMP_CLAUSE_CODE (*c) != OMP_CLAUSE_LASTPRIVATE)
<span class="lineNum">   16008 </span>            :                   c = &amp;OMP_CLAUSE_CHAIN (*c);
<span class="lineNum">   16009 </span>            :                 else
<span class="lineNum">   16010 </span>            :                   {
<span class="lineNum">   16011 </span>            :                     for (i = 0; i &lt; count; i++)
<span class="lineNum">   16012 </span><span class="lineCov">       4545 :                       if (TREE_VEC_ELT (declv, i) == OMP_CLAUSE_DECL (*c))</span>
<span class="lineNum">   16013 </span>            :                         break;
<span class="lineNum">   16014 </span><span class="lineCov">       4535 :                     if (i == count)</span>
<span class="lineNum">   16015 </span>            :                       c = &amp;OMP_CLAUSE_CHAIN (*c);
<span class="lineNum">   16016 </span>            :                     else if (OMP_CLAUSE_CODE (*c) == OMP_CLAUSE_FIRSTPRIVATE)
<span class="lineNum">   16017 </span>            :                       {
<span class="lineNum">   16018 </span><span class="lineCov">       4535 :                         error_at (loc,</span>
<span class="lineNum">   16019 </span>            :                                   &quot;iteration variable %qD should not be firstprivate&quot;,
<span class="lineNum">   16020 </span>            :                                   OMP_CLAUSE_DECL (*c));
<span class="lineNum">   16021 </span><span class="lineCov">       4474 :                         *c = OMP_CLAUSE_CHAIN (*c);</span>
<span class="lineNum">   16022 </span>            :                       }
<span class="lineNum">   16023 </span><span class="lineCov">       4431 :                     else</span>
<span class="lineNum">   16024 </span>            :                       {
<span class="lineNum">   16025 </span><span class="lineCov">       4431 :                         /* Move lastprivate (decl) clause to OMP_FOR_CLAUSES.  */</span>
<span class="lineNum">   16026 </span><span class="lineCov">       2003 :                         tree l = *c;</span>
<span class="lineNum">   16027 </span>            :                         *c = OMP_CLAUSE_CHAIN (*c);
<span class="lineNum">   16028 </span><span class="lineCov">        290 :                         if (code == OMP_SIMD)</span>
<span class="lineNum">   16029 </span><span class="lineCov">       1114 :                           {</span>
<span class="lineNum">   16030 </span><span class="lineCov">        824 :                             OMP_CLAUSE_CHAIN (l)</span>
<span class="lineNum">   16031 </span><span class="lineCov">        824 :                               = cclauses[C_OMP_CLAUSE_SPLIT_FOR];</span>
<span class="lineNum">   16032 </span><span class="lineCov">       1250 :                             cclauses[C_OMP_CLAUSE_SPLIT_FOR] = l;</span>
<span class="lineNum">   16033 </span>            :                           }
<span class="lineNum">   16034 </span>            :                         else
<span class="lineNum">   16035 </span><span class="lineCov">        430 :                           {</span>
<span class="lineNum">   16036 </span><span class="lineCov">        266 :                             OMP_CLAUSE_CHAIN (l) = clauses;</span>
<span class="lineNum">   16037 </span>            :                             clauses = l;
<span class="lineNum">   16038 </span><span class="lineCov">        199 :                           }</span>
<span class="lineNum">   16039 </span><span class="lineCov">        328 :                       }</span>
<span class="lineNum">   16040 </span><span class="lineCov">         70 :                   }</span>
<span class="lineNum">   16041 </span>            :             }
<span class="lineNum">   16042 </span><span class="lineCov">          1 :           OMP_FOR_CLAUSES (stmt) = clauses;</span>
<span class="lineNum">   16043 </span>            :         }
<span class="lineNum">   16044 </span><span class="lineCov">          2 :       ret = stmt;</span>
<span class="lineNum">   16045 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">   16046 </span>            : pop_scopes:
<span class="lineNum">   16047 </span>            :   while (!for_block-&gt;is_empty ())
<span class="lineNum">   16048 </span>            :     {
<span class="lineNum">   16049 </span>            :       /* FIXME diagnostics: LOC below should be the actual location of
<span class="lineNum">   16050 </span><span class="lineCov">         34 :          this particular for block.  We need to build a list of</span>
<span class="lineNum">   16051 </span><span class="lineCov">         68 :          locations to go along with FOR_BLOCK.  */</span>
<span class="lineNum">   16052 </span><span class="lineCov">         34 :       stmt = c_end_compound_stmt (loc, for_block-&gt;pop (), true);</span>
<span class="lineNum">   16053 </span>            :       add_stmt (stmt);
<span class="lineNum">   16054 </span><span class="lineCov">         10 :     }</span>
<span class="lineNum">   16055 </span><span class="lineCov">         10 :   release_tree_vector (for_block);</span>
<span class="lineNum">   16056 </span><span class="lineCov">         10 :   return ret;</span>
<span class="lineNum">   16057 </span>            : }
<span class="lineNum">   16058 </span>            : 
<span class="lineNum">   16059 </span>            : /* Helper function for OpenMP parsing, split clauses and call
<span class="lineNum">   16060 </span><span class="lineCov">         24 :    finish_omp_clauses on each of the set of clauses afterwards.  */</span>
<a name="16061"><span class="lineNum">   16061 </span><span class="lineCov">         24 : </span></a>
<span class="lineNum">   16062 </span>            : static void
<span class="lineNum">   16063 </span>            : omp_split_clauses (location_t loc, enum tree_code code,
<span class="lineNum">   16064 </span>            :                    omp_clause_mask mask, tree clauses, tree *cclauses)
<span class="lineNum">   16065 </span>            : {
<span class="lineNum">   16066 </span><span class="lineCov">       8862 :   int i;</span>
<span class="lineNum">   16067 </span>            :   c_omp_split_clauses (loc, code, mask, clauses, cclauses);
<span class="lineNum">   16068 </span>            :   for (i = 0; i &lt; C_OMP_CLAUSE_SPLIT_COUNT; i++)
<span class="lineNum">   16069 </span>            :     if (cclauses[i])
<span class="lineNum">   16070 </span><span class="lineCov">       4549 :       cclauses[i] = c_finish_omp_clauses (cclauses[i], C_ORT_OMP);</span>
<span class="lineNum">   16071 </span><span class="lineCov">       5247 : }</span>
<span class="lineNum">   16072 </span>            : 
<span class="lineNum">   16073 </span>            : /* OpenMP 4.0:
<span class="lineNum">   16074 </span>            :    #pragma omp simd simd-clause[optseq] new-line
<span class="lineNum">   16075 </span>            :      for-loop
<span class="lineNum">   16076 </span><span class="lineCov">       1396 : </span>
<span class="lineNum">   16077 </span><span class="lineCov">        698 :    LOC is the location of the #pragma token.</span>
<span class="lineNum">   16078 </span>            : */
<span class="lineNum">   16079 </span><span class="lineCov">       4549 : </span>
<span class="lineNum">   16080 </span><span class="lineCov">       4549 : #define OMP_SIMD_CLAUSE_MASK                                    \</span>
<span class="lineNum">   16081 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SAFELEN)        \
<span class="lineNum">   16082 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SIMDLEN)        \
<span class="lineNum">   16083 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LINEAR) \
<span class="lineNum">   16084 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_ALIGNED)        \
<span class="lineNum">   16085 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \
<span class="lineNum">   16086 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LASTPRIVATE)    \
<span class="lineNum">   16087 </span><span class="lineCov">       2152 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_REDUCTION)      \</span>
<span class="lineNum">   16088 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_COLLAPSE))
<a name="16089"><span class="lineNum">   16089 </span>            : </a>
<span class="lineNum">   16090 </span><span class="lineCov">       2152 : static tree</span>
<span class="lineNum">   16091 </span><span class="lineCov">       2152 : c_parser_omp_simd (location_t loc, c_parser *parser,</span>
<span class="lineNum">   16092 </span><span class="lineCov">      15064 :                    char *p_name, omp_clause_mask mask, tree *cclauses,</span>
<span class="lineNum">   16093 </span><span class="lineCov">      12912 :                    bool *if_p)</span>
<span class="lineNum">   16094 </span><span class="lineCov">       3587 : {</span>
<span class="lineNum">   16095 </span><span class="lineCov">       2152 :   tree block, clauses, ret;</span>
<span class="lineNum">   16096 </span>            : 
<span class="lineNum">   16097 </span>            :   strcat (p_name, &quot; simd&quot;);
<span class="lineNum">   16098 </span>            :   mask |= OMP_SIMD_CLAUSE_MASK;
<span class="lineNum">   16099 </span>            : 
<span class="lineNum">   16100 </span>            :   clauses = c_parser_omp_all_clauses (parser, mask, p_name, cclauses == NULL);
<span class="lineNum">   16101 </span>            :   if (cclauses)
<span class="lineNum">   16102 </span>            :     {
<span class="lineNum">   16103 </span>            :       omp_split_clauses (loc, OMP_SIMD, mask, clauses, cclauses);
<span class="lineNum">   16104 </span>            :       clauses = cclauses[C_OMP_CLAUSE_SPLIT_SIMD];
<span class="lineNum">   16105 </span>            :       tree c = omp_find_clause (cclauses[C_OMP_CLAUSE_SPLIT_FOR],
<span class="lineNum">   16106 </span>            :                                 OMP_CLAUSE_ORDERED);
<span class="lineNum">   16107 </span>            :       if (c &amp;&amp; OMP_CLAUSE_ORDERED_EXPR (c))
<span class="lineNum">   16108 </span>            :         {
<span class="lineNum">   16109 </span>            :           error_at (OMP_CLAUSE_LOCATION (c),
<span class="lineNum">   16110 </span>            :                     &quot;%&lt;ordered%&gt; clause with parameter may not be specified &quot;
<span class="lineNum">   16111 </span>            :                     &quot;on %qs construct&quot;, p_name);
<span class="lineNum">   16112 </span>            :           OMP_CLAUSE_ORDERED_EXPR (c) = NULL_TREE;
<span class="lineNum">   16113 </span>            :         }
<span class="lineNum">   16114 </span>            :     }
<span class="lineNum">   16115 </span><span class="lineCov">       1220 : </span>
<span class="lineNum">   16116 </span>            :   block = c_begin_compound_stmt (true);
<span class="lineNum">   16117 </span>            :   ret = c_parser_omp_for_loop (loc, parser, OMP_SIMD, clauses, cclauses, if_p);
<span class="lineNum">   16118 </span>            :   block = c_end_compound_stmt (loc, block, true);
<span class="lineNum">   16119 </span><span class="lineCov">       1220 :   add_stmt (block);</span>
<span class="lineNum">   16120 </span>            : 
<span class="lineNum">   16121 </span><span class="lineCov">       1220 :   return ret;</span>
<span class="lineNum">   16122 </span><span class="lineCov">      19520 : }</span>
<span class="lineNum">   16123 </span>            : 
<span class="lineNum">   16124 </span><span class="lineCov">       1220 : /* OpenMP 2.5:</span>
<span class="lineNum">   16125 </span><span class="lineCov">       1220 :    #pragma omp for for-clause[optseq] new-line</span>
<span class="lineNum">   16126 </span>            :      for-loop
<span class="lineNum">   16127 </span><span class="lineCov">        968 : </span>
<span class="lineNum">   16128 </span><span class="lineCov">        968 :    OpenMP 4.0:</span>
<span class="lineNum">   16129 </span><span class="lineCov">        968 :    #pragma omp for simd for-simd-clause[optseq] new-line</span>
<span class="lineNum">   16130 </span><span class="lineCov">        968 :      for-loop</span>
<span class="lineNum">   16131 </span><span class="lineCov">        968 : </span>
<span class="lineNum">   16132 </span>            :    LOC is the location of the #pragma token.
<span class="lineNum">   16133 </span><span class="lineCov">          2 : */</span>
<span class="lineNum">   16134 </span>            : 
<span class="lineNum">   16135 </span>            : #define OMP_FOR_CLAUSE_MASK                                     \
<span class="lineNum">   16136 </span><span class="lineCov">          2 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \</span>
<span class="lineNum">   16137 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \
<span class="lineNum">   16138 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LASTPRIVATE)    \
<span class="lineNum">   16139 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LINEAR) \
<span class="lineNum">   16140 </span><span class="lineCov">       1220 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_REDUCTION)      \</span>
<span class="lineNum">   16141 </span><span class="lineCov">       1220 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_ORDERED)        \</span>
<span class="lineNum">   16142 </span><span class="lineCov">       1220 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SCHEDULE)       \</span>
<span class="lineNum">   16143 </span><span class="lineCov">       1220 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_COLLAPSE)       \</span>
<span class="lineNum">   16144 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT))
<a name="16145"><span class="lineNum">   16145 </span><span class="lineCov">       1220 : </span></a>
<span class="lineNum">   16146 </span>            : static tree
<span class="lineNum">   16147 </span>            : c_parser_omp_for (location_t loc, c_parser *parser,
<span class="lineNum">   16148 </span>            :                   char *p_name, omp_clause_mask mask, tree *cclauses,
<span class="lineNum">   16149 </span>            :                   bool *if_p)
<span class="lineNum">   16150 </span>            : {
<span class="lineNum">   16151 </span>            :   tree block, clauses, ret;
<span class="lineNum">   16152 </span>            : 
<span class="lineNum">   16153 </span>            :   strcat (p_name, &quot; for&quot;);
<span class="lineNum">   16154 </span>            :   mask |= OMP_FOR_CLAUSE_MASK;
<span class="lineNum">   16155 </span>            :   /* parallel for{, simd} disallows nowait clause, but for
<span class="lineNum">   16156 </span>            :      target {teams distribute ,}parallel for{, simd} it should be accepted.  */
<span class="lineNum">   16157 </span>            :   if (cclauses &amp;&amp; (mask &amp; (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MAP)) == 0)
<span class="lineNum">   16158 </span>            :     mask &amp;= ~(OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT);
<span class="lineNum">   16159 </span>            :   /* Composite distribute parallel for{, simd} disallows ordered clause.  */
<span class="lineNum">   16160 </span>            :   if ((mask &amp; (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)
<span class="lineNum">   16161 </span>            :     mask &amp;= ~(OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_ORDERED);
<span class="lineNum">   16162 </span>            : 
<span class="lineNum">   16163 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   16164 </span>            :     {
<span class="lineNum">   16165 </span>            :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   16166 </span>            : 
<span class="lineNum">   16167 </span>            :       if (strcmp (p, &quot;simd&quot;) == 0)
<span class="lineNum">   16168 </span>            :         {
<span class="lineNum">   16169 </span>            :           tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];
<span class="lineNum">   16170 </span>            :           if (cclauses == NULL)
<span class="lineNum">   16171 </span><span class="lineCov">       2533 :             cclauses = cclauses_buf;</span>
<span class="lineNum">   16172 </span>            : 
<span class="lineNum">   16173 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   16174 </span>            :           if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   16175 </span><span class="lineCov">       2533 :             return c_parser_omp_simd (loc, parser, p_name, mask, cclauses,</span>
<span class="lineNum">   16176 </span>            :                                       if_p);
<span class="lineNum">   16177 </span><span class="lineCov">       2533 :           block = c_begin_compound_stmt (true);</span>
<span class="lineNum">   16178 </span><span class="lineCov">      45594 :           ret = c_parser_omp_simd (loc, parser, p_name, mask, cclauses, if_p);</span>
<span class="lineNum">   16179 </span>            :           block = c_end_compound_stmt (loc, block, true);
<span class="lineNum">   16180 </span>            :           if (ret == NULL_TREE)
<span class="lineNum">   16181 </span><span class="lineCov">       2533 :             return ret;</span>
<span class="lineNum">   16182 </span><span class="lineCov">       5060 :           ret = make_node (OMP_FOR);</span>
<span class="lineNum">   16183 </span>            :           TREE_TYPE (ret) = void_type_node;
<span class="lineNum">   16184 </span><span class="lineCov">       7599 :           OMP_FOR_BODY (ret) = block;</span>
<span class="lineNum">   16185 </span><span class="lineCov">       3920 :           OMP_FOR_CLAUSES (ret) = cclauses[C_OMP_CLAUSE_SPLIT_FOR];</span>
<span class="lineNum">   16186 </span>            :           SET_EXPR_LOCATION (ret, loc);
<span class="lineNum">   16187 </span><span class="lineCov">       2533 :           add_stmt (ret);</span>
<span class="lineNum">   16188 </span>            :           return ret;
<span class="lineNum">   16189 </span><span class="lineCov">       2176 :         }</span>
<span class="lineNum">   16190 </span>            :     }
<span class="lineNum">   16191 </span><span class="lineCov">       2176 :   if (!flag_openmp)  /* flag_openmp_simd  */</span>
<span class="lineNum">   16192 </span>            :     {
<span class="lineNum">   16193 </span><span class="lineCov">        795 :       c_parser_skip_to_pragma_eol (parser, false);</span>
<span class="lineNum">   16194 </span><span class="lineCov">        795 :       return NULL_TREE;</span>
<span class="lineNum">   16195 </span><span class="lineCov">        101 :     }</span>
<span class="lineNum">   16196 </span>            : 
<span class="lineNum">   16197 </span><span class="lineCov">        795 :   /* Composite distribute parallel for disallows linear clause.  */</span>
<span class="lineNum">   16198 </span><span class="lineCov">        795 :   if ((mask &amp; (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)</span>
<span class="lineNum">   16199 </span><span class="lineCov">          7 :     mask &amp;= ~(OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LINEAR);</span>
<span class="lineNum">   16200 </span><span class="lineCov">          7 : </span>
<span class="lineNum">   16201 </span><span class="lineCov">        788 :   clauses = c_parser_omp_all_clauses (parser, mask, p_name, cclauses == NULL);</span>
<span class="lineNum">   16202 </span><span class="lineCov">        788 :   if (cclauses)</span>
<span class="lineNum">   16203 </span><span class="lineCov">        788 :     {</span>
<span class="lineNum">   16204 </span><span class="lineCov">        788 :       omp_split_clauses (loc, OMP_FOR, mask, clauses, cclauses);</span>
<span class="lineNum">   16205 </span>            :       clauses = cclauses[C_OMP_CLAUSE_SPLIT_FOR];
<span class="lineNum">   16206 </span><span class="lineCov">        779 :     }</span>
<span class="lineNum">   16207 </span><span class="lineCov">        779 : </span>
<span class="lineNum">   16208 </span><span class="lineCov">       1558 :   block = c_begin_compound_stmt (true);</span>
<span class="lineNum">   16209 </span><span class="lineCov">       1558 :   ret = c_parser_omp_for_loop (loc, parser, OMP_FOR, clauses, cclauses, if_p);</span>
<span class="lineNum">   16210 </span><span class="lineCov">        779 :   block = c_end_compound_stmt (loc, block, true);</span>
<span class="lineNum">   16211 </span><span class="lineCov">        779 :   add_stmt (block);</span>
<span class="lineNum">   16212 </span><span class="lineCov">        779 : </span>
<span class="lineNum">   16213 </span>            :   return ret;
<span class="lineNum">   16214 </span>            : }
<span class="lineNum">   16215 </span><span class="lineCov">       1738 : </span>
<span class="lineNum">   16216 </span>            : /* OpenMP 2.5:
<span class="lineNum">   16217 </span><span class="lineCov">          4 :    # pragma omp master new-line</span>
<span class="lineNum">   16218 </span><span class="lineCov">          4 :      structured-block</span>
<span class="lineNum">   16219 </span>            : 
<span class="lineNum">   16220 </span>            :    LOC is the location of the #pragma token.
<span class="lineNum">   16221 </span>            : */
<a name="16222"><span class="lineNum">   16222 </span><span class="lineCov">       5202 : </span></a>
<span class="lineNum">   16223 </span><span class="lineCov">       1956 : static tree</span>
<span class="lineNum">   16224 </span>            : c_parser_omp_master (location_t loc, c_parser *parser, bool *if_p)
<span class="lineNum">   16225 </span><span class="lineCov">       1734 : {</span>
<span class="lineNum">   16226 </span><span class="lineCov">       1734 :   c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   16227 </span>            :   return c_finish_omp_master (loc, c_parser_omp_structured_block (parser,
<span class="lineNum">   16228 </span><span class="lineCov">       1050 :                                                                   if_p));</span>
<span class="lineNum">   16229 </span><span class="lineCov">       1050 : }</span>
<span class="lineNum">   16230 </span>            : 
<span class="lineNum">   16231 </span>            : /* OpenMP 2.5:
<span class="lineNum">   16232 </span><span class="lineCov">       1734 :    # pragma omp ordered new-line</span>
<span class="lineNum">   16233 </span><span class="lineCov">       1734 :      structured-block</span>
<span class="lineNum">   16234 </span><span class="lineCov">       1734 : </span>
<span class="lineNum">   16235 </span><span class="lineCov">       1734 :    OpenMP 4.5:</span>
<span class="lineNum">   16236 </span>            :    # pragma omp ordered ordered-clauses new-line
<span class="lineNum">   16237 </span><span class="lineCov">       1734 :      structured-block</span>
<span class="lineNum">   16238 </span>            : 
<span class="lineNum">   16239 </span>            :    # pragma omp ordered depend-clauses new-line  */
<span class="lineNum">   16240 </span>            : 
<span class="lineNum">   16241 </span>            : #define OMP_ORDERED_CLAUSE_MASK                                 \
<span class="lineNum">   16242 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_THREADS)        \
<span class="lineNum">   16243 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SIMD))
<span class="lineNum">   16244 </span>            : 
<span class="lineNum">   16245 </span>            : #define OMP_ORDERED_DEPEND_CLAUSE_MASK                          \
<span class="lineNum">   16246 </span>            :         (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEPEND)
<a name="16247"><span class="lineNum">   16247 </span>            : </a>
<span class="lineNum">   16248 </span><span class="lineCov">         57 : static bool</span>
<span class="lineNum">   16249 </span>            : c_parser_omp_ordered (c_parser *parser, enum pragma_context context,
<span class="lineNum">   16250 </span><span class="lineCov">         57 :                       bool *if_p)</span>
<span class="lineNum">   16251 </span><span class="lineCov">         57 : {</span>
<span class="lineNum">   16252 </span><span class="lineCov">         57 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   16253 </span>            :   c_parser_consume_pragma (parser);
<span class="lineNum">   16254 </span>            : 
<span class="lineNum">   16255 </span>            :   if (context != pragma_stmt &amp;&amp; context != pragma_compound)
<span class="lineNum">   16256 </span>            :     {
<span class="lineNum">   16257 </span>            :       c_parser_error (parser, &quot;expected declaration specifiers&quot;);
<span class="lineNum">   16258 </span>            :       c_parser_skip_to_pragma_eol (parser, false);
<span class="lineNum">   16259 </span>            :       return false;
<span class="lineNum">   16260 </span>            :     }
<span class="lineNum">   16261 </span>            : 
<span class="lineNum">   16262 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   16263 </span>            :     {
<span class="lineNum">   16264 </span>            :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   16265 </span>            : 
<span class="lineNum">   16266 </span>            :       if (!strcmp (&quot;depend&quot;, p))
<span class="lineNum">   16267 </span>            :         {
<span class="lineNum">   16268 </span>            :           if (!flag_openmp)     /* flag_openmp_simd  */
<span class="lineNum">   16269 </span>            :             {
<span class="lineNum">   16270 </span>            :               c_parser_skip_to_pragma_eol (parser, false);
<span class="lineNum">   16271 </span>            :               return false;
<span class="lineNum">   16272 </span>            :             }
<span class="lineNum">   16273 </span><span class="lineCov">        250 :           if (context == pragma_stmt)</span>
<span class="lineNum">   16274 </span>            :             {
<span class="lineNum">   16275 </span>            :               error_at (loc,
<span class="lineNum">   16276 </span><span class="lineCov">        250 :                         &quot;%&lt;#pragma omp ordered%&gt; with %&lt;depend%&gt; clause may &quot;</span>
<span class="lineNum">   16277 </span><span class="lineCov">        250 :                         &quot;only be used in compound statements&quot;);</span>
<span class="lineNum">   16278 </span>            :               c_parser_skip_to_pragma_eol (parser, false);
<span class="lineNum">   16279 </span><span class="lineCov">        250 :               return false;</span>
<span class="lineNum">   16280 </span>            :             }
<span class="lineNum">   16281 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   16282 </span><span class="lineCov">          1 :           tree clauses</span>
<span class="lineNum">   16283 </span><span class="lineCov">          1 :             = c_parser_omp_all_clauses (parser,</span>
<span class="lineNum">   16284 </span>            :                                         OMP_ORDERED_DEPEND_CLAUSE_MASK,
<span class="lineNum">   16285 </span>            :                                         &quot;#pragma omp ordered&quot;);
<span class="lineNum">   16286 </span><span class="lineCov">        249 :           c_finish_omp_ordered (loc, clauses, NULL_TREE);</span>
<span class="lineNum">   16287 </span>            :           return false;
<span class="lineNum">   16288 </span><span class="lineCov">        178 :         }</span>
<span class="lineNum">   16289 </span>            :     }
<span class="lineNum">   16290 </span><span class="lineCov">        178 : </span>
<span class="lineNum">   16291 </span>            :   tree clauses = c_parser_omp_all_clauses (parser, OMP_ORDERED_CLAUSE_MASK,
<span class="lineNum">   16292 </span><span class="lineCov">        122 :                                            &quot;#pragma omp ordered&quot;);</span>
<span class="lineNum">   16293 </span>            : 
<span class="lineNum">   16294 </span><span class="lineCov">          2 :   if (!flag_openmp      /* flag_openmp_simd  */</span>
<span class="lineNum">   16295 </span><span class="lineCov">          2 :       &amp;&amp; omp_find_clause (clauses, OMP_CLAUSE_SIMD) == NULL_TREE)</span>
<span class="lineNum">   16296 </span>            :     return false;
<span class="lineNum">   16297 </span><span class="lineCov">        120 : </span>
<span class="lineNum">   16298 </span>            :   c_finish_omp_ordered (loc, clauses,
<span class="lineNum">   16299 </span><span class="lineCov">         16 :                         c_parser_omp_structured_block (parser, if_p));</span>
<span class="lineNum">   16300 </span>            :   return true;
<span class="lineNum">   16301 </span>            : }
<span class="lineNum">   16302 </span><span class="lineCov">         16 : </span>
<span class="lineNum">   16303 </span><span class="lineCov">         16 : /* OpenMP 2.5:</span>
<span class="lineNum">   16304 </span>            : 
<span class="lineNum">   16305 </span>            :    section-scope:
<span class="lineNum">   16306 </span><span class="lineCov">        104 :      { section-sequence }</span>
<span class="lineNum">   16307 </span><span class="lineCov">        104 : </span>
<span class="lineNum">   16308 </span><span class="lineCov">        104 :    section-sequence:</span>
<span class="lineNum">   16309 </span>            :      section-directive[opt] structured-block
<span class="lineNum">   16310 </span><span class="lineCov">        104 :      section-sequence section-directive structured-block</span>
<span class="lineNum">   16311 </span><span class="lineCov">        104 : </span>
<span class="lineNum">   16312 </span>            :     SECTIONS_LOC is the location of the #pragma omp sections.  */
<a name="16313"><span class="lineNum">   16313 </span>            : </a>
<span class="lineNum">   16314 </span>            : static tree
<span class="lineNum">   16315 </span><span class="lineCov">        508 : c_parser_omp_sections_scope (location_t sections_loc, c_parser *parser)</span>
<span class="lineNum">   16316 </span>            : {
<span class="lineNum">   16317 </span>            :   tree stmt, substmt;
<span class="lineNum">   16318 </span><span class="lineCov">        127 :   bool error_suppress = false;</span>
<span class="lineNum">   16319 </span><span class="lineCov">        127 :   location_t loc;</span>
<span class="lineNum">   16320 </span>            : 
<span class="lineNum">   16321 </span>            :   loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   16322 </span><span class="lineCov">        125 :   if (!c_parser_require (parser, CPP_OPEN_BRACE, &quot;expected %&lt;{%&gt;&quot;))</span>
<span class="lineNum">   16323 </span>            :     {
<span class="lineNum">   16324 </span><span class="lineCov">        125 :       /* Avoid skipping until the end of the block.  */</span>
<span class="lineNum">   16325 </span>            :       parser-&gt;error = false;
<span class="lineNum">   16326 </span>            :       return NULL_TREE;
<span class="lineNum">   16327 </span>            :     }
<span class="lineNum">   16328 </span>            : 
<span class="lineNum">   16329 </span>            :   stmt = push_stmt_list ();
<span class="lineNum">   16330 </span>            : 
<span class="lineNum">   16331 </span>            :   if (c_parser_peek_token (parser)-&gt;pragma_kind != PRAGMA_OMP_SECTION)
<span class="lineNum">   16332 </span>            :     {
<span class="lineNum">   16333 </span>            :       substmt = c_parser_omp_structured_block (parser, NULL);
<span class="lineNum">   16334 </span>            :       substmt = build1 (OMP_SECTION, void_type_node, substmt);
<span class="lineNum">   16335 </span>            :       SET_EXPR_LOCATION (substmt, loc);
<span class="lineNum">   16336 </span>            :       add_stmt (substmt);
<span class="lineNum">   16337 </span>            :     }
<span class="lineNum">   16338 </span>            : 
<span class="lineNum">   16339 </span><span class="lineCov">         92 :   while (1)</span>
<span class="lineNum">   16340 </span>            :     {
<span class="lineNum">   16341 </span><span class="lineCov">         92 :       if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))</span>
<span class="lineNum">   16342 </span><span class="lineCov">         92 :         break;</span>
<span class="lineNum">   16343 </span><span class="lineCov">         92 :       if (c_parser_next_token_is (parser, CPP_EOF))</span>
<span class="lineNum">   16344 </span>            :         break;
<span class="lineNum">   16345 </span><span class="lineCov">         92 : </span>
<span class="lineNum">   16346 </span><span class="lineCov">         92 :       loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   16347 </span>            :       if (c_parser_peek_token (parser)-&gt;pragma_kind == PRAGMA_OMP_SECTION)
<span class="lineNum">   16348 </span>            :         {
<span class="lineNum">   16349 </span><span class="lineCov">          2 :           c_parser_consume_pragma (parser);</span>
<span class="lineNum">   16350 </span><span class="lineCov">          2 :           c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   16351 </span>            :           error_suppress = false;
<span class="lineNum">   16352 </span>            :         }
<span class="lineNum">   16353 </span><span class="lineCov">         90 :       else if (!error_suppress)</span>
<span class="lineNum">   16354 </span>            :         {
<span class="lineNum">   16355 </span><span class="lineCov">         90 :           error_at (loc, &quot;expected %&lt;#pragma omp section%&gt; or %&lt;}%&gt;&quot;);</span>
<span class="lineNum">   16356 </span>            :           error_suppress = true;
<span class="lineNum">   16357 </span><span class="lineCov">         44 :         }</span>
<span class="lineNum">   16358 </span><span class="lineCov">         44 : </span>
<span class="lineNum">   16359 </span><span class="lineCov">         44 :       substmt = c_parser_omp_structured_block (parser, NULL);</span>
<span class="lineNum">   16360 </span><span class="lineCov">         44 :       substmt = build1 (OMP_SECTION, void_type_node, substmt);</span>
<span class="lineNum">   16361 </span>            :       SET_EXPR_LOCATION (substmt, loc);
<span class="lineNum">   16362 </span>            :       add_stmt (substmt);
<span class="lineNum">   16363 </span><span class="lineCov">        221 :     }</span>
<span class="lineNum">   16364 </span>            :   c_parser_skip_until_found (parser, CPP_CLOSE_BRACE,
<span class="lineNum">   16365 </span><span class="lineCov">        221 :                              &quot;expected %&lt;#pragma omp section%&gt; or %&lt;}%&gt;&quot;);</span>
<span class="lineNum">   16366 </span>            : 
<span class="lineNum">   16367 </span><span class="lineCov">        131 :   substmt = pop_stmt_list (stmt);</span>
<span class="lineNum">   16368 </span>            : 
<span class="lineNum">   16369 </span>            :   stmt = make_node (OMP_SECTIONS);
<span class="lineNum">   16370 </span><span class="lineCov">        131 :   SET_EXPR_LOCATION (stmt, sections_loc);</span>
<span class="lineNum">   16371 </span><span class="lineCov">        131 :   TREE_TYPE (stmt) = void_type_node;</span>
<span class="lineNum">   16372 </span>            :   OMP_SECTIONS_BODY (stmt) = substmt;
<span class="lineNum">   16373 </span><span class="lineCov">        125 : </span>
<span class="lineNum">   16374 </span><span class="lineCov">        125 :   return add_stmt (stmt);</span>
<span class="lineNum">   16375 </span><span class="lineCov">        125 : }</span>
<span class="lineNum">   16376 </span>            : 
<span class="lineNum">   16377 </span><span class="lineCov">          6 : /* OpenMP 2.5:</span>
<span class="lineNum">   16378 </span>            :    # pragma omp sections sections-clause[optseq] newline
<span class="lineNum">   16379 </span><span class="lineCov">          4 :      sections-scope</span>
<span class="lineNum">   16380 </span><span class="lineCov">          4 : </span>
<span class="lineNum">   16381 </span>            :    LOC is the location of the #pragma token.
<span class="lineNum">   16382 </span>            : */
<span class="lineNum">   16383 </span><span class="lineCov">        131 : </span>
<span class="lineNum">   16384 </span><span class="lineCov">        131 : #define OMP_SECTIONS_CLAUSE_MASK                                \</span>
<span class="lineNum">   16385 </span><span class="lineCov">        131 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \</span>
<span class="lineNum">   16386 </span><span class="lineCov">        131 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \</span>
<span class="lineNum">   16387 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LASTPRIVATE)    \
<span class="lineNum">   16388 </span><span class="lineCov">         90 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_REDUCTION)      \</span>
<span class="lineNum">   16389 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT))
<a name="16390"><span class="lineNum">   16390 </span>            : </a>
<span class="lineNum">   16391 </span><span class="lineCov">         90 : static tree</span>
<span class="lineNum">   16392 </span>            : c_parser_omp_sections (location_t loc, c_parser *parser,
<span class="lineNum">   16393 </span><span class="lineCov">         90 :                        char *p_name, omp_clause_mask mask, tree *cclauses)</span>
<span class="lineNum">   16394 </span><span class="lineCov">         90 : {</span>
<span class="lineNum">   16395 </span><span class="lineCov">         90 :   tree block, clauses, ret;</span>
<span class="lineNum">   16396 </span><span class="lineCov">         90 : </span>
<span class="lineNum">   16397 </span>            :   strcat (p_name, &quot; sections&quot;);
<span class="lineNum">   16398 </span><span class="lineCov">         90 :   mask |= OMP_SECTIONS_CLAUSE_MASK;</span>
<span class="lineNum">   16399 </span>            :   if (cclauses)
<span class="lineNum">   16400 </span>            :     mask &amp;= ~(OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT);
<span class="lineNum">   16401 </span>            : 
<span class="lineNum">   16402 </span>            :   clauses = c_parser_omp_all_clauses (parser, mask, p_name, cclauses == NULL);
<span class="lineNum">   16403 </span>            :   if (cclauses)
<span class="lineNum">   16404 </span>            :     {
<span class="lineNum">   16405 </span>            :       omp_split_clauses (loc, OMP_SECTIONS, mask, clauses, cclauses);
<span class="lineNum">   16406 </span>            :       clauses = cclauses[C_OMP_CLAUSE_SPLIT_SECTIONS];
<span class="lineNum">   16407 </span>            :     }
<span class="lineNum">   16408 </span>            : 
<span class="lineNum">   16409 </span>            :   block = c_begin_compound_stmt (true);
<span class="lineNum">   16410 </span>            :   ret = c_parser_omp_sections_scope (loc, parser);
<span class="lineNum">   16411 </span>            :   if (ret)
<span class="lineNum">   16412 </span>            :     OMP_SECTIONS_CLAUSES (ret) = clauses;
<span class="lineNum">   16413 </span>            :   block = c_end_compound_stmt (loc, block, true);
<span class="lineNum">   16414 </span>            :   add_stmt (block);
<span class="lineNum">   16415 </span>            : 
<span class="lineNum">   16416 </span><span class="lineCov">         92 :   return ret;</span>
<span class="lineNum">   16417 </span>            : }
<span class="lineNum">   16418 </span>            : 
<span class="lineNum">   16419 </span><span class="lineCov">         92 : /* OpenMP 2.5:</span>
<span class="lineNum">   16420 </span>            :    # pragma omp parallel parallel-clause[optseq] new-line
<span class="lineNum">   16421 </span><span class="lineCov">         92 :      structured-block</span>
<span class="lineNum">   16422 </span><span class="lineCov">        920 :    # pragma omp parallel for parallel-for-clause[optseq] new-line</span>
<span class="lineNum">   16423 </span><span class="lineCov">         92 :      structured-block</span>
<span class="lineNum">   16424 </span><span class="lineCov">         64 :    # pragma omp parallel sections parallel-sections-clause[optseq] new-line</span>
<span class="lineNum">   16425 </span>            :      structured-block
<span class="lineNum">   16426 </span><span class="lineCov">         92 : </span>
<span class="lineNum">   16427 </span><span class="lineCov">         92 :    OpenMP 4.0:</span>
<span class="lineNum">   16428 </span>            :    # pragma omp parallel for simd parallel-for-simd-clause[optseq] new-line
<span class="lineNum">   16429 </span><span class="lineCov">         16 :      structured-block</span>
<span class="lineNum">   16430 </span><span class="lineCov">         16 : </span>
<span class="lineNum">   16431 </span>            :    LOC is the location of the #pragma token.
<span class="lineNum">   16432 </span>            : */
<span class="lineNum">   16433 </span><span class="lineCov">         92 : </span>
<span class="lineNum">   16434 </span><span class="lineCov">         92 : #define OMP_PARALLEL_CLAUSE_MASK                                \</span>
<span class="lineNum">   16435 </span><span class="lineCov">         92 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \</span>
<span class="lineNum">   16436 </span><span class="lineCov">         90 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \</span>
<span class="lineNum">   16437 </span><span class="lineCov">         92 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \</span>
<span class="lineNum">   16438 </span><span class="lineCov">         92 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEFAULT)        \</span>
<span class="lineNum">   16439 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SHARED) \
<span class="lineNum">   16440 </span><span class="lineCov">         92 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_COPYIN) \</span>
<span class="lineNum">   16441 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_REDUCTION)      \
<span class="lineNum">   16442 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NUM_THREADS)    \
<span class="lineNum">   16443 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PROC_BIND))
<a name="16444"><span class="lineNum">   16444 </span>            : </a>
<span class="lineNum">   16445 </span>            : static tree
<span class="lineNum">   16446 </span>            : c_parser_omp_parallel (location_t loc, c_parser *parser,
<span class="lineNum">   16447 </span>            :                        char *p_name, omp_clause_mask mask, tree *cclauses,
<span class="lineNum">   16448 </span>            :                        bool *if_p)
<span class="lineNum">   16449 </span>            : {
<span class="lineNum">   16450 </span>            :   tree stmt, clauses, block;
<span class="lineNum">   16451 </span>            : 
<span class="lineNum">   16452 </span>            :   strcat (p_name, &quot; parallel&quot;);
<span class="lineNum">   16453 </span>            :   mask |= OMP_PARALLEL_CLAUSE_MASK;
<span class="lineNum">   16454 </span>            :   /* #pragma omp target parallel{, for, for simd} disallow copyin clause.  */
<span class="lineNum">   16455 </span>            :   if ((mask &amp; (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MAP)) != 0
<span class="lineNum">   16456 </span>            :       &amp;&amp; (mask &amp; (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) == 0)
<span class="lineNum">   16457 </span>            :     mask &amp;= ~(OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_COPYIN);
<span class="lineNum">   16458 </span>            : 
<span class="lineNum">   16459 </span>            :   if (c_parser_next_token_is_keyword (parser, RID_FOR))
<span class="lineNum">   16460 </span>            :     {
<span class="lineNum">   16461 </span>            :       tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];
<span class="lineNum">   16462 </span>            :       if (cclauses == NULL)
<span class="lineNum">   16463 </span>            :         cclauses = cclauses_buf;
<span class="lineNum">   16464 </span>            : 
<span class="lineNum">   16465 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   16466 </span>            :       if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   16467 </span>            :         return c_parser_omp_for (loc, parser, p_name, mask, cclauses, if_p);
<span class="lineNum">   16468 </span>            :       block = c_begin_omp_parallel ();
<span class="lineNum">   16469 </span>            :       tree ret = c_parser_omp_for (loc, parser, p_name, mask, cclauses, if_p);
<span class="lineNum">   16470 </span><span class="lineCov">       2352 :       stmt</span>
<span class="lineNum">   16471 </span>            :         = c_finish_omp_parallel (loc, cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL],
<span class="lineNum">   16472 </span>            :                                  block);
<span class="lineNum">   16473 </span>            :       if (ret == NULL_TREE)
<span class="lineNum">   16474 </span><span class="lineCov">       2352 :         return ret;</span>
<span class="lineNum">   16475 </span>            :       OMP_PARALLEL_COMBINED (stmt) = 1;
<span class="lineNum">   16476 </span><span class="lineCov">       2352 :       return stmt;</span>
<span class="lineNum">   16477 </span><span class="lineCov">      42336 :     }</span>
<span class="lineNum">   16478 </span>            :   /* When combined with distribute, parallel has to be followed by for.
<span class="lineNum">   16479 </span><span class="lineCov">       7056 :      #pragma omp target parallel is allowed though.  */</span>
<span class="lineNum">   16480 </span><span class="lineCov">       1458 :   else if (cclauses</span>
<span class="lineNum">   16481 </span><span class="lineCov">        640 :            &amp;&amp; (mask &amp; (OMP_CLAUSE_MASK_1</span>
<span class="lineNum">   16482 </span>            :                        &lt;&lt; PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)
<span class="lineNum">   16483 </span><span class="lineCov">       2352 :     {</span>
<span class="lineNum">   16484 </span>            :       error_at (loc, &quot;expected %&lt;for%&gt; after %qs&quot;, p_name);
<span class="lineNum">   16485 </span><span class="lineCov">       1747 :       c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   16486 </span><span class="lineCov">       1747 :       return NULL_TREE;</span>
<span class="lineNum">   16487 </span><span class="lineCov">        611 :     }</span>
<span class="lineNum">   16488 </span>            :   else if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   16489 </span><span class="lineCov">       1747 :     {</span>
<span class="lineNum">   16490 </span><span class="lineCov">       1747 :       c_parser_skip_to_pragma_eol (parser, false);</span>
<span class="lineNum">   16491 </span><span class="lineCov">          9 :       return NULL_TREE;</span>
<span class="lineNum">   16492 </span><span class="lineCov">       1738 :     }</span>
<span class="lineNum">   16493 </span><span class="lineCov">       1738 :   else if (cclauses == NULL &amp;&amp; c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">   16494 </span><span class="lineCov">       1738 :     {</span>
<span class="lineNum">   16495 </span><span class="lineCov">       1738 :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">   16496 </span>            :       if (strcmp (p, &quot;sections&quot;) == 0)
<span class="lineNum">   16497 </span><span class="lineCov">       1738 :         {</span>
<span class="lineNum">   16498 </span>            :           tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];
<span class="lineNum">   16499 </span><span class="lineCov">       1725 :           if (cclauses == NULL)</span>
<span class="lineNum">   16500 </span><span class="lineCov">       1725 :             cclauses = cclauses_buf;</span>
<span class="lineNum">   16501 </span>            : 
<span class="lineNum">   16502 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   16503 </span>            :           block = c_begin_omp_parallel ();
<span class="lineNum">   16504 </span><span class="lineCov">        605 :           c_parser_omp_sections (loc, parser, p_name, mask, cclauses);</span>
<span class="lineNum">   16505 </span><span class="lineCov">        605 :           stmt = c_finish_omp_parallel (loc,</span>
<span class="lineNum">   16506 </span><span class="lineCov">         12 :                                         cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL],</span>
<span class="lineNum">   16507 </span>            :                                         block);
<span class="lineNum">   16508 </span><span class="lineNoCov">          0 :           OMP_PARALLEL_COMBINED (stmt) = 1;</span>
<span class="lineNum">   16509 </span><span class="lineNoCov">          0 :           return stmt;</span>
<span class="lineNum">   16510 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   16511 </span>            :     }
<span class="lineNum">   16512 </span><span class="lineCov">        605 : </span>
<span class="lineNum">   16513 </span>            :   clauses = c_parser_omp_all_clauses (parser, mask, p_name, cclauses == NULL);
<span class="lineNum">   16514 </span><span class="lineNoCov">          0 :   if (cclauses)</span>
<span class="lineNum">   16515 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   16516 </span>            :       omp_split_clauses (loc, OMP_PARALLEL, mask, clauses, cclauses);
<span class="lineNum">   16517 </span><span class="lineCov">        605 :       clauses = cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL];</span>
<span class="lineNum">   16518 </span>            :     }
<span class="lineNum">   16519 </span><span class="lineCov">        354 : </span>
<span class="lineNum">   16520 </span><span class="lineCov">        354 :   block = c_begin_omp_parallel ();</span>
<span class="lineNum">   16521 </span>            :   c_parser_statement (parser, if_p);
<span class="lineNum">   16522 </span><span class="lineCov">         16 :   stmt = c_finish_omp_parallel (loc, clauses, block);</span>
<span class="lineNum">   16523 </span><span class="lineCov">         16 : </span>
<span class="lineNum">   16524 </span><span class="lineCov">         16 :   return stmt;</span>
<span class="lineNum">   16525 </span>            : }
<span class="lineNum">   16526 </span><span class="lineCov">         16 : </span>
<span class="lineNum">   16527 </span><span class="lineCov">         16 : /* OpenMP 2.5:</span>
<span class="lineNum">   16528 </span><span class="lineCov">         16 :    # pragma omp single single-clause[optseq] new-line</span>
<span class="lineNum">   16529 </span><span class="lineCov">         16 :      structured-block</span>
<span class="lineNum">   16530 </span>            : 
<span class="lineNum">   16531 </span>            :    LOC is the location of the #pragma.
<span class="lineNum">   16532 </span><span class="lineCov">         16 : */</span>
<span class="lineNum">   16533 </span><span class="lineCov">         16 : </span>
<span class="lineNum">   16534 </span>            : #define OMP_SINGLE_CLAUSE_MASK                                  \
<span class="lineNum">   16535 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \
<span class="lineNum">   16536 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \
<span class="lineNum">   16537 </span><span class="lineCov">        589 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_COPYPRIVATE)    \</span>
<span class="lineNum">   16538 </span><span class="lineCov">        589 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT))</span>
<a name="16539"><span class="lineNum">   16539 </span>            : </a>
<span class="lineNum">   16540 </span><span class="lineCov">          4 : static tree</span>
<span class="lineNum">   16541 </span><span class="lineCov">          4 : c_parser_omp_single (location_t loc, c_parser *parser, bool *if_p)</span>
<span class="lineNum">   16542 </span>            : {
<span class="lineNum">   16543 </span>            :   tree stmt = make_node (OMP_SINGLE);
<span class="lineNum">   16544 </span><span class="lineCov">        589 :   SET_EXPR_LOCATION (stmt, loc);</span>
<span class="lineNum">   16545 </span><span class="lineCov">        589 :   TREE_TYPE (stmt) = void_type_node;</span>
<span class="lineNum">   16546 </span><span class="lineCov">        589 : </span>
<span class="lineNum">   16547 </span>            :   OMP_SINGLE_CLAUSES (stmt)
<span class="lineNum">   16548 </span><span class="lineCov">        589 :     = c_parser_omp_all_clauses (parser, OMP_SINGLE_CLAUSE_MASK,</span>
<span class="lineNum">   16549 </span>            :                                 &quot;#pragma omp single&quot;);
<span class="lineNum">   16550 </span>            :   OMP_SINGLE_BODY (stmt) = c_parser_omp_structured_block (parser, if_p);
<span class="lineNum">   16551 </span>            : 
<span class="lineNum">   16552 </span>            :   return add_stmt (stmt);
<span class="lineNum">   16553 </span>            : }
<span class="lineNum">   16554 </span>            : 
<span class="lineNum">   16555 </span>            : /* OpenMP 3.0:
<span class="lineNum">   16556 </span>            :    # pragma omp task task-clause[optseq] new-line
<span class="lineNum">   16557 </span>            : 
<span class="lineNum">   16558 </span>            :    LOC is the location of the #pragma.
<span class="lineNum">   16559 </span>            : */
<span class="lineNum">   16560 </span>            : 
<span class="lineNum">   16561 </span>            : #define OMP_TASK_CLAUSE_MASK                                    \
<span class="lineNum">   16562 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \
<span class="lineNum">   16563 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_UNTIED) \
<span class="lineNum">   16564 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEFAULT)        \
<span class="lineNum">   16565 </span><span class="lineCov">        150 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \</span>
<span class="lineNum">   16566 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \
<span class="lineNum">   16567 </span><span class="lineCov">        150 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SHARED) \</span>
<span class="lineNum">   16568 </span><span class="lineCov">        150 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FINAL)  \</span>
<span class="lineNum">   16569 </span><span class="lineCov">        150 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MERGEABLE)      \</span>
<span class="lineNum">   16570 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEPEND) \
<span class="lineNum">   16571 </span><span class="lineCov">        150 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIORITY))</span>
<a name="16572"><span class="lineNum">   16572 </span><span class="lineCov">       1350 : </span></a>
<span class="lineNum">   16573 </span>            : static tree
<span class="lineNum">   16574 </span><span class="lineCov">        150 : c_parser_omp_task (location_t loc, c_parser *parser, bool *if_p)</span>
<span class="lineNum">   16575 </span>            : {
<span class="lineNum">   16576 </span><span class="lineCov">        150 :   tree clauses, block;</span>
<span class="lineNum">   16577 </span>            : 
<span class="lineNum">   16578 </span>            :   clauses = c_parser_omp_all_clauses (parser, OMP_TASK_CLAUSE_MASK,
<span class="lineNum">   16579 </span>            :                                       &quot;#pragma omp task&quot;);
<span class="lineNum">   16580 </span>            : 
<span class="lineNum">   16581 </span>            :   block = c_begin_omp_task ();
<span class="lineNum">   16582 </span>            :   c_parser_statement (parser, if_p);
<span class="lineNum">   16583 </span>            :   return c_finish_omp_task (loc, clauses, block);
<span class="lineNum">   16584 </span>            : }
<span class="lineNum">   16585 </span>            : 
<span class="lineNum">   16586 </span>            : /* OpenMP 3.0:
<span class="lineNum">   16587 </span>            :    # pragma omp taskwait new-line
<span class="lineNum">   16588 </span>            : */
<a name="16589"><span class="lineNum">   16589 </span>            : </a>
<span class="lineNum">   16590 </span>            : static void
<span class="lineNum">   16591 </span>            : c_parser_omp_taskwait (c_parser *parser)
<span class="lineNum">   16592 </span>            : {
<span class="lineNum">   16593 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   16594 </span>            :   c_parser_consume_pragma (parser);
<span class="lineNum">   16595 </span>            :   c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   16596 </span>            : 
<span class="lineNum">   16597 </span>            :   c_finish_omp_taskwait (loc);
<span class="lineNum">   16598 </span><span class="lineCov">        321 : }</span>
<span class="lineNum">   16599 </span>            : 
<span class="lineNum">   16600 </span><span class="lineCov">        321 : /* OpenMP 3.1:</span>
<span class="lineNum">   16601 </span>            :    # pragma omp taskyield new-line
<span class="lineNum">   16602 </span><span class="lineCov">       6420 : */</span>
<a name="16603"><span class="lineNum">   16603 </span>            : </a>
<span class="lineNum">   16604 </span>            : static void
<span class="lineNum">   16605 </span><span class="lineCov">        321 : c_parser_omp_taskyield (c_parser *parser)</span>
<span class="lineNum">   16606 </span><span class="lineCov">        321 : {</span>
<span class="lineNum">   16607 </span><span class="lineCov">        321 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   16608 </span>            :   c_parser_consume_pragma (parser);
<span class="lineNum">   16609 </span>            :   c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   16610 </span>            : 
<span class="lineNum">   16611 </span>            :   c_finish_omp_taskyield (loc);
<span class="lineNum">   16612 </span>            : }
<span class="lineNum">   16613 </span>            : 
<span class="lineNum">   16614 </span>            : /* OpenMP 4.0:
<span class="lineNum">   16615 </span><span class="lineCov">         32 :    # pragma omp taskgroup new-line</span>
<span class="lineNum">   16616 </span>            : */
<a name="16617"><span class="lineNum">   16617 </span><span class="lineCov">         32 : </span></a>
<span class="lineNum">   16618 </span><span class="lineCov">         32 : static tree</span>
<span class="lineNum">   16619 </span><span class="lineCov">         32 : c_parser_omp_taskgroup (c_parser *parser, bool *if_p)</span>
<span class="lineNum">   16620 </span>            : {
<span class="lineNum">   16621 </span><span class="lineCov">         32 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   16622 </span><span class="lineCov">         32 :   c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   16623 </span>            :   return c_finish_omp_taskgroup (loc, c_parser_omp_structured_block (parser,
<span class="lineNum">   16624 </span>            :                                                                      if_p));
<span class="lineNum">   16625 </span>            : }
<span class="lineNum">   16626 </span>            : 
<span class="lineNum">   16627 </span>            : /* OpenMP 4.0:
<span class="lineNum">   16628 </span>            :    # pragma omp cancel cancel-clause[optseq] new-line
<span class="lineNum">   16629 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   16630 </span>            :    LOC is the location of the #pragma.
<span class="lineNum">   16631 </span><span class="lineCov">          1 : */</span>
<span class="lineNum">   16632 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   16633 </span><span class="lineCov">          1 : #define OMP_CANCEL_CLAUSE_MASK                                  \</span>
<span class="lineNum">   16634 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PARALLEL)       \
<span class="lineNum">   16635 </span><span class="lineCov">          1 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FOR)            \</span>
<span class="lineNum">   16636 </span><span class="lineCov">          1 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SECTIONS)       \</span>
<span class="lineNum">   16637 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_TASKGROUP)      \
<span class="lineNum">   16638 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF))
<a name="16639"><span class="lineNum">   16639 </span>            : </a>
<span class="lineNum">   16640 </span>            : static void
<span class="lineNum">   16641 </span>            : c_parser_omp_cancel (c_parser *parser)
<span class="lineNum">   16642 </span>            : {
<span class="lineNum">   16643 </span><span class="lineCov">         35 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   16644 </span>            : 
<span class="lineNum">   16645 </span><span class="lineCov">         35 :   c_parser_consume_pragma (parser);</span>
<span class="lineNum">   16646 </span><span class="lineCov">         35 :   tree clauses = c_parser_omp_all_clauses (parser, OMP_CANCEL_CLAUSE_MASK,</span>
<span class="lineNum">   16647 </span><span class="lineCov">         35 :                                            &quot;#pragma omp cancel&quot;);</span>
<span class="lineNum">   16648 </span><span class="lineCov">         35 : </span>
<span class="lineNum">   16649 </span>            :   c_finish_omp_cancel (loc, clauses);
<span class="lineNum">   16650 </span>            : }
<span class="lineNum">   16651 </span>            : 
<span class="lineNum">   16652 </span>            : /* OpenMP 4.0:
<span class="lineNum">   16653 </span>            :    # pragma omp cancellation point cancelpt-clause[optseq] new-line
<span class="lineNum">   16654 </span>            : 
<span class="lineNum">   16655 </span>            :    LOC is the location of the #pragma.
<span class="lineNum">   16656 </span>            : */
<span class="lineNum">   16657 </span>            : 
<span class="lineNum">   16658 </span>            : #define OMP_CANCELLATION_POINT_CLAUSE_MASK                      \
<span class="lineNum">   16659 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PARALLEL)       \
<span class="lineNum">   16660 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FOR)            \
<span class="lineNum">   16661 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SECTIONS)       \
<span class="lineNum">   16662 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_TASKGROUP))
<a name="16663"><span class="lineNum">   16663 </span>            : </a>
<span class="lineNum">   16664 </span>            : static void
<span class="lineNum">   16665 </span><span class="lineCov">        157 : c_parser_omp_cancellation_point (c_parser *parser, enum pragma_context context)</span>
<span class="lineNum">   16666 </span>            : {
<span class="lineNum">   16667 </span><span class="lineCov">        157 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   16668 </span>            :   tree clauses;
<span class="lineNum">   16669 </span><span class="lineCov">        157 :   bool point_seen = false;</span>
<span class="lineNum">   16670 </span><span class="lineCov">       1570 : </span>
<span class="lineNum">   16671 </span>            :   c_parser_consume_pragma (parser);
<span class="lineNum">   16672 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   16673 </span><span class="lineCov">        157 :     {</span>
<span class="lineNum">   16674 </span><span class="lineCov">        157 :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">   16675 </span>            :       if (strcmp (p, &quot;point&quot;) == 0)
<span class="lineNum">   16676 </span>            :         {
<span class="lineNum">   16677 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   16678 </span>            :           point_seen = true;
<span class="lineNum">   16679 </span>            :         }
<span class="lineNum">   16680 </span>            :     }
<span class="lineNum">   16681 </span>            :   if (!point_seen)
<span class="lineNum">   16682 </span>            :     {
<span class="lineNum">   16683 </span>            :       c_parser_error (parser, &quot;expected %&lt;point%&gt;&quot;);
<span class="lineNum">   16684 </span>            :       c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   16685 </span>            :       return;
<span class="lineNum">   16686 </span>            :     }
<span class="lineNum">   16687 </span>            : 
<span class="lineNum">   16688 </span>            :   if (context != pragma_compound)
<span class="lineNum">   16689 </span><span class="lineCov">        145 :     {</span>
<span class="lineNum">   16690 </span>            :       if (context == pragma_stmt)
<span class="lineNum">   16691 </span><span class="lineCov">        145 :         error_at (loc,</span>
<span class="lineNum">   16692 </span><span class="lineCov">        145 :                   &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,</span>
<span class="lineNum">   16693 </span><span class="lineCov">        145 :                   &quot;omp cancellation point&quot;);</span>
<span class="lineNum">   16694 </span>            :       else
<span class="lineNum">   16695 </span><span class="lineCov">        145 :         c_parser_error (parser, &quot;expected declaration specifiers&quot;);</span>
<span class="lineNum">   16696 </span><span class="lineCov">        145 :       c_parser_skip_to_pragma_eol (parser, false);</span>
<span class="lineNum">   16697 </span>            :       return;
<span class="lineNum">   16698 </span><span class="lineCov">        145 :     }</span>
<span class="lineNum">   16699 </span><span class="lineCov">        145 : </span>
<span class="lineNum">   16700 </span>            :   clauses
<span class="lineNum">   16701 </span><span class="lineCov">        143 :     = c_parser_omp_all_clauses (parser, OMP_CANCELLATION_POINT_CLAUSE_MASK,</span>
<span class="lineNum">   16702 </span><span class="lineCov">        143 :                                 &quot;#pragma omp cancellation point&quot;);</span>
<span class="lineNum">   16703 </span>            : 
<span class="lineNum">   16704 </span>            :   c_finish_omp_cancellation_point (loc, clauses);
<span class="lineNum">   16705 </span><span class="lineCov">        143 : }</span>
<span class="lineNum">   16706 </span>            : 
<span class="lineNum">   16707 </span><span class="lineCov">          2 : /* OpenMP 4.0:</span>
<span class="lineNum">   16708 </span><span class="lineCov">          2 :    #pragma omp distribute distribute-clause[optseq] new-line</span>
<span class="lineNum">   16709 </span><span class="lineCov">          2 :      for-loop  */</span>
<span class="lineNum">   16710 </span>            : 
<span class="lineNum">   16711 </span>            : #define OMP_DISTRIBUTE_CLAUSE_MASK                              \
<span class="lineNum">   16712 </span><span class="lineCov">        143 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \</span>
<span class="lineNum">   16713 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \
<span class="lineNum">   16714 </span><span class="lineCov">         10 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LASTPRIVATE)    \</span>
<span class="lineNum">   16715 </span><span class="lineCov">          9 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)\</span>
<span class="lineNum">   16716 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_COLLAPSE))
<a name="16717"><span class="lineNum">   16717 </span>            : </a>
<span class="lineNum">   16718 </span>            : static tree
<span class="lineNum">   16719 </span><span class="lineCov">          1 : c_parser_omp_distribute (location_t loc, c_parser *parser,</span>
<span class="lineNum">   16720 </span><span class="lineCov">         10 :                          char *p_name, omp_clause_mask mask, tree *cclauses,</span>
<span class="lineNum">   16721 </span><span class="lineCov">         10 :                          bool *if_p)</span>
<span class="lineNum">   16722 </span>            : {
<span class="lineNum">   16723 </span>            :   tree clauses, block, ret;
<span class="lineNum">   16724 </span><span class="lineCov">        133 : </span>
<span class="lineNum">   16725 </span><span class="lineCov">       1064 :   strcat (p_name, &quot; distribute&quot;);</span>
<span class="lineNum">   16726 </span>            :   mask |= OMP_DISTRIBUTE_CLAUSE_MASK;
<span class="lineNum">   16727 </span>            : 
<span class="lineNum">   16728 </span><span class="lineCov">        133 :   if (c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">   16729 </span>            :     {
<span class="lineNum">   16730 </span>            :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   16731 </span>            :       bool simd = false;
<span class="lineNum">   16732 </span>            :       bool parallel = false;
<span class="lineNum">   16733 </span>            : 
<span class="lineNum">   16734 </span>            :       if (strcmp (p, &quot;simd&quot;) == 0)
<span class="lineNum">   16735 </span>            :         simd = true;
<span class="lineNum">   16736 </span>            :       else
<span class="lineNum">   16737 </span>            :         parallel = strcmp (p, &quot;parallel&quot;) == 0;
<span class="lineNum">   16738 </span>            :       if (parallel || simd)
<span class="lineNum">   16739 </span>            :         {
<span class="lineNum">   16740 </span>            :           tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];
<span class="lineNum">   16741 </span>            :           if (cclauses == NULL)
<span class="lineNum">   16742 </span>            :             cclauses = cclauses_buf;
<span class="lineNum">   16743 </span><span class="lineCov">       1231 :           c_parser_consume_token (parser);</span>
<span class="lineNum">   16744 </span>            :           if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   16745 </span>            :             {
<span class="lineNum">   16746 </span>            :               if (simd)
<span class="lineNum">   16747 </span><span class="lineCov">       1231 :                 return c_parser_omp_simd (loc, parser, p_name, mask, cclauses,</span>
<span class="lineNum">   16748 </span>            :                                           if_p);
<span class="lineNum">   16749 </span><span class="lineCov">       1231 :               else</span>
<span class="lineNum">   16750 </span><span class="lineCov">      12310 :                 return c_parser_omp_parallel (loc, parser, p_name, mask,</span>
<span class="lineNum">   16751 </span>            :                                               cclauses, if_p);
<span class="lineNum">   16752 </span><span class="lineCov">       1231 :             }</span>
<span class="lineNum">   16753 </span>            :           block = c_begin_compound_stmt (true);
<span class="lineNum">   16754 </span><span class="lineCov">       1192 :           if (simd)</span>
<span class="lineNum">   16755 </span><span class="lineCov">       1192 :             ret = c_parser_omp_simd (loc, parser, p_name, mask, cclauses,</span>
<span class="lineNum">   16756 </span><span class="lineCov">       1192 :                                      if_p);</span>
<span class="lineNum">   16757 </span>            :           else
<span class="lineNum">   16758 </span><span class="lineCov">       1192 :             ret = c_parser_omp_parallel (loc, parser, p_name, mask, cclauses,</span>
<span class="lineNum">   16759 </span>            :                                          if_p);
<span class="lineNum">   16760 </span>            :           block = c_end_compound_stmt (loc, block, true);
<span class="lineNum">   16761 </span><span class="lineCov">       1066 :           if (ret == NULL)</span>
<span class="lineNum">   16762 </span><span class="lineCov">       1192 :             return ret;</span>
<span class="lineNum">   16763 </span>            :           ret = make_node (OMP_DISTRIBUTE);
<span class="lineNum">   16764 </span><span class="lineCov">       1106 :           TREE_TYPE (ret) = void_type_node;</span>
<span class="lineNum">   16765 </span><span class="lineCov">       1106 :           OMP_FOR_BODY (ret) = block;</span>
<span class="lineNum">   16766 </span><span class="lineCov">        379 :           OMP_FOR_CLAUSES (ret) = cclauses[C_OMP_CLAUSE_SPLIT_DISTRIBUTE];</span>
<span class="lineNum">   16767 </span><span class="lineCov">       1106 :           SET_EXPR_LOCATION (ret, loc);</span>
<span class="lineNum">   16768 </span><span class="lineCov">       1106 :           add_stmt (ret);</span>
<span class="lineNum">   16769 </span>            :           return ret;
<span class="lineNum">   16770 </span><span class="lineCov">          6 :         }</span>
<span class="lineNum">   16771 </span><span class="lineCov">          3 :     }</span>
<span class="lineNum">   16772 </span><span class="lineCov">          3 :   if (!flag_openmp)  /* flag_openmp_simd  */</span>
<span class="lineNum">   16773 </span>            :     {
<span class="lineNum">   16774 </span><span class="lineCov">          3 :       c_parser_skip_to_pragma_eol (parser, false);</span>
<span class="lineNum">   16775 </span><span class="lineCov">          3 :       return NULL_TREE;</span>
<span class="lineNum">   16776 </span>            :     }
<span class="lineNum">   16777 </span><span class="lineCov">       1100 : </span>
<span class="lineNum">   16778 </span><span class="lineCov">       1100 :   clauses = c_parser_omp_all_clauses (parser, mask, p_name, cclauses == NULL);</span>
<span class="lineNum">   16779 </span><span class="lineCov">        123 :   if (cclauses)</span>
<span class="lineNum">   16780 </span>            :     {
<span class="lineNum">   16781 </span>            :       omp_split_clauses (loc, OMP_DISTRIBUTE, mask, clauses, cclauses);
<span class="lineNum">   16782 </span><span class="lineCov">        977 :       clauses = cclauses[C_OMP_CLAUSE_SPLIT_DISTRIBUTE];</span>
<span class="lineNum">   16783 </span>            :     }
<span class="lineNum">   16784 </span><span class="lineCov">       1100 : </span>
<span class="lineNum">   16785 </span><span class="lineCov">       1100 :   block = c_begin_compound_stmt (true);</span>
<span class="lineNum">   16786 </span>            :   ret = c_parser_omp_for_loop (loc, parser, OMP_DISTRIBUTE, clauses, NULL,
<span class="lineNum">   16787 </span><span class="lineCov">       1095 :                                if_p);</span>
<span class="lineNum">   16788 </span><span class="lineCov">       1095 :   block = c_end_compound_stmt (loc, block, true);</span>
<span class="lineNum">   16789 </span><span class="lineCov">       2190 :   add_stmt (block);</span>
<span class="lineNum">   16790 </span><span class="lineCov">       2190 : </span>
<span class="lineNum">   16791 </span><span class="lineCov">       1095 :   return ret;</span>
<span class="lineNum">   16792 </span><span class="lineCov">       1095 : }</span>
<span class="lineNum">   16793 </span><span class="lineCov">       1095 : </span>
<span class="lineNum">   16794 </span>            : /* OpenMP 4.0:
<span class="lineNum">   16795 </span>            :    # pragma omp teams teams-clause[optseq] new-line
<span class="lineNum">   16796 </span><span class="lineCov">        125 :      structured-block  */</span>
<span class="lineNum">   16797 </span>            : 
<span class="lineNum">   16798 </span><span class="lineNoCov">          0 : #define OMP_TEAMS_CLAUSE_MASK                                   \</span>
<span class="lineNum">   16799 </span><span class="lineNoCov">          0 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \</span>
<span class="lineNum">   16800 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \
<span class="lineNum">   16801 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SHARED) \
<span class="lineNum">   16802 </span><span class="lineCov">        125 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_REDUCTION)      \</span>
<span class="lineNum">   16803 </span><span class="lineCov">        125 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NUM_TEAMS)      \</span>
<span class="lineNum">   16804 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_THREAD_LIMIT)   \
<span class="lineNum">   16805 </span><span class="lineCov">         71 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEFAULT))</span>
<a name="16806"><span class="lineNum">   16806 </span><span class="lineCov">         71 : </span></a>
<span class="lineNum">   16807 </span>            : static tree
<span class="lineNum">   16808 </span>            : c_parser_omp_teams (location_t loc, c_parser *parser,
<span class="lineNum">   16809 </span><span class="lineCov">        125 :                     char *p_name, omp_clause_mask mask, tree *cclauses,</span>
<span class="lineNum">   16810 </span><span class="lineCov">        125 :                     bool *if_p)</span>
<span class="lineNum">   16811 </span>            : {
<span class="lineNum">   16812 </span><span class="lineCov">        125 :   tree clauses, block, ret;</span>
<span class="lineNum">   16813 </span><span class="lineCov">        125 : </span>
<span class="lineNum">   16814 </span>            :   strcat (p_name, &quot; teams&quot;);
<span class="lineNum">   16815 </span><span class="lineCov">        125 :   mask |= OMP_TEAMS_CLAUSE_MASK;</span>
<span class="lineNum">   16816 </span>            : 
<span class="lineNum">   16817 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   16818 </span>            :     {
<span class="lineNum">   16819 </span>            :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   16820 </span>            :       if (strcmp (p, &quot;distribute&quot;) == 0)
<span class="lineNum">   16821 </span>            :         {
<span class="lineNum">   16822 </span>            :           tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];
<span class="lineNum">   16823 </span>            :           if (cclauses == NULL)
<span class="lineNum">   16824 </span>            :             cclauses = cclauses_buf;
<span class="lineNum">   16825 </span>            : 
<span class="lineNum">   16826 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   16827 </span>            :           if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   16828 </span>            :             return c_parser_omp_distribute (loc, parser, p_name, mask,
<span class="lineNum">   16829 </span>            :                                             cclauses, if_p);
<span class="lineNum">   16830 </span>            :           block = c_begin_compound_stmt (true);
<span class="lineNum">   16831 </span>            :           ret = c_parser_omp_distribute (loc, parser, p_name, mask, cclauses,
<span class="lineNum">   16832 </span><span class="lineCov">        891 :                                          if_p);</span>
<span class="lineNum">   16833 </span>            :           block = c_end_compound_stmt (loc, block, true);
<span class="lineNum">   16834 </span>            :           if (ret == NULL)
<span class="lineNum">   16835 </span>            :             return ret;
<span class="lineNum">   16836 </span><span class="lineCov">        891 :           clauses = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];</span>
<span class="lineNum">   16837 </span>            :           ret = make_node (OMP_TEAMS);
<span class="lineNum">   16838 </span><span class="lineCov">        891 :           TREE_TYPE (ret) = void_type_node;</span>
<span class="lineNum">   16839 </span><span class="lineCov">      12474 :           OMP_TEAMS_CLAUSES (ret) = clauses;</span>
<span class="lineNum">   16840 </span>            :           OMP_TEAMS_BODY (ret) = block;
<span class="lineNum">   16841 </span><span class="lineCov">        891 :           OMP_TEAMS_COMBINED (ret) = 1;</span>
<span class="lineNum">   16842 </span>            :           return add_stmt (ret);
<span class="lineNum">   16843 </span><span class="lineCov">        861 :         }</span>
<span class="lineNum">   16844 </span><span class="lineCov">        861 :     }</span>
<span class="lineNum">   16845 </span>            :   if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   16846 </span><span class="lineCov">        798 :     {</span>
<span class="lineNum">   16847 </span><span class="lineCov">        798 :       c_parser_skip_to_pragma_eol (parser, false);</span>
<span class="lineNum">   16848 </span><span class="lineCov">        399 :       return NULL_TREE;</span>
<span class="lineNum">   16849 </span>            :     }
<span class="lineNum">   16850 </span><span class="lineCov">        798 : </span>
<span class="lineNum">   16851 </span><span class="lineCov">        798 :   clauses = c_parser_omp_all_clauses (parser, mask, p_name, cclauses == NULL);</span>
<span class="lineNum">   16852 </span><span class="lineCov">          4 :   if (cclauses)</span>
<span class="lineNum">   16853 </span><span class="lineCov">          4 :     {</span>
<span class="lineNum">   16854 </span><span class="lineCov">        794 :       omp_split_clauses (loc, OMP_TEAMS, mask, clauses, cclauses);</span>
<span class="lineNum">   16855 </span><span class="lineCov">        794 :       clauses = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];</span>
<span class="lineNum">   16856 </span>            :     }
<span class="lineNum">   16857 </span><span class="lineCov">        794 : </span>
<span class="lineNum">   16858 </span><span class="lineCov">        794 :   tree stmt = make_node (OMP_TEAMS);</span>
<span class="lineNum">   16859 </span>            :   TREE_TYPE (stmt) = void_type_node;
<span class="lineNum">   16860 </span><span class="lineCov">        794 :   OMP_TEAMS_CLAUSES (stmt) = clauses;</span>
<span class="lineNum">   16861 </span><span class="lineCov">        794 :   OMP_TEAMS_BODY (stmt) = c_parser_omp_structured_block (parser, if_p);</span>
<span class="lineNum">   16862 </span><span class="lineCov">        794 : </span>
<span class="lineNum">   16863 </span><span class="lineCov">        794 :   return add_stmt (stmt);</span>
<span class="lineNum">   16864 </span><span class="lineCov">        794 : }</span>
<span class="lineNum">   16865 </span><span class="lineCov">        794 : </span>
<span class="lineNum">   16866 </span><span class="lineCov">        794 : /* OpenMP 4.0:</span>
<span class="lineNum">   16867 </span>            :    # pragma omp target data target-data-clause[optseq] new-line
<span class="lineNum">   16868 </span>            :      structured-block  */
<span class="lineNum">   16869 </span><span class="lineCov">         93 : </span>
<span class="lineNum">   16870 </span>            : #define OMP_TARGET_DATA_CLAUSE_MASK                             \
<span class="lineNum">   16871 </span><span class="lineCov">          1 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEVICE) \</span>
<span class="lineNum">   16872 </span><span class="lineCov">          1 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MAP)            \</span>
<span class="lineNum">   16873 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \
<span class="lineNum">   16874 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR))
<a name="16875"><span class="lineNum">   16875 </span><span class="lineCov">         92 : </span></a>
<span class="lineNum">   16876 </span><span class="lineCov">         92 : static tree</span>
<span class="lineNum">   16877 </span>            : c_parser_omp_target_data (location_t loc, c_parser *parser, bool *if_p)
<span class="lineNum">   16878 </span><span class="lineCov">         43 : {</span>
<span class="lineNum">   16879 </span><span class="lineCov">         43 :   tree clauses</span>
<span class="lineNum">   16880 </span>            :     = c_parser_omp_all_clauses (parser, OMP_TARGET_DATA_CLAUSE_MASK,
<span class="lineNum">   16881 </span>            :                                 &quot;#pragma omp target data&quot;);
<span class="lineNum">   16882 </span><span class="lineCov">         92 :   int map_seen = 0;</span>
<span class="lineNum">   16883 </span><span class="lineCov">         92 :   for (tree *pc = &amp;clauses; *pc;)</span>
<span class="lineNum">   16884 </span><span class="lineCov">         92 :     {</span>
<span class="lineNum">   16885 </span><span class="lineCov">         92 :       if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)</span>
<span class="lineNum">   16886 </span>            :         switch (OMP_CLAUSE_MAP_KIND (*pc))
<span class="lineNum">   16887 </span><span class="lineCov">         92 :           {</span>
<span class="lineNum">   16888 </span>            :           case GOMP_MAP_TO:
<span class="lineNum">   16889 </span>            :           case GOMP_MAP_ALWAYS_TO:
<span class="lineNum">   16890 </span>            :           case GOMP_MAP_FROM:
<span class="lineNum">   16891 </span>            :           case GOMP_MAP_ALWAYS_FROM:
<span class="lineNum">   16892 </span>            :           case GOMP_MAP_TOFROM:
<span class="lineNum">   16893 </span>            :           case GOMP_MAP_ALWAYS_TOFROM:
<span class="lineNum">   16894 </span>            :           case GOMP_MAP_ALLOC:
<span class="lineNum">   16895 </span>            :             map_seen = 3;
<span class="lineNum">   16896 </span>            :             break;
<span class="lineNum">   16897 </span>            :           case GOMP_MAP_FIRSTPRIVATE_POINTER:
<span class="lineNum">   16898 </span>            :           case GOMP_MAP_ALWAYS_POINTER:
<span class="lineNum">   16899 </span>            :             break;
<span class="lineNum">   16900 </span>            :           default:
<span class="lineNum">   16901 </span><span class="lineCov">         69 :             map_seen |= 1;</span>
<span class="lineNum">   16902 </span>            :             error_at (OMP_CLAUSE_LOCATION (*pc),
<span class="lineNum">   16903 </span><span class="lineCov">         69 :                       &quot;%&lt;#pragma omp target data%&gt; with map-type other &quot;</span>
<span class="lineNum">   16904 </span><span class="lineCov">        552 :                       &quot;than %&lt;to%&gt;, %&lt;from%&gt;, %&lt;tofrom%&gt; or %&lt;alloc%&gt; &quot;</span>
<span class="lineNum">   16905 </span><span class="lineCov">         69 :                       &quot;on %&lt;map%&gt; clause&quot;);</span>
<span class="lineNum">   16906 </span><span class="lineCov">         69 :             *pc = OMP_CLAUSE_CHAIN (*pc);</span>
<span class="lineNum">   16907 </span><span class="lineCov">        212 :             continue;</span>
<span class="lineNum">   16908 </span>            :           }
<span class="lineNum">   16909 </span><span class="lineCov">        143 :       pc = &amp;OMP_CLAUSE_CHAIN (*pc);</span>
<span class="lineNum">   16910 </span><span class="lineCov">        122 :     }</span>
<span class="lineNum">   16911 </span>            : 
<span class="lineNum">   16912 </span><span class="lineCov">         94 :   if (map_seen != 3)</span>
<span class="lineNum">   16913 </span><span class="lineCov">         94 :     {</span>
<span class="lineNum">   16914 </span><span class="lineCov">         94 :       if (map_seen == 0)</span>
<span class="lineNum">   16915 </span><span class="lineCov">         94 :         error_at (loc,</span>
<span class="lineNum">   16916 </span><span class="lineCov">         94 :                   &quot;%&lt;#pragma omp target data%&gt; must contain at least &quot;</span>
<span class="lineNum">   16917 </span><span class="lineCov">         94 :                   &quot;one %&lt;map%&gt; clause&quot;);</span>
<span class="lineNum">   16918 </span><span class="lineCov">         94 :       return NULL_TREE;</span>
<span class="lineNum">   16919 </span><span class="lineCov">         94 :     }</span>
<span class="lineNum">   16920 </span><span class="lineCov">         94 : </span>
<span class="lineNum">   16921 </span>            :   tree stmt = make_node (OMP_TARGET_DATA);
<span class="lineNum">   16922 </span>            :   TREE_TYPE (stmt) = void_type_node;
<span class="lineNum">   16923 </span>            :   OMP_TARGET_DATA_CLAUSES (stmt) = clauses;
<span class="lineNum">   16924 </span><span class="lineNoCov">          0 :   keep_next_level ();</span>
<span class="lineNum">   16925 </span><span class="lineNoCov">          0 :   tree block = c_begin_compound_stmt (true);</span>
<span class="lineNum">   16926 </span><span class="lineNoCov">          0 :   add_stmt (c_parser_omp_structured_block (parser, if_p));</span>
<span class="lineNum">   16927 </span>            :   OMP_TARGET_DATA_BODY (stmt) = c_end_compound_stmt (loc, block, true);
<span class="lineNum">   16928 </span>            : 
<span class="lineNum">   16929 </span>            :   SET_EXPR_LOCATION (stmt, loc);
<span class="lineNum">   16930 </span><span class="lineNoCov">          0 :   return add_stmt (stmt);</span>
<span class="lineNum">   16931 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   16932 </span>            : 
<span class="lineNum">   16933 </span><span class="lineCov">        286 : /* OpenMP 4.0:</span>
<span class="lineNum">   16934 </span>            :    # pragma omp target update target-update-clause[optseq] new-line */
<span class="lineNum">   16935 </span>            : 
<span class="lineNum">   16936 </span><span class="lineCov">         69 : #define OMP_TARGET_UPDATE_CLAUSE_MASK                           \</span>
<span class="lineNum">   16937 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FROM)           \
<span class="lineNum">   16938 </span><span class="lineCov">          1 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_TO)             \</span>
<span class="lineNum">   16939 </span><span class="lineCov">          1 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEVICE) \</span>
<span class="lineNum">   16940 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \
<span class="lineNum">   16941 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEPEND) \
<span class="lineNum">   16942 </span><span class="lineCov">          1 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT))</span>
<a name="16943"><span class="lineNum">   16943 </span>            : </a>
<span class="lineNum">   16944 </span>            : static bool
<span class="lineNum">   16945 </span><span class="lineCov">         68 : c_parser_omp_target_update (location_t loc, c_parser *parser,</span>
<span class="lineNum">   16946 </span><span class="lineCov">         68 :                             enum pragma_context context)</span>
<span class="lineNum">   16947 </span><span class="lineCov">         68 : {</span>
<span class="lineNum">   16948 </span><span class="lineCov">         68 :   if (context == pragma_stmt)</span>
<span class="lineNum">   16949 </span><span class="lineCov">         68 :     {</span>
<span class="lineNum">   16950 </span><span class="lineCov">         68 :       error_at (loc, &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,</span>
<span class="lineNum">   16951 </span><span class="lineCov">         68 :                 &quot;omp target update&quot;);</span>
<span class="lineNum">   16952 </span>            :       c_parser_skip_to_pragma_eol (parser, false);
<span class="lineNum">   16953 </span><span class="lineCov">         68 :       return false;</span>
<span class="lineNum">   16954 </span><span class="lineCov">         68 :     }</span>
<span class="lineNum">   16955 </span>            : 
<span class="lineNum">   16956 </span>            :   tree clauses
<span class="lineNum">   16957 </span>            :     = c_parser_omp_all_clauses (parser, OMP_TARGET_UPDATE_CLAUSE_MASK,
<span class="lineNum">   16958 </span>            :                                 &quot;#pragma omp target update&quot;);
<span class="lineNum">   16959 </span>            :   if (omp_find_clause (clauses, OMP_CLAUSE_TO) == NULL_TREE
<span class="lineNum">   16960 </span>            :       &amp;&amp; omp_find_clause (clauses, OMP_CLAUSE_FROM) == NULL_TREE)
<span class="lineNum">   16961 </span>            :     {
<span class="lineNum">   16962 </span>            :       error_at (loc,
<span class="lineNum">   16963 </span>            :                 &quot;%&lt;#pragma omp target update%&gt; must contain at least one &quot;
<span class="lineNum">   16964 </span>            :                 &quot;%&lt;from%&gt; or %&lt;to%&gt; clauses&quot;);
<span class="lineNum">   16965 </span>            :       return false;
<span class="lineNum">   16966 </span>            :     }
<span class="lineNum">   16967 </span>            : 
<span class="lineNum">   16968 </span>            :   tree stmt = make_node (OMP_TARGET_UPDATE);
<span class="lineNum">   16969 </span><span class="lineCov">       1063 :   TREE_TYPE (stmt) = void_type_node;</span>
<span class="lineNum">   16970 </span>            :   OMP_TARGET_UPDATE_CLAUSES (stmt) = clauses;
<span class="lineNum">   16971 </span>            :   SET_EXPR_LOCATION (stmt, loc);
<span class="lineNum">   16972 </span><span class="lineCov">       1063 :   add_stmt (stmt);</span>
<span class="lineNum">   16973 </span>            :   return false;
<span class="lineNum">   16974 </span><span class="lineCov">          8 : }</span>
<span class="lineNum">   16975 </span>            : 
<span class="lineNum">   16976 </span><span class="lineCov">          8 : /* OpenMP 4.5:</span>
<span class="lineNum">   16977 </span><span class="lineCov">          8 :    # pragma omp target enter data target-data-clause[optseq] new-line  */</span>
<span class="lineNum">   16978 </span>            : 
<span class="lineNum">   16979 </span>            : #define OMP_TARGET_ENTER_DATA_CLAUSE_MASK                       \
<span class="lineNum">   16980 </span><span class="lineCov">       1055 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEVICE) \</span>
<span class="lineNum">   16981 </span><span class="lineCov">      12660 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MAP)            \</span>
<span class="lineNum">   16982 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \
<span class="lineNum">   16983 </span><span class="lineCov">       1055 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEPEND) \</span>
<span class="lineNum">   16984 </span><span class="lineCov">       1055 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT))</span>
<a name="16985"><span class="lineNum">   16985 </span>            : </a>
<span class="lineNum">   16986 </span><span class="lineCov">          3 : static tree</span>
<span class="lineNum">   16987 </span>            : c_parser_omp_target_enter_data (location_t loc, c_parser *parser,
<span class="lineNum">   16988 </span>            :                                 enum pragma_context context)
<span class="lineNum">   16989 </span><span class="lineCov">          3 : {</span>
<span class="lineNum">   16990 </span>            :   bool data_seen = false;
<span class="lineNum">   16991 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   16992 </span><span class="lineCov">       1052 :     {</span>
<span class="lineNum">   16993 </span><span class="lineCov">       1052 :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">   16994 </span><span class="lineCov">       1052 :       if (strcmp (p, &quot;data&quot;) == 0)</span>
<span class="lineNum">   16995 </span><span class="lineCov">       1052 :         {</span>
<span class="lineNum">   16996 </span><span class="lineCov">       1052 :           c_parser_consume_token (parser);</span>
<span class="lineNum">   16997 </span><span class="lineCov">       1052 :           data_seen = true;</span>
<span class="lineNum">   16998 </span>            :         }
<span class="lineNum">   16999 </span>            :     }
<span class="lineNum">   17000 </span>            :   if (!data_seen)
<span class="lineNum">   17001 </span>            :     {
<span class="lineNum">   17002 </span>            :       c_parser_error (parser, &quot;expected %&lt;data%&gt;&quot;);
<span class="lineNum">   17003 </span>            :       c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   17004 </span>            :       return NULL_TREE;
<span class="lineNum">   17005 </span>            :     }
<span class="lineNum">   17006 </span>            : 
<span class="lineNum">   17007 </span>            :   if (context == pragma_stmt)
<span class="lineNum">   17008 </span>            :     {
<span class="lineNum">   17009 </span>            :       error_at (loc, &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,
<span class="lineNum">   17010 </span>            :                 &quot;omp target enter data&quot;);
<span class="lineNum">   17011 </span><span class="lineCov">         27 :       c_parser_skip_to_pragma_eol (parser, false);</span>
<span class="lineNum">   17012 </span>            :       return NULL_TREE;
<span class="lineNum">   17013 </span>            :     }
<span class="lineNum">   17014 </span><span class="lineCov">         27 : </span>
<span class="lineNum">   17015 </span><span class="lineCov">         27 :   tree clauses</span>
<span class="lineNum">   17016 </span>            :     = c_parser_omp_all_clauses (parser, OMP_TARGET_ENTER_DATA_CLAUSE_MASK,
<span class="lineNum">   17017 </span><span class="lineCov">         27 :                                 &quot;#pragma omp target enter data&quot;);</span>
<span class="lineNum">   17018 </span><span class="lineCov">         27 :   int map_seen = 0;</span>
<span class="lineNum">   17019 </span>            :   for (tree *pc = &amp;clauses; *pc;)
<span class="lineNum">   17020 </span><span class="lineCov">         27 :     {</span>
<span class="lineNum">   17021 </span><span class="lineCov">         27 :       if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)</span>
<span class="lineNum">   17022 </span>            :         switch (OMP_CLAUSE_MAP_KIND (*pc))
<span class="lineNum">   17023 </span>            :           {
<span class="lineNum">   17024 </span><span class="lineCov">         27 :           case GOMP_MAP_TO:</span>
<span class="lineNum">   17025 </span>            :           case GOMP_MAP_ALWAYS_TO:
<span class="lineNum">   17026 </span><span class="lineNoCov">          0 :           case GOMP_MAP_ALLOC:</span>
<span class="lineNum">   17027 </span><span class="lineNoCov">          0 :             map_seen = 3;</span>
<span class="lineNum">   17028 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   17029 </span>            :           case GOMP_MAP_FIRSTPRIVATE_POINTER:
<span class="lineNum">   17030 </span>            :           case GOMP_MAP_ALWAYS_POINTER:
<span class="lineNum">   17031 </span><span class="lineCov">         27 :             break;</span>
<span class="lineNum">   17032 </span>            :           default:
<span class="lineNum">   17033 </span><span class="lineCov">          8 :             map_seen |= 1;</span>
<span class="lineNum">   17034 </span>            :             error_at (OMP_CLAUSE_LOCATION (*pc),
<span class="lineNum">   17035 </span><span class="lineCov">          8 :                       &quot;%&lt;#pragma omp target enter data%&gt; with map-type other &quot;</span>
<span class="lineNum">   17036 </span><span class="lineCov">          8 :                       &quot;than %&lt;to%&gt; or %&lt;alloc%&gt; on %&lt;map%&gt; clause&quot;);</span>
<span class="lineNum">   17037 </span>            :             *pc = OMP_CLAUSE_CHAIN (*pc);
<span class="lineNum">   17038 </span>            :             continue;
<span class="lineNum">   17039 </span><span class="lineCov">         19 :           }</span>
<span class="lineNum">   17040 </span><span class="lineCov">        190 :       pc = &amp;OMP_CLAUSE_CHAIN (*pc);</span>
<span class="lineNum">   17041 </span><span class="lineCov">         19 :     }</span>
<span class="lineNum">   17042 </span><span class="lineCov">         19 : </span>
<span class="lineNum">   17043 </span><span class="lineCov">         82 :   if (map_seen != 3)</span>
<span class="lineNum">   17044 </span>            :     {
<span class="lineNum">   17045 </span><span class="lineCov">         63 :       if (map_seen == 0)</span>
<span class="lineNum">   17046 </span><span class="lineCov">         45 :         error_at (loc,</span>
<span class="lineNum">   17047 </span>            :                   &quot;%&lt;#pragma omp target enter data%&gt; must contain at least &quot;
<span class="lineNum">   17048 </span><span class="lineCov">         37 :                   &quot;one %&lt;map%&gt; clause&quot;);</span>
<span class="lineNum">   17049 </span><span class="lineCov">         37 :       return NULL_TREE;</span>
<span class="lineNum">   17050 </span><span class="lineCov">         37 :     }</span>
<span class="lineNum">   17051 </span><span class="lineCov">         37 : </span>
<span class="lineNum">   17052 </span><span class="lineCov">         37 :   tree stmt = make_node (OMP_TARGET_ENTER_DATA);</span>
<span class="lineNum">   17053 </span>            :   TREE_TYPE (stmt) = void_type_node;
<span class="lineNum">   17054 </span>            :   OMP_TARGET_ENTER_DATA_CLAUSES (stmt) = clauses;
<span class="lineNum">   17055 </span>            :   SET_EXPR_LOCATION (stmt, loc);
<span class="lineNum">   17056 </span><span class="lineNoCov">          0 :   add_stmt (stmt);</span>
<span class="lineNum">   17057 </span><span class="lineNoCov">          0 :   return stmt;</span>
<span class="lineNum">   17058 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   17059 </span>            : 
<span class="lineNum">   17060 </span>            : /* OpenMP 4.5:
<span class="lineNum">   17061 </span><span class="lineNoCov">          0 :    # pragma omp target exit data target-data-clause[optseq] new-line  */</span>
<span class="lineNum">   17062 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   17063 </span>            : #define OMP_TARGET_EXIT_DATA_CLAUSE_MASK                        \
<span class="lineNum">   17064 </span><span class="lineCov">        126 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEVICE) \</span>
<span class="lineNum">   17065 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MAP)            \
<span class="lineNum">   17066 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \
<span class="lineNum">   17067 </span><span class="lineCov">         19 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEPEND) \</span>
<span class="lineNum">   17068 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT))
<a name="17069"><span class="lineNum">   17069 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   17070 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   17071 </span>            : c_parser_omp_target_exit_data (location_t loc, c_parser *parser,
<span class="lineNum">   17072 </span>            :                                enum pragma_context context)
<span class="lineNum">   17073 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   17074 </span>            :   bool data_seen = false;
<span class="lineNum">   17075 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   17076 </span><span class="lineCov">         19 :     {</span>
<span class="lineNum">   17077 </span><span class="lineCov">         19 :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);</span>
<span class="lineNum">   17078 </span><span class="lineCov">         19 :       if (strcmp (p, &quot;data&quot;) == 0)</span>
<span class="lineNum">   17079 </span><span class="lineCov">         19 :         {</span>
<span class="lineNum">   17080 </span><span class="lineCov">         19 :           c_parser_consume_token (parser);</span>
<span class="lineNum">   17081 </span><span class="lineCov">         19 :           data_seen = true;</span>
<span class="lineNum">   17082 </span>            :         }
<span class="lineNum">   17083 </span>            :     }
<span class="lineNum">   17084 </span>            :   if (!data_seen)
<span class="lineNum">   17085 </span>            :     {
<span class="lineNum">   17086 </span>            :       c_parser_error (parser, &quot;expected %&lt;data%&gt;&quot;);
<span class="lineNum">   17087 </span>            :       c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   17088 </span>            :       return NULL_TREE;
<span class="lineNum">   17089 </span>            :     }
<span class="lineNum">   17090 </span>            : 
<span class="lineNum">   17091 </span>            :   if (context == pragma_stmt)
<span class="lineNum">   17092 </span>            :     {
<span class="lineNum">   17093 </span>            :       error_at (loc, &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,
<span class="lineNum">   17094 </span>            :                 &quot;omp target exit data&quot;);
<span class="lineNum">   17095 </span><span class="lineCov">         29 :       c_parser_skip_to_pragma_eol (parser, false);</span>
<span class="lineNum">   17096 </span>            :       return NULL_TREE;
<span class="lineNum">   17097 </span>            :     }
<span class="lineNum">   17098 </span><span class="lineCov">         29 : </span>
<span class="lineNum">   17099 </span><span class="lineCov">         29 :   tree clauses</span>
<span class="lineNum">   17100 </span>            :     = c_parser_omp_all_clauses (parser, OMP_TARGET_EXIT_DATA_CLAUSE_MASK,
<span class="lineNum">   17101 </span><span class="lineCov">         29 :                                 &quot;#pragma omp target exit data&quot;);</span>
<span class="lineNum">   17102 </span><span class="lineCov">         29 : </span>
<span class="lineNum">   17103 </span>            :   int map_seen = 0;
<span class="lineNum">   17104 </span><span class="lineCov">         29 :   for (tree *pc = &amp;clauses; *pc;)</span>
<span class="lineNum">   17105 </span><span class="lineCov">         29 :     {</span>
<span class="lineNum">   17106 </span>            :       if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)
<span class="lineNum">   17107 </span>            :         switch (OMP_CLAUSE_MAP_KIND (*pc))
<span class="lineNum">   17108 </span><span class="lineCov">         29 :           {</span>
<span class="lineNum">   17109 </span>            :           case GOMP_MAP_FROM:
<span class="lineNum">   17110 </span><span class="lineNoCov">          0 :           case GOMP_MAP_ALWAYS_FROM:</span>
<span class="lineNum">   17111 </span><span class="lineNoCov">          0 :           case GOMP_MAP_RELEASE:</span>
<span class="lineNum">   17112 </span><span class="lineNoCov">          0 :           case GOMP_MAP_DELETE:</span>
<span class="lineNum">   17113 </span>            :             map_seen = 3;
<span class="lineNum">   17114 </span>            :             break;
<span class="lineNum">   17115 </span><span class="lineCov">         29 :           case GOMP_MAP_FIRSTPRIVATE_POINTER:</span>
<span class="lineNum">   17116 </span>            :           case GOMP_MAP_ALWAYS_POINTER:
<span class="lineNum">   17117 </span><span class="lineCov">          8 :             break;</span>
<span class="lineNum">   17118 </span>            :           default:
<span class="lineNum">   17119 </span><span class="lineCov">          8 :             map_seen |= 1;</span>
<span class="lineNum">   17120 </span><span class="lineCov">          8 :             error_at (OMP_CLAUSE_LOCATION (*pc),</span>
<span class="lineNum">   17121 </span>            :                       &quot;%&lt;#pragma omp target exit data%&gt; with map-type other &quot;
<span class="lineNum">   17122 </span>            :                       &quot;than %&lt;from%&gt;, %&lt;release%&gt; or %&lt;delete%&gt; on %&lt;map%&gt;&quot;
<span class="lineNum">   17123 </span><span class="lineCov">         21 :                       &quot; clause&quot;);</span>
<span class="lineNum">   17124 </span><span class="lineCov">        210 :             *pc = OMP_CLAUSE_CHAIN (*pc);</span>
<span class="lineNum">   17125 </span><span class="lineCov">         21 :             continue;</span>
<span class="lineNum">   17126 </span>            :           }
<span class="lineNum">   17127 </span><span class="lineCov">         21 :       pc = &amp;OMP_CLAUSE_CHAIN (*pc);</span>
<span class="lineNum">   17128 </span><span class="lineCov">         87 :     }</span>
<span class="lineNum">   17129 </span>            : 
<span class="lineNum">   17130 </span><span class="lineCov">         66 :   if (map_seen != 3)</span>
<span class="lineNum">   17131 </span><span class="lineCov">         47 :     {</span>
<span class="lineNum">   17132 </span>            :       if (map_seen == 0)
<span class="lineNum">   17133 </span><span class="lineCov">         37 :         error_at (loc,</span>
<span class="lineNum">   17134 </span><span class="lineCov">         37 :                   &quot;%&lt;#pragma omp target exit data%&gt; must contain at least one &quot;</span>
<span class="lineNum">   17135 </span><span class="lineCov">         37 :                   &quot;%&lt;map%&gt; clause&quot;);</span>
<span class="lineNum">   17136 </span><span class="lineCov">         37 :       return NULL_TREE;</span>
<span class="lineNum">   17137 </span><span class="lineCov">         37 :     }</span>
<span class="lineNum">   17138 </span><span class="lineCov">         37 : </span>
<span class="lineNum">   17139 </span>            :   tree stmt = make_node (OMP_TARGET_EXIT_DATA);
<span class="lineNum">   17140 </span>            :   TREE_TYPE (stmt) = void_type_node;
<span class="lineNum">   17141 </span>            :   OMP_TARGET_EXIT_DATA_CLAUSES (stmt) = clauses;
<span class="lineNum">   17142 </span><span class="lineNoCov">          0 :   SET_EXPR_LOCATION (stmt, loc);</span>
<span class="lineNum">   17143 </span><span class="lineNoCov">          0 :   add_stmt (stmt);</span>
<span class="lineNum">   17144 </span><span class="lineNoCov">          0 :   return stmt;</span>
<span class="lineNum">   17145 </span>            : }
<span class="lineNum">   17146 </span>            : 
<span class="lineNum">   17147 </span>            : /* OpenMP 4.0:
<span class="lineNum">   17148 </span><span class="lineNoCov">          0 :    # pragma omp target target-clause[optseq] new-line</span>
<span class="lineNum">   17149 </span><span class="lineNoCov">          0 :      structured-block  */</span>
<span class="lineNum">   17150 </span>            : 
<span class="lineNum">   17151 </span><span class="lineCov">        132 : #define OMP_TARGET_CLAUSE_MASK                                  \</span>
<span class="lineNum">   17152 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEVICE) \
<span class="lineNum">   17153 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MAP)            \
<span class="lineNum">   17154 </span><span class="lineCov">         21 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \</span>
<span class="lineNum">   17155 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEPEND) \
<span class="lineNum">   17156 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT) \</span>
<span class="lineNum">   17157 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \</span>
<span class="lineNum">   17158 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \
<span class="lineNum">   17159 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEFAULTMAP)     \
<span class="lineNum">   17160 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR))</span>
<a name="17161"><span class="lineNum">   17161 </span>            : </a>
<span class="lineNum">   17162 </span>            : static bool
<span class="lineNum">   17163 </span><span class="lineCov">         21 : c_parser_omp_target (c_parser *parser, enum pragma_context context, bool *if_p)</span>
<span class="lineNum">   17164 </span><span class="lineCov">         21 : {</span>
<span class="lineNum">   17165 </span><span class="lineCov">         21 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   17166 </span><span class="lineCov">         21 :   c_parser_consume_pragma (parser);</span>
<span class="lineNum">   17167 </span><span class="lineCov">         21 :   tree *pc = NULL, stmt, block;</span>
<span class="lineNum">   17168 </span><span class="lineCov">         21 : </span>
<span class="lineNum">   17169 </span>            :   if (context != pragma_stmt &amp;&amp; context != pragma_compound)
<span class="lineNum">   17170 </span>            :     {
<span class="lineNum">   17171 </span>            :       c_parser_error (parser, &quot;expected declaration specifiers&quot;);
<span class="lineNum">   17172 </span>            :       c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   17173 </span>            :       return false;
<span class="lineNum">   17174 </span>            :     }
<span class="lineNum">   17175 </span>            : 
<span class="lineNum">   17176 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   17177 </span>            :     {
<span class="lineNum">   17178 </span>            :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   17179 </span>            :       enum tree_code ccode = ERROR_MARK;
<span class="lineNum">   17180 </span>            : 
<span class="lineNum">   17181 </span>            :       if (strcmp (p, &quot;teams&quot;) == 0)
<span class="lineNum">   17182 </span>            :         ccode = OMP_TEAMS;
<span class="lineNum">   17183 </span>            :       else if (strcmp (p, &quot;parallel&quot;) == 0)
<span class="lineNum">   17184 </span>            :         ccode = OMP_PARALLEL;
<span class="lineNum">   17185 </span>            :       else if (strcmp (p, &quot;simd&quot;) == 0)
<span class="lineNum">   17186 </span>            :         ccode = OMP_SIMD;
<span class="lineNum">   17187 </span><span class="lineCov">       2617 :       if (ccode != ERROR_MARK)</span>
<span class="lineNum">   17188 </span>            :         {
<span class="lineNum">   17189 </span><span class="lineCov">       2617 :           tree cclauses[C_OMP_CLAUSE_SPLIT_COUNT];</span>
<span class="lineNum">   17190 </span><span class="lineCov">       2617 :           char p_name[sizeof (&quot;#pragma omp target teams distribute &quot;</span>
<span class="lineNum">   17191 </span><span class="lineCov">       2617 :                               &quot;parallel for simd&quot;)];</span>
<span class="lineNum">   17192 </span>            : 
<span class="lineNum">   17193 </span><span class="lineCov">       2617 :           c_parser_consume_token (parser);</span>
<span class="lineNum">   17194 </span>            :           strcpy (p_name, &quot;#pragma omp target&quot;);
<span class="lineNum">   17195 </span><span class="lineCov">          2 :           if (!flag_openmp)  /* flag_openmp_simd  */</span>
<span class="lineNum">   17196 </span><span class="lineCov">          2 :             {</span>
<span class="lineNum">   17197 </span><span class="lineCov">          2 :               tree stmt;</span>
<span class="lineNum">   17198 </span>            :               switch (ccode)
<span class="lineNum">   17199 </span>            :                 {
<span class="lineNum">   17200 </span><span class="lineCov">       2615 :                 case OMP_TEAMS:</span>
<span class="lineNum">   17201 </span>            :                   stmt = c_parser_omp_teams (loc, parser, p_name,
<span class="lineNum">   17202 </span><span class="lineCov">       2151 :                                              OMP_TARGET_CLAUSE_MASK,</span>
<span class="lineNum">   17203 </span><span class="lineCov">       2151 :                                              cclauses, if_p);</span>
<span class="lineNum">   17204 </span>            :                   break;
<span class="lineNum">   17205 </span><span class="lineCov">       2151 :                 case OMP_PARALLEL:</span>
<span class="lineNum">   17206 </span>            :                   stmt = c_parser_omp_parallel (loc, parser, p_name,
<span class="lineNum">   17207 </span><span class="lineCov">       1709 :                                                 OMP_TARGET_CLAUSE_MASK,</span>
<span class="lineNum">   17208 </span>            :                                                 cclauses, if_p);
<span class="lineNum">   17209 </span><span class="lineCov">       1549 :                   break;</span>
<span class="lineNum">   17210 </span>            :                 case OMP_SIMD:
<span class="lineNum">   17211 </span><span class="lineCov">       1527 :                   stmt = c_parser_omp_simd (loc, parser, p_name,</span>
<span class="lineNum">   17212 </span>            :                                             OMP_TARGET_CLAUSE_MASK,
<span class="lineNum">   17213 </span><span class="lineCov">        624 :                                             cclauses, if_p);</span>
<span class="lineNum">   17214 </span><span class="lineCov">        624 :                   break;</span>
<span class="lineNum">   17215 </span>            :                 default:
<span class="lineNum">   17216 </span>            :                   gcc_unreachable ();
<span class="lineNum">   17217 </span><span class="lineCov">        624 :                 }</span>
<span class="lineNum">   17218 </span><span class="lineCov">        624 :               return stmt != NULL_TREE;</span>
<span class="lineNum">   17219 </span><span class="lineCov">        624 :             }</span>
<span class="lineNum">   17220 </span>            :           keep_next_level ();
<span class="lineNum">   17221 </span><span class="lineCov">          2 :           tree block = c_begin_compound_stmt (true), ret;</span>
<span class="lineNum">   17222 </span><span class="lineCov">          2 :           switch (ccode)</span>
<span class="lineNum">   17223 </span>            :             {
<span class="lineNum">   17224 </span><span class="lineCov">          2 :             case OMP_TEAMS:</span>
<span class="lineNum">   17225 </span><span class="lineCov">         10 :               ret = c_parser_omp_teams (loc, parser, p_name,</span>
<span class="lineNum">   17226 </span><span class="lineCov">         34 :                                         OMP_TARGET_CLAUSE_MASK, cclauses,</span>
<span class="lineNum">   17227 </span>            :                                         if_p);
<span class="lineNum">   17228 </span><span class="lineCov">          2 :               break;</span>
<span class="lineNum">   17229 </span><span class="lineNoCov">          0 :             case OMP_PARALLEL:</span>
<span class="lineNum">   17230 </span><span class="lineNoCov">          0 :               ret = c_parser_omp_parallel (loc, parser, p_name,</span>
<span class="lineNum">   17231 </span><span class="lineNoCov">          0 :                                            OMP_TARGET_CLAUSE_MASK, cclauses,</span>
<span class="lineNum">   17232 </span>            :                                            if_p);
<span class="lineNum">   17233 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">   17234 </span><span class="lineNoCov">          0 :             case OMP_SIMD:</span>
<span class="lineNum">   17235 </span><span class="lineNoCov">          0 :               ret = c_parser_omp_simd (loc, parser, p_name,</span>
<span class="lineNum">   17236 </span><span class="lineNoCov">          0 :                                        OMP_TARGET_CLAUSE_MASK, cclauses,</span>
<span class="lineNum">   17237 </span>            :                                        if_p);
<span class="lineNum">   17238 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">   17239 </span><span class="lineNoCov">          0 :             default:</span>
<span class="lineNum">   17240 </span><span class="lineNoCov">          0 :               gcc_unreachable ();</span>
<span class="lineNum">   17241 </span>            :             }
<span class="lineNum">   17242 </span><span class="lineCov">          2 :           block = c_end_compound_stmt (loc, block, true);</span>
<span class="lineNum">   17243 </span>            :           if (ret == NULL_TREE)
<span class="lineNum">   17244 </span><span class="lineCov">        622 :             return false;</span>
<span class="lineNum">   17245 </span><span class="lineCov">        622 :           if (ccode == OMP_TEAMS)</span>
<span class="lineNum">   17246 </span><span class="lineCov">        622 :             {</span>
<span class="lineNum">   17247 </span>            :               /* For combined target teams, ensure the num_teams and
<span class="lineNum">   17248 </span><span class="lineCov">        440 :                  thread_limit clause expressions are evaluated on the host,</span>
<span class="lineNum">   17249 </span><span class="lineCov">       2200 :                  before entering the target construct.  */</span>
<span class="lineNum">   17250 </span><span class="lineCov">       7480 :               tree c;</span>
<span class="lineNum">   17251 </span>            :               for (c = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];
<span class="lineNum">   17252 </span><span class="lineCov">        440 :                    c; c = OMP_CLAUSE_CHAIN (c))</span>
<span class="lineNum">   17253 </span><span class="lineCov">        160 :                 if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_NUM_TEAMS</span>
<span class="lineNum">   17254 </span><span class="lineCov">        800 :                      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_THREAD_LIMIT)</span>
<span class="lineNum">   17255 </span><span class="lineCov">       2720 :                     &amp;&amp; TREE_CODE (OMP_CLAUSE_OPERAND (c, 0)) != INTEGER_CST)</span>
<span class="lineNum">   17256 </span>            :                   {
<span class="lineNum">   17257 </span><span class="lineCov">        160 :                     tree expr = OMP_CLAUSE_OPERAND (c, 0);</span>
<span class="lineNum">   17258 </span><span class="lineCov">         22 :                     tree tmp = create_tmp_var_raw (TREE_TYPE (expr));</span>
<span class="lineNum">   17259 </span><span class="lineCov">        110 :                     expr = build4 (TARGET_EXPR, TREE_TYPE (expr), tmp,</span>
<span class="lineNum">   17260 </span><span class="lineCov">        374 :                                    expr, NULL_TREE, NULL_TREE);</span>
<span class="lineNum">   17261 </span>            :                     add_stmt (expr);
<span class="lineNum">   17262 </span><span class="lineCov">         22 :                     OMP_CLAUSE_OPERAND (c, 0) = expr;</span>
<span class="lineNum">   17263 </span><span class="lineNoCov">          0 :                     tree tc = build_omp_clause (OMP_CLAUSE_LOCATION (c),</span>
<span class="lineNum">   17264 </span><span class="lineNoCov">          0 :                                                 OMP_CLAUSE_FIRSTPRIVATE);</span>
<span class="lineNum">   17265 </span>            :                     OMP_CLAUSE_DECL (tc) = tmp;
<span class="lineNum">   17266 </span><span class="lineCov">        622 :                     OMP_CLAUSE_CHAIN (tc)</span>
<span class="lineNum">   17267 </span><span class="lineCov">        622 :                       = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];</span>
<span class="lineNum">   17268 </span>            :                     cclauses[C_OMP_CLAUSE_SPLIT_TARGET] = tc;
<span class="lineNum">   17269 </span><span class="lineCov">        622 :                   }</span>
<span class="lineNum">   17270 </span>            :             }
<span class="lineNum">   17271 </span>            :           tree stmt = make_node (OMP_TARGET);
<span class="lineNum">   17272 </span>            :           TREE_TYPE (stmt) = void_type_node;
<span class="lineNum">   17273 </span>            :           OMP_TARGET_CLAUSES (stmt) = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];
<span class="lineNum">   17274 </span><span class="lineCov">        440 :           OMP_TARGET_BODY (stmt) = block;</span>
<span class="lineNum">   17275 </span><span class="lineCov">        440 :           OMP_TARGET_COMBINED (stmt) = 1;</span>
<span class="lineNum">   17276 </span><span class="lineCov">        637 :           add_stmt (stmt);</span>
<span class="lineNum">   17277 </span><span class="lineCov">        197 :           pc = &amp;OMP_TARGET_CLAUSES (stmt);</span>
<span class="lineNum">   17278 </span><span class="lineCov">        328 :           goto check_clauses;</span>
<span class="lineNum">   17279 </span><span class="lineCov">        230 :         }</span>
<span class="lineNum">   17280 </span>            :       else if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   17281 </span><span class="lineCov">         58 :         {</span>
<span class="lineNum">   17282 </span><span class="lineCov">         58 :           c_parser_skip_to_pragma_eol (parser, false);</span>
<span class="lineNum">   17283 </span><span class="lineCov">         58 :           return false;</span>
<span class="lineNum">   17284 </span>            :         }
<span class="lineNum">   17285 </span><span class="lineCov">         58 :       else if (strcmp (p, &quot;data&quot;) == 0)</span>
<span class="lineNum">   17286 </span><span class="lineCov">         58 :         {</span>
<span class="lineNum">   17287 </span><span class="lineCov">         58 :           c_parser_consume_token (parser);</span>
<span class="lineNum">   17288 </span><span class="lineCov">         58 :           c_parser_omp_target_data (loc, parser, if_p);</span>
<span class="lineNum">   17289 </span><span class="lineCov">         58 :           return true;</span>
<span class="lineNum">   17290 </span><span class="lineCov">         58 :         }</span>
<span class="lineNum">   17291 </span><span class="lineCov">         58 :       else if (strcmp (p, &quot;enter&quot;) == 0)</span>
<span class="lineNum">   17292 </span><span class="lineCov">         58 :         {</span>
<span class="lineNum">   17293 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   17294 </span>            :           c_parser_omp_target_enter_data (loc, parser, context);
<span class="lineNum">   17295 </span><span class="lineCov">        622 :           return false;</span>
<span class="lineNum">   17296 </span><span class="lineCov">        622 :         }</span>
<span class="lineNum">   17297 </span><span class="lineCov">        622 :       else if (strcmp (p, &quot;exit&quot;) == 0)</span>
<span class="lineNum">   17298 </span><span class="lineCov">        622 :         {</span>
<span class="lineNum">   17299 </span><span class="lineCov">        622 :           c_parser_consume_token (parser);</span>
<span class="lineNum">   17300 </span><span class="lineCov">        622 :           c_parser_omp_target_exit_data (loc, parser, context);</span>
<span class="lineNum">   17301 </span><span class="lineCov">        622 :           return false;</span>
<span class="lineNum">   17302 </span><span class="lineCov">        622 :         }</span>
<span class="lineNum">   17303 </span>            :       else if (strcmp (p, &quot;update&quot;) == 0)
<span class="lineNum">   17304 </span><span class="lineCov">       1527 :         {</span>
<span class="lineNum">   17305 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   17306 </span><span class="lineNoCov">          0 :           return c_parser_omp_target_update (loc, parser, context);</span>
<span class="lineNum">   17307 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   17308 </span>            :     }
<span class="lineNum">   17309 </span><span class="lineCov">       1527 :   if (!flag_openmp) /* flag_openmp_simd  */</span>
<span class="lineNum">   17310 </span>            :     {
<span class="lineNum">   17311 </span><span class="lineCov">         69 :       c_parser_skip_to_pragma_eol (parser, false);</span>
<span class="lineNum">   17312 </span><span class="lineCov">         69 :       return false;</span>
<span class="lineNum">   17313 </span><span class="lineCov">         69 :     }</span>
<span class="lineNum">   17314 </span>            : 
<span class="lineNum">   17315 </span><span class="lineCov">       1458 :   stmt = make_node (OMP_TARGET);</span>
<span class="lineNum">   17316 </span>            :   TREE_TYPE (stmt) = void_type_node;
<span class="lineNum">   17317 </span><span class="lineCov">         27 : </span>
<span class="lineNum">   17318 </span><span class="lineCov">         27 :   OMP_TARGET_CLAUSES (stmt)</span>
<span class="lineNum">   17319 </span><span class="lineCov">         27 :     = c_parser_omp_all_clauses (parser, OMP_TARGET_CLAUSE_MASK,</span>
<span class="lineNum">   17320 </span>            :                                 &quot;#pragma omp target&quot;);
<span class="lineNum">   17321 </span><span class="lineCov">       1431 :   pc = &amp;OMP_TARGET_CLAUSES (stmt);</span>
<span class="lineNum">   17322 </span>            :   keep_next_level ();
<span class="lineNum">   17323 </span><span class="lineCov">         29 :   block = c_begin_compound_stmt (true);</span>
<span class="lineNum">   17324 </span><span class="lineCov">         29 :   add_stmt (c_parser_omp_structured_block (parser, if_p));</span>
<span class="lineNum">   17325 </span><span class="lineCov">         29 :   OMP_TARGET_BODY (stmt) = c_end_compound_stmt (loc, block, true);</span>
<span class="lineNum">   17326 </span>            : 
<span class="lineNum">   17327 </span><span class="lineCov">       1402 :   SET_EXPR_LOCATION (stmt, loc);</span>
<span class="lineNum">   17328 </span>            :   add_stmt (stmt);
<span class="lineNum">   17329 </span><span class="lineCov">       1063 : </span>
<span class="lineNum">   17330 </span><span class="lineCov">       1063 : check_clauses:</span>
<span class="lineNum">   17331 </span>            :   while (*pc)
<span class="lineNum">   17332 </span>            :     {
<span class="lineNum">   17333 </span><span class="lineCov">        803 :       if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)</span>
<span class="lineNum">   17334 </span>            :         switch (OMP_CLAUSE_MAP_KIND (*pc))
<span class="lineNum">   17335 </span><span class="lineCov">          1 :           {</span>
<span class="lineNum">   17336 </span><span class="lineCov">          1 :           case GOMP_MAP_TO:</span>
<span class="lineNum">   17337 </span>            :           case GOMP_MAP_ALWAYS_TO:
<span class="lineNum">   17338 </span>            :           case GOMP_MAP_FROM:
<span class="lineNum">   17339 </span><span class="lineCov">        802 :           case GOMP_MAP_ALWAYS_FROM:</span>
<span class="lineNum">   17340 </span><span class="lineCov">        802 :           case GOMP_MAP_TOFROM:</span>
<span class="lineNum">   17341 </span>            :           case GOMP_MAP_ALWAYS_TOFROM:
<span class="lineNum">   17342 </span><span class="lineCov">        802 :           case GOMP_MAP_ALLOC:</span>
<span class="lineNum">   17343 </span><span class="lineCov">      15238 :           case GOMP_MAP_FIRSTPRIVATE_POINTER:</span>
<span class="lineNum">   17344 </span>            :           case GOMP_MAP_ALWAYS_POINTER:
<span class="lineNum">   17345 </span><span class="lineCov">        802 :             break;</span>
<span class="lineNum">   17346 </span><span class="lineCov">        802 :           default:</span>
<span class="lineNum">   17347 </span><span class="lineCov">        802 :             error_at (OMP_CLAUSE_LOCATION (*pc),</span>
<span class="lineNum">   17348 </span><span class="lineCov">        802 :                       &quot;%&lt;#pragma omp target%&gt; with map-type other &quot;</span>
<span class="lineNum">   17349 </span><span class="lineCov">        802 :                       &quot;than %&lt;to%&gt;, %&lt;from%&gt;, %&lt;tofrom%&gt; or %&lt;alloc%&gt; &quot;</span>
<span class="lineNum">   17350 </span>            :                       &quot;on %&lt;map%&gt; clause&quot;);
<span class="lineNum">   17351 </span><span class="lineCov">        802 :             *pc = OMP_CLAUSE_CHAIN (*pc);</span>
<span class="lineNum">   17352 </span><span class="lineCov">        802 :             continue;</span>
<span class="lineNum">   17353 </span>            :           }
<span class="lineNum">   17354 </span><span class="lineCov">       2493 :       pc = &amp;OMP_CLAUSE_CHAIN (*pc);</span>
<span class="lineNum">   17355 </span><span class="lineCov">       2493 :     }</span>
<span class="lineNum">   17356 </span>            :   return true;
<span class="lineNum">   17357 </span><span class="lineCov">       1069 : }</span>
<span class="lineNum">   17358 </span><span class="lineCov">        679 : </span>
<span class="lineNum">   17359 </span>            : /* OpenMP 4.0:
<span class="lineNum">   17360 </span>            :    # pragma omp declare simd declare-simd-clauses[optseq] new-line  */
<span class="lineNum">   17361 </span>            : 
<span class="lineNum">   17362 </span>            : #define OMP_DECLARE_SIMD_CLAUSE_MASK                            \
<span class="lineNum">   17363 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SIMDLEN)        \
<span class="lineNum">   17364 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LINEAR) \
<span class="lineNum">   17365 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_ALIGNED)        \
<span class="lineNum">   17366 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_UNIFORM)        \
<span class="lineNum">   17367 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_INBRANCH)       \
<span class="lineNum">   17368 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOTINBRANCH))
<a name="17369"><span class="lineNum">   17369 </span>            : </a>
<span class="lineNum">   17370 </span><span class="lineNoCov">          0 : static void</span>
<span class="lineNum">   17371 </span><span class="lineNoCov">          0 : c_parser_omp_declare_simd (c_parser *parser, enum pragma_context context)</span>
<span class="lineNum">   17372 </span>            : {
<span class="lineNum">   17373 </span>            :   auto_vec&lt;c_token&gt; clauses;
<span class="lineNum">   17374 </span>            :   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))
<span class="lineNum">   17375 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   17376 </span><span class="lineNoCov">          0 :       c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">   17377 </span>            :       if (token-&gt;type == CPP_EOF)
<span class="lineNum">   17378 </span><span class="lineCov">       2138 :         {</span>
<span class="lineNum">   17379 </span>            :           c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   17380 </span>            :           return;
<span class="lineNum">   17381 </span>            :         }
<span class="lineNum">   17382 </span>            :       clauses.safe_push (*token);
<span class="lineNum">   17383 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   17384 </span>            :     }
<span class="lineNum">   17385 </span>            :   clauses.safe_push (*c_parser_peek_token (parser));
<span class="lineNum">   17386 </span>            :   c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   17387 </span>            : 
<span class="lineNum">   17388 </span>            :   while (c_parser_next_token_is (parser, CPP_PRAGMA))
<span class="lineNum">   17389 </span>            :     {
<span class="lineNum">   17390 </span>            :       if (c_parser_peek_token (parser)-&gt;pragma_kind
<span class="lineNum">   17391 </span>            :           != PRAGMA_OMP_DECLARE
<span class="lineNum">   17392 </span>            :           || c_parser_peek_2nd_token (parser)-&gt;type != CPP_NAME
<span class="lineNum">   17393 </span>            :           || strcmp (IDENTIFIER_POINTER
<span class="lineNum">   17394 </span>            :                                 (c_parser_peek_2nd_token (parser)-&gt;value),
<span class="lineNum">   17395 </span><span class="lineCov">        154 :                      &quot;simd&quot;) != 0)</span>
<span class="lineNum">   17396 </span>            :         {
<span class="lineNum">   17397 </span><span class="lineCov">        460 :           c_parser_error (parser,</span>
<span class="lineNum">   17398 </span><span class="lineCov">       1469 :                           &quot;%&lt;#pragma omp declare simd%&gt; must be followed by &quot;</span>
<span class="lineNum">   17399 </span>            :                           &quot;function declaration or definition or another &quot;
<span class="lineNum">   17400 </span><span class="lineCov">       1315 :                           &quot;%&lt;#pragma omp declare simd%&gt;&quot;);</span>
<span class="lineNum">   17401 </span><span class="lineCov">       1315 :           return;</span>
<span class="lineNum">   17402 </span>            :         }
<span class="lineNum">   17403 </span><span class="lineNoCov">          0 :       c_parser_consume_pragma (parser);</span>
<span class="lineNum">   17404 </span><span class="lineCov">          2 :       while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))</span>
<span class="lineNum">   17405 </span>            :         {
<span class="lineNum">   17406 </span><span class="lineCov">       1315 :           c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">   17407 </span><span class="lineCov">       1315 :           if (token-&gt;type == CPP_EOF)</span>
<span class="lineNum">   17408 </span>            :             {
<span class="lineNum">   17409 </span><span class="lineCov">        154 :               c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   17410 </span><span class="lineCov">        154 :               return;</span>
<span class="lineNum">   17411 </span>            :             }
<span class="lineNum">   17412 </span><span class="lineCov">        175 :           clauses.safe_push (*token);</span>
<span class="lineNum">   17413 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   17414 </span><span class="lineCov">         22 :         }</span>
<span class="lineNum">   17415 </span>            :       clauses.safe_push (*c_parser_peek_token (parser));
<span class="lineNum">   17416 </span><span class="lineCov">         21 :       c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   17417 </span><span class="lineCov">         43 :     }</span>
<span class="lineNum">   17418 </span>            : 
<span class="lineNum">   17419 </span>            :   /* Make sure nothing tries to read past the end of the tokens.  */
<span class="lineNum">   17420 </span>            :   c_token eof_token;
<span class="lineNum">   17421 </span><span class="lineCov">          1 :   memset (&amp;eof_token, 0, sizeof (eof_token));</span>
<span class="lineNum">   17422 </span>            :   eof_token.type = CPP_EOF;
<span class="lineNum">   17423 </span>            :   clauses.safe_push (eof_token);
<span class="lineNum">   17424 </span>            :   clauses.safe_push (eof_token);
<span class="lineNum">   17425 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   17426 </span>            :   switch (context)
<span class="lineNum">   17427 </span><span class="lineCov">         21 :     {</span>
<span class="lineNum">   17428 </span><span class="lineCov">        319 :     case pragma_external:</span>
<span class="lineNum">   17429 </span>            :       if (c_parser_next_token_is (parser, CPP_KEYWORD)
<span class="lineNum">   17430 </span><span class="lineCov">        298 :           &amp;&amp; c_parser_peek_token (parser)-&gt;keyword == RID_EXTENSION)</span>
<span class="lineNum">   17431 </span><span class="lineCov">        298 :         {</span>
<span class="lineNum">   17432 </span>            :           int ext = disable_extension_diagnostics ();
<span class="lineNum">   17433 </span><span class="lineNoCov">          0 :           do</span>
<span class="lineNum">   17434 </span><span class="lineNoCov">          0 :             c_parser_consume_token (parser);</span>
<span class="lineNum">   17435 </span>            :           while (c_parser_next_token_is (parser, CPP_KEYWORD)
<span class="lineNum">   17436 </span><span class="lineCov">        298 :                  &amp;&amp; c_parser_peek_token (parser)-&gt;keyword == RID_EXTENSION);</span>
<span class="lineNum">   17437 </span><span class="lineCov">        298 :           c_parser_declaration_or_fndef (parser, true, true, true, false, true,</span>
<span class="lineNum">   17438 </span>            :                                          NULL, clauses);
<span class="lineNum">   17439 </span><span class="lineCov">         21 :           restore_extension_diagnostics (ext);</span>
<span class="lineNum">   17440 </span><span class="lineCov">         21 :         }</span>
<span class="lineNum">   17441 </span>            :       else
<span class="lineNum">   17442 </span>            :         c_parser_declaration_or_fndef (parser, true, true, true, false, true,
<span class="lineNum">   17443 </span>            :                                        NULL, clauses);
<span class="lineNum">   17444 </span><span class="lineCov">        153 :       break;</span>
<span class="lineNum">   17445 </span><span class="lineCov">        153 :     case pragma_struct:</span>
<span class="lineNum">   17446 </span><span class="lineCov">        153 :     case pragma_param:</span>
<span class="lineNum">   17447 </span><span class="lineCov">        153 :     case pragma_stmt:</span>
<span class="lineNum">   17448 </span><span class="lineCov">        153 :       c_parser_error (parser, &quot;%&lt;#pragma omp declare simd%&gt; must be followed by &quot;</span>
<span class="lineNum">   17449 </span>            :                               &quot;function declaration or definition&quot;);
<span class="lineNum">   17450 </span><span class="lineCov">        153 :       break;</span>
<span class="lineNum">   17451 </span>            :     case pragma_compound:
<span class="lineNum">   17452 </span><span class="lineCov">        147 :       if (c_parser_next_token_is (parser, CPP_KEYWORD)</span>
<span class="lineNum">   17453 </span><span class="lineCov">        147 :           &amp;&amp; c_parser_peek_token (parser)-&gt;keyword == RID_EXTENSION)</span>
<span class="lineNum">   17454 </span><span class="lineCov">        147 :         {</span>
<span class="lineNum">   17455 </span>            :           int ext = disable_extension_diagnostics ();
<span class="lineNum">   17456 </span><span class="lineCov">          1 :           do</span>
<span class="lineNum">   17457 </span><span class="lineCov">          1 :             c_parser_consume_token (parser);</span>
<span class="lineNum">   17458 </span><span class="lineCov">          1 :           while (c_parser_next_token_is (parser, CPP_KEYWORD)</span>
<span class="lineNum">   17459 </span><span class="lineCov">          1 :                  &amp;&amp; c_parser_peek_token (parser)-&gt;keyword == RID_EXTENSION);</span>
<span class="lineNum">   17460 </span><span class="lineCov">          1 :           if (c_parser_next_tokens_start_declaration (parser))</span>
<span class="lineNum">   17461 </span><span class="lineCov">          1 :             {</span>
<span class="lineNum">   17462 </span>            :               c_parser_declaration_or_fndef (parser, true, true, true, true,
<span class="lineNum">   17463 </span><span class="lineCov">          1 :                                              true, NULL, clauses);</span>
<span class="lineNum">   17464 </span>            :               restore_extension_diagnostics (ext);
<span class="lineNum">   17465 </span>            :               break;
<span class="lineNum">   17466 </span><span class="lineCov">        146 :             }</span>
<span class="lineNum">   17467 </span>            :           restore_extension_diagnostics (ext);
<span class="lineNum">   17468 </span>            :         }
<span class="lineNum">   17469 </span><span class="lineCov">          3 :       else if (c_parser_next_tokens_start_declaration (parser))</span>
<span class="lineNum">   17470 </span><span class="lineCov">          3 :         {</span>
<span class="lineNum">   17471 </span><span class="lineCov">          3 :           c_parser_declaration_or_fndef (parser, true, true, true, true, true,</span>
<span class="lineNum">   17472 </span><span class="lineCov">          3 :                                          NULL, clauses);</span>
<span class="lineNum">   17473 </span>            :           break;
<span class="lineNum">   17474 </span><span class="lineCov">          3 :         }</span>
<span class="lineNum">   17475 </span><span class="lineCov">          3 :       c_parser_error (parser, &quot;%&lt;#pragma omp declare simd%&gt; must be followed by &quot;</span>
<span class="lineNum">   17476 </span><span class="lineCov">          3 :                               &quot;function declaration or definition&quot;);</span>
<span class="lineNum">   17477 </span><span class="lineCov">          3 :       break;</span>
<span class="lineNum">   17478 </span>            :     default:
<span class="lineNum">   17479 </span><span class="lineCov">          1 :       gcc_unreachable ();</span>
<span class="lineNum">   17480 </span><span class="lineCov">          3 :     }</span>
<span class="lineNum">   17481 </span><span class="lineCov">          3 : }</span>
<span class="lineNum">   17482 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   17483 </span><span class="lineCov">          3 : /* Finalize #pragma omp declare simd clauses after FNDECL has been parsed,</span>
<span class="lineNum">   17484 </span><span class="lineCov">          1 :    and put that into &quot;omp declare simd&quot; attribute.  */</span>
<a name="17485"><span class="lineNum">   17485 </span>            : </a>
<span class="lineNum">   17486 </span><span class="lineCov">          1 : static void</span>
<span class="lineNum">   17487 </span>            : c_finish_omp_declare_simd (c_parser *parser, tree fndecl, tree parms,
<span class="lineNum">   17488 </span><span class="lineCov">          1 :                            vec&lt;c_token&gt; clauses)</span>
<span class="lineNum">   17489 </span><span class="lineCov">          1 : {</span>
<span class="lineNum">   17490 </span>            :   /* Normally first token is CPP_NAME &quot;simd&quot;.  CPP_EOF there indicates
<span class="lineNum">   17491 </span><span class="lineNoCov">          0 :      error has been reported and CPP_PRAGMA that c_finish_omp_declare_simd</span>
<span class="lineNum">   17492 </span>            :      has already processed the tokens.  */
<span class="lineNum">   17493 </span><span class="lineCov">          2 :   if (clauses.exists () &amp;&amp; clauses[0].type == CPP_EOF)</span>
<span class="lineNum">   17494 </span>            :     return;
<span class="lineNum">   17495 </span><span class="lineCov">          2 :   if (fndecl == NULL_TREE || TREE_CODE (fndecl) != FUNCTION_DECL)</span>
<span class="lineNum">   17496 </span>            :     {
<span class="lineNum">   17497 </span><span class="lineCov">          2 :       error (&quot;%&lt;#pragma omp declare simd%&gt; not immediately followed by &quot;</span>
<span class="lineNum">   17498 </span>            :              &quot;a function declaration or definition&quot;);
<span class="lineNum">   17499 </span><span class="lineNoCov">          0 :       clauses[0].type = CPP_EOF;</span>
<span class="lineNum">   17500 </span>            :       return;
<span class="lineNum">   17501 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   17502 </span><span class="lineNoCov">          0 :   if (clauses.exists () &amp;&amp; clauses[0].type != CPP_NAME)</span>
<span class="lineNum">   17503 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   17504 </span>            :       error_at (DECL_SOURCE_LOCATION (fndecl),
<span class="lineNum">   17505 </span>            :                 &quot;%&lt;#pragma omp declare simd%&gt; not immediately followed by &quot;
<span class="lineNum">   17506 </span>            :                 &quot;a single function declaration or definition&quot;);
<span class="lineNum">   17507 </span>            :       clauses[0].type = CPP_EOF;
<span class="lineNum">   17508 </span>            :       return;
<span class="lineNum">   17509 </span>            :     }
<span class="lineNum">   17510 </span>            : 
<span class="lineNum">   17511 </span><span class="lineCov">        153 :   if (parms == NULL_TREE)</span>
<span class="lineNum">   17512 </span>            :     parms = DECL_ARGUMENTS (fndecl);
<span class="lineNum">   17513 </span>            : 
<span class="lineNum">   17514 </span>            :   unsigned int tokens_avail = parser-&gt;tokens_avail;
<span class="lineNum">   17515 </span>            :   gcc_assert (parser-&gt;tokens == &amp;parser-&gt;tokens_buf[0]);
<span class="lineNum">   17516 </span>            :   
<span class="lineNum">   17517 </span><span class="lineCov">        153 : </span>
<span class="lineNum">   17518 </span>            :   parser-&gt;tokens = clauses.address ();
<span class="lineNum">   17519 </span><span class="lineCov">        152 :   parser-&gt;tokens_avail = clauses.length ();</span>
<span class="lineNum">   17520 </span>            :   
<span class="lineNum">   17521 </span><span class="lineCov">          3 :   /* c_parser_omp_declare_simd pushed 2 extra CPP_EOF tokens at the end.  */</span>
<span class="lineNum">   17522 </span>            :   while (parser-&gt;tokens_avail &gt; 3)
<span class="lineNum">   17523 </span><span class="lineCov">          3 :     {</span>
<span class="lineNum">   17524 </span><span class="lineCov">          3 :       c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">   17525 </span>            :       gcc_assert (token-&gt;type == CPP_NAME
<span class="lineNum">   17526 </span><span class="lineCov">        149 :                   &amp;&amp; strcmp (IDENTIFIER_POINTER (token-&gt;value), &quot;simd&quot;) == 0);</span>
<span class="lineNum">   17527 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   17528 </span><span class="lineCov">          1 :       parser-&gt;in_pragma = true;</span>
<span class="lineNum">   17529 </span>            : 
<span class="lineNum">   17530 </span>            :       tree c = NULL_TREE;
<span class="lineNum">   17531 </span><span class="lineCov">          1 :       c = c_parser_omp_all_clauses (parser, OMP_DECLARE_SIMD_CLAUSE_MASK,</span>
<span class="lineNum">   17532 </span><span class="lineCov">          1 :                                       &quot;#pragma omp declare simd&quot;);</span>
<span class="lineNum">   17533 </span>            :       c = c_omp_declare_simd_clauses_to_numbers (parms, c);
<span class="lineNum">   17534 </span>            :       if (c != NULL_TREE)
<span class="lineNum">   17535 </span><span class="lineCov">        148 :         c = tree_cons (NULL_TREE, c, NULL_TREE);</span>
<span class="lineNum">   17536 </span><span class="lineCov">        186 :       c = build_tree_list (get_identifier (&quot;omp declare simd&quot;), c);</span>
<span class="lineNum">   17537 </span>            :       TREE_CHAIN (c) = DECL_ATTRIBUTES (fndecl);
<span class="lineNum">   17538 </span><span class="lineCov">        148 :       DECL_ATTRIBUTES (fndecl) = c;</span>
<span class="lineNum">   17539 </span><span class="lineCov">        148 :     }</span>
<span class="lineNum">   17540 </span>            : 
<span class="lineNum">   17541 </span>            :   parser-&gt;tokens = &amp;parser-&gt;tokens_buf[0];
<span class="lineNum">   17542 </span><span class="lineCov">        148 :   parser-&gt;tokens_avail = tokens_avail;</span>
<span class="lineNum">   17543 </span><span class="lineCov">        296 :   if (clauses.exists ())</span>
<span class="lineNum">   17544 </span>            :     clauses[0].type = CPP_PRAGMA;
<span class="lineNum">   17545 </span>            : }
<span class="lineNum">   17546 </span><span class="lineCov">        316 : </span>
<span class="lineNum">   17547 </span>            : 
<span class="lineNum">   17548 </span><span class="lineCov">        168 : /* OpenMP 4.0:</span>
<span class="lineNum">   17549 </span><span class="lineCov">        168 :    # pragma omp declare target new-line</span>
<span class="lineNum">   17550 </span>            :    declarations and definitions
<span class="lineNum">   17551 </span><span class="lineCov">        168 :    # pragma omp end declare target new-line</span>
<span class="lineNum">   17552 </span><span class="lineCov">        168 : </span>
<span class="lineNum">   17553 </span>            :    OpenMP 4.5:
<span class="lineNum">   17554 </span><span class="lineCov">        168 :    # pragma omp declare target ( extended-list ) new-line</span>
<span class="lineNum">   17555 </span><span class="lineCov">       2016 : </span>
<span class="lineNum">   17556 </span>            :    # pragma omp declare target declare-target-clauses[seq] new-line  */
<span class="lineNum">   17557 </span><span class="lineCov">        168 : </span>
<span class="lineNum">   17558 </span><span class="lineCov">        168 : #define OMP_DECLARE_TARGET_CLAUSE_MASK                          \</span>
<span class="lineNum">   17559 </span><span class="lineCov">        142 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_TO)             \</span>
<span class="lineNum">   17560 </span><span class="lineCov">        168 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LINK))</span>
<a name="17561"><span class="lineNum">   17561 </span><span class="lineCov">        168 : </span></a>
<span class="lineNum">   17562 </span><span class="lineCov">        168 : static void</span>
<span class="lineNum">   17563 </span>            : c_parser_omp_declare_target (c_parser *parser)
<span class="lineNum">   17564 </span>            : {
<span class="lineNum">   17565 </span><span class="lineCov">        148 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   17566 </span><span class="lineCov">        148 :   tree clauses = NULL_TREE;</span>
<span class="lineNum">   17567 </span><span class="lineCov">        148 :   if (c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">   17568 </span><span class="lineCov">        148 :     clauses = c_parser_omp_all_clauses (parser, OMP_DECLARE_TARGET_CLAUSE_MASK,</span>
<span class="lineNum">   17569 </span>            :                                         &quot;#pragma omp declare target&quot;);
<span class="lineNum">   17570 </span>            :   else if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))
<span class="lineNum">   17571 </span>            :     {
<span class="lineNum">   17572 </span>            :       clauses = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_TO_DECLARE,
<span class="lineNum">   17573 </span>            :                                               clauses);
<span class="lineNum">   17574 </span>            :       clauses = c_finish_omp_clauses (clauses, C_ORT_OMP);
<span class="lineNum">   17575 </span>            :       c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   17576 </span>            :     }
<span class="lineNum">   17577 </span>            :   else
<span class="lineNum">   17578 </span>            :     {
<span class="lineNum">   17579 </span>            :       c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   17580 </span>            :       current_omp_declare_target_attribute++;
<span class="lineNum">   17581 </span>            :       return;
<span class="lineNum">   17582 </span>            :     }
<span class="lineNum">   17583 </span>            :   if (current_omp_declare_target_attribute)
<span class="lineNum">   17584 </span>            :     error_at (loc, &quot;%&lt;#pragma omp declare target%&gt; with clauses in between &quot;
<span class="lineNum">   17585 </span>            :                    &quot;%&lt;#pragma omp declare target%&gt; without clauses and &quot;
<span class="lineNum">   17586 </span>            :                    &quot;%&lt;#pragma omp end declare target%&gt;&quot;);
<span class="lineNum">   17587 </span><span class="lineCov">         77 :   for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))</span>
<span class="lineNum">   17588 </span>            :     {
<span class="lineNum">   17589 </span><span class="lineCov">         77 :       tree t = OMP_CLAUSE_DECL (c), id;</span>
<span class="lineNum">   17590 </span><span class="lineCov">         77 :       tree at1 = lookup_attribute (&quot;omp declare target&quot;, DECL_ATTRIBUTES (t));</span>
<span class="lineNum">   17591 </span><span class="lineCov">         77 :       tree at2 = lookup_attribute (&quot;omp declare target link&quot;,</span>
<span class="lineNum">   17592 </span><span class="lineCov">        128 :                                    DECL_ATTRIBUTES (t));</span>
<span class="lineNum">   17593 </span>            :       if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINK)
<span class="lineNum">   17594 </span><span class="lineCov">         45 :         {</span>
<span class="lineNum">   17595 </span>            :           id = get_identifier (&quot;omp declare target link&quot;);
<span class="lineNum">   17596 </span><span class="lineCov">         11 :           std::swap (at1, at2);</span>
<span class="lineNum">   17597 </span>            :         }
<span class="lineNum">   17598 </span><span class="lineCov">         11 :       else</span>
<span class="lineNum">   17599 </span><span class="lineCov">         11 :         id = get_identifier (&quot;omp declare target&quot;);</span>
<span class="lineNum">   17600 </span>            :       if (at2)
<span class="lineNum">   17601 </span>            :         {
<span class="lineNum">   17602 </span>            :           error_at (OMP_CLAUSE_LOCATION (c),
<span class="lineNum">   17603 </span><span class="lineCov">         34 :                     &quot;%qD specified both in declare target %&lt;link%&gt; and %&lt;to%&gt;&quot;</span>
<span class="lineNum">   17604 </span><span class="lineCov">         34 :                     &quot; clauses&quot;, t);</span>
<span class="lineNum">   17605 </span><span class="lineCov">         34 :           continue;</span>
<span class="lineNum">   17606 </span>            :         }
<span class="lineNum">   17607 </span><span class="lineCov">         43 :       if (!at1)</span>
<span class="lineNum">   17608 </span><span class="lineCov">          1 :         {</span>
<span class="lineNum">   17609 </span>            :           DECL_ATTRIBUTES (t) = tree_cons (id, NULL_TREE, DECL_ATTRIBUTES (t));
<span class="lineNum">   17610 </span>            :           if (TREE_CODE (t) != FUNCTION_DECL &amp;&amp; !is_global_var (t))
<span class="lineNum">   17611 </span><span class="lineCov">        107 :             continue;</span>
<span class="lineNum">   17612 </span>            : 
<span class="lineNum">   17613 </span><span class="lineCov">         64 :           symtab_node *node = symtab_node::get (t);</span>
<span class="lineNum">   17614 </span><span class="lineCov">         64 :           if (node != NULL)</span>
<span class="lineNum">   17615 </span><span class="lineCov">        128 :             {</span>
<span class="lineNum">   17616 </span><span class="lineCov">         64 :               node-&gt;offloadable = 1;</span>
<span class="lineNum">   17617 </span><span class="lineCov">         64 :               if (ENABLE_OFFLOADING)</span>
<span class="lineNum">   17618 </span>            :                 {
<span class="lineNum">   17619 </span><span class="lineCov">         10 :                   g-&gt;have_offload = true;</span>
<span class="lineNum">   17620 </span><span class="lineCov">         10 :                   if (is_a &lt;varpool_node *&gt; (node))</span>
<span class="lineNum">   17621 </span>            :                     vec_safe_push (offload_vars, t);
<span class="lineNum">   17622 </span>            :                 }
<span class="lineNum">   17623 </span><span class="lineCov">         54 :             }</span>
<span class="lineNum">   17624 </span><span class="lineCov">         64 :         }</span>
<span class="lineNum">   17625 </span>            :     }
<span class="lineNum">   17626 </span><span class="lineCov">          1 : }</span>
<a name="17627"><span class="lineNum">   17627 </span>            : </a>
<span class="lineNum">   17628 </span>            : static void
<span class="lineNum">   17629 </span><span class="lineCov">          1 : c_parser_omp_end_declare_target (c_parser *parser)</span>
<span class="lineNum">   17630 </span>            : {
<span class="lineNum">   17631 </span><span class="lineCov">         63 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   17632 </span>            :   c_parser_consume_pragma (parser);
<span class="lineNum">   17633 </span><span class="lineCov">         58 :   if (c_parser_next_token_is (parser, CPP_NAME)</span>
<span class="lineNum">   17634 </span><span class="lineCov">         58 :       &amp;&amp; strcmp (IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value),</span>
<span class="lineNum">   17635 </span>            :                  &quot;declare&quot;) == 0)
<span class="lineNum">   17636 </span>            :     {
<span class="lineNum">   17637 </span><span class="lineCov">         57 :       c_parser_consume_token (parser);</span>
<span class="lineNum">   17638 </span><span class="lineCov">         57 :       if (c_parser_next_token_is (parser, CPP_NAME)</span>
<span class="lineNum">   17639 </span>            :           &amp;&amp; strcmp (IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value),
<span class="lineNum">   17640 </span><span class="lineCov">         44 :                      &quot;target&quot;) == 0)</span>
<span class="lineNum">   17641 </span><span class="lineCov">         44 :         c_parser_consume_token (parser);</span>
<span class="lineNum">   17642 </span>            :       else
<span class="lineNum">   17643 </span>            :         {
<span class="lineNum">   17644 </span>            :           c_parser_error (parser, &quot;expected %&lt;target%&gt;&quot;);
<span class="lineNum">   17645 </span>            :           c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   17646 </span>            :           return;
<span class="lineNum">   17647 </span>            :         }
<span class="lineNum">   17648 </span>            :     }
<span class="lineNum">   17649 </span>            :   else
<span class="lineNum">   17650 </span>            :     {
<span class="lineNum">   17651 </span>            :       c_parser_error (parser, &quot;expected %&lt;declare%&gt;&quot;);
<span class="lineNum">   17652 </span>            :       c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   17653 </span><span class="lineCov">         34 :       return;</span>
<span class="lineNum">   17654 </span>            :     }
<span class="lineNum">   17655 </span><span class="lineCov">         34 :   c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   17656 </span><span class="lineCov">         34 :   if (!current_omp_declare_target_attribute)</span>
<span class="lineNum">   17657 </span><span class="lineCov">         34 :     error_at (loc, &quot;%&lt;#pragma omp end declare target%&gt; without corresponding &quot;</span>
<span class="lineNum">   17658 </span><span class="lineCov">         34 :                    &quot;%&lt;#pragma omp declare target%&gt;&quot;);</span>
<span class="lineNum">   17659 </span>            :   else
<span class="lineNum">   17660 </span>            :     current_omp_declare_target_attribute--;
<span class="lineNum">   17661 </span><span class="lineCov">         34 : }</span>
<span class="lineNum">   17662 </span><span class="lineCov">         34 : </span>
<span class="lineNum">   17663 </span><span class="lineCov">         34 : </span>
<span class="lineNum">   17664 </span>            : /* OpenMP 4.0
<span class="lineNum">   17665 </span><span class="lineCov">         34 :    #pragma omp declare reduction (reduction-id : typename-list : expression) \</span>
<span class="lineNum">   17666 </span>            :       initializer-clause[opt] new-line
<span class="lineNum">   17667 </span>            : 
<span class="lineNum">   17668 </span><span class="lineNoCov">          0 :    initializer-clause:</span>
<span class="lineNum">   17669 </span><span class="lineNoCov">          0 :       initializer (omp_priv = initializer)</span>
<span class="lineNum">   17670 </span><span class="lineNoCov">          0 :       initializer (function-name (argument-list))  */</span>
<a name="17671"><span class="lineNum">   17671 </span>            : </a>
<span class="lineNum">   17672 </span>            : static void
<span class="lineNum">   17673 </span>            : c_parser_omp_declare_reduction (c_parser *parser, enum pragma_context context)
<span class="lineNum">   17674 </span>            : {
<span class="lineNum">   17675 </span><span class="lineNoCov">          0 :   unsigned int tokens_avail = 0, i;</span>
<span class="lineNum">   17676 </span><span class="lineNoCov">          0 :   vec&lt;tree&gt; types = vNULL;</span>
<span class="lineNum">   17677 </span><span class="lineNoCov">          0 :   vec&lt;c_token&gt; clauses = vNULL;</span>
<span class="lineNum">   17678 </span>            :   enum tree_code reduc_code = ERROR_MARK;
<span class="lineNum">   17679 </span><span class="lineCov">         34 :   tree reduc_id = NULL_TREE;</span>
<span class="lineNum">   17680 </span><span class="lineCov">         34 :   tree type;</span>
<span class="lineNum">   17681 </span><span class="lineNoCov">          0 :   location_t rloc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   17682 </span>            : 
<span class="lineNum">   17683 </span>            :   if (context == pragma_struct || context == pragma_param)
<span class="lineNum">   17684 </span><span class="lineCov">         34 :     {</span>
<span class="lineNum">   17685 </span>            :       error (&quot;%&lt;#pragma omp declare reduction%&gt; not at file or block scope&quot;);
<span class="lineNum">   17686 </span>            :       goto fail;
<span class="lineNum">   17687 </span>            :     }
<span class="lineNum">   17688 </span>            : 
<span class="lineNum">   17689 </span>            :   if (!c_parser_require (parser, CPP_OPEN_PAREN, &quot;expected %&lt;(%&gt;&quot;))
<span class="lineNum">   17690 </span>            :     goto fail;
<span class="lineNum">   17691 </span>            : 
<span class="lineNum">   17692 </span>            :   switch (c_parser_peek_token (parser)-&gt;type)
<span class="lineNum">   17693 </span>            :     {
<span class="lineNum">   17694 </span>            :     case CPP_PLUS:
<span class="lineNum">   17695 </span>            :       reduc_code = PLUS_EXPR;
<span class="lineNum">   17696 </span>            :       break;
<span class="lineNum">   17697 </span><span class="lineCov">        127 :     case CPP_MULT:</span>
<span class="lineNum">   17698 </span>            :       reduc_code = MULT_EXPR;
<span class="lineNum">   17699 </span><span class="lineCov">        127 :       break;</span>
<span class="lineNum">   17700 </span><span class="lineCov">        127 :     case CPP_MINUS:</span>
<span class="lineNum">   17701 </span><span class="lineCov">        127 :       reduc_code = MINUS_EXPR;</span>
<span class="lineNum">   17702 </span><span class="lineCov">        127 :       break;</span>
<span class="lineNum">   17703 </span><span class="lineCov">        127 :     case CPP_AND:</span>
<span class="lineNum">   17704 </span><span class="lineCov">        127 :       reduc_code = BIT_AND_EXPR;</span>
<span class="lineNum">   17705 </span><span class="lineCov">        127 :       break;</span>
<span class="lineNum">   17706 </span>            :     case CPP_XOR:
<span class="lineNum">   17707 </span><span class="lineCov">        127 :       reduc_code = BIT_XOR_EXPR;</span>
<span class="lineNum">   17708 </span>            :       break;
<span class="lineNum">   17709 </span><span class="lineCov">          2 :     case CPP_OR:</span>
<span class="lineNum">   17710 </span><span class="lineCov">          2 :       reduc_code = BIT_IOR_EXPR;</span>
<span class="lineNum">   17711 </span>            :       break;
<span class="lineNum">   17712 </span>            :     case CPP_AND_AND:
<span class="lineNum">   17713 </span><span class="lineCov">        125 :       reduc_code = TRUTH_ANDIF_EXPR;</span>
<span class="lineNum">   17714 </span>            :       break;
<span class="lineNum">   17715 </span>            :     case CPP_OR_OR:
<span class="lineNum">   17716 </span><span class="lineCov">        125 :       reduc_code = TRUTH_ORIF_EXPR;</span>
<span class="lineNum">   17717 </span>            :       break;
<span class="lineNum">   17718 </span>            :     case CPP_NAME:
<span class="lineNum">   17719 </span>            :       const char *p;
<span class="lineNum">   17720 </span>            :       p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   17721 </span><span class="lineCov">         10 :       if (strcmp (p, &quot;min&quot;) == 0)</span>
<span class="lineNum">   17722 </span><span class="lineCov">         10 :         {</span>
<span class="lineNum">   17723 </span><span class="lineCov">         10 :           reduc_code = MIN_EXPR;</span>
<span class="lineNum">   17724 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   17725 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   17726 </span><span class="lineNoCov">          0 :       if (strcmp (p, &quot;max&quot;) == 0)</span>
<span class="lineNum">   17727 </span><span class="lineCov">          4 :         {</span>
<span class="lineNum">   17728 </span><span class="lineCov">          4 :           reduc_code = MAX_EXPR;</span>
<span class="lineNum">   17729 </span><span class="lineCov">          4 :           break;</span>
<span class="lineNum">   17730 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   17731 </span><span class="lineNoCov">          0 :       reduc_id = c_parser_peek_token (parser)-&gt;value;</span>
<span class="lineNum">   17732 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   17733 </span><span class="lineCov">         10 :     default:</span>
<span class="lineNum">   17734 </span><span class="lineCov">         10 :       c_parser_error (parser,</span>
<span class="lineNum">   17735 </span><span class="lineCov">         10 :                       &quot;expected %&lt;+%&gt;, %&lt;*%&gt;, %&lt;-%&gt;, %&lt;&amp;%&gt;, &quot;</span>
<span class="lineNum">   17736 </span><span class="lineNoCov">          0 :                       &quot;%&lt;^%&gt;, %&lt;|%&gt;, %&lt;&amp;&amp;%&gt;, %&lt;||%&gt; or identifier&quot;);</span>
<span class="lineNum">   17737 </span><span class="lineNoCov">          0 :       goto fail;</span>
<span class="lineNum">   17738 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   17739 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   17740 </span><span class="lineNoCov">          0 :   tree orig_reduc_id, reduc_decl;</span>
<span class="lineNum">   17741 </span><span class="lineNoCov">          0 :   orig_reduc_id = reduc_id;</span>
<span class="lineNum">   17742 </span><span class="lineCov">         67 :   reduc_id = c_omp_reduction_id (reduc_code, reduc_id);</span>
<span class="lineNum">   17743 </span><span class="lineCov">         67 :   reduc_decl = c_omp_reduction_decl (reduc_id);</span>
<span class="lineNum">   17744 </span><span class="lineCov">         67 :   c_parser_consume_token (parser);</span>
<span class="lineNum">   17745 </span><span class="lineCov">         67 : </span>
<span class="lineNum">   17746 </span>            :   if (!c_parser_require (parser, CPP_COLON, &quot;expected %&lt;:%&gt;&quot;))
<span class="lineNum">   17747 </span>            :     goto fail;
<span class="lineNum">   17748 </span>            : 
<span class="lineNum">   17749 </span>            :   while (true)
<span class="lineNum">   17750 </span><span class="lineCov">         61 :     {</span>
<span class="lineNum">   17751 </span>            :       location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   17752 </span>            :       struct c_type_name *ctype = c_parser_type_name (parser);
<span class="lineNum">   17753 </span>            :       if (ctype != NULL)
<span class="lineNum">   17754 </span>            :         {
<span class="lineNum">   17755 </span><span class="lineCov">         61 :           type = groktypename (ctype, NULL, NULL);</span>
<span class="lineNum">   17756 </span><span class="lineCov">         61 :           if (type == error_mark_node)</span>
<span class="lineNum">   17757 </span><span class="lineNoCov">          0 :             ;</span>
<span class="lineNum">   17758 </span><span class="lineNoCov">          0 :           else if ((INTEGRAL_TYPE_P (type)</span>
<span class="lineNum">   17759 </span>            :                     || TREE_CODE (type) == REAL_TYPE
<span class="lineNum">   17760 </span>            :                     || TREE_CODE (type) == COMPLEX_TYPE)
<span class="lineNum">   17761 </span><span class="lineNoCov">          0 :                    &amp;&amp; orig_reduc_id == NULL_TREE)</span>
<span class="lineNum">   17762 </span>            :             error_at (loc, &quot;predeclared arithmetic type in &quot;
<span class="lineNum">   17763 </span>            :                            &quot;%&lt;#pragma omp declare reduction%&gt;&quot;);
<span class="lineNum">   17764 </span><span class="lineCov">        125 :           else if (TREE_CODE (type) == FUNCTION_TYPE</span>
<span class="lineNum">   17765 </span><span class="lineCov">        125 :                    || TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">   17766 </span><span class="lineCov">        125 :             error_at (loc, &quot;function or array type in &quot;</span>
<span class="lineNum">   17767 </span><span class="lineCov">        125 :                       &quot;%&lt;#pragma omp declare reduction%&gt;&quot;);</span>
<span class="lineNum">   17768 </span><span class="lineCov">        125 :           else if (TYPE_ATOMIC (type))</span>
<span class="lineNum">   17769 </span>            :             error_at (loc, &quot;%&lt;_Atomic%&gt; qualified type in &quot;
<span class="lineNum">   17770 </span><span class="lineCov">        125 :                            &quot;%&lt;#pragma omp declare reduction%&gt;&quot;);</span>
<span class="lineNum">   17771 </span>            :           else if (TYPE_QUALS_NO_ADDR_SPACE (type))
<span class="lineNum">   17772 </span>            :             error_at (loc, &quot;const, volatile or restrict qualified type in &quot;
<span class="lineNum">   17773 </span><span class="lineCov">        127 :                            &quot;%&lt;#pragma omp declare reduction%&gt;&quot;);</span>
<span class="lineNum">   17774 </span>            :           else
<span class="lineNum">   17775 </span><span class="lineCov">        127 :             {</span>
<span class="lineNum">   17776 </span><span class="lineCov">        127 :               tree t;</span>
<span class="lineNum">   17777 </span><span class="lineCov">        127 :               for (t = DECL_INITIAL (reduc_decl); t; t = TREE_CHAIN (t))</span>
<span class="lineNum">   17778 </span>            :                 if (comptypes (TREE_PURPOSE (t), type))
<span class="lineNum">   17779 </span><span class="lineCov">        127 :                   {</span>
<span class="lineNum">   17780 </span><span class="lineCov">        127 :                     error_at (loc, &quot;redeclaration of %qs &quot;</span>
<span class="lineNum">   17781 </span>            :                                    &quot;%&lt;#pragma omp declare reduction%&gt; for &quot;
<span class="lineNum">   17782 </span><span class="lineCov">        254 :                                    &quot;type %qT&quot;,</span>
<span class="lineNum">   17783 </span><span class="lineCov">        127 :                                    IDENTIFIER_POINTER (reduc_id)</span>
<span class="lineNum">   17784 </span><span class="lineCov">         83 :                                    + sizeof (&quot;omp declare reduction &quot;) - 1,</span>
<span class="lineNum">   17785 </span><span class="lineCov">         48 :                                    type);</span>
<span class="lineNum">   17786 </span><span class="lineCov">          8 :                     location_t ploc</span>
<span class="lineNum">   17787 </span>            :                       = DECL_SOURCE_LOCATION (TREE_VEC_ELT (TREE_VALUE (t),
<span class="lineNum">   17788 </span><span class="lineCov">        119 :                                                             0));</span>
<span class="lineNum">   17789 </span><span class="lineCov">        114 :                     error_at (ploc, &quot;previous %&lt;#pragma omp declare &quot;</span>
<span class="lineNum">   17790 </span><span class="lineCov">          8 :                                     &quot;reduction%&gt;&quot;);</span>
<span class="lineNum">   17791 </span>            :                     break;
<span class="lineNum">   17792 </span><span class="lineCov">        111 :                   }</span>
<span class="lineNum">   17793 </span><span class="lineCov">          1 :               if (t == NULL_TREE)</span>
<span class="lineNum">   17794 </span>            :                 types.safe_push (type);
<span class="lineNum">   17795 </span><span class="lineCov">        550 :             }</span>
<span class="lineNum">   17796 </span><span class="lineCov">          8 :           if (c_parser_next_token_is (parser, CPP_COMMA))</span>
<span class="lineNum">   17797 </span>            :             c_parser_consume_token (parser);
<span class="lineNum">   17798 </span>            :           else
<span class="lineNum">   17799 </span>            :             break;
<span class="lineNum">   17800 </span><span class="lineCov">        102 :         }</span>
<span class="lineNum">   17801 </span><span class="lineCov">        163 :       else</span>
<span class="lineNum">   17802 </span><span class="lineCov">         65 :         break;</span>
<span class="lineNum">   17803 </span>            :     }
<span class="lineNum">   17804 </span><span class="lineCov">          8 : </span>
<span class="lineNum">   17805 </span>            :   if (!c_parser_require (parser, CPP_COLON, &quot;expected %&lt;:%&gt;&quot;)
<span class="lineNum">   17806 </span>            :       || types.is_empty ())
<span class="lineNum">   17807 </span><span class="lineCov">          4 :     {</span>
<span class="lineNum">   17808 </span>            :      fail:
<span class="lineNum">   17809 </span>            :       clauses.release ();
<span class="lineNum">   17810 </span><span class="lineCov">          4 :       types.release ();</span>
<span class="lineNum">   17811 </span><span class="lineCov">          4 :       while (true)</span>
<span class="lineNum">   17812 </span>            :         {
<span class="lineNum">   17813 </span><span class="lineCov">          4 :           c_token *token = c_parser_peek_token (parser);</span>
<span class="lineNum">   17814 </span>            :           if (token-&gt;type == CPP_EOF || token-&gt;type == CPP_PRAGMA_EOL)
<span class="lineNum">   17815 </span><span class="lineCov">          4 :             break;</span>
<span class="lineNum">   17816 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   17817 </span><span class="lineCov">        102 :         }</span>
<span class="lineNum">   17818 </span><span class="lineCov">         98 :       c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   17819 </span>            :       return;
<span class="lineNum">   17820 </span><span class="lineCov">        127 :     }</span>
<span class="lineNum">   17821 </span><span class="lineCov">          2 : </span>
<span class="lineNum">   17822 </span>            :   if (types.length () &gt; 1)
<span class="lineNum">   17823 </span>            :     {
<span class="lineNum">   17824 </span>            :       while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))
<span class="lineNum">   17825 </span>            :         {
<span class="lineNum">   17826 </span>            :           c_token *token = c_parser_peek_token (parser);
<span class="lineNum">   17827 </span><span class="lineCov">          2 :           if (token-&gt;type == CPP_EOF)</span>
<span class="lineNum">   17828 </span>            :             goto fail;
<span class="lineNum">   17829 </span><span class="lineCov">        125 :           clauses.safe_push (*token);</span>
<span class="lineNum">   17830 </span><span class="lineCov">        125 :           c_parser_consume_token (parser);</span>
<span class="lineNum">   17831 </span>            :         }
<span class="lineNum">   17832 </span><span class="lineCov">         33 :       clauses.safe_push (*c_parser_peek_token (parser));</span>
<span class="lineNum">   17833 </span><span class="lineCov">         33 :       c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   17834 </span><span class="lineCov">         33 : </span>
<span class="lineNum">   17835 </span><span class="lineCov">        229 :       /* Make sure nothing tries to read past the end of the tokens.  */</span>
<span class="lineNum">   17836 </span>            :       c_token eof_token;
<span class="lineNum">   17837 </span><span class="lineCov">        229 :       memset (&amp;eof_token, 0, sizeof (eof_token));</span>
<span class="lineNum">   17838 </span><span class="lineCov">        229 :       eof_token.type = CPP_EOF;</span>
<span class="lineNum">   17839 </span>            :       clauses.safe_push (eof_token);
<span class="lineNum">   17840 </span><span class="lineCov">        196 :       clauses.safe_push (eof_token);</span>
<span class="lineNum">   17841 </span><span class="lineCov">        196 :     }</span>
<span class="lineNum">   17842 </span><span class="lineCov">         33 : </span>
<span class="lineNum">   17843 </span><span class="lineCov">         33 :   int errs = errorcount;</span>
<span class="lineNum">   17844 </span>            :   FOR_EACH_VEC_ELT (types, i, type)
<span class="lineNum">   17845 </span>            :     {
<span class="lineNum">   17846 </span><span class="lineCov">        192 :       tokens_avail = parser-&gt;tokens_avail;</span>
<span class="lineNum">   17847 </span>            :       gcc_assert (parser-&gt;tokens == &amp;parser-&gt;tokens_buf[0]);
<span class="lineNum">   17848 </span><span class="lineCov">         13 :       if (!clauses.is_empty ())</span>
<span class="lineNum">   17849 </span>            :         {
<span class="lineNum">   17850 </span><span class="lineCov">         12 :           parser-&gt;tokens = clauses.address ();</span>
<span class="lineNum">   17851 </span><span class="lineCov">         12 :           parser-&gt;tokens_avail = clauses.length ();</span>
<span class="lineNum">   17852 </span><span class="lineNoCov">          0 :           parser-&gt;in_pragma = true;</span>
<span class="lineNum">   17853 </span><span class="lineCov">         12 :         }</span>
<span class="lineNum">   17854 </span><span class="lineCov">         12 : </span>
<span class="lineNum">   17855 </span>            :       bool nested = current_function_decl != NULL_TREE;
<span class="lineNum">   17856 </span><span class="lineCov">          1 :       if (nested)</span>
<span class="lineNum">   17857 </span><span class="lineCov">          1 :         c_push_function_context ();</span>
<span class="lineNum">   17858 </span>            :       tree fndecl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,
<span class="lineNum">   17859 </span>            :                                 reduc_id, default_function_type);
<span class="lineNum">   17860 </span><span class="lineCov">          1 :       current_function_decl = fndecl;</span>
<span class="lineNum">   17861 </span><span class="lineCov">          1 :       allocate_struct_function (fndecl, true);</span>
<span class="lineNum">   17862 </span><span class="lineCov">          1 :       push_scope ();</span>
<span class="lineNum">   17863 </span><span class="lineCov">          1 :       tree stmt = push_stmt_list ();</span>
<span class="lineNum">   17864 </span><span class="lineCov">          1 :       /* Intentionally BUILTINS_LOCATION, so that -Wshadow doesn't</span>
<span class="lineNum">   17865 </span>            :          warn about these.  */
<span class="lineNum">   17866 </span>            :       tree omp_out = build_decl (BUILTINS_LOCATION, VAR_DECL,
<span class="lineNum">   17867 </span><span class="lineCov">         96 :                                  get_identifier (&quot;omp_out&quot;), type);</span>
<span class="lineNum">   17868 </span><span class="lineCov">        234 :       DECL_ARTIFICIAL (omp_out) = 1;</span>
<span class="lineNum">   17869 </span>            :       DECL_CONTEXT (omp_out) = fndecl;
<span class="lineNum">   17870 </span><span class="lineCov">         98 :       pushdecl (omp_out);</span>
<span class="lineNum">   17871 </span><span class="lineCov">         98 :       tree omp_in = build_decl (BUILTINS_LOCATION, VAR_DECL,</span>
<span class="lineNum">   17872 </span><span class="lineCov">         98 :                                 get_identifier (&quot;omp_in&quot;), type);</span>
<span class="lineNum">   17873 </span>            :       DECL_ARTIFICIAL (omp_in) = 1;
<span class="lineNum">   17874 </span><span class="lineCov">          3 :       DECL_CONTEXT (omp_in) = fndecl;</span>
<span class="lineNum">   17875 </span><span class="lineCov">          3 :       pushdecl (omp_in);</span>
<span class="lineNum">   17876 </span><span class="lineCov">          3 :       struct c_expr combiner = c_parser_expression (parser);</span>
<span class="lineNum">   17877 </span>            :       struct c_expr initializer;
<span class="lineNum">   17878 </span>            :       tree omp_priv = NULL_TREE, omp_orig = NULL_TREE;
<span class="lineNum">   17879 </span><span class="lineCov">         98 :       bool bad = false;</span>
<span class="lineNum">   17880 </span><span class="lineCov">         98 :       initializer.set_error ();</span>
<span class="lineNum">   17881 </span><span class="lineCov">         24 :       if (!c_parser_require (parser, CPP_CLOSE_PAREN, &quot;expected %&lt;)%&gt;&quot;))</span>
<span class="lineNum">   17882 </span><span class="lineCov">         98 :         bad = true;</span>
<span class="lineNum">   17883 </span>            :       else if (c_parser_next_token_is (parser, CPP_NAME)
<span class="lineNum">   17884 </span><span class="lineCov">         98 :                &amp;&amp; strcmp (IDENTIFIER_POINTER</span>
<span class="lineNum">   17885 </span><span class="lineCov">         98 :                                 (c_parser_peek_token (parser)-&gt;value),</span>
<span class="lineNum">   17886 </span><span class="lineCov">         98 :                           &quot;initializer&quot;) == 0)</span>
<span class="lineNum">   17887 </span><span class="lineCov">         98 :         {</span>
<span class="lineNum">   17888 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   17889 </span>            :           pop_scope ();
<span class="lineNum">   17890 </span><span class="lineCov">         98 :           push_scope ();</span>
<span class="lineNum">   17891 </span><span class="lineCov">         98 :           omp_priv = build_decl (BUILTINS_LOCATION, VAR_DECL,</span>
<span class="lineNum">   17892 </span><span class="lineCov">         98 :                                  get_identifier (&quot;omp_priv&quot;), type);</span>
<span class="lineNum">   17893 </span><span class="lineCov">         98 :           DECL_ARTIFICIAL (omp_priv) = 1;</span>
<span class="lineNum">   17894 </span><span class="lineCov">         98 :           DECL_INITIAL (omp_priv) = error_mark_node;</span>
<span class="lineNum">   17895 </span><span class="lineCov">         98 :           DECL_CONTEXT (omp_priv) = fndecl;</span>
<span class="lineNum">   17896 </span><span class="lineCov">         98 :           pushdecl (omp_priv);</span>
<span class="lineNum">   17897 </span><span class="lineCov">         98 :           omp_orig = build_decl (BUILTINS_LOCATION, VAR_DECL,</span>
<span class="lineNum">   17898 </span><span class="lineCov">         98 :                                  get_identifier (&quot;omp_orig&quot;), type);</span>
<span class="lineNum">   17899 </span><span class="lineCov">         98 :           DECL_ARTIFICIAL (omp_orig) = 1;</span>
<span class="lineNum">   17900 </span><span class="lineCov">         98 :           DECL_CONTEXT (omp_orig) = fndecl;</span>
<span class="lineNum">   17901 </span><span class="lineCov">         98 :           pushdecl (omp_orig);</span>
<span class="lineNum">   17902 </span><span class="lineCov">         98 :           if (!c_parser_require (parser, CPP_OPEN_PAREN, &quot;expected %&lt;(%&gt;&quot;))</span>
<span class="lineNum">   17903 </span><span class="lineCov">         98 :             bad = true;</span>
<span class="lineNum">   17904 </span><span class="lineCov">         98 :           else if (!c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">   17905 </span><span class="lineCov">         98 :             {</span>
<span class="lineNum">   17906 </span>            :               c_parser_error (parser, &quot;expected %&lt;omp_priv%&gt; or &quot;
<span class="lineNum">   17907 </span><span class="lineCov">         98 :                                       &quot;function-name&quot;);</span>
<span class="lineNum">   17908 </span><span class="lineCov">         98 :               bad = true;</span>
<span class="lineNum">   17909 </span>            :             }
<span class="lineNum">   17910 </span>            :           else if (strcmp (IDENTIFIER_POINTER
<span class="lineNum">   17911 </span>            :                                 (c_parser_peek_token (parser)-&gt;value),
<span class="lineNum">   17912 </span><span class="lineCov">         45 :                            &quot;omp_priv&quot;) != 0)</span>
<span class="lineNum">   17913 </span><span class="lineCov">         45 :             {</span>
<span class="lineNum">   17914 </span><span class="lineCov">         45 :               if (c_parser_peek_2nd_token (parser)-&gt;type != CPP_OPEN_PAREN</span>
<span class="lineNum">   17915 </span><span class="lineCov">         45 :                   || c_parser_peek_token (parser)-&gt;id_kind != C_ID_ID)</span>
<span class="lineNum">   17916 </span>            :                 {
<span class="lineNum">   17917 </span><span class="lineCov">         45 :                   c_parser_error (parser, &quot;expected function-name %&lt;(%&gt;&quot;);</span>
<span class="lineNum">   17918 </span><span class="lineCov">         45 :                   bad = true;</span>
<span class="lineNum">   17919 </span><span class="lineCov">         45 :                 }</span>
<span class="lineNum">   17920 </span><span class="lineCov">         45 :               else</span>
<span class="lineNum">   17921 </span><span class="lineCov">         45 :                 initializer = c_parser_postfix_expression (parser);</span>
<span class="lineNum">   17922 </span>            :               if (initializer.value
<span class="lineNum">   17923 </span><span class="lineCov">         45 :                   &amp;&amp; TREE_CODE (initializer.value) == CALL_EXPR)</span>
<span class="lineNum">   17924 </span><span class="lineCov">         45 :                 {</span>
<span class="lineNum">   17925 </span><span class="lineCov">         45 :                   int j;</span>
<span class="lineNum">   17926 </span><span class="lineCov">         45 :                   tree c = initializer.value;</span>
<span class="lineNum">   17927 </span>            :                   for (j = 0; j &lt; call_expr_nargs (c); j++)
<span class="lineNum">   17928 </span><span class="lineCov">         45 :                     {</span>
<span class="lineNum">   17929 </span>            :                       tree a = CALL_EXPR_ARG (c, j);
<span class="lineNum">   17930 </span><span class="lineNoCov">          0 :                       STRIP_NOPS (a);</span>
<span class="lineNum">   17931 </span>            :                       if (TREE_CODE (a) == ADDR_EXPR
<span class="lineNum">   17932 </span><span class="lineNoCov">          0 :                           &amp;&amp; TREE_OPERAND (a, 0) == omp_priv)</span>
<span class="lineNum">   17933 </span>            :                         break;
<span class="lineNum">   17934 </span><span class="lineCov">         45 :                     }</span>
<span class="lineNum">   17935 </span>            :                   if (j == call_expr_nargs (c))
<span class="lineNum">   17936 </span>            :                     error (&quot;one of the initializer call arguments should be &quot;
<span class="lineNum">   17937 </span>            :                            &quot;%&lt;&amp;omp_priv%&gt;&quot;);
<span class="lineNum">   17938 </span><span class="lineCov">         13 :                 }</span>
<span class="lineNum">   17939 </span><span class="lineCov">         13 :             }</span>
<span class="lineNum">   17940 </span>            :           else
<span class="lineNum">   17941 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">   17942 </span><span class="lineNoCov">          0 :               c_parser_consume_token (parser);</span>
<span class="lineNum">   17943 </span>            :               if (!c_parser_require (parser, CPP_EQ, &quot;expected %&lt;=%&gt;&quot;))
<span class="lineNum">   17944 </span>            :                 bad = true;
<span class="lineNum">   17945 </span><span class="lineCov">         13 :               else</span>
<span class="lineNum">   17946 </span><span class="lineCov">         13 :                 {</span>
<span class="lineNum">   17947 </span><span class="lineCov">         13 :                   tree st = push_stmt_list ();</span>
<span class="lineNum">   17948 </span>            :                   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   17949 </span>            :                   rich_location richloc (line_table, loc);
<span class="lineNum">   17950 </span>            :                   start_init (omp_priv, NULL_TREE, 0, &amp;richloc);
<span class="lineNum">   17951 </span><span class="lineCov">         14 :                   struct c_expr init = c_parser_initializer (parser);</span>
<span class="lineNum">   17952 </span>            :                   finish_init ();
<span class="lineNum">   17953 </span><span class="lineCov">         13 :                   finish_decl (omp_priv, loc, init.value,</span>
<span class="lineNum">   17954 </span><span class="lineCov">         13 :                                init.original_type, NULL_TREE);</span>
<span class="lineNum">   17955 </span><span class="lineCov">         13 :                   pop_stmt_list (st);</span>
<span class="lineNum">   17956 </span><span class="lineCov">         13 :                 }</span>
<span class="lineNum">   17957 </span>            :             }
<span class="lineNum">   17958 </span>            :           if (!bad
<span class="lineNum">   17959 </span><span class="lineCov">         13 :               &amp;&amp; !c_parser_require (parser, CPP_CLOSE_PAREN, &quot;expected %&lt;)%&gt;&quot;))</span>
<span class="lineNum">   17960 </span><span class="lineCov">          1 :             bad = true;</span>
<span class="lineNum">   17961 </span>            :         }
<span class="lineNum">   17962 </span>            : 
<span class="lineNum">   17963 </span>            :       if (!bad)
<span class="lineNum">   17964 </span>            :         {
<span class="lineNum">   17965 </span>            :           c_parser_skip_to_pragma_eol (parser);
<span class="lineNum">   17966 </span><span class="lineCov">         32 : </span>
<span class="lineNum">   17967 </span><span class="lineCov">         32 :           tree t = tree_cons (type, make_tree_vec (omp_priv ? 6 : 3),</span>
<span class="lineNum">   17968 </span>            :                               DECL_INITIAL (reduc_decl));
<span class="lineNum">   17969 </span>            :           DECL_INITIAL (reduc_decl) = t;
<span class="lineNum">   17970 </span>            :           DECL_SOURCE_LOCATION (omp_out) = rloc;
<span class="lineNum">   17971 </span><span class="lineCov">         30 :           TREE_VEC_ELT (TREE_VALUE (t), 0) = omp_out;</span>
<span class="lineNum">   17972 </span><span class="lineCov">         30 :           TREE_VEC_ELT (TREE_VALUE (t), 1) = omp_in;</span>
<span class="lineNum">   17973 </span><span class="lineCov">         60 :           TREE_VEC_ELT (TREE_VALUE (t), 2) = combiner.value;</span>
<span class="lineNum">   17974 </span><span class="lineCov">         30 :           walk_tree (&amp;combiner.value, c_check_omp_declare_reduction_r,</span>
<span class="lineNum">   17975 </span><span class="lineCov">         30 :                      &amp;TREE_VEC_ELT (TREE_VALUE (t), 0), NULL);</span>
<span class="lineNum">   17976 </span><span class="lineCov">         30 :           if (omp_priv)</span>
<span class="lineNum">   17977 </span><span class="lineCov">         30 :             {</span>
<span class="lineNum">   17978 </span>            :               DECL_SOURCE_LOCATION (omp_priv) = rloc;
<span class="lineNum">   17979 </span><span class="lineCov">         30 :               TREE_VEC_ELT (TREE_VALUE (t), 3) = omp_priv;</span>
<span class="lineNum">   17980 </span>            :               TREE_VEC_ELT (TREE_VALUE (t), 4) = omp_orig;
<span class="lineNum">   17981 </span>            :               TREE_VEC_ELT (TREE_VALUE (t), 5) = initializer.value;
<span class="lineNum">   17982 </span><span class="lineCov">         30 :               walk_tree (&amp;initializer.value, c_check_omp_declare_reduction_r,</span>
<span class="lineNum">   17983 </span><span class="lineCov">         43 :                          &amp;TREE_VEC_ELT (TREE_VALUE (t), 3), NULL);</span>
<span class="lineNum">   17984 </span>            :               walk_tree (&amp;DECL_INITIAL (omp_priv),
<span class="lineNum">   17985 </span>            :                          c_check_omp_declare_reduction_r,
<span class="lineNum">   17986 </span>            :                          &amp;TREE_VEC_ELT (TREE_VALUE (t), 3), NULL);
<span class="lineNum">   17987 </span><span class="lineCov">         98 :             }</span>
<span class="lineNum">   17988 </span>            :         }
<span class="lineNum">   17989 </span><span class="lineCov">         96 : </span>
<span class="lineNum">   17990 </span>            :       pop_stmt_list (stmt);
<span class="lineNum">   17991 </span><span class="lineCov">         96 :       pop_scope ();</span>
<span class="lineNum">   17992 </span><span class="lineCov">         96 :       if (cfun-&gt;language != NULL)</span>
<span class="lineNum">   17993 </span><span class="lineCov">         96 :         {</span>
<span class="lineNum">   17994 </span><span class="lineCov">         96 :           ggc_free (cfun-&gt;language);</span>
<span class="lineNum">   17995 </span><span class="lineCov">         96 :           cfun-&gt;language = NULL;</span>
<span class="lineNum">   17996 </span><span class="lineCov">         96 :         }</span>
<span class="lineNum">   17997 </span><span class="lineCov">         96 :       set_cfun (NULL);</span>
<span class="lineNum">   17998 </span><span class="lineCov">         96 :       current_function_decl = NULL_TREE;</span>
<span class="lineNum">   17999 </span>            :       if (nested)
<span class="lineNum">   18000 </span><span class="lineCov">         96 :         c_pop_function_context ();</span>
<span class="lineNum">   18001 </span>            : 
<span class="lineNum">   18002 </span><span class="lineCov">         43 :       if (!clauses.is_empty ())</span>
<span class="lineNum">   18003 </span><span class="lineCov">         43 :         {</span>
<span class="lineNum">   18004 </span><span class="lineCov">         43 :           parser-&gt;tokens = &amp;parser-&gt;tokens_buf[0];</span>
<span class="lineNum">   18005 </span><span class="lineCov">         43 :           parser-&gt;tokens_avail = tokens_avail;</span>
<span class="lineNum">   18006 </span><span class="lineCov">         43 :         }</span>
<span class="lineNum">   18007 </span>            :       if (bad)
<span class="lineNum">   18008 </span><span class="lineCov">         43 :         goto fail;</span>
<span class="lineNum">   18009 </span>            :       if (errs != errorcount)
<span class="lineNum">   18010 </span>            :         break;
<span class="lineNum">   18011 </span>            :     }
<span class="lineNum">   18012 </span>            : 
<span class="lineNum">   18013 </span>            :   clauses.release ();
<span class="lineNum">   18014 </span><span class="lineCov">         98 :   types.release ();</span>
<span class="lineNum">   18015 </span><span class="lineCov">         98 : }</span>
<span class="lineNum">   18016 </span><span class="lineCov">         98 : </span>
<span class="lineNum">   18017 </span>            : 
<span class="lineNum">   18018 </span><span class="lineNoCov">          0 : /* OpenMP 4.0</span>
<span class="lineNum">   18019 </span><span class="lineNoCov">          0 :    #pragma omp declare simd declare-simd-clauses[optseq] new-line</span>
<span class="lineNum">   18020 </span>            :    #pragma omp declare reduction (reduction-id : typename-list : expression) \
<span class="lineNum">   18021 </span><span class="lineCov">         98 :       initializer-clause[opt] new-line</span>
<span class="lineNum">   18022 </span><span class="lineCov">         98 :    #pragma omp declare target new-line  */</span>
<a name="18023"><span class="lineNum">   18023 </span><span class="lineCov">         98 : </span></a>
<span class="lineNum">   18024 </span><span class="lineCov">         24 : static void</span>
<span class="lineNum">   18025 </span>            : c_parser_omp_declare (c_parser *parser, enum pragma_context context)
<span class="lineNum">   18026 </span><span class="lineCov">         98 : {</span>
<span class="lineNum">   18027 </span>            :   c_parser_consume_pragma (parser);
<span class="lineNum">   18028 </span><span class="lineCov">          3 :   if (c_parser_next_token_is (parser, CPP_NAME))</span>
<span class="lineNum">   18029 </span><span class="lineCov">          3 :     {</span>
<span class="lineNum">   18030 </span>            :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   18031 </span><span class="lineCov">         98 :       if (strcmp (p, &quot;simd&quot;) == 0)</span>
<span class="lineNum">   18032 </span><span class="lineCov">          2 :         {</span>
<span class="lineNum">   18033 </span><span class="lineCov">         96 :           /* c_parser_consume_token (parser); done in</span>
<span class="lineNum">   18034 </span>            :              c_parser_omp_declare_simd.  */
<span class="lineNum">   18035 </span>            :           c_parser_omp_declare_simd (parser, context);
<span class="lineNum">   18036 </span>            :           return;
<span class="lineNum">   18037 </span><span class="lineCov">         94 :         }</span>
<span class="lineNum">   18038 </span><span class="lineCov">        188 :       if (strcmp (p, &quot;reduction&quot;) == 0)</span>
<span class="lineNum">   18039 </span>            :         {
<span class="lineNum">   18040 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   18041 </span>            :           c_parser_omp_declare_reduction (parser, context);
<span class="lineNum">   18042 </span>            :           return;
<span class="lineNum">   18043 </span>            :         }
<span class="lineNum">   18044 </span>            :       if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   18045 </span>            :         {
<span class="lineNum">   18046 </span>            :           c_parser_skip_to_pragma_eol (parser, false);
<span class="lineNum">   18047 </span>            :           return;
<span class="lineNum">   18048 </span>            :         }
<span class="lineNum">   18049 </span><span class="lineCov">        358 :       if (strcmp (p, &quot;target&quot;) == 0)</span>
<span class="lineNum">   18050 </span>            :         {
<span class="lineNum">   18051 </span><span class="lineCov">        358 :           c_parser_consume_token (parser);</span>
<span class="lineNum">   18052 </span><span class="lineCov">        358 :           c_parser_omp_declare_target (parser);</span>
<span class="lineNum">   18053 </span>            :           return;
<span class="lineNum">   18054 </span><span class="lineCov">        358 :         }</span>
<span class="lineNum">   18055 </span><span class="lineCov">        358 :     }</span>
<span class="lineNum">   18056 </span>            : 
<span class="lineNum">   18057 </span>            :   c_parser_error (parser, &quot;expected %&lt;simd%&gt; or %&lt;reduction%&gt; &quot;
<span class="lineNum">   18058 </span>            :                           &quot;or %&lt;target%&gt;&quot;);
<span class="lineNum">   18059 </span><span class="lineCov">        154 :   c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   18060 </span><span class="lineCov">        154 : }</span>
<span class="lineNum">   18061 </span>            : 
<span class="lineNum">   18062 </span><span class="lineCov">        204 : /* OpenMP 4.5:</span>
<span class="lineNum">   18063 </span>            :    #pragma omp taskloop taskloop-clause[optseq] new-line
<span class="lineNum">   18064 </span><span class="lineCov">        127 :      for-loop</span>
<span class="lineNum">   18065 </span><span class="lineCov">        127 : </span>
<span class="lineNum">   18066 </span><span class="lineCov">        127 :    #pragma omp taskloop simd taskloop-simd-clause[optseq] new-line</span>
<span class="lineNum">   18067 </span>            :      for-loop  */
<span class="lineNum">   18068 </span><span class="lineCov">         77 : </span>
<span class="lineNum">   18069 </span>            : #define OMP_TASKLOOP_CLAUSE_MASK                                \
<span class="lineNum">   18070 </span><span class="lineNoCov">          0 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SHARED) \</span>
<span class="lineNum">   18071 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \</span>
<span class="lineNum">   18072 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \
<span class="lineNum">   18073 </span><span class="lineCov">         77 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LASTPRIVATE)    \</span>
<span class="lineNum">   18074 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEFAULT)        \
<span class="lineNum">   18075 </span><span class="lineCov">         77 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_GRAINSIZE)      \</span>
<span class="lineNum">   18076 </span><span class="lineCov">         77 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NUM_TASKS)      \</span>
<span class="lineNum">   18077 </span><span class="lineCov">         77 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_COLLAPSE)       \</span>
<span class="lineNum">   18078 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_UNTIED) \
<span class="lineNum">   18079 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \
<span class="lineNum">   18080 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FINAL)  \
<span class="lineNum">   18081 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MERGEABLE)      \</span>
<span class="lineNum">   18082 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOGROUP)        \
<span class="lineNum">   18083 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIORITY))</span>
<a name="18084"><span class="lineNum">   18084 </span>            : </a>
<span class="lineNum">   18085 </span>            : static tree
<span class="lineNum">   18086 </span>            : c_parser_omp_taskloop (location_t loc, c_parser *parser,
<span class="lineNum">   18087 </span>            :                        char *p_name, omp_clause_mask mask, tree *cclauses,
<span class="lineNum">   18088 </span>            :                        bool *if_p)
<span class="lineNum">   18089 </span>            : {
<span class="lineNum">   18090 </span>            :   tree clauses, block, ret;
<span class="lineNum">   18091 </span>            : 
<span class="lineNum">   18092 </span>            :   strcat (p_name, &quot; taskloop&quot;);
<span class="lineNum">   18093 </span>            :   mask |= OMP_TASKLOOP_CLAUSE_MASK;
<span class="lineNum">   18094 </span>            : 
<span class="lineNum">   18095 </span>            :   if (c_parser_next_token_is (parser, CPP_NAME))
<span class="lineNum">   18096 </span>            :     {
<span class="lineNum">   18097 </span>            :       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)-&gt;value);
<span class="lineNum">   18098 </span>            : 
<span class="lineNum">   18099 </span>            :       if (strcmp (p, &quot;simd&quot;) == 0)
<span class="lineNum">   18100 </span>            :         {
<span class="lineNum">   18101 </span>            :           tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];
<span class="lineNum">   18102 </span>            :           if (cclauses == NULL)
<span class="lineNum">   18103 </span>            :             cclauses = cclauses_buf;
<span class="lineNum">   18104 </span>            :           mask &amp;= ~(OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_REDUCTION);
<span class="lineNum">   18105 </span>            :           c_parser_consume_token (parser);
<span class="lineNum">   18106 </span>            :           if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   18107 </span>            :             return c_parser_omp_simd (loc, parser, p_name, mask, cclauses,
<span class="lineNum">   18108 </span>            :                                       if_p);
<span class="lineNum">   18109 </span>            :           block = c_begin_compound_stmt (true);
<span class="lineNum">   18110 </span><span class="lineCov">         72 :           ret = c_parser_omp_simd (loc, parser, p_name, mask, cclauses, if_p);</span>
<span class="lineNum">   18111 </span>            :           block = c_end_compound_stmt (loc, block, true);
<span class="lineNum">   18112 </span>            :           if (ret == NULL)
<span class="lineNum">   18113 </span>            :             return ret;
<span class="lineNum">   18114 </span><span class="lineCov">         72 :           ret = make_node (OMP_TASKLOOP);</span>
<span class="lineNum">   18115 </span>            :           TREE_TYPE (ret) = void_type_node;
<span class="lineNum">   18116 </span><span class="lineCov">         72 :           OMP_FOR_BODY (ret) = block;</span>
<span class="lineNum">   18117 </span><span class="lineCov">       2016 :           OMP_FOR_CLAUSES (ret) = cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP];</span>
<span class="lineNum">   18118 </span>            :           SET_EXPR_LOCATION (ret, loc);
<span class="lineNum">   18119 </span><span class="lineCov">         72 :           add_stmt (ret);</span>
<span class="lineNum">   18120 </span>            :           return ret;
<span class="lineNum">   18121 </span><span class="lineCov">         49 :         }</span>
<span class="lineNum">   18122 </span>            :     }
<span class="lineNum">   18123 </span><span class="lineCov">         49 :   if (!flag_openmp)  /* flag_openmp_simd  */</span>
<span class="lineNum">   18124 </span>            :     {
<span class="lineNum">   18125 </span><span class="lineCov">         25 :       c_parser_skip_to_pragma_eol (parser, false);</span>
<span class="lineNum">   18126 </span><span class="lineCov">         25 :       return NULL_TREE;</span>
<span class="lineNum">   18127 </span><span class="lineCov">         25 :     }</span>
<span class="lineNum">   18128 </span><span class="lineCov">         75 : </span>
<span class="lineNum">   18129 </span><span class="lineCov">         25 :   clauses = c_parser_omp_all_clauses (parser, mask, p_name, cclauses == NULL);</span>
<span class="lineNum">   18130 </span><span class="lineCov">         25 :   if (cclauses)</span>
<span class="lineNum">   18131 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   18132 </span><span class="lineNoCov">          0 :       omp_split_clauses (loc, OMP_TASKLOOP, mask, clauses, cclauses);</span>
<span class="lineNum">   18133 </span><span class="lineCov">         25 :       clauses = cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP];</span>
<span class="lineNum">   18134 </span><span class="lineCov">         25 :     }</span>
<span class="lineNum">   18135 </span><span class="lineCov">         25 : </span>
<span class="lineNum">   18136 </span><span class="lineCov">         25 :   block = c_begin_compound_stmt (true);</span>
<span class="lineNum">   18137 </span>            :   ret = c_parser_omp_for_loop (loc, parser, OMP_TASKLOOP, clauses, NULL, if_p);
<span class="lineNum">   18138 </span><span class="lineCov">         25 :   block = c_end_compound_stmt (loc, block, true);</span>
<span class="lineNum">   18139 </span><span class="lineCov">         25 :   add_stmt (block);</span>
<span class="lineNum">   18140 </span><span class="lineCov">         50 : </span>
<span class="lineNum">   18141 </span><span class="lineCov">         50 :   return ret;</span>
<span class="lineNum">   18142 </span><span class="lineCov">         25 : }</span>
<span class="lineNum">   18143 </span><span class="lineCov">         25 : </span>
<span class="lineNum">   18144 </span><span class="lineCov">         25 : /* Main entry point to parsing most OpenMP pragmas.  */</span>
<a name="18145"><span class="lineNum">   18145 </span>            : </a>
<span class="lineNum">   18146 </span>            : static void
<span class="lineNum">   18147 </span><span class="lineCov">         47 : c_parser_omp_construct (c_parser *parser, bool *if_p)</span>
<span class="lineNum">   18148 </span>            : {
<span class="lineNum">   18149 </span><span class="lineNoCov">          0 :   enum pragma_kind p_kind;</span>
<span class="lineNum">   18150 </span><span class="lineNoCov">          0 :   location_t loc;</span>
<span class="lineNum">   18151 </span>            :   tree stmt;
<span class="lineNum">   18152 </span>            :   char p_name[sizeof &quot;#pragma omp teams distribute parallel for simd&quot;];
<span class="lineNum">   18153 </span><span class="lineCov">         47 :   omp_clause_mask mask (0);</span>
<span class="lineNum">   18154 </span><span class="lineCov">         47 : </span>
<span class="lineNum">   18155 </span>            :   loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   18156 </span><span class="lineNoCov">          0 :   p_kind = c_parser_peek_token (parser)-&gt;pragma_kind;</span>
<span class="lineNum">   18157 </span><span class="lineNoCov">          0 :   c_parser_consume_pragma (parser);</span>
<span class="lineNum">   18158 </span>            : 
<span class="lineNum">   18159 </span>            :   switch (p_kind)
<span class="lineNum">   18160 </span><span class="lineCov">         47 :     {</span>
<span class="lineNum">   18161 </span><span class="lineCov">         47 :     case PRAGMA_OACC_ATOMIC:</span>
<span class="lineNum">   18162 </span><span class="lineCov">         47 :       c_parser_omp_atomic (loc, parser);</span>
<span class="lineNum">   18163 </span><span class="lineCov">         47 :       return;</span>
<span class="lineNum">   18164 </span>            :     case PRAGMA_OACC_CACHE:
<span class="lineNum">   18165 </span><span class="lineCov">         47 :       strcpy (p_name, &quot;#pragma acc&quot;);</span>
<span class="lineNum">   18166 </span>            :       stmt = c_parser_oacc_cache (loc, parser);
<span class="lineNum">   18167 </span>            :       break;
<span class="lineNum">   18168 </span>            :     case PRAGMA_OACC_DATA:
<span class="lineNum">   18169 </span>            :       stmt = c_parser_oacc_data (loc, parser, if_p);
<span class="lineNum">   18170 </span>            :       break;
<span class="lineNum">   18171 </span><span class="lineCov">       7868 :     case PRAGMA_OACC_HOST_DATA:</span>
<span class="lineNum">   18172 </span>            :       stmt = c_parser_oacc_host_data (loc, parser, if_p);
<span class="lineNum">   18173 </span><span class="lineCov">       7868 :       break;</span>
<span class="lineNum">   18174 </span><span class="lineCov">       7868 :     case PRAGMA_OACC_KERNELS:</span>
<span class="lineNum">   18175 </span><span class="lineCov">       7868 :     case PRAGMA_OACC_PARALLEL:</span>
<span class="lineNum">   18176 </span><span class="lineCov">       7868 :       strcpy (p_name, &quot;#pragma acc&quot;);</span>
<span class="lineNum">   18177 </span><span class="lineCov">       7868 :       stmt = c_parser_oacc_kernels_parallel (loc, parser, p_kind, p_name,</span>
<span class="lineNum">   18178 </span>            :                                              if_p);
<span class="lineNum">   18179 </span><span class="lineCov">       7868 :       break;</span>
<span class="lineNum">   18180 </span><span class="lineCov">       7868 :     case PRAGMA_OACC_LOOP:</span>
<span class="lineNum">   18181 </span><span class="lineCov">       7868 :       strcpy (p_name, &quot;#pragma acc&quot;);</span>
<span class="lineNum">   18182 </span>            :       stmt = c_parser_oacc_loop (loc, parser, p_name, mask, NULL, if_p);
<span class="lineNum">   18183 </span><span class="lineCov">       7868 :       break;</span>
<span class="lineNum">   18184 </span>            :     case PRAGMA_OACC_WAIT:
<span class="lineNum">   18185 </span><span class="lineCov">        188 :       strcpy (p_name, &quot;#pragma wait&quot;);</span>
<span class="lineNum">   18186 </span><span class="lineCov">        188 :       stmt = c_parser_oacc_wait (loc, parser, p_name);</span>
<span class="lineNum">   18187 </span><span class="lineCov">       1034 :       break;</span>
<span class="lineNum">   18188 </span><span class="lineCov">         68 :     case PRAGMA_OMP_ATOMIC:</span>
<span class="lineNum">   18189 </span><span class="lineCov">         68 :       c_parser_omp_atomic (loc, parser);</span>
<span class="lineNum">   18190 </span><span class="lineCov">         68 :       return;</span>
<span class="lineNum">   18191 </span><span class="lineCov">         68 :     case PRAGMA_OMP_CRITICAL:</span>
<span class="lineNum">   18192 </span><span class="lineCov">        322 :       stmt = c_parser_omp_critical (loc, parser, if_p);</span>
<span class="lineNum">   18193 </span><span class="lineCov">        322 :       break;</span>
<span class="lineNum">   18194 </span><span class="lineCov">        322 :     case PRAGMA_OMP_DISTRIBUTE:</span>
<span class="lineNum">   18195 </span><span class="lineCov">         12 :       strcpy (p_name, &quot;#pragma omp&quot;);</span>
<span class="lineNum">   18196 </span><span class="lineCov">         12 :       stmt = c_parser_omp_distribute (loc, parser, p_name, mask, NULL, if_p);</span>
<span class="lineNum">   18197 </span><span class="lineCov">         12 :       break;</span>
<span class="lineNum">   18198 </span><span class="lineCov">       1472 :     case PRAGMA_OMP_FOR:</span>
<span class="lineNum">   18199 </span><span class="lineCov">       1472 :       strcpy (p_name, &quot;#pragma omp&quot;);</span>
<span class="lineNum">   18200 </span><span class="lineCov">       1472 :       stmt = c_parser_omp_for (loc, parser, p_name, mask, NULL, if_p);</span>
<span class="lineNum">   18201 </span><span class="lineCov">       1472 :       break;</span>
<span class="lineNum">   18202 </span>            :     case PRAGMA_OMP_MASTER:
<span class="lineNum">   18203 </span><span class="lineCov">       1472 :       stmt = c_parser_omp_master (loc, parser, if_p);</span>
<span class="lineNum">   18204 </span><span class="lineCov">        966 :       break;</span>
<span class="lineNum">   18205 </span><span class="lineCov">        966 :     case PRAGMA_OMP_PARALLEL:</span>
<span class="lineNum">   18206 </span><span class="lineCov">        966 :       strcpy (p_name, &quot;#pragma omp&quot;);</span>
<span class="lineNum">   18207 </span><span class="lineCov">        966 :       stmt = c_parser_omp_parallel (loc, parser, p_name, mask, NULL, if_p);</span>
<span class="lineNum">   18208 </span><span class="lineCov">         61 :       break;</span>
<span class="lineNum">   18209 </span><span class="lineCov">         61 :     case PRAGMA_OMP_SECTIONS:</span>
<span class="lineNum">   18210 </span><span class="lineCov">         61 :       strcpy (p_name, &quot;#pragma omp&quot;);</span>
<span class="lineNum">   18211 </span><span class="lineCov">         61 :       stmt = c_parser_omp_sections (loc, parser, p_name, mask, NULL);</span>
<span class="lineNum">   18212 </span><span class="lineCov">        846 :       break;</span>
<span class="lineNum">   18213 </span><span class="lineCov">        846 :     case PRAGMA_OMP_SIMD:</span>
<span class="lineNum">   18214 </span><span class="lineCov">        846 :       strcpy (p_name, &quot;#pragma omp&quot;);</span>
<span class="lineNum">   18215 </span><span class="lineCov">         90 :       stmt = c_parser_omp_simd (loc, parser, p_name, mask, NULL, if_p);</span>
<span class="lineNum">   18216 </span><span class="lineCov">         90 :       break;</span>
<span class="lineNum">   18217 </span><span class="lineCov">         90 :     case PRAGMA_OMP_SINGLE:</span>
<span class="lineNum">   18218 </span><span class="lineCov">        433 :       stmt = c_parser_omp_single (loc, parser, if_p);</span>
<span class="lineNum">   18219 </span><span class="lineCov">        433 :       break;</span>
<span class="lineNum">   18220 </span><span class="lineCov">        433 :     case PRAGMA_OMP_TASK:</span>
<span class="lineNum">   18221 </span><span class="lineCov">        433 :       stmt = c_parser_omp_task (loc, parser, if_p);</span>
<span class="lineNum">   18222 </span><span class="lineCov">        786 :       break;</span>
<span class="lineNum">   18223 </span><span class="lineCov">        786 :     case PRAGMA_OMP_TASKGROUP:</span>
<span class="lineNum">   18224 </span><span class="lineCov">        786 :       stmt = c_parser_omp_taskgroup (parser, if_p);</span>
<span class="lineNum">   18225 </span><span class="lineCov">        786 :       break;</span>
<span class="lineNum">   18226 </span><span class="lineCov">         57 :     case PRAGMA_OMP_TASKLOOP:</span>
<span class="lineNum">   18227 </span><span class="lineCov">         57 :       strcpy (p_name, &quot;#pragma omp&quot;);</span>
<span class="lineNum">   18228 </span><span class="lineCov">         57 :       stmt = c_parser_omp_taskloop (loc, parser, p_name, mask, NULL, if_p);</span>
<span class="lineNum">   18229 </span><span class="lineCov">       1212 :       break;</span>
<span class="lineNum">   18230 </span><span class="lineCov">       1212 :     case PRAGMA_OMP_TEAMS:</span>
<span class="lineNum">   18231 </span><span class="lineCov">       1212 :       strcpy (p_name, &quot;#pragma omp&quot;);</span>
<span class="lineNum">   18232 </span><span class="lineCov">       1212 :       stmt = c_parser_omp_teams (loc, parser, p_name, mask, NULL, if_p);</span>
<span class="lineNum">   18233 </span><span class="lineCov">         76 :       break;</span>
<span class="lineNum">   18234 </span><span class="lineCov">         76 :     default:</span>
<span class="lineNum">   18235 </span><span class="lineCov">         76 :       gcc_unreachable ();</span>
<span class="lineNum">   18236 </span><span class="lineCov">         76 :     }</span>
<span class="lineNum">   18237 </span><span class="lineCov">        252 : </span>
<span class="lineNum">   18238 </span><span class="lineCov">        252 :   if (stmt)</span>
<span class="lineNum">   18239 </span><span class="lineCov">        252 :     gcc_assert (EXPR_LOCATION (stmt) != UNKNOWN_LOCATION);</span>
<span class="lineNum">   18240 </span><span class="lineCov">        252 : }</span>
<span class="lineNum">   18241 </span><span class="lineCov">        150 : </span>
<span class="lineNum">   18242 </span><span class="lineCov">        150 : </span>
<span class="lineNum">   18243 </span><span class="lineCov">        150 : /* OpenMP 2.5:</span>
<span class="lineNum">   18244 </span><span class="lineCov">        321 :    # pragma omp threadprivate (variable-list) */</span>
<a name="18245"><span class="lineNum">   18245 </span><span class="lineCov">        321 : </span></a>
<span class="lineNum">   18246 </span><span class="lineCov">        321 : static void</span>
<span class="lineNum">   18247 </span><span class="lineCov">         35 : c_parser_omp_threadprivate (c_parser *parser)</span>
<span class="lineNum">   18248 </span><span class="lineCov">         35 : {</span>
<span class="lineNum">   18249 </span><span class="lineCov">         35 :   tree vars, t;</span>
<span class="lineNum">   18250 </span><span class="lineCov">         72 :   location_t loc;</span>
<span class="lineNum">   18251 </span><span class="lineCov">         72 : </span>
<span class="lineNum">   18252 </span><span class="lineCov">         72 :   c_parser_consume_pragma (parser);</span>
<span class="lineNum">   18253 </span><span class="lineCov">         72 :   loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   18254 </span><span class="lineCov">        449 :   vars = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);</span>
<span class="lineNum">   18255 </span><span class="lineCov">        449 : </span>
<span class="lineNum">   18256 </span><span class="lineCov">        449 :   /* Mark every variable in VARS to be assigned thread local storage.  */</span>
<span class="lineNum">   18257 </span><span class="lineCov">        449 :   for (t = vars; t; t = TREE_CHAIN (t))</span>
<span class="lineNum">   18258 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   18259 </span><span class="lineNoCov">          0 :       tree v = TREE_PURPOSE (t);</span>
<span class="lineNum">   18260 </span>            : 
<span class="lineNum">   18261 </span>            :       /* FIXME diagnostics: Ideally we should keep individual
<span class="lineNum">   18262 </span><span class="lineCov">       6834 :          locations for all the variables in the var list to make the</span>
<span class="lineNum">   18263 </span><span class="lineCov">       6704 :          following errors more precise.  Perhaps</span>
<span class="lineNum">   18264 </span>            :          c_parser_omp_var_list_parens() should construct a list of
<span class="lineNum">   18265 </span>            :          locations to go along with the var list.  */
<span class="lineNum">   18266 </span>            : 
<span class="lineNum">   18267 </span>            :       /* If V had already been marked threadprivate, it doesn't matter
<span class="lineNum">   18268 </span>            :          whether it had been used prior to this point.  */
<span class="lineNum">   18269 </span>            :       if (!VAR_P (v))
<span class="lineNum">   18270 </span>            :         error_at (loc, &quot;%qD is not a variable&quot;, v);
<span class="lineNum">   18271 </span><span class="lineCov">         40 :       else if (TREE_USED (v) &amp;&amp; !C_DECL_THREADPRIVATE_P (v))</span>
<span class="lineNum">   18272 </span>            :         error_at (loc, &quot;%qE declared %&lt;threadprivate%&gt; after first use&quot;, v);
<span class="lineNum">   18273 </span><span class="lineCov">         40 :       else if (! is_global_var (v))</span>
<span class="lineNum">   18274 </span><span class="lineCov">         40 :         error_at (loc, &quot;automatic variable %qE cannot be %&lt;threadprivate%&gt;&quot;, v);</span>
<span class="lineNum">   18275 </span>            :       else if (TREE_TYPE (v) == error_mark_node)
<span class="lineNum">   18276 </span><span class="lineCov">         40 :         ;</span>
<span class="lineNum">   18277 </span><span class="lineCov">         40 :       else if (! COMPLETE_TYPE_P (TREE_TYPE (v)))</span>
<span class="lineNum">   18278 </span><span class="lineCov">         40 :         error_at (loc, &quot;%&lt;threadprivate%&gt; %qE has incomplete type&quot;, v);</span>
<span class="lineNum">   18279 </span>            :       else
<span class="lineNum">   18280 </span>            :         {
<span class="lineNum">   18281 </span><span class="lineCov">         87 :           if (! DECL_THREAD_LOCAL_P (v))</span>
<span class="lineNum">   18282 </span>            :             {
<span class="lineNum">   18283 </span><span class="lineCov">         47 :               set_decl_tls_model (v, decl_default_tls_model (v));</span>
<span class="lineNum">   18284 </span>            :               /* If rtl has been already set for this var, call
<span class="lineNum">   18285 </span>            :                  make_decl_rtl once again, so that encode_section_info
<span class="lineNum">   18286 </span>            :                  has a chance to look at the new decl flags.  */
<span class="lineNum">   18287 </span>            :               if (DECL_RTL_SET_P (v))
<span class="lineNum">   18288 </span>            :                 make_decl_rtl (v);
<span class="lineNum">   18289 </span>            :             }
<span class="lineNum">   18290 </span>            :           C_DECL_THREADPRIVATE_P (v) = 1;
<span class="lineNum">   18291 </span>            :         }
<span class="lineNum">   18292 </span>            :     }
<span class="lineNum">   18293 </span><span class="lineCov">         47 : </span>
<span class="lineNum">   18294 </span><span class="lineCov">          1 :   c_parser_skip_to_pragma_eol (parser);</span>
<span class="lineNum">   18295 </span><span class="lineCov">         46 : }</span>
<span class="lineNum">   18296 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   18297 </span><span class="lineCov">         45 : /* Parse a transaction attribute (GCC Extension).</span>
<span class="lineNum">   18298 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   18299 </span><span class="lineCov">         44 :    transaction-attribute:</span>
<span class="lineNum">   18300 </span>            :      attributes
<span class="lineNum">   18301 </span><span class="lineCov">         86 :      [ [ any-word ] ]</span>
<span class="lineNum">   18302 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   18303 </span>            :    The transactional memory language description is written for C++,
<span class="lineNum">   18304 </span>            :    and uses the C++0x attribute syntax.  For compatibility, allow the
<span class="lineNum">   18305 </span><span class="lineCov">         42 :    bracket style for transactions in C as well.  */</span>
<a name="18306"><span class="lineNum">   18306 </span>            : </a>
<span class="lineNum">   18307 </span><span class="lineCov">         42 : static tree</span>
<span class="lineNum">   18308 </span>            : c_parser_transaction_attributes (c_parser *parser)
<span class="lineNum">   18309 </span>            : {
<span class="lineNum">   18310 </span>            :   tree attr_name, attr = NULL;
<span class="lineNum">   18311 </span><span class="lineCov">         42 : </span>
<span class="lineNum">   18312 </span><span class="lineNoCov">          0 :   if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))</span>
<span class="lineNum">   18313 </span>            :     return c_parser_attributes (parser);
<span class="lineNum">   18314 </span><span class="lineCov">         42 : </span>
<span class="lineNum">   18315 </span>            :   if (!c_parser_next_token_is (parser, CPP_OPEN_SQUARE))
<span class="lineNum">   18316 </span>            :     return NULL_TREE;
<span class="lineNum">   18317 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">   18318 </span><span class="lineCov">         40 :   if (!c_parser_require (parser, CPP_OPEN_SQUARE, &quot;expected %&lt;[%&gt;&quot;))</span>
<span class="lineNum">   18319 </span><span class="lineCov">         40 :     goto error1;</span>
<span class="lineNum">   18320 </span>            : 
<span class="lineNum">   18321 </span>            :   attr_name = c_parser_attribute_any_word (parser);
<span class="lineNum">   18322 </span>            :   if (attr_name)
<span class="lineNum">   18323 </span>            :     {
<span class="lineNum">   18324 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   18325 </span>            :       attr = build_tree_list (attr_name, NULL_TREE);
<span class="lineNum">   18326 </span>            :     }
<span class="lineNum">   18327 </span>            :   else
<span class="lineNum">   18328 </span>            :     c_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">   18329 </span>            : 
<span class="lineNum">   18330 </span>            :   c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, &quot;expected %&lt;]%&gt;&quot;);
<span class="lineNum">   18331 </span>            :  error1:
<span class="lineNum">   18332 </span><span class="lineCov">        128 :   c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, &quot;expected %&lt;]%&gt;&quot;);</span>
<span class="lineNum">   18333 </span>            :   return attr;
<span class="lineNum">   18334 </span><span class="lineCov">        128 : }</span>
<span class="lineNum">   18335 </span>            : 
<span class="lineNum">   18336 </span><span class="lineCov">        128 : /* Parse a __transaction_atomic or __transaction_relaxed statement</span>
<span class="lineNum">   18337 </span><span class="lineNoCov">          0 :    (GCC Extension).</span>
<span class="lineNum">   18338 </span>            : 
<span class="lineNum">   18339 </span><span class="lineCov">        128 :    transaction-statement:</span>
<span class="lineNum">   18340 </span>            :      __transaction_atomic transaction-attribute[opt] compound-statement
<span class="lineNum">   18341 </span><span class="lineCov">         12 :      __transaction_relaxed compound-statement</span>
<span class="lineNum">   18342 </span><span class="lineCov">         12 : </span>
<span class="lineNum">   18343 </span>            :    Note that the only valid attribute is: &quot;outer&quot;.
<span class="lineNum">   18344 </span>            : */
<a name="18345"><span class="lineNum">   18345 </span><span class="lineCov">         12 : </span></a>
<span class="lineNum">   18346 </span><span class="lineCov">         12 : static tree</span>
<span class="lineNum">   18347 </span>            : c_parser_transaction (c_parser *parser, enum rid keyword)
<span class="lineNum">   18348 </span><span class="lineCov">         12 : {</span>
<span class="lineNum">   18349 </span><span class="lineCov">         12 :   unsigned int old_in = parser-&gt;in_transaction;</span>
<span class="lineNum">   18350 </span>            :   unsigned int this_in = 1, new_in;
<span class="lineNum">   18351 </span>            :   location_t loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   18352 </span><span class="lineNoCov">          0 :   tree stmt, attrs;</span>
<span class="lineNum">   18353 </span>            : 
<span class="lineNum">   18354 </span><span class="lineCov">         12 :   gcc_assert ((keyword == RID_TRANSACTION_ATOMIC</span>
<span class="lineNum">   18355 </span><span class="lineCov">         12 :       || keyword == RID_TRANSACTION_RELAXED)</span>
<span class="lineNum">   18356 </span><span class="lineCov">         12 :       &amp;&amp; c_parser_next_token_is_keyword (parser, keyword));</span>
<span class="lineNum">   18357 </span><span class="lineCov">         12 :   c_parser_consume_token (parser);</span>
<span class="lineNum">   18358 </span>            : 
<span class="lineNum">   18359 </span>            :   if (keyword == RID_TRANSACTION_RELAXED)
<span class="lineNum">   18360 </span>            :     this_in |= TM_STMT_ATTR_RELAXED;
<span class="lineNum">   18361 </span>            :   else
<span class="lineNum">   18362 </span>            :     {
<span class="lineNum">   18363 </span>            :       attrs = c_parser_transaction_attributes (parser);
<span class="lineNum">   18364 </span>            :       if (attrs)
<span class="lineNum">   18365 </span>            :         this_in |= parse_tm_stmt_attr (attrs, TM_STMT_ATTR_OUTER);
<span class="lineNum">   18366 </span>            :     }
<span class="lineNum">   18367 </span>            : 
<span class="lineNum">   18368 </span>            :   /* Keep track if we're in the lexical scope of an outer transaction.  */
<span class="lineNum">   18369 </span>            :   new_in = this_in | (old_in &amp; TM_STMT_ATTR_OUTER);
<span class="lineNum">   18370 </span>            : 
<span class="lineNum">   18371 </span><span class="lineCov">        128 :   parser-&gt;in_transaction = new_in;</span>
<span class="lineNum">   18372 </span>            :   stmt = c_parser_compound_statement (parser);
<span class="lineNum">   18373 </span><span class="lineCov">        128 :   parser-&gt;in_transaction = old_in;</span>
<span class="lineNum">   18374 </span><span class="lineCov">        128 : </span>
<span class="lineNum">   18375 </span><span class="lineCov">        128 :   if (flag_tm)</span>
<span class="lineNum">   18376 </span><span class="lineCov">        128 :     stmt = c_finish_transaction (loc, stmt, this_in);</span>
<span class="lineNum">   18377 </span>            :   else
<span class="lineNum">   18378 </span><span class="lineCov">        128 :     error_at (loc, (keyword == RID_TRANSACTION_ATOMIC ?</span>
<span class="lineNum">   18379 </span>            :         &quot;%&lt;__transaction_atomic%&gt; without transactional memory support enabled&quot;
<span class="lineNum">   18380 </span>            :         : &quot;%&lt;__transaction_relaxed %&gt; &quot;
<span class="lineNum">   18381 </span><span class="lineCov">        128 :         &quot;without transactional memory support enabled&quot;));</span>
<span class="lineNum">   18382 </span>            : 
<span class="lineNum">   18383 </span><span class="lineCov">        128 :   return stmt;</span>
<span class="lineNum">   18384 </span>            : }
<span class="lineNum">   18385 </span>            : 
<span class="lineNum">   18386 </span>            : /* Parse a __transaction_atomic or __transaction_relaxed expression
<span class="lineNum">   18387 </span><span class="lineCov">         97 :    (GCC Extension).</span>
<span class="lineNum">   18388 </span><span class="lineCov">         97 : </span>
<span class="lineNum">   18389 </span><span class="lineCov">          8 :    transaction-expression:</span>
<span class="lineNum">   18390 </span>            :      __transaction_atomic ( expression )
<span class="lineNum">   18391 </span>            :      __transaction_relaxed ( expression )
<span class="lineNum">   18392 </span>            : */
<a name="18393"><span class="lineNum">   18393 </span><span class="lineCov">        128 : </span></a>
<span class="lineNum">   18394 </span>            : static struct c_expr
<span class="lineNum">   18395 </span><span class="lineCov">        128 : c_parser_transaction_expression (c_parser *parser, enum rid keyword)</span>
<span class="lineNum">   18396 </span><span class="lineCov">        128 : {</span>
<span class="lineNum">   18397 </span><span class="lineCov">        128 :   struct c_expr ret;</span>
<span class="lineNum">   18398 </span>            :   unsigned int old_in = parser-&gt;in_transaction;
<span class="lineNum">   18399 </span><span class="lineCov">        128 :   unsigned int this_in = 1;</span>
<span class="lineNum">   18400 </span><span class="lineCov">        126 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   18401 </span>            :   tree attrs;
<span class="lineNum">   18402 </span><span class="lineCov">          2 : </span>
<span class="lineNum">   18403 </span>            :   gcc_assert ((keyword == RID_TRANSACTION_ATOMIC
<span class="lineNum">   18404 </span>            :       || keyword == RID_TRANSACTION_RELAXED)
<span class="lineNum">   18405 </span>            :       &amp;&amp; c_parser_next_token_is_keyword (parser, keyword));
<span class="lineNum">   18406 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">   18407 </span><span class="lineCov">        128 : </span>
<span class="lineNum">   18408 </span>            :   if (keyword == RID_TRANSACTION_RELAXED)
<span class="lineNum">   18409 </span>            :     this_in |= TM_STMT_ATTR_RELAXED;
<span class="lineNum">   18410 </span>            :   else
<span class="lineNum">   18411 </span>            :     {
<span class="lineNum">   18412 </span>            :       attrs = c_parser_transaction_attributes (parser);
<span class="lineNum">   18413 </span>            :       if (attrs)
<span class="lineNum">   18414 </span>            :         this_in |= parse_tm_stmt_attr (attrs, 0);
<span class="lineNum">   18415 </span>            :     }
<span class="lineNum">   18416 </span>            : 
<span class="lineNum">   18417 </span>            :   parser-&gt;in_transaction = this_in;
<span class="lineNum">   18418 </span>            :   matching_parens parens;
<span class="lineNum">   18419 </span><span class="lineCov">          7 :   if (parens.require_open (parser))</span>
<span class="lineNum">   18420 </span>            :     {
<span class="lineNum">   18421 </span><span class="lineCov">          7 :       tree expr = c_parser_expression (parser).value;</span>
<span class="lineNum">   18422 </span><span class="lineCov">          7 :       ret.original_type = TREE_TYPE (expr);</span>
<span class="lineNum">   18423 </span><span class="lineCov">          7 :       ret.value = build1 (TRANSACTION_EXPR, ret.original_type, expr);</span>
<span class="lineNum">   18424 </span><span class="lineCov">          7 :       if (this_in &amp; TM_STMT_ATTR_RELAXED)</span>
<span class="lineNum">   18425 </span><span class="lineCov">          7 :         TRANSACTION_EXPR_RELAXED (ret.value) = 1;</span>
<span class="lineNum">   18426 </span>            :       SET_EXPR_LOCATION (ret.value, loc);
<span class="lineNum">   18427 </span><span class="lineCov">          7 :       ret.original_code = TRANSACTION_EXPR;</span>
<span class="lineNum">   18428 </span>            :       if (!parens.require_close (parser))
<span class="lineNum">   18429 </span>            :         {
<span class="lineNum">   18430 </span><span class="lineCov">          7 :           c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);</span>
<span class="lineNum">   18431 </span>            :           goto error;
<span class="lineNum">   18432 </span><span class="lineCov">          7 :         }</span>
<span class="lineNum">   18433 </span>            :     }
<span class="lineNum">   18434 </span>            :   else
<span class="lineNum">   18435 </span>            :     {
<span class="lineNum">   18436 </span><span class="lineCov">          5 :      error:</span>
<span class="lineNum">   18437 </span><span class="lineCov">          5 :       ret.set_error ();</span>
<span class="lineNum">   18438 </span><span class="lineNoCov">          0 :       ret.original_code = ERROR_MARK;</span>
<span class="lineNum">   18439 </span>            :       ret.original_type = NULL;
<span class="lineNum">   18440 </span>            :     }
<span class="lineNum">   18441 </span><span class="lineCov">          7 :   parser-&gt;in_transaction = old_in;</span>
<span class="lineNum">   18442 </span><span class="lineCov">         14 : </span>
<span class="lineNum">   18443 </span><span class="lineCov">          7 :   if (!flag_tm)</span>
<span class="lineNum">   18444 </span>            :     error_at (loc, (keyword == RID_TRANSACTION_ATOMIC ?
<span class="lineNum">   18445 </span><span class="lineCov">          7 :         &quot;%&lt;__transaction_atomic%&gt; without transactional memory support enabled&quot;</span>
<span class="lineNum">   18446 </span><span class="lineCov">          7 :         : &quot;%&lt;__transaction_relaxed %&gt; &quot;</span>
<span class="lineNum">   18447 </span><span class="lineCov">          7 :         &quot;without transactional memory support enabled&quot;));</span>
<span class="lineNum">   18448 </span><span class="lineCov">          7 : </span>
<span class="lineNum">   18449 </span><span class="lineCov">          2 :   set_c_expr_source_range (&amp;ret, loc, loc);</span>
<span class="lineNum">   18450 </span><span class="lineCov">          7 : </span>
<span class="lineNum">   18451 </span><span class="lineCov">          7 :   return ret;</span>
<span class="lineNum">   18452 </span><span class="lineCov">          7 : }</span>
<span class="lineNum">   18453 </span>            : 
<span class="lineNum">   18454 </span><span class="lineNoCov">          0 : /* Parse a __transaction_cancel statement (GCC Extension).</span>
<span class="lineNum">   18455 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   18456 </span>            :    transaction-cancel-statement:
<span class="lineNum">   18457 </span>            :      __transaction_cancel transaction-attribute[opt] ;
<span class="lineNum">   18458 </span>            : 
<span class="lineNum">   18459 </span>            :    Note that the only valid attribute is &quot;outer&quot;.
<span class="lineNum">   18460 </span><span class="lineNoCov">          0 : */</span>
<a name="18461"><span class="lineNum">   18461 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   18462 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   18463 </span><span class="lineNoCov">          0 : c_parser_transaction_cancel (c_parser *parser)</span>
<span class="lineNum">   18464 </span>            : {
<span class="lineNum">   18465 </span><span class="lineCov">          7 :   location_t loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   18466 </span>            :   tree attrs;
<span class="lineNum">   18467 </span><span class="lineCov">          7 :   bool is_outer = false;</span>
<span class="lineNum">   18468 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   18469 </span>            :   gcc_assert (c_parser_next_token_is_keyword (parser, RID_TRANSACTION_CANCEL));
<span class="lineNum">   18470 </span>            :   c_parser_consume_token (parser);
<span class="lineNum">   18471 </span>            : 
<span class="lineNum">   18472 </span>            :   attrs = c_parser_transaction_attributes (parser);
<span class="lineNum">   18473 </span><span class="lineCov">          7 :   if (attrs)</span>
<span class="lineNum">   18474 </span>            :     is_outer = (parse_tm_stmt_attr (attrs, TM_STMT_ATTR_OUTER) != 0);
<span class="lineNum">   18475 </span><span class="lineCov">          7 : </span>
<span class="lineNum">   18476 </span>            :   if (!flag_tm)
<span class="lineNum">   18477 </span>            :     {
<span class="lineNum">   18478 </span>            :       error_at (loc, &quot;%&lt;__transaction_cancel%&gt; without &quot;
<span class="lineNum">   18479 </span>            :                 &quot;transactional memory support enabled&quot;);
<span class="lineNum">   18480 </span>            :       goto ret_error;
<span class="lineNum">   18481 </span>            :     }
<span class="lineNum">   18482 </span>            :   else if (parser-&gt;in_transaction &amp; TM_STMT_ATTR_RELAXED)
<span class="lineNum">   18483 </span>            :     {
<span class="lineNum">   18484 </span>            :       error_at (loc, &quot;%&lt;__transaction_cancel%&gt; within a &quot;
<span class="lineNum">   18485 </span>            :                 &quot;%&lt;__transaction_relaxed%&gt;&quot;);
<span class="lineNum">   18486 </span>            :       goto ret_error;
<span class="lineNum">   18487 </span><span class="lineCov">         26 :     }</span>
<span class="lineNum">   18488 </span>            :   else if (is_outer)
<span class="lineNum">   18489 </span><span class="lineCov">         26 :     {</span>
<span class="lineNum">   18490 </span><span class="lineCov">         26 :       if ((parser-&gt;in_transaction &amp; TM_STMT_ATTR_OUTER) == 0</span>
<span class="lineNum">   18491 </span><span class="lineCov">         26 :           &amp;&amp; !is_tm_may_cancel_outer (current_function_decl))</span>
<span class="lineNum">   18492 </span>            :         {
<span class="lineNum">   18493 </span><span class="lineCov">         26 :           error_at (loc, &quot;outer %&lt;__transaction_cancel%&gt; not &quot;</span>
<span class="lineNum">   18494 </span><span class="lineCov">         26 :                     &quot;within outer %&lt;__transaction_atomic%&gt;&quot;);</span>
<span class="lineNum">   18495 </span>            :           error_at (loc, &quot;  or a %&lt;transaction_may_cancel_outer%&gt; function&quot;);
<span class="lineNum">   18496 </span><span class="lineCov">         26 :           goto ret_error;</span>
<span class="lineNum">   18497 </span><span class="lineCov">         26 :         }</span>
<span class="lineNum">   18498 </span><span class="lineCov">          4 :     }</span>
<span class="lineNum">   18499 </span>            :   else if (parser-&gt;in_transaction == 0)
<span class="lineNum">   18500 </span><span class="lineCov">         26 :     {</span>
<span class="lineNum">   18501 </span>            :       error_at (loc, &quot;%&lt;__transaction_cancel%&gt; not within &quot;
<span class="lineNum">   18502 </span><span class="lineCov">          2 :                 &quot;%&lt;__transaction_atomic%&gt;&quot;);</span>
<span class="lineNum">   18503 </span>            :       goto ret_error;
<span class="lineNum">   18504 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">   18505 </span>            : 
<span class="lineNum">   18506 </span><span class="lineCov">         24 :   return add_stmt (build_tm_abort_call (loc, is_outer));</span>
<span class="lineNum">   18507 </span>            : 
<span class="lineNum">   18508 </span><span class="lineNoCov">          0 :  ret_error:</span>
<span class="lineNum">   18509 </span>            :   return build1 (NOP_EXPR, void_type_node, error_mark_node);
<span class="lineNum">   18510 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   18511 </span>            : 
<span class="lineNum">   18512 </span><span class="lineCov">         24 : /* Parse a single source file.  */</span>
<a name="18513"><span class="lineNum">   18513 </span>            : </a>
<span class="lineNum">   18514 </span><span class="lineCov">          4 : void</span>
<span class="lineNum">   18515 </span><span class="lineCov">          4 : c_parse_file (void)</span>
<span class="lineNum">   18516 </span>            : {
<span class="lineNum">   18517 </span><span class="lineNoCov">          0 :   /* Use local storage to begin.  If the first token is a pragma, parse it.</span>
<span class="lineNum">   18518 </span>            :      If it is #pragma GCC pch_preprocess, then this will load a PCH file
<span class="lineNum">   18519 </span><span class="lineNoCov">          0 :      which will cause garbage collection.  */</span>
<span class="lineNum">   18520 </span><span class="lineNoCov">          0 :   c_parser tparser;</span>
<span class="lineNum">   18521 </span>            : 
<span class="lineNum">   18522 </span>            :   memset (&amp;tparser, 0, sizeof tparser);
<span class="lineNum">   18523 </span><span class="lineCov">         20 :   tparser.tokens = &amp;tparser.tokens_buf[0];</span>
<span class="lineNum">   18524 </span>            :   the_parser = &amp;tparser;
<span class="lineNum">   18525 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   18526 </span>            :   if (c_parser_peek_token (&amp;tparser)-&gt;pragma_kind == PRAGMA_GCC_PCH_PREPROCESS)
<span class="lineNum">   18527 </span><span class="lineNoCov">          0 :     c_parser_pragma_pch_preprocess (&amp;tparser);</span>
<span class="lineNum">   18528 </span>            : 
<span class="lineNum">   18529 </span>            :   the_parser = ggc_alloc&lt;c_parser&gt; ();
<span class="lineNum">   18530 </span><span class="lineCov">         24 :   *the_parser = tparser;</span>
<span class="lineNum">   18531 </span>            :   if (tparser.tokens == &amp;tparser.tokens_buf[0])
<span class="lineNum">   18532 </span><span class="lineCov">          2 :     the_parser-&gt;tokens = &amp;the_parser-&gt;tokens_buf[0];</span>
<span class="lineNum">   18533 </span><span class="lineCov">          2 : </span>
<span class="lineNum">   18534 </span>            :   /* Initialize EH, if we've been told to do so.  */
<span class="lineNum">   18535 </span>            :   if (flag_exceptions)
<span class="lineNum">   18536 </span>            :     using_eh_for_cleanups ();
<span class="lineNum">   18537 </span>            : 
<span class="lineNum">   18538 </span>            :   c_parser_translation_unit (the_parser);
<span class="lineNum">   18539 </span><span class="lineCov">      71409 :   the_parser = NULL;</span>
<span class="lineNum">   18540 </span>            : }
<span class="lineNum">   18541 </span>            : 
<span class="lineNum">   18542 </span>            : /* Parse the body of a function declaration marked with &quot;__RTL&quot;.
<span class="lineNum">   18543 </span>            : 
<span class="lineNum">   18544 </span><span class="lineCov">      71409 :    The RTL parser works on the level of characters read from a</span>
<span class="lineNum">   18545 </span>            :    FILE *, whereas c_parser works at the level of tokens.
<span class="lineNum">   18546 </span><span class="lineCov">      71409 :    Square this circle by consuming all of the tokens up to and</span>
<span class="lineNum">   18547 </span><span class="lineCov">      71409 :    including the closing brace, recording the start/end of the RTL</span>
<span class="lineNum">   18548 </span><span class="lineCov">      71409 :    fragment, and reopening the file and re-reading the relevant</span>
<span class="lineNum">   18549 </span>            :    lines within the RTL parser.
<span class="lineNum">   18550 </span><span class="lineCov">      71409 : </span>
<span class="lineNum">   18551 </span><span class="lineCov">          6 :    This requires the opening and closing braces of the C function</span>
<span class="lineNum">   18552 </span>            :    to be on separate lines from the RTL they wrap.
<span class="lineNum">   18553 </span><span class="lineCov">      71373 : </span>
<span class="lineNum">   18554 </span><span class="lineCov">      71373 :    Take ownership of START_WITH_PASS, if non-NULL.  */</span>
<a name="18555"><span class="lineNum">   18555 </span><span class="lineCov">      71373 : </span></a>
<span class="lineNum">   18556 </span><span class="lineCov">      71373 : void</span>
<span class="lineNum">   18557 </span>            : c_parser_parse_rtl_body (c_parser *parser, char *start_with_pass)
<span class="lineNum">   18558 </span>            : {
<span class="lineNum">   18559 </span><span class="lineCov">      71373 :   if (!c_parser_require (parser, CPP_OPEN_BRACE, &quot;expected %&lt;{%&gt;&quot;))</span>
<span class="lineNum">   18560 </span><span class="lineCov">        348 :     {</span>
<span class="lineNum">   18561 </span>            :       free (start_with_pass);
<span class="lineNum">   18562 </span><span class="lineCov">      71373 :       return;</span>
<span class="lineNum">   18563 </span><span class="lineCov">      71314 :     }</span>
<span class="lineNum">   18564 </span><span class="lineCov">      71314 : </span>
<span class="lineNum">   18565 </span>            :   location_t start_loc = c_parser_peek_token (parser)-&gt;location;
<span class="lineNum">   18566 </span>            : 
<span class="lineNum">   18567 </span>            :   /* Consume all tokens, up to the closing brace, handling
<span class="lineNum">   18568 </span>            :      matching pairs of braces in the rtl dump.  */
<span class="lineNum">   18569 </span>            :   int num_open_braces = 1;
<span class="lineNum">   18570 </span>            :   while (1)
<span class="lineNum">   18571 </span>            :     {
<span class="lineNum">   18572 </span>            :       switch (c_parser_peek_token (parser)-&gt;type)
<span class="lineNum">   18573 </span>            :         {
<span class="lineNum">   18574 </span>            :         case CPP_OPEN_BRACE:
<span class="lineNum">   18575 </span>            :           num_open_braces++;
<span class="lineNum">   18576 </span>            :           break;
<span class="lineNum">   18577 </span>            :         case CPP_CLOSE_BRACE:
<span class="lineNum">   18578 </span>            :           if (--num_open_braces == 0)
<span class="lineNum">   18579 </span>            :             goto found_closing_brace;
<span class="lineNum">   18580 </span>            :           break;
<span class="lineNum">   18581 </span><span class="lineCov">         18 :         case CPP_EOF:</span>
<span class="lineNum">   18582 </span>            :           error_at (start_loc, &quot;no closing brace&quot;);
<span class="lineNum">   18583 </span><span class="lineCov">         18 :           free (start_with_pass);</span>
<span class="lineNum">   18584 </span>            :           return;
<span class="lineNum">   18585 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">   18586 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   18587 </span>            :         }
<span class="lineNum">   18588 </span>            :       c_parser_consume_token (parser);
<span class="lineNum">   18589 </span><span class="lineCov">         18 :     }</span>
<span class="lineNum">   18590 </span>            : 
<span class="lineNum">   18591 </span>            :  found_closing_brace:
<span class="lineNum">   18592 </span>            :   /* At the closing brace; record its location.  */
<span class="lineNum">   18593 </span><span class="lineCov">         18 :   location_t end_loc = c_parser_peek_token (parser)-&gt;location;</span>
<span class="lineNum">   18594 </span><span class="lineCov">      11205 : </span>
<span class="lineNum">   18595 </span>            :   /* Consume the closing brace.  */
<span class="lineNum">   18596 </span><span class="lineCov">      11205 :   c_parser_consume_token (parser);</span>
<span class="lineNum">   18597 </span>            : 
<span class="lineNum">   18598 </span><span class="lineCov">          1 :   /* Invoke the RTL parser.  */</span>
<span class="lineNum">   18599 </span><span class="lineCov">          1 :   if (!read_rtl_function_body_from_file_range (start_loc, end_loc))</span>
<span class="lineNum">   18600 </span><span class="lineCov">          1 :     {</span>
<span class="lineNum">   18601 </span><span class="lineCov">         18 :       free (start_with_pass);</span>
<span class="lineNum">   18602 </span><span class="lineCov">         18 :       return;</span>
<span class="lineNum">   18603 </span><span class="lineCov">         17 :     }</span>
<span class="lineNum">   18604 </span>            : 
<span class="lineNum">   18605 </span><span class="lineCov">          1 :  /*  If a pass name was provided for START_WITH_PASS, run the backend</span>
<span class="lineNum">   18606 </span><span class="lineCov">          1 :      accordingly now, on the cfun created above, transferring</span>
<span class="lineNum">   18607 </span><span class="lineCov">          1 :      ownership of START_WITH_PASS.  */</span>
<span class="lineNum">   18608 </span><span class="lineCov">          1 :   if (start_with_pass)</span>
<span class="lineNum">   18609 </span>            :     run_rtl_passes (start_with_pass);
<span class="lineNum">   18610 </span>            : }
<span class="lineNum">   18611 </span>            : 
<span class="lineNum">   18612 </span><span class="lineCov">      11187 : #include &quot;gt-c-c-parser.h&quot;</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
